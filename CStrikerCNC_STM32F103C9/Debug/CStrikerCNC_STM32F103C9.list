
CStrikerCNC_STM32F103C9.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00014774  08000110  08000110  00010110  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000bec  08014884  08014884  00024884  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08015470  08015470  00030084  2**0
                  CONTENTS
  4 .ARM          00000000  08015470  08015470  00030084  2**0
                  CONTENTS
  5 .preinit_array 00000000  08015470  08015470  00030084  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08015470  08015470  00025470  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08015474  08015474  00025474  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000084  20000000  08015478  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000026b4  20000088  080154fc  00030088  2**3
                  ALLOC
 10 ._user_heap_stack 00000904  2000273c  080154fc  0003273c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00030084  2**0
                  CONTENTS, READONLY
 12 .debug_info   0007b439  00000000  00000000  000300ad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000a8c3  00000000  00000000  000ab4e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0002087a  00000000  00000000  000b5da9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001528  00000000  00000000  000d6623  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00005130  00000000  00000000  000d7b4b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001c73f  00000000  00000000  000dcc7b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000344e6  00000000  00000000  000f93ba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000847a9  00000000  00000000  0012d8a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000053  00000000  00000000  001b2049  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00005630  00000000  00000000  001b209c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	; (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	; (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	; (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	20000088 	.word	0x20000088
 800012c:	00000000 	.word	0x00000000
 8000130:	0801486c 	.word	0x0801486c

08000134 <frame_dummy>:
 8000134:	b508      	push	{r3, lr}
 8000136:	4b03      	ldr	r3, [pc, #12]	; (8000144 <frame_dummy+0x10>)
 8000138:	b11b      	cbz	r3, 8000142 <frame_dummy+0xe>
 800013a:	4903      	ldr	r1, [pc, #12]	; (8000148 <frame_dummy+0x14>)
 800013c:	4803      	ldr	r0, [pc, #12]	; (800014c <frame_dummy+0x18>)
 800013e:	f3af 8000 	nop.w
 8000142:	bd08      	pop	{r3, pc}
 8000144:	00000000 	.word	0x00000000
 8000148:	2000008c 	.word	0x2000008c
 800014c:	0801486c 	.word	0x0801486c

08000150 <strlen>:
 8000150:	4603      	mov	r3, r0
 8000152:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000156:	2a00      	cmp	r2, #0
 8000158:	d1fb      	bne.n	8000152 <strlen+0x2>
 800015a:	1a18      	subs	r0, r3, r0
 800015c:	3801      	subs	r0, #1
 800015e:	4770      	bx	lr

08000160 <__aeabi_drsub>:
 8000160:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000164:	e002      	b.n	800016c <__adddf3>
 8000166:	bf00      	nop

08000168 <__aeabi_dsub>:
 8000168:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800016c <__adddf3>:
 800016c:	b530      	push	{r4, r5, lr}
 800016e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000172:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000176:	ea94 0f05 	teq	r4, r5
 800017a:	bf08      	it	eq
 800017c:	ea90 0f02 	teqeq	r0, r2
 8000180:	bf1f      	itttt	ne
 8000182:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000186:	ea55 0c02 	orrsne.w	ip, r5, r2
 800018a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800018e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000192:	f000 80e2 	beq.w	800035a <__adddf3+0x1ee>
 8000196:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800019a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800019e:	bfb8      	it	lt
 80001a0:	426d      	neglt	r5, r5
 80001a2:	dd0c      	ble.n	80001be <__adddf3+0x52>
 80001a4:	442c      	add	r4, r5
 80001a6:	ea80 0202 	eor.w	r2, r0, r2
 80001aa:	ea81 0303 	eor.w	r3, r1, r3
 80001ae:	ea82 0000 	eor.w	r0, r2, r0
 80001b2:	ea83 0101 	eor.w	r1, r3, r1
 80001b6:	ea80 0202 	eor.w	r2, r0, r2
 80001ba:	ea81 0303 	eor.w	r3, r1, r3
 80001be:	2d36      	cmp	r5, #54	; 0x36
 80001c0:	bf88      	it	hi
 80001c2:	bd30      	pophi	{r4, r5, pc}
 80001c4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80001c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80001cc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80001d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80001d4:	d002      	beq.n	80001dc <__adddf3+0x70>
 80001d6:	4240      	negs	r0, r0
 80001d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80001dc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80001e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80001e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80001e8:	d002      	beq.n	80001f0 <__adddf3+0x84>
 80001ea:	4252      	negs	r2, r2
 80001ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80001f0:	ea94 0f05 	teq	r4, r5
 80001f4:	f000 80a7 	beq.w	8000346 <__adddf3+0x1da>
 80001f8:	f1a4 0401 	sub.w	r4, r4, #1
 80001fc:	f1d5 0e20 	rsbs	lr, r5, #32
 8000200:	db0d      	blt.n	800021e <__adddf3+0xb2>
 8000202:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000206:	fa22 f205 	lsr.w	r2, r2, r5
 800020a:	1880      	adds	r0, r0, r2
 800020c:	f141 0100 	adc.w	r1, r1, #0
 8000210:	fa03 f20e 	lsl.w	r2, r3, lr
 8000214:	1880      	adds	r0, r0, r2
 8000216:	fa43 f305 	asr.w	r3, r3, r5
 800021a:	4159      	adcs	r1, r3
 800021c:	e00e      	b.n	800023c <__adddf3+0xd0>
 800021e:	f1a5 0520 	sub.w	r5, r5, #32
 8000222:	f10e 0e20 	add.w	lr, lr, #32
 8000226:	2a01      	cmp	r2, #1
 8000228:	fa03 fc0e 	lsl.w	ip, r3, lr
 800022c:	bf28      	it	cs
 800022e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000232:	fa43 f305 	asr.w	r3, r3, r5
 8000236:	18c0      	adds	r0, r0, r3
 8000238:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800023c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000240:	d507      	bpl.n	8000252 <__adddf3+0xe6>
 8000242:	f04f 0e00 	mov.w	lr, #0
 8000246:	f1dc 0c00 	rsbs	ip, ip, #0
 800024a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800024e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000252:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000256:	d31b      	bcc.n	8000290 <__adddf3+0x124>
 8000258:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800025c:	d30c      	bcc.n	8000278 <__adddf3+0x10c>
 800025e:	0849      	lsrs	r1, r1, #1
 8000260:	ea5f 0030 	movs.w	r0, r0, rrx
 8000264:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000268:	f104 0401 	add.w	r4, r4, #1
 800026c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000270:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000274:	f080 809a 	bcs.w	80003ac <__adddf3+0x240>
 8000278:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800027c:	bf08      	it	eq
 800027e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000282:	f150 0000 	adcs.w	r0, r0, #0
 8000286:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800028a:	ea41 0105 	orr.w	r1, r1, r5
 800028e:	bd30      	pop	{r4, r5, pc}
 8000290:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000294:	4140      	adcs	r0, r0
 8000296:	eb41 0101 	adc.w	r1, r1, r1
 800029a:	3c01      	subs	r4, #1
 800029c:	bf28      	it	cs
 800029e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80002a2:	d2e9      	bcs.n	8000278 <__adddf3+0x10c>
 80002a4:	f091 0f00 	teq	r1, #0
 80002a8:	bf04      	itt	eq
 80002aa:	4601      	moveq	r1, r0
 80002ac:	2000      	moveq	r0, #0
 80002ae:	fab1 f381 	clz	r3, r1
 80002b2:	bf08      	it	eq
 80002b4:	3320      	addeq	r3, #32
 80002b6:	f1a3 030b 	sub.w	r3, r3, #11
 80002ba:	f1b3 0220 	subs.w	r2, r3, #32
 80002be:	da0c      	bge.n	80002da <__adddf3+0x16e>
 80002c0:	320c      	adds	r2, #12
 80002c2:	dd08      	ble.n	80002d6 <__adddf3+0x16a>
 80002c4:	f102 0c14 	add.w	ip, r2, #20
 80002c8:	f1c2 020c 	rsb	r2, r2, #12
 80002cc:	fa01 f00c 	lsl.w	r0, r1, ip
 80002d0:	fa21 f102 	lsr.w	r1, r1, r2
 80002d4:	e00c      	b.n	80002f0 <__adddf3+0x184>
 80002d6:	f102 0214 	add.w	r2, r2, #20
 80002da:	bfd8      	it	le
 80002dc:	f1c2 0c20 	rsble	ip, r2, #32
 80002e0:	fa01 f102 	lsl.w	r1, r1, r2
 80002e4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002e8:	bfdc      	itt	le
 80002ea:	ea41 010c 	orrle.w	r1, r1, ip
 80002ee:	4090      	lslle	r0, r2
 80002f0:	1ae4      	subs	r4, r4, r3
 80002f2:	bfa2      	ittt	ge
 80002f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80002f8:	4329      	orrge	r1, r5
 80002fa:	bd30      	popge	{r4, r5, pc}
 80002fc:	ea6f 0404 	mvn.w	r4, r4
 8000300:	3c1f      	subs	r4, #31
 8000302:	da1c      	bge.n	800033e <__adddf3+0x1d2>
 8000304:	340c      	adds	r4, #12
 8000306:	dc0e      	bgt.n	8000326 <__adddf3+0x1ba>
 8000308:	f104 0414 	add.w	r4, r4, #20
 800030c:	f1c4 0220 	rsb	r2, r4, #32
 8000310:	fa20 f004 	lsr.w	r0, r0, r4
 8000314:	fa01 f302 	lsl.w	r3, r1, r2
 8000318:	ea40 0003 	orr.w	r0, r0, r3
 800031c:	fa21 f304 	lsr.w	r3, r1, r4
 8000320:	ea45 0103 	orr.w	r1, r5, r3
 8000324:	bd30      	pop	{r4, r5, pc}
 8000326:	f1c4 040c 	rsb	r4, r4, #12
 800032a:	f1c4 0220 	rsb	r2, r4, #32
 800032e:	fa20 f002 	lsr.w	r0, r0, r2
 8000332:	fa01 f304 	lsl.w	r3, r1, r4
 8000336:	ea40 0003 	orr.w	r0, r0, r3
 800033a:	4629      	mov	r1, r5
 800033c:	bd30      	pop	{r4, r5, pc}
 800033e:	fa21 f004 	lsr.w	r0, r1, r4
 8000342:	4629      	mov	r1, r5
 8000344:	bd30      	pop	{r4, r5, pc}
 8000346:	f094 0f00 	teq	r4, #0
 800034a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800034e:	bf06      	itte	eq
 8000350:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000354:	3401      	addeq	r4, #1
 8000356:	3d01      	subne	r5, #1
 8000358:	e74e      	b.n	80001f8 <__adddf3+0x8c>
 800035a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800035e:	bf18      	it	ne
 8000360:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000364:	d029      	beq.n	80003ba <__adddf3+0x24e>
 8000366:	ea94 0f05 	teq	r4, r5
 800036a:	bf08      	it	eq
 800036c:	ea90 0f02 	teqeq	r0, r2
 8000370:	d005      	beq.n	800037e <__adddf3+0x212>
 8000372:	ea54 0c00 	orrs.w	ip, r4, r0
 8000376:	bf04      	itt	eq
 8000378:	4619      	moveq	r1, r3
 800037a:	4610      	moveq	r0, r2
 800037c:	bd30      	pop	{r4, r5, pc}
 800037e:	ea91 0f03 	teq	r1, r3
 8000382:	bf1e      	ittt	ne
 8000384:	2100      	movne	r1, #0
 8000386:	2000      	movne	r0, #0
 8000388:	bd30      	popne	{r4, r5, pc}
 800038a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800038e:	d105      	bne.n	800039c <__adddf3+0x230>
 8000390:	0040      	lsls	r0, r0, #1
 8000392:	4149      	adcs	r1, r1
 8000394:	bf28      	it	cs
 8000396:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800039a:	bd30      	pop	{r4, r5, pc}
 800039c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80003a0:	bf3c      	itt	cc
 80003a2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80003a6:	bd30      	popcc	{r4, r5, pc}
 80003a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003ac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80003b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80003b4:	f04f 0000 	mov.w	r0, #0
 80003b8:	bd30      	pop	{r4, r5, pc}
 80003ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003be:	bf1a      	itte	ne
 80003c0:	4619      	movne	r1, r3
 80003c2:	4610      	movne	r0, r2
 80003c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80003c8:	bf1c      	itt	ne
 80003ca:	460b      	movne	r3, r1
 80003cc:	4602      	movne	r2, r0
 80003ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80003d2:	bf06      	itte	eq
 80003d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80003d8:	ea91 0f03 	teqeq	r1, r3
 80003dc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80003e0:	bd30      	pop	{r4, r5, pc}
 80003e2:	bf00      	nop

080003e4 <__aeabi_ui2d>:
 80003e4:	f090 0f00 	teq	r0, #0
 80003e8:	bf04      	itt	eq
 80003ea:	2100      	moveq	r1, #0
 80003ec:	4770      	bxeq	lr
 80003ee:	b530      	push	{r4, r5, lr}
 80003f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80003f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80003f8:	f04f 0500 	mov.w	r5, #0
 80003fc:	f04f 0100 	mov.w	r1, #0
 8000400:	e750      	b.n	80002a4 <__adddf3+0x138>
 8000402:	bf00      	nop

08000404 <__aeabi_i2d>:
 8000404:	f090 0f00 	teq	r0, #0
 8000408:	bf04      	itt	eq
 800040a:	2100      	moveq	r1, #0
 800040c:	4770      	bxeq	lr
 800040e:	b530      	push	{r4, r5, lr}
 8000410:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000414:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000418:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800041c:	bf48      	it	mi
 800041e:	4240      	negmi	r0, r0
 8000420:	f04f 0100 	mov.w	r1, #0
 8000424:	e73e      	b.n	80002a4 <__adddf3+0x138>
 8000426:	bf00      	nop

08000428 <__aeabi_f2d>:
 8000428:	0042      	lsls	r2, r0, #1
 800042a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800042e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000432:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000436:	bf1f      	itttt	ne
 8000438:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800043c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000440:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000444:	4770      	bxne	lr
 8000446:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800044a:	bf08      	it	eq
 800044c:	4770      	bxeq	lr
 800044e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000452:	bf04      	itt	eq
 8000454:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000458:	4770      	bxeq	lr
 800045a:	b530      	push	{r4, r5, lr}
 800045c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000460:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000464:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000468:	e71c      	b.n	80002a4 <__adddf3+0x138>
 800046a:	bf00      	nop

0800046c <__aeabi_ul2d>:
 800046c:	ea50 0201 	orrs.w	r2, r0, r1
 8000470:	bf08      	it	eq
 8000472:	4770      	bxeq	lr
 8000474:	b530      	push	{r4, r5, lr}
 8000476:	f04f 0500 	mov.w	r5, #0
 800047a:	e00a      	b.n	8000492 <__aeabi_l2d+0x16>

0800047c <__aeabi_l2d>:
 800047c:	ea50 0201 	orrs.w	r2, r0, r1
 8000480:	bf08      	it	eq
 8000482:	4770      	bxeq	lr
 8000484:	b530      	push	{r4, r5, lr}
 8000486:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800048a:	d502      	bpl.n	8000492 <__aeabi_l2d+0x16>
 800048c:	4240      	negs	r0, r0
 800048e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000492:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000496:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800049a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800049e:	f43f aed8 	beq.w	8000252 <__adddf3+0xe6>
 80004a2:	f04f 0203 	mov.w	r2, #3
 80004a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004aa:	bf18      	it	ne
 80004ac:	3203      	addne	r2, #3
 80004ae:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004b2:	bf18      	it	ne
 80004b4:	3203      	addne	r2, #3
 80004b6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80004ba:	f1c2 0320 	rsb	r3, r2, #32
 80004be:	fa00 fc03 	lsl.w	ip, r0, r3
 80004c2:	fa20 f002 	lsr.w	r0, r0, r2
 80004c6:	fa01 fe03 	lsl.w	lr, r1, r3
 80004ca:	ea40 000e 	orr.w	r0, r0, lr
 80004ce:	fa21 f102 	lsr.w	r1, r1, r2
 80004d2:	4414      	add	r4, r2
 80004d4:	e6bd      	b.n	8000252 <__adddf3+0xe6>
 80004d6:	bf00      	nop

080004d8 <__aeabi_d2f>:
 80004d8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80004dc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80004e0:	bf24      	itt	cs
 80004e2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80004e6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80004ea:	d90d      	bls.n	8000508 <__aeabi_d2f+0x30>
 80004ec:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80004f0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80004f4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80004f8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80004fc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000500:	bf08      	it	eq
 8000502:	f020 0001 	biceq.w	r0, r0, #1
 8000506:	4770      	bx	lr
 8000508:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 800050c:	d121      	bne.n	8000552 <__aeabi_d2f+0x7a>
 800050e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000512:	bfbc      	itt	lt
 8000514:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000518:	4770      	bxlt	lr
 800051a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800051e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000522:	f1c2 0218 	rsb	r2, r2, #24
 8000526:	f1c2 0c20 	rsb	ip, r2, #32
 800052a:	fa10 f30c 	lsls.w	r3, r0, ip
 800052e:	fa20 f002 	lsr.w	r0, r0, r2
 8000532:	bf18      	it	ne
 8000534:	f040 0001 	orrne.w	r0, r0, #1
 8000538:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800053c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000540:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000544:	ea40 000c 	orr.w	r0, r0, ip
 8000548:	fa23 f302 	lsr.w	r3, r3, r2
 800054c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000550:	e7cc      	b.n	80004ec <__aeabi_d2f+0x14>
 8000552:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000556:	d107      	bne.n	8000568 <__aeabi_d2f+0x90>
 8000558:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800055c:	bf1e      	ittt	ne
 800055e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000562:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000566:	4770      	bxne	lr
 8000568:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 800056c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000570:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000574:	4770      	bx	lr
 8000576:	bf00      	nop

08000578 <__aeabi_frsub>:
 8000578:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 800057c:	e002      	b.n	8000584 <__addsf3>
 800057e:	bf00      	nop

08000580 <__aeabi_fsub>:
 8000580:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000584 <__addsf3>:
 8000584:	0042      	lsls	r2, r0, #1
 8000586:	bf1f      	itttt	ne
 8000588:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 800058c:	ea92 0f03 	teqne	r2, r3
 8000590:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000594:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000598:	d06a      	beq.n	8000670 <__addsf3+0xec>
 800059a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800059e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80005a2:	bfc1      	itttt	gt
 80005a4:	18d2      	addgt	r2, r2, r3
 80005a6:	4041      	eorgt	r1, r0
 80005a8:	4048      	eorgt	r0, r1
 80005aa:	4041      	eorgt	r1, r0
 80005ac:	bfb8      	it	lt
 80005ae:	425b      	neglt	r3, r3
 80005b0:	2b19      	cmp	r3, #25
 80005b2:	bf88      	it	hi
 80005b4:	4770      	bxhi	lr
 80005b6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80005ba:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80005be:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80005c2:	bf18      	it	ne
 80005c4:	4240      	negne	r0, r0
 80005c6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80005ca:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80005ce:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80005d2:	bf18      	it	ne
 80005d4:	4249      	negne	r1, r1
 80005d6:	ea92 0f03 	teq	r2, r3
 80005da:	d03f      	beq.n	800065c <__addsf3+0xd8>
 80005dc:	f1a2 0201 	sub.w	r2, r2, #1
 80005e0:	fa41 fc03 	asr.w	ip, r1, r3
 80005e4:	eb10 000c 	adds.w	r0, r0, ip
 80005e8:	f1c3 0320 	rsb	r3, r3, #32
 80005ec:	fa01 f103 	lsl.w	r1, r1, r3
 80005f0:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80005f4:	d502      	bpl.n	80005fc <__addsf3+0x78>
 80005f6:	4249      	negs	r1, r1
 80005f8:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80005fc:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000600:	d313      	bcc.n	800062a <__addsf3+0xa6>
 8000602:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000606:	d306      	bcc.n	8000616 <__addsf3+0x92>
 8000608:	0840      	lsrs	r0, r0, #1
 800060a:	ea4f 0131 	mov.w	r1, r1, rrx
 800060e:	f102 0201 	add.w	r2, r2, #1
 8000612:	2afe      	cmp	r2, #254	; 0xfe
 8000614:	d251      	bcs.n	80006ba <__addsf3+0x136>
 8000616:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800061a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800061e:	bf08      	it	eq
 8000620:	f020 0001 	biceq.w	r0, r0, #1
 8000624:	ea40 0003 	orr.w	r0, r0, r3
 8000628:	4770      	bx	lr
 800062a:	0049      	lsls	r1, r1, #1
 800062c:	eb40 0000 	adc.w	r0, r0, r0
 8000630:	3a01      	subs	r2, #1
 8000632:	bf28      	it	cs
 8000634:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000638:	d2ed      	bcs.n	8000616 <__addsf3+0x92>
 800063a:	fab0 fc80 	clz	ip, r0
 800063e:	f1ac 0c08 	sub.w	ip, ip, #8
 8000642:	ebb2 020c 	subs.w	r2, r2, ip
 8000646:	fa00 f00c 	lsl.w	r0, r0, ip
 800064a:	bfaa      	itet	ge
 800064c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000650:	4252      	neglt	r2, r2
 8000652:	4318      	orrge	r0, r3
 8000654:	bfbc      	itt	lt
 8000656:	40d0      	lsrlt	r0, r2
 8000658:	4318      	orrlt	r0, r3
 800065a:	4770      	bx	lr
 800065c:	f092 0f00 	teq	r2, #0
 8000660:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000664:	bf06      	itte	eq
 8000666:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 800066a:	3201      	addeq	r2, #1
 800066c:	3b01      	subne	r3, #1
 800066e:	e7b5      	b.n	80005dc <__addsf3+0x58>
 8000670:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000674:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000678:	bf18      	it	ne
 800067a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800067e:	d021      	beq.n	80006c4 <__addsf3+0x140>
 8000680:	ea92 0f03 	teq	r2, r3
 8000684:	d004      	beq.n	8000690 <__addsf3+0x10c>
 8000686:	f092 0f00 	teq	r2, #0
 800068a:	bf08      	it	eq
 800068c:	4608      	moveq	r0, r1
 800068e:	4770      	bx	lr
 8000690:	ea90 0f01 	teq	r0, r1
 8000694:	bf1c      	itt	ne
 8000696:	2000      	movne	r0, #0
 8000698:	4770      	bxne	lr
 800069a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 800069e:	d104      	bne.n	80006aa <__addsf3+0x126>
 80006a0:	0040      	lsls	r0, r0, #1
 80006a2:	bf28      	it	cs
 80006a4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80006a8:	4770      	bx	lr
 80006aa:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80006ae:	bf3c      	itt	cc
 80006b0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80006b4:	4770      	bxcc	lr
 80006b6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80006ba:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80006be:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80006c2:	4770      	bx	lr
 80006c4:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80006c8:	bf16      	itet	ne
 80006ca:	4608      	movne	r0, r1
 80006cc:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80006d0:	4601      	movne	r1, r0
 80006d2:	0242      	lsls	r2, r0, #9
 80006d4:	bf06      	itte	eq
 80006d6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80006da:	ea90 0f01 	teqeq	r0, r1
 80006de:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80006e2:	4770      	bx	lr

080006e4 <__aeabi_ui2f>:
 80006e4:	f04f 0300 	mov.w	r3, #0
 80006e8:	e004      	b.n	80006f4 <__aeabi_i2f+0x8>
 80006ea:	bf00      	nop

080006ec <__aeabi_i2f>:
 80006ec:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80006f0:	bf48      	it	mi
 80006f2:	4240      	negmi	r0, r0
 80006f4:	ea5f 0c00 	movs.w	ip, r0
 80006f8:	bf08      	it	eq
 80006fa:	4770      	bxeq	lr
 80006fc:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000700:	4601      	mov	r1, r0
 8000702:	f04f 0000 	mov.w	r0, #0
 8000706:	e01c      	b.n	8000742 <__aeabi_l2f+0x2a>

08000708 <__aeabi_ul2f>:
 8000708:	ea50 0201 	orrs.w	r2, r0, r1
 800070c:	bf08      	it	eq
 800070e:	4770      	bxeq	lr
 8000710:	f04f 0300 	mov.w	r3, #0
 8000714:	e00a      	b.n	800072c <__aeabi_l2f+0x14>
 8000716:	bf00      	nop

08000718 <__aeabi_l2f>:
 8000718:	ea50 0201 	orrs.w	r2, r0, r1
 800071c:	bf08      	it	eq
 800071e:	4770      	bxeq	lr
 8000720:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000724:	d502      	bpl.n	800072c <__aeabi_l2f+0x14>
 8000726:	4240      	negs	r0, r0
 8000728:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800072c:	ea5f 0c01 	movs.w	ip, r1
 8000730:	bf02      	ittt	eq
 8000732:	4684      	moveq	ip, r0
 8000734:	4601      	moveq	r1, r0
 8000736:	2000      	moveq	r0, #0
 8000738:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 800073c:	bf08      	it	eq
 800073e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000742:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000746:	fabc f28c 	clz	r2, ip
 800074a:	3a08      	subs	r2, #8
 800074c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000750:	db10      	blt.n	8000774 <__aeabi_l2f+0x5c>
 8000752:	fa01 fc02 	lsl.w	ip, r1, r2
 8000756:	4463      	add	r3, ip
 8000758:	fa00 fc02 	lsl.w	ip, r0, r2
 800075c:	f1c2 0220 	rsb	r2, r2, #32
 8000760:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000764:	fa20 f202 	lsr.w	r2, r0, r2
 8000768:	eb43 0002 	adc.w	r0, r3, r2
 800076c:	bf08      	it	eq
 800076e:	f020 0001 	biceq.w	r0, r0, #1
 8000772:	4770      	bx	lr
 8000774:	f102 0220 	add.w	r2, r2, #32
 8000778:	fa01 fc02 	lsl.w	ip, r1, r2
 800077c:	f1c2 0220 	rsb	r2, r2, #32
 8000780:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000784:	fa21 f202 	lsr.w	r2, r1, r2
 8000788:	eb43 0002 	adc.w	r0, r3, r2
 800078c:	bf08      	it	eq
 800078e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000792:	4770      	bx	lr

08000794 <__aeabi_fmul>:
 8000794:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000798:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 800079c:	bf1e      	ittt	ne
 800079e:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80007a2:	ea92 0f0c 	teqne	r2, ip
 80007a6:	ea93 0f0c 	teqne	r3, ip
 80007aa:	d06f      	beq.n	800088c <__aeabi_fmul+0xf8>
 80007ac:	441a      	add	r2, r3
 80007ae:	ea80 0c01 	eor.w	ip, r0, r1
 80007b2:	0240      	lsls	r0, r0, #9
 80007b4:	bf18      	it	ne
 80007b6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80007ba:	d01e      	beq.n	80007fa <__aeabi_fmul+0x66>
 80007bc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80007c0:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80007c4:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80007c8:	fba0 3101 	umull	r3, r1, r0, r1
 80007cc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80007d0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80007d4:	bf3e      	ittt	cc
 80007d6:	0049      	lslcc	r1, r1, #1
 80007d8:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80007dc:	005b      	lslcc	r3, r3, #1
 80007de:	ea40 0001 	orr.w	r0, r0, r1
 80007e2:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80007e6:	2afd      	cmp	r2, #253	; 0xfd
 80007e8:	d81d      	bhi.n	8000826 <__aeabi_fmul+0x92>
 80007ea:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80007ee:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80007f2:	bf08      	it	eq
 80007f4:	f020 0001 	biceq.w	r0, r0, #1
 80007f8:	4770      	bx	lr
 80007fa:	f090 0f00 	teq	r0, #0
 80007fe:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000802:	bf08      	it	eq
 8000804:	0249      	lsleq	r1, r1, #9
 8000806:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800080a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800080e:	3a7f      	subs	r2, #127	; 0x7f
 8000810:	bfc2      	ittt	gt
 8000812:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000816:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 800081a:	4770      	bxgt	lr
 800081c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000820:	f04f 0300 	mov.w	r3, #0
 8000824:	3a01      	subs	r2, #1
 8000826:	dc5d      	bgt.n	80008e4 <__aeabi_fmul+0x150>
 8000828:	f112 0f19 	cmn.w	r2, #25
 800082c:	bfdc      	itt	le
 800082e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000832:	4770      	bxle	lr
 8000834:	f1c2 0200 	rsb	r2, r2, #0
 8000838:	0041      	lsls	r1, r0, #1
 800083a:	fa21 f102 	lsr.w	r1, r1, r2
 800083e:	f1c2 0220 	rsb	r2, r2, #32
 8000842:	fa00 fc02 	lsl.w	ip, r0, r2
 8000846:	ea5f 0031 	movs.w	r0, r1, rrx
 800084a:	f140 0000 	adc.w	r0, r0, #0
 800084e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000852:	bf08      	it	eq
 8000854:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000858:	4770      	bx	lr
 800085a:	f092 0f00 	teq	r2, #0
 800085e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000862:	bf02      	ittt	eq
 8000864:	0040      	lsleq	r0, r0, #1
 8000866:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 800086a:	3a01      	subeq	r2, #1
 800086c:	d0f9      	beq.n	8000862 <__aeabi_fmul+0xce>
 800086e:	ea40 000c 	orr.w	r0, r0, ip
 8000872:	f093 0f00 	teq	r3, #0
 8000876:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800087a:	bf02      	ittt	eq
 800087c:	0049      	lsleq	r1, r1, #1
 800087e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000882:	3b01      	subeq	r3, #1
 8000884:	d0f9      	beq.n	800087a <__aeabi_fmul+0xe6>
 8000886:	ea41 010c 	orr.w	r1, r1, ip
 800088a:	e78f      	b.n	80007ac <__aeabi_fmul+0x18>
 800088c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000890:	ea92 0f0c 	teq	r2, ip
 8000894:	bf18      	it	ne
 8000896:	ea93 0f0c 	teqne	r3, ip
 800089a:	d00a      	beq.n	80008b2 <__aeabi_fmul+0x11e>
 800089c:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80008a0:	bf18      	it	ne
 80008a2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80008a6:	d1d8      	bne.n	800085a <__aeabi_fmul+0xc6>
 80008a8:	ea80 0001 	eor.w	r0, r0, r1
 80008ac:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80008b0:	4770      	bx	lr
 80008b2:	f090 0f00 	teq	r0, #0
 80008b6:	bf17      	itett	ne
 80008b8:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80008bc:	4608      	moveq	r0, r1
 80008be:	f091 0f00 	teqne	r1, #0
 80008c2:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80008c6:	d014      	beq.n	80008f2 <__aeabi_fmul+0x15e>
 80008c8:	ea92 0f0c 	teq	r2, ip
 80008cc:	d101      	bne.n	80008d2 <__aeabi_fmul+0x13e>
 80008ce:	0242      	lsls	r2, r0, #9
 80008d0:	d10f      	bne.n	80008f2 <__aeabi_fmul+0x15e>
 80008d2:	ea93 0f0c 	teq	r3, ip
 80008d6:	d103      	bne.n	80008e0 <__aeabi_fmul+0x14c>
 80008d8:	024b      	lsls	r3, r1, #9
 80008da:	bf18      	it	ne
 80008dc:	4608      	movne	r0, r1
 80008de:	d108      	bne.n	80008f2 <__aeabi_fmul+0x15e>
 80008e0:	ea80 0001 	eor.w	r0, r0, r1
 80008e4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80008e8:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80008ec:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80008f0:	4770      	bx	lr
 80008f2:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80008f6:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80008fa:	4770      	bx	lr

080008fc <__aeabi_fdiv>:
 80008fc:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000900:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000904:	bf1e      	ittt	ne
 8000906:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 800090a:	ea92 0f0c 	teqne	r2, ip
 800090e:	ea93 0f0c 	teqne	r3, ip
 8000912:	d069      	beq.n	80009e8 <__aeabi_fdiv+0xec>
 8000914:	eba2 0203 	sub.w	r2, r2, r3
 8000918:	ea80 0c01 	eor.w	ip, r0, r1
 800091c:	0249      	lsls	r1, r1, #9
 800091e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000922:	d037      	beq.n	8000994 <__aeabi_fdiv+0x98>
 8000924:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000928:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 800092c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000930:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000934:	428b      	cmp	r3, r1
 8000936:	bf38      	it	cc
 8000938:	005b      	lslcc	r3, r3, #1
 800093a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 800093e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000942:	428b      	cmp	r3, r1
 8000944:	bf24      	itt	cs
 8000946:	1a5b      	subcs	r3, r3, r1
 8000948:	ea40 000c 	orrcs.w	r0, r0, ip
 800094c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000950:	bf24      	itt	cs
 8000952:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000956:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800095a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 800095e:	bf24      	itt	cs
 8000960:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000964:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000968:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 800096c:	bf24      	itt	cs
 800096e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000972:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000976:	011b      	lsls	r3, r3, #4
 8000978:	bf18      	it	ne
 800097a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 800097e:	d1e0      	bne.n	8000942 <__aeabi_fdiv+0x46>
 8000980:	2afd      	cmp	r2, #253	; 0xfd
 8000982:	f63f af50 	bhi.w	8000826 <__aeabi_fmul+0x92>
 8000986:	428b      	cmp	r3, r1
 8000988:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800098c:	bf08      	it	eq
 800098e:	f020 0001 	biceq.w	r0, r0, #1
 8000992:	4770      	bx	lr
 8000994:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000998:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800099c:	327f      	adds	r2, #127	; 0x7f
 800099e:	bfc2      	ittt	gt
 80009a0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80009a4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80009a8:	4770      	bxgt	lr
 80009aa:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80009ae:	f04f 0300 	mov.w	r3, #0
 80009b2:	3a01      	subs	r2, #1
 80009b4:	e737      	b.n	8000826 <__aeabi_fmul+0x92>
 80009b6:	f092 0f00 	teq	r2, #0
 80009ba:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80009be:	bf02      	ittt	eq
 80009c0:	0040      	lsleq	r0, r0, #1
 80009c2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80009c6:	3a01      	subeq	r2, #1
 80009c8:	d0f9      	beq.n	80009be <__aeabi_fdiv+0xc2>
 80009ca:	ea40 000c 	orr.w	r0, r0, ip
 80009ce:	f093 0f00 	teq	r3, #0
 80009d2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80009d6:	bf02      	ittt	eq
 80009d8:	0049      	lsleq	r1, r1, #1
 80009da:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80009de:	3b01      	subeq	r3, #1
 80009e0:	d0f9      	beq.n	80009d6 <__aeabi_fdiv+0xda>
 80009e2:	ea41 010c 	orr.w	r1, r1, ip
 80009e6:	e795      	b.n	8000914 <__aeabi_fdiv+0x18>
 80009e8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80009ec:	ea92 0f0c 	teq	r2, ip
 80009f0:	d108      	bne.n	8000a04 <__aeabi_fdiv+0x108>
 80009f2:	0242      	lsls	r2, r0, #9
 80009f4:	f47f af7d 	bne.w	80008f2 <__aeabi_fmul+0x15e>
 80009f8:	ea93 0f0c 	teq	r3, ip
 80009fc:	f47f af70 	bne.w	80008e0 <__aeabi_fmul+0x14c>
 8000a00:	4608      	mov	r0, r1
 8000a02:	e776      	b.n	80008f2 <__aeabi_fmul+0x15e>
 8000a04:	ea93 0f0c 	teq	r3, ip
 8000a08:	d104      	bne.n	8000a14 <__aeabi_fdiv+0x118>
 8000a0a:	024b      	lsls	r3, r1, #9
 8000a0c:	f43f af4c 	beq.w	80008a8 <__aeabi_fmul+0x114>
 8000a10:	4608      	mov	r0, r1
 8000a12:	e76e      	b.n	80008f2 <__aeabi_fmul+0x15e>
 8000a14:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000a18:	bf18      	it	ne
 8000a1a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000a1e:	d1ca      	bne.n	80009b6 <__aeabi_fdiv+0xba>
 8000a20:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000a24:	f47f af5c 	bne.w	80008e0 <__aeabi_fmul+0x14c>
 8000a28:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8000a2c:	f47f af3c 	bne.w	80008a8 <__aeabi_fmul+0x114>
 8000a30:	e75f      	b.n	80008f2 <__aeabi_fmul+0x15e>
 8000a32:	bf00      	nop

08000a34 <__gesf2>:
 8000a34:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8000a38:	e006      	b.n	8000a48 <__cmpsf2+0x4>
 8000a3a:	bf00      	nop

08000a3c <__lesf2>:
 8000a3c:	f04f 0c01 	mov.w	ip, #1
 8000a40:	e002      	b.n	8000a48 <__cmpsf2+0x4>
 8000a42:	bf00      	nop

08000a44 <__cmpsf2>:
 8000a44:	f04f 0c01 	mov.w	ip, #1
 8000a48:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a4c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000a50:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000a54:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000a58:	bf18      	it	ne
 8000a5a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000a5e:	d011      	beq.n	8000a84 <__cmpsf2+0x40>
 8000a60:	b001      	add	sp, #4
 8000a62:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000a66:	bf18      	it	ne
 8000a68:	ea90 0f01 	teqne	r0, r1
 8000a6c:	bf58      	it	pl
 8000a6e:	ebb2 0003 	subspl.w	r0, r2, r3
 8000a72:	bf88      	it	hi
 8000a74:	17c8      	asrhi	r0, r1, #31
 8000a76:	bf38      	it	cc
 8000a78:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8000a7c:	bf18      	it	ne
 8000a7e:	f040 0001 	orrne.w	r0, r0, #1
 8000a82:	4770      	bx	lr
 8000a84:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000a88:	d102      	bne.n	8000a90 <__cmpsf2+0x4c>
 8000a8a:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000a8e:	d105      	bne.n	8000a9c <__cmpsf2+0x58>
 8000a90:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000a94:	d1e4      	bne.n	8000a60 <__cmpsf2+0x1c>
 8000a96:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8000a9a:	d0e1      	beq.n	8000a60 <__cmpsf2+0x1c>
 8000a9c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000aa0:	4770      	bx	lr
 8000aa2:	bf00      	nop

08000aa4 <__aeabi_cfrcmple>:
 8000aa4:	4684      	mov	ip, r0
 8000aa6:	4608      	mov	r0, r1
 8000aa8:	4661      	mov	r1, ip
 8000aaa:	e7ff      	b.n	8000aac <__aeabi_cfcmpeq>

08000aac <__aeabi_cfcmpeq>:
 8000aac:	b50f      	push	{r0, r1, r2, r3, lr}
 8000aae:	f7ff ffc9 	bl	8000a44 <__cmpsf2>
 8000ab2:	2800      	cmp	r0, #0
 8000ab4:	bf48      	it	mi
 8000ab6:	f110 0f00 	cmnmi.w	r0, #0
 8000aba:	bd0f      	pop	{r0, r1, r2, r3, pc}

08000abc <__aeabi_fcmpeq>:
 8000abc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ac0:	f7ff fff4 	bl	8000aac <__aeabi_cfcmpeq>
 8000ac4:	bf0c      	ite	eq
 8000ac6:	2001      	moveq	r0, #1
 8000ac8:	2000      	movne	r0, #0
 8000aca:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ace:	bf00      	nop

08000ad0 <__aeabi_fcmplt>:
 8000ad0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ad4:	f7ff ffea 	bl	8000aac <__aeabi_cfcmpeq>
 8000ad8:	bf34      	ite	cc
 8000ada:	2001      	movcc	r0, #1
 8000adc:	2000      	movcs	r0, #0
 8000ade:	f85d fb08 	ldr.w	pc, [sp], #8
 8000ae2:	bf00      	nop

08000ae4 <__aeabi_fcmple>:
 8000ae4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ae8:	f7ff ffe0 	bl	8000aac <__aeabi_cfcmpeq>
 8000aec:	bf94      	ite	ls
 8000aee:	2001      	movls	r0, #1
 8000af0:	2000      	movhi	r0, #0
 8000af2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000af6:	bf00      	nop

08000af8 <__aeabi_fcmpge>:
 8000af8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000afc:	f7ff ffd2 	bl	8000aa4 <__aeabi_cfrcmple>
 8000b00:	bf94      	ite	ls
 8000b02:	2001      	movls	r0, #1
 8000b04:	2000      	movhi	r0, #0
 8000b06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0a:	bf00      	nop

08000b0c <__aeabi_fcmpgt>:
 8000b0c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b10:	f7ff ffc8 	bl	8000aa4 <__aeabi_cfrcmple>
 8000b14:	bf34      	ite	cc
 8000b16:	2001      	movcc	r0, #1
 8000b18:	2000      	movcs	r0, #0
 8000b1a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1e:	bf00      	nop

08000b20 <__aeabi_fcmpun>:
 8000b20:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000b24:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000b28:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000b2c:	d102      	bne.n	8000b34 <__aeabi_fcmpun+0x14>
 8000b2e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000b32:	d108      	bne.n	8000b46 <__aeabi_fcmpun+0x26>
 8000b34:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000b38:	d102      	bne.n	8000b40 <__aeabi_fcmpun+0x20>
 8000b3a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8000b3e:	d102      	bne.n	8000b46 <__aeabi_fcmpun+0x26>
 8000b40:	f04f 0000 	mov.w	r0, #0
 8000b44:	4770      	bx	lr
 8000b46:	f04f 0001 	mov.w	r0, #1
 8000b4a:	4770      	bx	lr

08000b4c <__aeabi_f2iz>:
 8000b4c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000b50:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000b54:	d30f      	bcc.n	8000b76 <__aeabi_f2iz+0x2a>
 8000b56:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000b5a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000b5e:	d90d      	bls.n	8000b7c <__aeabi_f2iz+0x30>
 8000b60:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000b64:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000b68:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000b6c:	fa23 f002 	lsr.w	r0, r3, r2
 8000b70:	bf18      	it	ne
 8000b72:	4240      	negne	r0, r0
 8000b74:	4770      	bx	lr
 8000b76:	f04f 0000 	mov.w	r0, #0
 8000b7a:	4770      	bx	lr
 8000b7c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000b80:	d101      	bne.n	8000b86 <__aeabi_f2iz+0x3a>
 8000b82:	0242      	lsls	r2, r0, #9
 8000b84:	d105      	bne.n	8000b92 <__aeabi_f2iz+0x46>
 8000b86:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8000b8a:	bf08      	it	eq
 8000b8c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000b90:	4770      	bx	lr
 8000b92:	f04f 0000 	mov.w	r0, #0
 8000b96:	4770      	bx	lr

08000b98 <__aeabi_f2uiz>:
 8000b98:	0042      	lsls	r2, r0, #1
 8000b9a:	d20e      	bcs.n	8000bba <__aeabi_f2uiz+0x22>
 8000b9c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000ba0:	d30b      	bcc.n	8000bba <__aeabi_f2uiz+0x22>
 8000ba2:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000ba6:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000baa:	d409      	bmi.n	8000bc0 <__aeabi_f2uiz+0x28>
 8000bac:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000bb0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000bb4:	fa23 f002 	lsr.w	r0, r3, r2
 8000bb8:	4770      	bx	lr
 8000bba:	f04f 0000 	mov.w	r0, #0
 8000bbe:	4770      	bx	lr
 8000bc0:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000bc4:	d101      	bne.n	8000bca <__aeabi_f2uiz+0x32>
 8000bc6:	0242      	lsls	r2, r0, #9
 8000bc8:	d102      	bne.n	8000bd0 <__aeabi_f2uiz+0x38>
 8000bca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000bce:	4770      	bx	lr
 8000bd0:	f04f 0000 	mov.w	r0, #0
 8000bd4:	4770      	bx	lr
 8000bd6:	bf00      	nop

08000bd8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000bd8:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000bda:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000bde:	4a0d      	ldr	r2, [pc, #52]	; (8000c14 <HAL_InitTick+0x3c>)
{
 8000be0:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000be2:	7811      	ldrb	r1, [r2, #0]
 8000be4:	4a0c      	ldr	r2, [pc, #48]	; (8000c18 <HAL_InitTick+0x40>)
 8000be6:	fbb3 f3f1 	udiv	r3, r3, r1
 8000bea:	6812      	ldr	r2, [r2, #0]
 8000bec:	fbb2 f0f3 	udiv	r0, r2, r3
 8000bf0:	f000 f892 	bl	8000d18 <HAL_SYSTICK_Config>
 8000bf4:	b908      	cbnz	r0, 8000bfa <HAL_InitTick+0x22>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000bf6:	2d0f      	cmp	r5, #15
 8000bf8:	d901      	bls.n	8000bfe <HAL_InitTick+0x26>
    return HAL_ERROR;
 8000bfa:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8000bfc:	bd38      	pop	{r3, r4, r5, pc}
 8000bfe:	4604      	mov	r4, r0
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000c00:	4602      	mov	r2, r0
 8000c02:	4629      	mov	r1, r5
 8000c04:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000c08:	f000 f834 	bl	8000c74 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000c0c:	4b03      	ldr	r3, [pc, #12]	; (8000c1c <HAL_InitTick+0x44>)
 8000c0e:	4620      	mov	r0, r4
 8000c10:	601d      	str	r5, [r3, #0]
}
 8000c12:	bd38      	pop	{r3, r4, r5, pc}
 8000c14:	20000000 	.word	0x20000000
 8000c18:	20000010 	.word	0x20000010
 8000c1c:	20000004 	.word	0x20000004

08000c20 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c20:	4a07      	ldr	r2, [pc, #28]	; (8000c40 <HAL_Init+0x20>)
{
 8000c22:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c24:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000c26:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c28:	f043 0310 	orr.w	r3, r3, #16
 8000c2c:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000c2e:	f000 f80f 	bl	8000c50 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000c32:	2000      	movs	r0, #0
 8000c34:	f7ff ffd0 	bl	8000bd8 <HAL_InitTick>
  HAL_MspInit();
 8000c38:	f004 f830 	bl	8004c9c <HAL_MspInit>
}
 8000c3c:	2000      	movs	r0, #0
 8000c3e:	bd08      	pop	{r3, pc}
 8000c40:	40022000 	.word	0x40022000

08000c44 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000c44:	4b01      	ldr	r3, [pc, #4]	; (8000c4c <HAL_GetTick+0x8>)
 8000c46:	6818      	ldr	r0, [r3, #0]
}
 8000c48:	4770      	bx	lr
 8000c4a:	bf00      	nop
 8000c4c:	20001ef8 	.word	0x20001ef8

08000c50 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000c50:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c54:	4a06      	ldr	r2, [pc, #24]	; (8000c70 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000c56:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c58:	68d0      	ldr	r0, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000c5a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000c5e:	4008      	ands	r0, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000c60:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8000c62:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000c66:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8000c6a:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000c6c:	4770      	bx	lr
 8000c6e:	bf00      	nop
 8000c70:	e000ed00 	.word	0xe000ed00

08000c74 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000c74:	4b19      	ldr	r3, [pc, #100]	; (8000cdc <HAL_NVIC_SetPriority+0x68>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000c76:	b430      	push	{r4, r5}
 8000c78:	68db      	ldr	r3, [r3, #12]
 8000c7a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000c7e:	f1c3 0507 	rsb	r5, r3, #7
 8000c82:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000c84:	f103 0404 	add.w	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000c88:	bf28      	it	cs
 8000c8a:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000c8c:	2c06      	cmp	r4, #6
 8000c8e:	d919      	bls.n	8000cc4 <HAL_NVIC_SetPriority+0x50>
 8000c90:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8000c94:	3b03      	subs	r3, #3
 8000c96:	409c      	lsls	r4, r3
 8000c98:	ea22 0204 	bic.w	r2, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000c9c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8000ca0:	40ac      	lsls	r4, r5
 8000ca2:	ea21 0104 	bic.w	r1, r1, r4
 8000ca6:	4099      	lsls	r1, r3
  if ((int32_t)(IRQn) < 0)
 8000ca8:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000caa:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) < 0)
 8000cae:	db0c      	blt.n	8000cca <HAL_NVIC_SetPriority+0x56>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000cb0:	0109      	lsls	r1, r1, #4
 8000cb2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000cb6:	b2c9      	uxtb	r1, r1
 8000cb8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000cbc:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000cc0:	bc30      	pop	{r4, r5}
 8000cc2:	4770      	bx	lr
 8000cc4:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000cc6:	4613      	mov	r3, r2
 8000cc8:	e7e8      	b.n	8000c9c <HAL_NVIC_SetPriority+0x28>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000cca:	4b05      	ldr	r3, [pc, #20]	; (8000ce0 <HAL_NVIC_SetPriority+0x6c>)
 8000ccc:	f000 000f 	and.w	r0, r0, #15
 8000cd0:	0109      	lsls	r1, r1, #4
 8000cd2:	b2c9      	uxtb	r1, r1
 8000cd4:	4403      	add	r3, r0
 8000cd6:	7619      	strb	r1, [r3, #24]
 8000cd8:	bc30      	pop	{r4, r5}
 8000cda:	4770      	bx	lr
 8000cdc:	e000ed00 	.word	0xe000ed00
 8000ce0:	e000ecfc 	.word	0xe000ecfc

08000ce4 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000ce4:	2301      	movs	r3, #1
 8000ce6:	f000 011f 	and.w	r1, r0, #31
 8000cea:	4a03      	ldr	r2, [pc, #12]	; (8000cf8 <HAL_NVIC_EnableIRQ+0x14>)
 8000cec:	0940      	lsrs	r0, r0, #5
 8000cee:	408b      	lsls	r3, r1
 8000cf0:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000cf4:	4770      	bx	lr
 8000cf6:	bf00      	nop
 8000cf8:	e000e100 	.word	0xe000e100

08000cfc <HAL_NVIC_DisableIRQ>:
  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000cfc:	2201      	movs	r2, #1
 8000cfe:	0943      	lsrs	r3, r0, #5
 8000d00:	4904      	ldr	r1, [pc, #16]	; (8000d14 <HAL_NVIC_DisableIRQ+0x18>)
 8000d02:	f000 001f 	and.w	r0, r0, #31
 8000d06:	3320      	adds	r3, #32
 8000d08:	fa02 f000 	lsl.w	r0, r2, r0
 8000d0c:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8000d10:	4770      	bx	lr
 8000d12:	bf00      	nop
 8000d14:	e000e100 	.word	0xe000e100

08000d18 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000d18:	3801      	subs	r0, #1
 8000d1a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000d1e:	d20d      	bcs.n	8000d3c <HAL_SYSTICK_Config+0x24>
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000d20:	b430      	push	{r4, r5}
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d22:	25f0      	movs	r5, #240	; 0xf0
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d24:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d26:	2107      	movs	r1, #7
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d28:	4b05      	ldr	r3, [pc, #20]	; (8000d40 <HAL_SYSTICK_Config+0x28>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d2a:	4c06      	ldr	r4, [pc, #24]	; (8000d44 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d2c:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d2e:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000d32:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 8000d34:	bc30      	pop	{r4, r5}
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d36:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d38:	6019      	str	r1, [r3, #0]
 8000d3a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000d3c:	2001      	movs	r0, #1
 8000d3e:	4770      	bx	lr
 8000d40:	e000e010 	.word	0xe000e010
 8000d44:	e000ed00 	.word	0xe000ed00

08000d48 <HAL_DMA_Abort_IT>:
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
  HAL_StatusTypeDef status = HAL_OK;
  
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8000d48:	f890 2021 	ldrb.w	r2, [r0, #33]	; 0x21
{  
 8000d4c:	4603      	mov	r3, r0
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8000d4e:	2a02      	cmp	r2, #2
 8000d50:	d003      	beq.n	8000d5a <HAL_DMA_Abort_IT+0x12>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000d52:	2204      	movs	r2, #4
        
    status = HAL_ERROR;
 8000d54:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000d56:	639a      	str	r2, [r3, #56]	; 0x38
    {
      hdma->XferAbortCallback(hdma);
    } 
  }
  return status;
}
 8000d58:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000d5a:	6802      	ldr	r2, [r0, #0]
{  
 8000d5c:	b510      	push	{r4, lr}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000d5e:	6811      	ldr	r1, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000d60:	481b      	ldr	r0, [pc, #108]	; (8000dd0 <HAL_DMA_Abort_IT+0x88>)
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8000d62:	f021 010e 	bic.w	r1, r1, #14
 8000d66:	6011      	str	r1, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 8000d68:	6811      	ldr	r1, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000d6a:	4282      	cmp	r2, r0
    __HAL_DMA_DISABLE(hdma);
 8000d6c:	f021 0101 	bic.w	r1, r1, #1
 8000d70:	6011      	str	r1, [r2, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000d72:	d021      	beq.n	8000db8 <HAL_DMA_Abort_IT+0x70>
 8000d74:	4917      	ldr	r1, [pc, #92]	; (8000dd4 <HAL_DMA_Abort_IT+0x8c>)
 8000d76:	428a      	cmp	r2, r1
 8000d78:	d01a      	beq.n	8000db0 <HAL_DMA_Abort_IT+0x68>
 8000d7a:	3114      	adds	r1, #20
 8000d7c:	428a      	cmp	r2, r1
 8000d7e:	d01d      	beq.n	8000dbc <HAL_DMA_Abort_IT+0x74>
 8000d80:	3114      	adds	r1, #20
 8000d82:	428a      	cmp	r2, r1
 8000d84:	d01d      	beq.n	8000dc2 <HAL_DMA_Abort_IT+0x7a>
 8000d86:	3114      	adds	r1, #20
 8000d88:	428a      	cmp	r2, r1
 8000d8a:	d01d      	beq.n	8000dc8 <HAL_DMA_Abort_IT+0x80>
 8000d8c:	3114      	adds	r1, #20
 8000d8e:	428a      	cmp	r2, r1
 8000d90:	bf0c      	ite	eq
 8000d92:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
 8000d96:	f04f 7280 	movne.w	r2, #16777216	; 0x1000000
    __HAL_UNLOCK(hdma);
 8000d9a:	f44f 7080 	mov.w	r0, #256	; 0x100
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000d9e:	4c0e      	ldr	r4, [pc, #56]	; (8000dd8 <HAL_DMA_Abort_IT+0x90>)
    if(hdma->XferAbortCallback != NULL)
 8000da0:	6b59      	ldr	r1, [r3, #52]	; 0x34
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000da2:	6062      	str	r2, [r4, #4]
    __HAL_UNLOCK(hdma);
 8000da4:	8418      	strh	r0, [r3, #32]
    if(hdma->XferAbortCallback != NULL)
 8000da6:	b129      	cbz	r1, 8000db4 <HAL_DMA_Abort_IT+0x6c>
      hdma->XferAbortCallback(hdma);
 8000da8:	4618      	mov	r0, r3
 8000daa:	4788      	blx	r1
  HAL_StatusTypeDef status = HAL_OK;
 8000dac:	2000      	movs	r0, #0
}
 8000dae:	bd10      	pop	{r4, pc}
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000db0:	2210      	movs	r2, #16
 8000db2:	e7f2      	b.n	8000d9a <HAL_DMA_Abort_IT+0x52>
  HAL_StatusTypeDef status = HAL_OK;
 8000db4:	4608      	mov	r0, r1
}
 8000db6:	bd10      	pop	{r4, pc}
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8000db8:	2201      	movs	r2, #1
 8000dba:	e7ee      	b.n	8000d9a <HAL_DMA_Abort_IT+0x52>
 8000dbc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000dc0:	e7eb      	b.n	8000d9a <HAL_DMA_Abort_IT+0x52>
 8000dc2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000dc6:	e7e8      	b.n	8000d9a <HAL_DMA_Abort_IT+0x52>
 8000dc8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000dcc:	e7e5      	b.n	8000d9a <HAL_DMA_Abort_IT+0x52>
 8000dce:	bf00      	nop
 8000dd0:	40020008 	.word	0x40020008
 8000dd4:	4002001c 	.word	0x4002001c
 8000dd8:	40020000 	.word	0x40020000

08000ddc <HAL_FLASH_Program>:
  * @param  Data:         Specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8000ddc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint8_t index = 0;
  uint8_t nbiterations = 0;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8000de0:	4e6b      	ldr	r6, [pc, #428]	; (8000f90 <HAL_FLASH_Program+0x1b4>)
{
 8000de2:	4680      	mov	r8, r0
  __HAL_LOCK(&pFlash);
 8000de4:	7e30      	ldrb	r0, [r6, #24]
 8000de6:	2801      	cmp	r0, #1
 8000de8:	f000 80c7 	beq.w	8000f7a <HAL_FLASH_Program+0x19e>
 8000dec:	461f      	mov	r7, r3
 8000dee:	2301      	movs	r3, #1
 8000df0:	460d      	mov	r5, r1
 8000df2:	4691      	mov	r9, r2
 8000df4:	7633      	strb	r3, [r6, #24]
{
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
     
  uint32_t tickstart = HAL_GetTick();
 8000df6:	f7ff ff25 	bl	8000c44 <HAL_GetTick>
     
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
  { 
    if (Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000dfa:	f24c 3b50 	movw	fp, #50000	; 0xc350
  uint32_t tickstart = HAL_GetTick();
 8000dfe:	4604      	mov	r4, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000e00:	f8df a190 	ldr.w	sl, [pc, #400]	; 8000f94 <HAL_FLASH_Program+0x1b8>
 8000e04:	e005      	b.n	8000e12 <HAL_FLASH_Program+0x36>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000e06:	f7ff ff1d 	bl	8000c44 <HAL_GetTick>
 8000e0a:	1b00      	subs	r0, r0, r4
 8000e0c:	4558      	cmp	r0, fp
 8000e0e:	f200 80b2 	bhi.w	8000f76 <HAL_FLASH_Program+0x19a>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000e12:	f8da 300c 	ldr.w	r3, [sl, #12]
 8000e16:	07db      	lsls	r3, r3, #31
 8000e18:	d4f5      	bmi.n	8000e06 <HAL_FLASH_Program+0x2a>
      }
    }
  }
  
  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000e1a:	f8da 300c 	ldr.w	r3, [sl, #12]
 8000e1e:	0698      	lsls	r0, r3, #26
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000e20:	bf44      	itt	mi
 8000e22:	2320      	movmi	r3, #32
 8000e24:	f8ca 300c 	strmi.w	r3, [sl, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000e28:	4b5a      	ldr	r3, [pc, #360]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000e2a:	68da      	ldr	r2, [r3, #12]
 8000e2c:	06d1      	lsls	r1, r2, #27
 8000e2e:	d453      	bmi.n	8000ed8 <HAL_FLASH_Program+0xfc>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000e30:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000e32:	07d2      	lsls	r2, r2, #31
 8000e34:	d450      	bmi.n	8000ed8 <HAL_FLASH_Program+0xfc>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000e36:	68db      	ldr	r3, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000e38:	f013 0a04 	ands.w	sl, r3, #4
 8000e3c:	d14c      	bne.n	8000ed8 <HAL_FLASH_Program+0xfc>
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8000e3e:	f1b8 0f01 	cmp.w	r8, #1
 8000e42:	d006      	beq.n	8000e52 <HAL_FLASH_Program+0x76>
      nbiterations = 4U;
 8000e44:	f1b8 0f02 	cmp.w	r8, #2
 8000e48:	bf0c      	ite	eq
 8000e4a:	f04f 0802 	moveq.w	r8, #2
 8000e4e:	f04f 0804 	movne.w	r8, #4
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000e52:	4c50      	ldr	r4, [pc, #320]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000e54:	eb05 0848 	add.w	r8, r5, r8, lsl #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000e58:	2200      	movs	r2, #0
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000e5a:	f1ca 0c20 	rsb	ip, sl, #32
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8000e5e:	61f2      	str	r2, [r6, #28]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000e60:	fa07 fc0c 	lsl.w	ip, r7, ip
 8000e64:	fa29 f00a 	lsr.w	r0, r9, sl
 8000e68:	f1aa 0120 	sub.w	r1, sl, #32
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000e6c:	6922      	ldr	r2, [r4, #16]
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000e6e:	ea40 000c 	orr.w	r0, r0, ip
 8000e72:	fa27 f101 	lsr.w	r1, r7, r1
 8000e76:	4308      	orrs	r0, r1
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000e78:	f042 0201 	orr.w	r2, r2, #1
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 8000e7c:	b280      	uxth	r0, r0
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8000e7e:	6122      	str	r2, [r4, #16]
  *(__IO uint16_t*)Address = Data;
 8000e80:	8028      	strh	r0, [r5, #0]
  uint32_t tickstart = HAL_GetTick();
 8000e82:	f7ff fedf 	bl	8000c44 <HAL_GetTick>
 8000e86:	4683      	mov	fp, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000e88:	e007      	b.n	8000e9a <HAL_FLASH_Program+0xbe>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8000e8a:	f7ff fedb 	bl	8000c44 <HAL_GetTick>
 8000e8e:	f24c 3350 	movw	r3, #50000	; 0xc350
 8000e92:	eba0 000b 	sub.w	r0, r0, fp
 8000e96:	4298      	cmp	r0, r3
 8000e98:	d865      	bhi.n	8000f66 <HAL_FLASH_Program+0x18a>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000e9a:	68e2      	ldr	r2, [r4, #12]
 8000e9c:	07d0      	lsls	r0, r2, #31
 8000e9e:	d4f4      	bmi.n	8000e8a <HAL_FLASH_Program+0xae>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000ea0:	68e2      	ldr	r2, [r4, #12]
 8000ea2:	0691      	lsls	r1, r2, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000ea4:	bf44      	itt	mi
 8000ea6:	2220      	movmi	r2, #32
 8000ea8:	60e2      	strmi	r2, [r4, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000eaa:	68e2      	ldr	r2, [r4, #12]
 8000eac:	06d2      	lsls	r2, r2, #27
 8000eae:	d432      	bmi.n	8000f16 <HAL_FLASH_Program+0x13a>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000eb0:	69e2      	ldr	r2, [r4, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000eb2:	07d3      	lsls	r3, r2, #31
 8000eb4:	d42f      	bmi.n	8000f16 <HAL_FLASH_Program+0x13a>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000eb6:	68e0      	ldr	r0, [r4, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8000eb8:	f010 0004 	ands.w	r0, r0, #4
 8000ebc:	d12b      	bne.n	8000f16 <HAL_FLASH_Program+0x13a>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000ebe:	6922      	ldr	r2, [r4, #16]
 8000ec0:	3502      	adds	r5, #2
 8000ec2:	f022 0201 	bic.w	r2, r2, #1
    for (index = 0U; index < nbiterations; index++)
 8000ec6:	4545      	cmp	r5, r8
 8000ec8:	f10a 0a10 	add.w	sl, sl, #16
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000ecc:	6122      	str	r2, [r4, #16]
    for (index = 0U; index < nbiterations; index++)
 8000ece:	d1c3      	bne.n	8000e58 <HAL_FLASH_Program+0x7c>
  __HAL_UNLOCK(&pFlash);
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	7633      	strb	r3, [r6, #24]
}
 8000ed4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint32_t flags = 0U;
  
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8000ed8:	4b2e      	ldr	r3, [pc, #184]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000eda:	68db      	ldr	r3, [r3, #12]
 8000edc:	f013 0310 	ands.w	r3, r3, #16
 8000ee0:	d14e      	bne.n	8000f80 <HAL_FLASH_Program+0x1a4>
 8000ee2:	2104      	movs	r1, #4
#endif /* FLASH_BANK2_END */
  }
#if defined(FLASH_BANK2_END)
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
#else
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000ee4:	4a2b      	ldr	r2, [pc, #172]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000ee6:	68d2      	ldr	r2, [r2, #12]
 8000ee8:	0755      	lsls	r5, r2, #29
 8000eea:	d504      	bpl.n	8000ef6 <HAL_FLASH_Program+0x11a>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
#if defined(FLASH_BANK2_END)
    flags |= FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2;
#else
    flags |= FLASH_FLAG_PGERR;
 8000eec:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8000eee:	69f2      	ldr	r2, [r6, #28]
 8000ef0:	f042 0201 	orr.w	r2, r2, #1
 8000ef4:	61f2      	str	r2, [r6, #28]
#endif /* FLASH_BANK2_END */
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8000ef6:	4a27      	ldr	r2, [pc, #156]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000ef8:	69d1      	ldr	r1, [r2, #28]
 8000efa:	07cc      	lsls	r4, r1, #31
 8000efc:	d507      	bpl.n	8000f0e <HAL_FLASH_Program+0x132>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8000efe:	69f1      	ldr	r1, [r6, #28]
 8000f00:	f041 0104 	orr.w	r1, r1, #4
 8000f04:	61f1      	str	r1, [r6, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8000f06:	69d1      	ldr	r1, [r2, #28]
 8000f08:	f021 0101 	bic.w	r1, r1, #1
 8000f0c:	61d1      	str	r1, [r2, #28]
  }

  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f0e:	4a21      	ldr	r2, [pc, #132]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
    return HAL_ERROR;
 8000f10:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f12:	60d3      	str	r3, [r2, #12]
  if(status == HAL_OK)
 8000f14:	e7dc      	b.n	8000ed0 <HAL_FLASH_Program+0xf4>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8000f16:	4b1f      	ldr	r3, [pc, #124]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000f18:	68db      	ldr	r3, [r3, #12]
 8000f1a:	f013 0310 	ands.w	r3, r3, #16
 8000f1e:	d028      	beq.n	8000f72 <HAL_FLASH_Program+0x196>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000f20:	69f3      	ldr	r3, [r6, #28]
 8000f22:	2114      	movs	r1, #20
 8000f24:	f043 0302 	orr.w	r3, r3, #2
 8000f28:	61f3      	str	r3, [r6, #28]
    flags |= FLASH_FLAG_WRPERR;
 8000f2a:	2310      	movs	r3, #16
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8000f2c:	4a19      	ldr	r2, [pc, #100]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000f2e:	68d2      	ldr	r2, [r2, #12]
 8000f30:	0750      	lsls	r0, r2, #29
 8000f32:	d504      	bpl.n	8000f3e <HAL_FLASH_Program+0x162>
    flags |= FLASH_FLAG_PGERR;
 8000f34:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8000f36:	69f2      	ldr	r2, [r6, #28]
 8000f38:	f042 0201 	orr.w	r2, r2, #1
 8000f3c:	61f2      	str	r2, [r6, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8000f3e:	4a15      	ldr	r2, [pc, #84]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
 8000f40:	69d1      	ldr	r1, [r2, #28]
 8000f42:	07c9      	lsls	r1, r1, #31
 8000f44:	d507      	bpl.n	8000f56 <HAL_FLASH_Program+0x17a>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8000f46:	69f1      	ldr	r1, [r6, #28]
 8000f48:	f041 0104 	orr.w	r1, r1, #4
 8000f4c:	61f1      	str	r1, [r6, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8000f4e:	69d1      	ldr	r1, [r2, #28]
 8000f50:	f021 0101 	bic.w	r1, r1, #1
 8000f54:	61d1      	str	r1, [r2, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f56:	4a0f      	ldr	r2, [pc, #60]	; (8000f94 <HAL_FLASH_Program+0x1b8>)
    return HAL_ERROR;
 8000f58:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 8000f5a:	60d3      	str	r3, [r2, #12]
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000f5c:	6913      	ldr	r3, [r2, #16]
 8000f5e:	f023 0301 	bic.w	r3, r3, #1
 8000f62:	6113      	str	r3, [r2, #16]
      if (status != HAL_OK)
 8000f64:	e7b4      	b.n	8000ed0 <HAL_FLASH_Program+0xf4>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8000f66:	6923      	ldr	r3, [r4, #16]
 8000f68:	2003      	movs	r0, #3
 8000f6a:	f023 0301 	bic.w	r3, r3, #1
 8000f6e:	6123      	str	r3, [r4, #16]
      if (status != HAL_OK)
 8000f70:	e7ae      	b.n	8000ed0 <HAL_FLASH_Program+0xf4>
 8000f72:	2104      	movs	r1, #4
 8000f74:	e7da      	b.n	8000f2c <HAL_FLASH_Program+0x150>
 8000f76:	2003      	movs	r0, #3
 8000f78:	e7aa      	b.n	8000ed0 <HAL_FLASH_Program+0xf4>
  __HAL_LOCK(&pFlash);
 8000f7a:	2002      	movs	r0, #2
}
 8000f7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8000f80:	69f3      	ldr	r3, [r6, #28]
 8000f82:	2114      	movs	r1, #20
 8000f84:	f043 0302 	orr.w	r3, r3, #2
 8000f88:	61f3      	str	r3, [r6, #28]
    flags |= FLASH_FLAG_WRPERR;
 8000f8a:	2310      	movs	r3, #16
 8000f8c:	e7aa      	b.n	8000ee4 <HAL_FLASH_Program+0x108>
 8000f8e:	bf00      	nop
 8000f90:	20001f00 	.word	0x20001f00
 8000f94:	40022000 	.word	0x40022000

08000f98 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8000f98:	4b06      	ldr	r3, [pc, #24]	; (8000fb4 <HAL_FLASH_Unlock+0x1c>)
 8000f9a:	6918      	ldr	r0, [r3, #16]
 8000f9c:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8000fa0:	d006      	beq.n	8000fb0 <HAL_FLASH_Unlock+0x18>
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8000fa2:	4905      	ldr	r1, [pc, #20]	; (8000fb8 <HAL_FLASH_Unlock+0x20>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8000fa4:	4a05      	ldr	r2, [pc, #20]	; (8000fbc <HAL_FLASH_Unlock+0x24>)
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8000fa6:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8000fa8:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8000faa:	6918      	ldr	r0, [r3, #16]
  HAL_StatusTypeDef status = HAL_OK;
 8000fac:	f3c0 10c0 	ubfx	r0, r0, #7, #1
}
 8000fb0:	4770      	bx	lr
 8000fb2:	bf00      	nop
 8000fb4:	40022000 	.word	0x40022000
 8000fb8:	45670123 	.word	0x45670123
 8000fbc:	cdef89ab 	.word	0xcdef89ab

08000fc0 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8000fc0:	4a03      	ldr	r2, [pc, #12]	; (8000fd0 <HAL_FLASH_Lock+0x10>)
}
 8000fc2:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8000fc4:	6913      	ldr	r3, [r2, #16]
 8000fc6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000fca:	6113      	str	r3, [r2, #16]
}
 8000fcc:	4770      	bx	lr
 8000fce:	bf00      	nop
 8000fd0:	40022000 	.word	0x40022000

08000fd4 <FLASH_WaitForLastOperation>:
{
 8000fd4:	b570      	push	{r4, r5, r6, lr}
 8000fd6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000fd8:	f7ff fe34 	bl	8000c44 <HAL_GetTick>
 8000fdc:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8000fde:	4e26      	ldr	r6, [pc, #152]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8000fe0:	1c60      	adds	r0, r4, #1
 8000fe2:	d136      	bne.n	8001052 <FLASH_WaitForLastOperation+0x7e>
 8000fe4:	4a24      	ldr	r2, [pc, #144]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8000fe6:	68d3      	ldr	r3, [r2, #12]
 8000fe8:	07d9      	lsls	r1, r3, #31
 8000fea:	d4fc      	bmi.n	8000fe6 <FLASH_WaitForLastOperation+0x12>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8000fec:	4b22      	ldr	r3, [pc, #136]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8000fee:	68da      	ldr	r2, [r3, #12]
 8000ff0:	0696      	lsls	r6, r2, #26
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8000ff2:	bf44      	itt	mi
 8000ff4:	2220      	movmi	r2, #32
 8000ff6:	60da      	strmi	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8000ff8:	4b1f      	ldr	r3, [pc, #124]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8000ffa:	68da      	ldr	r2, [r3, #12]
 8000ffc:	06d5      	lsls	r5, r2, #27
 8000ffe:	d407      	bmi.n	8001010 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8001000:	69da      	ldr	r2, [r3, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8001002:	07d4      	lsls	r4, r2, #31
 8001004:	d404      	bmi.n	8001010 <FLASH_WaitForLastOperation+0x3c>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8001006:	68d8      	ldr	r0, [r3, #12]
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
 8001008:	f010 0004 	ands.w	r0, r0, #4
 800100c:	d100      	bne.n	8001010 <FLASH_WaitForLastOperation+0x3c>
}
 800100e:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8001010:	4b19      	ldr	r3, [pc, #100]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8001012:	68db      	ldr	r3, [r3, #12]
 8001014:	f013 0310 	ands.w	r3, r3, #16
 8001018:	d126      	bne.n	8001068 <FLASH_WaitForLastOperation+0x94>
 800101a:	2104      	movs	r1, #4
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 800101c:	4a16      	ldr	r2, [pc, #88]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 800101e:	68d2      	ldr	r2, [r2, #12]
 8001020:	0750      	lsls	r0, r2, #29
 8001022:	d505      	bpl.n	8001030 <FLASH_WaitForLastOperation+0x5c>
    flags |= FLASH_FLAG_PGERR;
 8001024:	460b      	mov	r3, r1
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8001026:	4915      	ldr	r1, [pc, #84]	; (800107c <FLASH_WaitForLastOperation+0xa8>)
 8001028:	69ca      	ldr	r2, [r1, #28]
 800102a:	f042 0201 	orr.w	r2, r2, #1
 800102e:	61ca      	str	r2, [r1, #28]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
 8001030:	4a11      	ldr	r2, [pc, #68]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
 8001032:	69d1      	ldr	r1, [r2, #28]
 8001034:	07c9      	lsls	r1, r1, #31
 8001036:	d508      	bpl.n	800104a <FLASH_WaitForLastOperation+0x76>
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
 8001038:	4810      	ldr	r0, [pc, #64]	; (800107c <FLASH_WaitForLastOperation+0xa8>)
 800103a:	69c1      	ldr	r1, [r0, #28]
 800103c:	f041 0104 	orr.w	r1, r1, #4
 8001040:	61c1      	str	r1, [r0, #28]
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
 8001042:	69d1      	ldr	r1, [r2, #28]
 8001044:	f021 0101 	bic.w	r1, r1, #1
 8001048:	61d1      	str	r1, [r2, #28]
  __HAL_FLASH_CLEAR_FLAG(flags);
 800104a:	4a0b      	ldr	r2, [pc, #44]	; (8001078 <FLASH_WaitForLastOperation+0xa4>)
    return HAL_ERROR;
 800104c:	2001      	movs	r0, #1
  __HAL_FLASH_CLEAR_FLAG(flags);
 800104e:	60d3      	str	r3, [r2, #12]
}
 8001050:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8001052:	68f3      	ldr	r3, [r6, #12]
 8001054:	07db      	lsls	r3, r3, #31
 8001056:	d5c9      	bpl.n	8000fec <FLASH_WaitForLastOperation+0x18>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8001058:	b124      	cbz	r4, 8001064 <FLASH_WaitForLastOperation+0x90>
 800105a:	f7ff fdf3 	bl	8000c44 <HAL_GetTick>
 800105e:	1b40      	subs	r0, r0, r5
 8001060:	42a0      	cmp	r0, r4
 8001062:	d9bd      	bls.n	8000fe0 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 8001064:	2003      	movs	r0, #3
}
 8001066:	bd70      	pop	{r4, r5, r6, pc}
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001068:	4804      	ldr	r0, [pc, #16]	; (800107c <FLASH_WaitForLastOperation+0xa8>)
 800106a:	2114      	movs	r1, #20
 800106c:	69c2      	ldr	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 800106e:	2310      	movs	r3, #16
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001070:	f042 0202 	orr.w	r2, r2, #2
 8001074:	61c2      	str	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 8001076:	e7d1      	b.n	800101c <FLASH_WaitForLastOperation+0x48>
 8001078:	40022000 	.word	0x40022000
 800107c:	20001f00 	.word	0x20001f00

08001080 <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFF means that all the pages have been correctly erased)
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
{
 8001080:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef status = HAL_ERROR;
  uint32_t address = 0U;

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001084:	4e2d      	ldr	r6, [pc, #180]	; (800113c <HAL_FLASHEx_Erase+0xbc>)
 8001086:	7e33      	ldrb	r3, [r6, #24]
 8001088:	2b01      	cmp	r3, #1
 800108a:	d054      	beq.n	8001136 <HAL_FLASHEx_Erase+0xb6>
 800108c:	2301      	movs	r3, #1
 800108e:	7633      	strb	r3, [r6, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001090:	6803      	ldr	r3, [r0, #0]
 8001092:	4681      	mov	r9, r0
 8001094:	2b02      	cmp	r3, #2
 8001096:	d031      	beq.n	80010fc <HAL_FLASHEx_Erase+0x7c>
    else
#endif /* FLASH_BANK2_END */
   {
      /* Page Erase requested on address located on bank1 */
      /* Wait for last operation to be completed */
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 8001098:	f24c 3050 	movw	r0, #50000	; 0xc350
 800109c:	4688      	mov	r8, r1
 800109e:	f7ff ff99 	bl	8000fd4 <FLASH_WaitForLastOperation>
 80010a2:	bb80      	cbnz	r0, 8001106 <HAL_FLASHEx_Erase+0x86>
      {
        /*Initialization of PageError variable*/
        *PageError = 0xFFFFFFFFU;
 80010a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80010a8:	f8c8 3000 	str.w	r3, [r8]
        
        /* Erase page by page to be done*/
        for(address = pEraseInit->PageAddress;
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 80010ac:	e9d9 5302 	ldrd	r5, r3, [r9, #8]
 80010b0:	eb05 2383 	add.w	r3, r5, r3, lsl #10
        for(address = pEraseInit->PageAddress;
 80010b4:	429d      	cmp	r5, r3
 80010b6:	d226      	bcs.n	8001106 <HAL_FLASHEx_Erase+0x86>
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80010b8:	4607      	mov	r7, r0
  }
  else
  {
#endif /* FLASH_BANK2_END */
    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80010ba:	4c21      	ldr	r4, [pc, #132]	; (8001140 <HAL_FLASHEx_Erase+0xc0>)
 80010bc:	e007      	b.n	80010ce <HAL_FLASHEx_Erase+0x4e>
            address += FLASH_PAGE_SIZE)
 80010be:	f505 6580 	add.w	r5, r5, #1024	; 0x400
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 80010c2:	e9d9 3202 	ldrd	r3, r2, [r9, #8]
 80010c6:	eb03 2382 	add.w	r3, r3, r2, lsl #10
        for(address = pEraseInit->PageAddress;
 80010ca:	42ab      	cmp	r3, r5
 80010cc:	d91c      	bls.n	8001108 <HAL_FLASHEx_Erase+0x88>
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80010ce:	61f7      	str	r7, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80010d0:	6923      	ldr	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80010d2:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 80010d6:	f043 0302 	orr.w	r3, r3, #2
 80010da:	6123      	str	r3, [r4, #16]
    WRITE_REG(FLASH->AR, PageAddress);
 80010dc:	6165      	str	r5, [r4, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80010de:	6923      	ldr	r3, [r4, #16]
 80010e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80010e4:	6123      	str	r3, [r4, #16]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80010e6:	f7ff ff75 	bl	8000fd4 <FLASH_WaitForLastOperation>
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 80010ea:	6923      	ldr	r3, [r4, #16]
 80010ec:	f023 0302 	bic.w	r3, r3, #2
 80010f0:	6123      	str	r3, [r4, #16]
          if (status != HAL_OK)
 80010f2:	2800      	cmp	r0, #0
 80010f4:	d0e3      	beq.n	80010be <HAL_FLASHEx_Erase+0x3e>
            *PageError = address;
 80010f6:	f8c8 5000 	str.w	r5, [r8]
            break;
 80010fa:	e005      	b.n	8001108 <HAL_FLASHEx_Erase+0x88>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 80010fc:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001100:	f7ff ff68 	bl	8000fd4 <FLASH_WaitForLastOperation>
 8001104:	b120      	cbz	r0, 8001110 <HAL_FLASHEx_Erase+0x90>
  HAL_StatusTypeDef status = HAL_ERROR;
 8001106:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 8001108:	2300      	movs	r3, #0
 800110a:	7633      	strb	r3, [r6, #24]
}
 800110c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8001110:	4c0b      	ldr	r4, [pc, #44]	; (8001140 <HAL_FLASHEx_Erase+0xc0>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001112:	61f0      	str	r0, [r6, #28]
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8001114:	6923      	ldr	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001116:	f24c 3050 	movw	r0, #50000	; 0xc350
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 800111a:	f043 0304 	orr.w	r3, r3, #4
 800111e:	6123      	str	r3, [r4, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8001120:	6923      	ldr	r3, [r4, #16]
 8001122:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001126:	6123      	str	r3, [r4, #16]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001128:	f7ff ff54 	bl	8000fd4 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 800112c:	6923      	ldr	r3, [r4, #16]
 800112e:	f023 0304 	bic.w	r3, r3, #4
 8001132:	6123      	str	r3, [r4, #16]
 8001134:	e7e8      	b.n	8001108 <HAL_FLASHEx_Erase+0x88>
  __HAL_LOCK(&pFlash);
 8001136:	2002      	movs	r0, #2
}
 8001138:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800113c:	20001f00 	.word	0x20001f00
 8001140:	40022000 	.word	0x40022000

08001144 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001144:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position;
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;
  uint32_t config = 0x00U;
 8001148:	2600      	movs	r6, #0
{
 800114a:	b085      	sub	sp, #20
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0U; position < GPIO_NUMBER; position++)
 800114c:	4633      	mov	r3, r6
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 800114e:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 8001338 <HAL_GPIO_Init+0x1f4>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8001152:	4f74      	ldr	r7, [pc, #464]	; (8001324 <HAL_GPIO_Init+0x1e0>)
      switch (GPIO_Init->Mode)
 8001154:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 800133c <HAL_GPIO_Init+0x1f8>
 8001158:	f8df e1e4 	ldr.w	lr, [pc, #484]	; 8001340 <HAL_GPIO_Init+0x1fc>
 800115c:	9000      	str	r0, [sp, #0]
 800115e:	e003      	b.n	8001168 <HAL_GPIO_Init+0x24>
  for (position = 0U; position < GPIO_NUMBER; position++)
 8001160:	3301      	adds	r3, #1
 8001162:	2b10      	cmp	r3, #16
 8001164:	f000 808e 	beq.w	8001284 <HAL_GPIO_Init+0x140>
    ioposition = (0x01U << position);
 8001168:	2201      	movs	r2, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800116a:	680c      	ldr	r4, [r1, #0]
    ioposition = (0x01U << position);
 800116c:	409a      	lsls	r2, r3
    if (iocurrent == ioposition)
 800116e:	ea32 0004 	bics.w	r0, r2, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001172:	ea02 0504 	and.w	r5, r2, r4
    if (iocurrent == ioposition)
 8001176:	d1f3      	bne.n	8001160 <HAL_GPIO_Init+0x1c>
      switch (GPIO_Init->Mode)
 8001178:	684c      	ldr	r4, [r1, #4]
 800117a:	2c12      	cmp	r4, #18
 800117c:	f200 809a 	bhi.w	80012b4 <HAL_GPIO_Init+0x170>
 8001180:	2c12      	cmp	r4, #18
 8001182:	d80c      	bhi.n	800119e <HAL_GPIO_Init+0x5a>
 8001184:	e8df f004 	tbb	[pc, r4]
 8001188:	0a91949f 	.word	0x0a91949f
 800118c:	0b0b0b0b 	.word	0x0b0b0b0b
 8001190:	0b0b0b0b 	.word	0x0b0b0b0b
 8001194:	0b0b0b0b 	.word	0x0b0b0b0b
 8001198:	8e0b      	.short	0x8e0b
 800119a:	81          	.byte	0x81
 800119b:	00          	.byte	0x00
 800119c:	2600      	movs	r6, #0
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800119e:	2dff      	cmp	r5, #255	; 0xff
 80011a0:	d878      	bhi.n	8001294 <HAL_GPIO_Init+0x150>
 80011a2:	f8dd 9000 	ldr.w	r9, [sp]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
 80011a6:	ea4f 0a83 	mov.w	sl, r3, lsl #2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 80011aa:	240f      	movs	r4, #15
 80011ac:	f8d9 2000 	ldr.w	r2, [r9]
 80011b0:	fa04 fb0a 	lsl.w	fp, r4, sl
 80011b4:	ea22 020b 	bic.w	r2, r2, fp
 80011b8:	fa06 fa0a 	lsl.w	sl, r6, sl
 80011bc:	ea42 020a 	orr.w	r2, r2, sl
 80011c0:	f8c9 2000 	str.w	r2, [r9]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80011c4:	f8d1 9004 	ldr.w	r9, [r1, #4]
 80011c8:	f019 5f80 	tst.w	r9, #268435456	; 0x10000000
 80011cc:	d0c8      	beq.n	8001160 <HAL_GPIO_Init+0x1c>
        __HAL_RCC_AFIO_CLK_ENABLE();
 80011ce:	f8dc a018 	ldr.w	sl, [ip, #24]
 80011d2:	f023 0203 	bic.w	r2, r3, #3
 80011d6:	f04a 0a01 	orr.w	sl, sl, #1
 80011da:	f8cc a018 	str.w	sl, [ip, #24]
 80011de:	f8dc a018 	ldr.w	sl, [ip, #24]
 80011e2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80011e6:	f00a 0a01 	and.w	sl, sl, #1
 80011ea:	f8cd a00c 	str.w	sl, [sp, #12]
 80011ee:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80011f2:	f003 0a03 	and.w	sl, r3, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 80011f6:	f8dd b00c 	ldr.w	fp, [sp, #12]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80011fa:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = AFIO->EXTICR[position >> 2U];
 80011fe:	f8d2 b008 	ldr.w	fp, [r2, #8]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8001202:	fa04 f40a 	lsl.w	r4, r4, sl
 8001206:	ea2b 0004 	bic.w	r0, fp, r4
 800120a:	9001      	str	r0, [sp, #4]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800120c:	9c00      	ldr	r4, [sp, #0]
 800120e:	4846      	ldr	r0, [pc, #280]	; (8001328 <HAL_GPIO_Init+0x1e4>)
 8001210:	4284      	cmp	r4, r0
 8001212:	d013      	beq.n	800123c <HAL_GPIO_Init+0xf8>
 8001214:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8001218:	4284      	cmp	r4, r0
 800121a:	d069      	beq.n	80012f0 <HAL_GPIO_Init+0x1ac>
 800121c:	4843      	ldr	r0, [pc, #268]	; (800132c <HAL_GPIO_Init+0x1e8>)
 800121e:	4284      	cmp	r4, r0
 8001220:	d077      	beq.n	8001312 <HAL_GPIO_Init+0x1ce>
 8001222:	4843      	ldr	r0, [pc, #268]	; (8001330 <HAL_GPIO_Init+0x1ec>)
 8001224:	4284      	cmp	r4, r0
 8001226:	bf0c      	ite	eq
 8001228:	f04f 0b03 	moveq.w	fp, #3
 800122c:	f04f 0b04 	movne.w	fp, #4
 8001230:	9801      	ldr	r0, [sp, #4]
 8001232:	fa0b fa0a 	lsl.w	sl, fp, sl
 8001236:	ea40 000a 	orr.w	r0, r0, sl
 800123a:	9001      	str	r0, [sp, #4]
        AFIO->EXTICR[position >> 2U] = temp;
 800123c:	9801      	ldr	r0, [sp, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800123e:	f419 3f80 	tst.w	r9, #65536	; 0x10000
        AFIO->EXTICR[position >> 2U] = temp;
 8001242:	6090      	str	r0, [r2, #8]
          SET_BIT(EXTI->IMR, iocurrent);
 8001244:	683a      	ldr	r2, [r7, #0]
  for (position = 0U; position < GPIO_NUMBER; position++)
 8001246:	f103 0301 	add.w	r3, r3, #1
          SET_BIT(EXTI->IMR, iocurrent);
 800124a:	bf14      	ite	ne
 800124c:	432a      	orrne	r2, r5
          CLEAR_BIT(EXTI->IMR, iocurrent);
 800124e:	43aa      	biceq	r2, r5
 8001250:	603a      	str	r2, [r7, #0]
          SET_BIT(EXTI->EMR, iocurrent);
 8001252:	687a      	ldr	r2, [r7, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001254:	f419 3f00 	tst.w	r9, #131072	; 0x20000
          SET_BIT(EXTI->EMR, iocurrent);
 8001258:	bf14      	ite	ne
 800125a:	432a      	orrne	r2, r5
          CLEAR_BIT(EXTI->EMR, iocurrent);
 800125c:	43aa      	biceq	r2, r5
 800125e:	607a      	str	r2, [r7, #4]
          SET_BIT(EXTI->RTSR, iocurrent);
 8001260:	68ba      	ldr	r2, [r7, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001262:	f419 1f80 	tst.w	r9, #1048576	; 0x100000
          SET_BIT(EXTI->RTSR, iocurrent);
 8001266:	bf14      	ite	ne
 8001268:	432a      	orrne	r2, r5
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 800126a:	43aa      	biceq	r2, r5
 800126c:	60ba      	str	r2, [r7, #8]
          SET_BIT(EXTI->FTSR, iocurrent);
 800126e:	68fa      	ldr	r2, [r7, #12]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001270:	f419 1f00 	tst.w	r9, #2097152	; 0x200000
          SET_BIT(EXTI->FTSR, iocurrent);
 8001274:	bf14      	ite	ne
 8001276:	4315      	orrne	r5, r2
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8001278:	ea22 0505 	biceq.w	r5, r2, r5
  for (position = 0U; position < GPIO_NUMBER; position++)
 800127c:	2b10      	cmp	r3, #16
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 800127e:	60fd      	str	r5, [r7, #12]
  for (position = 0U; position < GPIO_NUMBER; position++)
 8001280:	f47f af72 	bne.w	8001168 <HAL_GPIO_Init+0x24>
        }
      }
    }
  }
}
 8001284:	b005      	add	sp, #20
 8001286:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 800128a:	68ce      	ldr	r6, [r1, #12]
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800128c:	2dff      	cmp	r5, #255	; 0xff
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 800128e:	f106 060c 	add.w	r6, r6, #12
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001292:	d986      	bls.n	80011a2 <HAL_GPIO_Init+0x5e>
 8001294:	9a00      	ldr	r2, [sp, #0]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
 8001296:	ea4f 0a83 	mov.w	sl, r3, lsl #2
 800129a:	f1aa 0a20 	sub.w	sl, sl, #32
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 800129e:	f102 0904 	add.w	r9, r2, #4
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2U) : ((position - 8U) << 2U);
 80012a2:	e782      	b.n	80011aa <HAL_GPIO_Init+0x66>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 80012a4:	68ce      	ldr	r6, [r1, #12]
 80012a6:	3604      	adds	r6, #4
          break;
 80012a8:	e779      	b.n	800119e <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 80012aa:	68ce      	ldr	r6, [r1, #12]
 80012ac:	3608      	adds	r6, #8
          break;
 80012ae:	e776      	b.n	800119e <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 80012b0:	68ce      	ldr	r6, [r1, #12]
          break;
 80012b2:	e774      	b.n	800119e <HAL_GPIO_Init+0x5a>
      switch (GPIO_Init->Mode)
 80012b4:	4544      	cmp	r4, r8
 80012b6:	d006      	beq.n	80012c6 <HAL_GPIO_Init+0x182>
 80012b8:	d909      	bls.n	80012ce <HAL_GPIO_Init+0x18a>
 80012ba:	4574      	cmp	r4, lr
 80012bc:	d003      	beq.n	80012c6 <HAL_GPIO_Init+0x182>
 80012be:	481d      	ldr	r0, [pc, #116]	; (8001334 <HAL_GPIO_Init+0x1f0>)
 80012c0:	4284      	cmp	r4, r0
 80012c2:	f47f af6c 	bne.w	800119e <HAL_GPIO_Init+0x5a>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 80012c6:	688c      	ldr	r4, [r1, #8]
 80012c8:	b9dc      	cbnz	r4, 8001302 <HAL_GPIO_Init+0x1be>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 80012ca:	2604      	movs	r6, #4
 80012cc:	e767      	b.n	800119e <HAL_GPIO_Init+0x5a>
      switch (GPIO_Init->Mode)
 80012ce:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8001344 <HAL_GPIO_Init+0x200>
 80012d2:	454c      	cmp	r4, r9
 80012d4:	d0f7      	beq.n	80012c6 <HAL_GPIO_Init+0x182>
 80012d6:	f509 2970 	add.w	r9, r9, #983040	; 0xf0000
 80012da:	454c      	cmp	r4, r9
 80012dc:	d0f3      	beq.n	80012c6 <HAL_GPIO_Init+0x182>
 80012de:	f5a9 1980 	sub.w	r9, r9, #1048576	; 0x100000
 80012e2:	454c      	cmp	r4, r9
 80012e4:	f47f af5b 	bne.w	800119e <HAL_GPIO_Init+0x5a>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 80012e8:	688c      	ldr	r4, [r1, #8]
 80012ea:	2c00      	cmp	r4, #0
 80012ec:	d0ed      	beq.n	80012ca <HAL_GPIO_Init+0x186>
 80012ee:	e008      	b.n	8001302 <HAL_GPIO_Init+0x1be>
 80012f0:	f04f 0b01 	mov.w	fp, #1
 80012f4:	9801      	ldr	r0, [sp, #4]
 80012f6:	fa0b fa0a 	lsl.w	sl, fp, sl
 80012fa:	ea40 000a 	orr.w	r0, r0, sl
 80012fe:	9001      	str	r0, [sp, #4]
 8001300:	e79c      	b.n	800123c <HAL_GPIO_Init+0xf8>
            GPIOx->BSRR = ioposition;
 8001302:	9800      	ldr	r0, [sp, #0]
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8001304:	2c01      	cmp	r4, #1
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8001306:	f04f 0608 	mov.w	r6, #8
            GPIOx->BSRR = ioposition;
 800130a:	bf0c      	ite	eq
 800130c:	6102      	streq	r2, [r0, #16]
            GPIOx->BRR = ioposition;
 800130e:	6142      	strne	r2, [r0, #20]
 8001310:	e745      	b.n	800119e <HAL_GPIO_Init+0x5a>
 8001312:	f04f 0b02 	mov.w	fp, #2
 8001316:	9801      	ldr	r0, [sp, #4]
 8001318:	fa0b fa0a 	lsl.w	sl, fp, sl
 800131c:	ea40 000a 	orr.w	r0, r0, sl
 8001320:	9001      	str	r0, [sp, #4]
 8001322:	e78b      	b.n	800123c <HAL_GPIO_Init+0xf8>
 8001324:	40010400 	.word	0x40010400
 8001328:	40010800 	.word	0x40010800
 800132c:	40011000 	.word	0x40011000
 8001330:	40011400 	.word	0x40011400
 8001334:	10320000 	.word	0x10320000
 8001338:	40021000 	.word	0x40021000
 800133c:	10220000 	.word	0x10220000
 8001340:	10310000 	.word	0x10310000
 8001344:	10120000 	.word	0x10120000

08001348 <HAL_I2C_MasterTxCpltCallback>:
 8001348:	4770      	bx	lr
 800134a:	bf00      	nop

0800134c <HAL_I2C_MasterRxCpltCallback>:
 800134c:	4770      	bx	lr
 800134e:	bf00      	nop

08001350 <HAL_I2C_SlaveTxCpltCallback>:
 8001350:	4770      	bx	lr
 8001352:	bf00      	nop

08001354 <HAL_I2C_SlaveRxCpltCallback>:
 8001354:	4770      	bx	lr
 8001356:	bf00      	nop

08001358 <HAL_I2C_AddrCallback>:
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback can be implemented in the user file
   */
}
 8001358:	4770      	bx	lr
 800135a:	bf00      	nop

0800135c <HAL_I2C_ListenCpltCallback>:
 800135c:	4770      	bx	lr
 800135e:	bf00      	nop

08001360 <HAL_I2C_MemTxCpltCallback>:
 8001360:	4770      	bx	lr
 8001362:	bf00      	nop

08001364 <HAL_I2C_MemRxCpltCallback>:
 8001364:	4770      	bx	lr
 8001366:	bf00      	nop

08001368 <HAL_I2C_ErrorCallback>:
 8001368:	4770      	bx	lr
 800136a:	bf00      	nop

0800136c <HAL_I2C_AbortCpltCallback>:
 800136c:	4770      	bx	lr
 800136e:	bf00      	nop

08001370 <I2C_ITError>:
  * @brief  I2C interrupts error process
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c)
{
 8001370:	b510      	push	{r4, lr}
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  uint32_t CurrentState = hi2c->State;
 8001372:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
{
 8001376:	4604      	mov	r4, r0

  if((CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8001378:	3b29      	subs	r3, #41	; 0x29
 800137a:	2b01      	cmp	r3, #1
 800137c:	d958      	bls.n	8001430 <I2C_ITError+0xc0>
  }
  else
  {
    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if((hi2c->State != HAL_I2C_STATE_ABORT) && ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) != I2C_CR2_DMAEN))
 800137e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001382:	2b60      	cmp	r3, #96	; 0x60
 8001384:	6803      	ldr	r3, [r0, #0]
 8001386:	d005      	beq.n	8001394 <I2C_ITError+0x24>
 8001388:	685a      	ldr	r2, [r3, #4]
 800138a:	0512      	lsls	r2, r2, #20
    {
      hi2c->State = HAL_I2C_STATE_READY;
 800138c:	bf5c      	itt	pl
 800138e:	2220      	movpl	r2, #32
 8001390:	f880 203d 	strbpl.w	r2, [r0, #61]	; 0x3d
    }
    hi2c->PreviousState = I2C_STATE_NONE;
 8001394:	2200      	movs	r2, #0
 8001396:	6322      	str	r2, [r4, #48]	; 0x30
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001398:	f884 203e 	strb.w	r2, [r4, #62]	; 0x3e
  }

  /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
  hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 800139c:	681a      	ldr	r2, [r3, #0]
 800139e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80013a2:	601a      	str	r2, [r3, #0]

  /* Abort DMA transfer */
  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80013a4:	685a      	ldr	r2, [r3, #4]
 80013a6:	f412 6200 	ands.w	r2, r2, #2048	; 0x800
 80013aa:	d02d      	beq.n	8001408 <I2C_ITError+0x98>
  {
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 80013ac:	685a      	ldr	r2, [r3, #4]

    if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 80013ae:	6b60      	ldr	r0, [r4, #52]	; 0x34
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 80013b0:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80013b4:	605a      	str	r2, [r3, #4]
    if(hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 80013b6:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80013ba:	2b01      	cmp	r3, #1
 80013bc:	d03f      	beq.n	800143e <I2C_ITError+0xce>
    {
      /* Set the DMA Abort callback : 
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 80013be:	4b3a      	ldr	r3, [pc, #232]	; (80014a8 <I2C_ITError+0x138>)
 80013c0:	6343      	str	r3, [r0, #52]	; 0x34

      if(HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 80013c2:	f7ff fcc1 	bl	8000d48 <HAL_DMA_Abort_IT>
 80013c6:	b150      	cbz	r0, 80013de <I2C_ITError+0x6e>
      {
        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);

        hi2c->State = HAL_I2C_STATE_READY;
 80013c8:	2120      	movs	r1, #32
        __HAL_I2C_DISABLE(hi2c);
 80013ca:	6822      	ldr	r2, [r4, #0]

        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80013cc:	6b60      	ldr	r0, [r4, #52]	; 0x34
        __HAL_I2C_DISABLE(hi2c);
 80013ce:	6813      	ldr	r3, [r2, #0]
 80013d0:	f023 0301 	bic.w	r3, r3, #1
 80013d4:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 80013d6:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80013da:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80013dc:	4798      	blx	r3
    HAL_I2C_ErrorCallback(hi2c);
  }
  /* STOP Flag is not set after a NACK reception */
  /* So may inform upper layer that listen phase is stopped */
  /* during NACK error treatment */
  if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
 80013de:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80013e2:	2b28      	cmp	r3, #40	; 0x28
 80013e4:	d000      	beq.n	80013e8 <I2C_ITError+0x78>
    hi2c->Mode = HAL_I2C_MODE_NONE;
    
    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    HAL_I2C_ListenCpltCallback(hi2c);
  }
}
 80013e6:	bd10      	pop	{r4, pc}
  if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
 80013e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80013ea:	075b      	lsls	r3, r3, #29
 80013ec:	d5fb      	bpl.n	80013e6 <I2C_ITError+0x76>
    hi2c->PreviousState = I2C_STATE_NONE;
 80013ee:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80013f0:	2220      	movs	r2, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80013f2:	492e      	ldr	r1, [pc, #184]	; (80014ac <I2C_ITError+0x13c>)
    HAL_I2C_ListenCpltCallback(hi2c);
 80013f4:	4620      	mov	r0, r4
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80013f6:	62e1      	str	r1, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 80013f8:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
 80013fa:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80013fe:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 8001402:	f7ff ffab 	bl	800135c <HAL_I2C_ListenCpltCallback>
}
 8001406:	bd10      	pop	{r4, pc}
  else if(hi2c->State == HAL_I2C_STATE_ABORT)
 8001408:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
 800140c:	2960      	cmp	r1, #96	; 0x60
 800140e:	d032      	beq.n	8001476 <I2C_ITError+0x106>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8001410:	695a      	ldr	r2, [r3, #20]
 8001412:	0652      	lsls	r2, r2, #25
 8001414:	d504      	bpl.n	8001420 <I2C_ITError+0xb0>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001416:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001418:	691b      	ldr	r3, [r3, #16]
 800141a:	1c51      	adds	r1, r2, #1
 800141c:	6261      	str	r1, [r4, #36]	; 0x24
 800141e:	7013      	strb	r3, [r2, #0]
    HAL_I2C_ErrorCallback(hi2c);
 8001420:	4620      	mov	r0, r4
 8001422:	f7ff ffa1 	bl	8001368 <HAL_I2C_ErrorCallback>
  if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
 8001426:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800142a:	2b28      	cmp	r3, #40	; 0x28
 800142c:	d1db      	bne.n	80013e6 <I2C_ITError+0x76>
 800142e:	e7db      	b.n	80013e8 <I2C_ITError+0x78>
    hi2c->PreviousState = I2C_STATE_NONE;
 8001430:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8001432:	2228      	movs	r2, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_NONE;
 8001434:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8001436:	6803      	ldr	r3, [r0, #0]
 8001438:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
 800143c:	e7ae      	b.n	800139c <I2C_ITError+0x2c>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800143e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8001440:	4b19      	ldr	r3, [pc, #100]	; (80014a8 <I2C_ITError+0x138>)
 8001442:	6343      	str	r3, [r0, #52]	; 0x34
      if(HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8001444:	f7ff fc80 	bl	8000d48 <HAL_DMA_Abort_IT>
 8001448:	2800      	cmp	r0, #0
 800144a:	d0c8      	beq.n	80013de <I2C_ITError+0x6e>
        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800144c:	6823      	ldr	r3, [r4, #0]
 800144e:	695a      	ldr	r2, [r3, #20]
 8001450:	0650      	lsls	r0, r2, #25
 8001452:	d505      	bpl.n	8001460 <I2C_ITError+0xf0>
          (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001454:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001456:	691b      	ldr	r3, [r3, #16]
 8001458:	1c51      	adds	r1, r2, #1
 800145a:	6261      	str	r1, [r4, #36]	; 0x24
 800145c:	7013      	strb	r3, [r2, #0]
 800145e:	6823      	ldr	r3, [r4, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8001460:	2120      	movs	r1, #32
        __HAL_I2C_DISABLE(hi2c);
 8001462:	681a      	ldr	r2, [r3, #0]
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8001464:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        __HAL_I2C_DISABLE(hi2c);
 8001466:	f022 0201 	bic.w	r2, r2, #1
 800146a:	601a      	str	r2, [r3, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 800146c:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8001470:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001472:	4798      	blx	r3
 8001474:	e7b3      	b.n	80013de <I2C_ITError+0x6e>
    hi2c->State = HAL_I2C_STATE_READY;
 8001476:	2120      	movs	r1, #32
 8001478:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800147c:	6422      	str	r2, [r4, #64]	; 0x40
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800147e:	695a      	ldr	r2, [r3, #20]
 8001480:	0651      	lsls	r1, r2, #25
 8001482:	d505      	bpl.n	8001490 <I2C_ITError+0x120>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001484:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001486:	691b      	ldr	r3, [r3, #16]
 8001488:	1c51      	adds	r1, r2, #1
 800148a:	6261      	str	r1, [r4, #36]	; 0x24
 800148c:	7013      	strb	r3, [r2, #0]
 800148e:	6823      	ldr	r3, [r4, #0]
    __HAL_I2C_DISABLE(hi2c);
 8001490:	681a      	ldr	r2, [r3, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 8001492:	4620      	mov	r0, r4
    __HAL_I2C_DISABLE(hi2c);
 8001494:	f022 0201 	bic.w	r2, r2, #1
 8001498:	601a      	str	r2, [r3, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 800149a:	f7ff ff67 	bl	800136c <HAL_I2C_AbortCpltCallback>
  if((hi2c->State == HAL_I2C_STATE_LISTEN) && ((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF))
 800149e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80014a2:	2b28      	cmp	r3, #40	; 0x28
 80014a4:	d19f      	bne.n	80013e6 <I2C_ITError+0x76>
 80014a6:	e79f      	b.n	80013e8 <I2C_ITError+0x78>
 80014a8:	08001dc5 	.word	0x08001dc5
 80014ac:	ffff0000 	.word	0xffff0000

080014b0 <HAL_I2C_EV_IRQHandler>:
{
 80014b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
 80014b2:	6803      	ldr	r3, [r0, #0]
{
 80014b4:	b08d      	sub	sp, #52	; 0x34
  uint32_t sr2itflags   = READ_REG(hi2c->Instance->SR2);
 80014b6:	699d      	ldr	r5, [r3, #24]
  uint32_t sr1itflags   = READ_REG(hi2c->Instance->SR1);
 80014b8:	695a      	ldr	r2, [r3, #20]
  uint32_t itsources    = READ_REG(hi2c->Instance->CR2);
 80014ba:	685c      	ldr	r4, [r3, #4]
  uint32_t CurrentMode  = hi2c->Mode;
 80014bc:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
  if((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 80014c0:	2910      	cmp	r1, #16
 80014c2:	d03d      	beq.n	8001540 <HAL_I2C_EV_IRQHandler+0x90>
 80014c4:	b2ce      	uxtb	r6, r1
 80014c6:	2e40      	cmp	r6, #64	; 0x40
 80014c8:	d03a      	beq.n	8001540 <HAL_I2C_EV_IRQHandler+0x90>
    if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 80014ca:	4999      	ldr	r1, [pc, #612]	; (8001730 <HAL_I2C_EV_IRQHandler+0x280>)
 80014cc:	4011      	ands	r1, r2
 80014ce:	2900      	cmp	r1, #0
 80014d0:	f000 80c7 	beq.w	8001662 <HAL_I2C_EV_IRQHandler+0x1b2>
 80014d4:	05a1      	lsls	r1, r4, #22
 80014d6:	f100 817f 	bmi.w	80017d8 <HAL_I2C_EV_IRQHandler+0x328>
    else if((sr2itflags & I2C_FLAG_TRA) != RESET)
 80014da:	4996      	ldr	r1, [pc, #600]	; (8001734 <HAL_I2C_EV_IRQHandler+0x284>)
 80014dc:	4029      	ands	r1, r5
 80014de:	2900      	cmp	r1, #0
 80014e0:	f000 8134 	beq.w	800174c <HAL_I2C_EV_IRQHandler+0x29c>
      if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 80014e4:	4994      	ldr	r1, [pc, #592]	; (8001738 <HAL_I2C_EV_IRQHandler+0x288>)
 80014e6:	4011      	ands	r1, r2
 80014e8:	2900      	cmp	r1, #0
 80014ea:	f000 8182 	beq.w	80017f2 <HAL_I2C_EV_IRQHandler+0x342>
 80014ee:	0565      	lsls	r5, r4, #21
 80014f0:	f140 817f 	bpl.w	80017f2 <HAL_I2C_EV_IRQHandler+0x342>
 80014f4:	4991      	ldr	r1, [pc, #580]	; (800173c <HAL_I2C_EV_IRQHandler+0x28c>)
 80014f6:	4011      	ands	r1, r2
 80014f8:	2900      	cmp	r1, #0
 80014fa:	f040 817f 	bne.w	80017fc <HAL_I2C_EV_IRQHandler+0x34c>
  uint32_t CurrentState = hi2c->State;
 80014fe:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if(hi2c->XferCount != 0U)
 8001502:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
  uint32_t CurrentState = hi2c->State;
 8001504:	b2c9      	uxtb	r1, r1
  if(hi2c->XferCount != 0U)
 8001506:	b292      	uxth	r2, r2
 8001508:	b1c2      	cbz	r2, 800153c <HAL_I2C_EV_IRQHandler+0x8c>
    hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 800150a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800150c:	1c54      	adds	r4, r2, #1
 800150e:	6244      	str	r4, [r0, #36]	; 0x24
 8001510:	7812      	ldrb	r2, [r2, #0]
 8001512:	611a      	str	r2, [r3, #16]
    hi2c->XferCount--;
 8001514:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001516:	3a01      	subs	r2, #1
 8001518:	b292      	uxth	r2, r2
 800151a:	8542      	strh	r2, [r0, #42]	; 0x2a
    if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800151c:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 800151e:	b292      	uxth	r2, r2
 8001520:	b962      	cbnz	r2, 800153c <HAL_I2C_EV_IRQHandler+0x8c>
 8001522:	2929      	cmp	r1, #41	; 0x29
 8001524:	d10a      	bne.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001526:	2421      	movs	r4, #33	; 0x21
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8001528:	2128      	movs	r1, #40	; 0x28
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800152a:	685a      	ldr	r2, [r3, #4]
 800152c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001530:	605a      	str	r2, [r3, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001532:	6304      	str	r4, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8001534:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001538:	f7ff ff0a 	bl	8001350 <HAL_I2C_SlaveTxCpltCallback>
}
 800153c:	b00d      	add	sp, #52	; 0x34
 800153e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(((sr1itflags & I2C_FLAG_SB) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001540:	f012 1f01 	tst.w	r2, #65537	; 0x10001
 8001544:	d039      	beq.n	80015ba <HAL_I2C_EV_IRQHandler+0x10a>
 8001546:	05a6      	lsls	r6, r4, #22
 8001548:	f100 8130 	bmi.w	80017ac <HAL_I2C_EV_IRQHandler+0x2fc>
    else if(((sr1itflags & I2C_FLAG_ADD10) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 800154c:	497c      	ldr	r1, [pc, #496]	; (8001740 <HAL_I2C_EV_IRQHandler+0x290>)
 800154e:	4011      	ands	r1, r2
 8001550:	2900      	cmp	r1, #0
 8001552:	d061      	beq.n	8001618 <HAL_I2C_EV_IRQHandler+0x168>
    if((sr2itflags & I2C_FLAG_TRA) != RESET)
 8001554:	4977      	ldr	r1, [pc, #476]	; (8001734 <HAL_I2C_EV_IRQHandler+0x284>)
 8001556:	4029      	ands	r1, r5
 8001558:	2900      	cmp	r1, #0
 800155a:	d03b      	beq.n	80015d4 <HAL_I2C_EV_IRQHandler+0x124>
      if(((sr1itflags & I2C_FLAG_TXE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 800155c:	4976      	ldr	r1, [pc, #472]	; (8001738 <HAL_I2C_EV_IRQHandler+0x288>)
 800155e:	4011      	ands	r1, r2
 8001560:	2900      	cmp	r1, #0
 8001562:	d072      	beq.n	800164a <HAL_I2C_EV_IRQHandler+0x19a>
 8001564:	0567      	lsls	r7, r4, #21
 8001566:	d570      	bpl.n	800164a <HAL_I2C_EV_IRQHandler+0x19a>
 8001568:	4974      	ldr	r1, [pc, #464]	; (800173c <HAL_I2C_EV_IRQHandler+0x28c>)
 800156a:	4011      	ands	r1, r2
 800156c:	2900      	cmp	r1, #0
 800156e:	f000 8165 	beq.w	800183c <HAL_I2C_EV_IRQHandler+0x38c>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001572:	05a6      	lsls	r6, r4, #22
 8001574:	d5e2      	bpl.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001576:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8001578:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 800157c:	2a21      	cmp	r2, #33	; 0x21
 800157e:	d1dd      	bne.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    if(hi2c->XferCount != 0U)
 8001580:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001582:	b292      	uxth	r2, r2
 8001584:	2a00      	cmp	r2, #0
 8001586:	f040 8141 	bne.w	800180c <HAL_I2C_EV_IRQHandler+0x35c>
      if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800158a:	2904      	cmp	r1, #4
 800158c:	f000 825b 	beq.w	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
 8001590:	2908      	cmp	r1, #8
 8001592:	f000 8258 	beq.w	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
 8001596:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 800159a:	f000 8254 	beq.w	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800159e:	2511      	movs	r5, #17
        hi2c->State = HAL_I2C_STATE_READY;
 80015a0:	2420      	movs	r4, #32
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80015a2:	6859      	ldr	r1, [r3, #4]
 80015a4:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 80015a8:	6059      	str	r1, [r3, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80015aa:	6305      	str	r5, [r0, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80015ac:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 80015b0:	f880 403d 	strb.w	r4, [r0, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 80015b4:	f7ff fec8 	bl	8001348 <HAL_I2C_MasterTxCpltCallback>
 80015b8:	e7c0      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    else if(((sr1itflags & I2C_FLAG_ADD10) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 80015ba:	4961      	ldr	r1, [pc, #388]	; (8001740 <HAL_I2C_EV_IRQHandler+0x290>)
 80015bc:	4011      	ands	r1, r2
 80015be:	2900      	cmp	r1, #0
 80015c0:	d02a      	beq.n	8001618 <HAL_I2C_EV_IRQHandler+0x168>
 80015c2:	05a1      	lsls	r1, r4, #22
 80015c4:	d5c6      	bpl.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 80015c6:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80015c8:	b2c9      	uxtb	r1, r1
 80015ca:	6119      	str	r1, [r3, #16]
    if((sr2itflags & I2C_FLAG_TRA) != RESET)
 80015cc:	4959      	ldr	r1, [pc, #356]	; (8001734 <HAL_I2C_EV_IRQHandler+0x284>)
 80015ce:	4029      	ands	r1, r5
 80015d0:	2900      	cmp	r1, #0
 80015d2:	d1c3      	bne.n	800155c <HAL_I2C_EV_IRQHandler+0xac>
      if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 80015d4:	495b      	ldr	r1, [pc, #364]	; (8001744 <HAL_I2C_EV_IRQHandler+0x294>)
 80015d6:	4011      	ands	r1, r2
 80015d8:	2900      	cmp	r1, #0
 80015da:	d03c      	beq.n	8001656 <HAL_I2C_EV_IRQHandler+0x1a6>
 80015dc:	0565      	lsls	r5, r4, #21
 80015de:	d53a      	bpl.n	8001656 <HAL_I2C_EV_IRQHandler+0x1a6>
 80015e0:	4956      	ldr	r1, [pc, #344]	; (800173c <HAL_I2C_EV_IRQHandler+0x28c>)
 80015e2:	4011      	ands	r1, r2
 80015e4:	2900      	cmp	r1, #0
 80015e6:	f000 8156 	beq.w	8001896 <HAL_I2C_EV_IRQHandler+0x3e6>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 80015ea:	05a4      	lsls	r4, r4, #22
 80015ec:	d5a6      	bpl.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 80015ee:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  if(hi2c->XferCount == 3U)
 80015f0:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80015f2:	b292      	uxth	r2, r2
 80015f4:	2a03      	cmp	r2, #3
 80015f6:	f000 81da 	beq.w	80019ae <HAL_I2C_EV_IRQHandler+0x4fe>
  else if(hi2c->XferCount == 2U)
 80015fa:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80015fc:	b292      	uxth	r2, r2
 80015fe:	2a02      	cmp	r2, #2
 8001600:	f000 81ec 	beq.w	80019dc <HAL_I2C_EV_IRQHandler+0x52c>
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001604:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001606:	691b      	ldr	r3, [r3, #16]
 8001608:	1c51      	adds	r1, r2, #1
 800160a:	6241      	str	r1, [r0, #36]	; 0x24
 800160c:	7013      	strb	r3, [r2, #0]
    hi2c->XferCount--;
 800160e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001610:	3b01      	subs	r3, #1
 8001612:	b29b      	uxth	r3, r3
 8001614:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8001616:	e791      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    else if(((sr1itflags & I2C_FLAG_ADDR) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001618:	4945      	ldr	r1, [pc, #276]	; (8001730 <HAL_I2C_EV_IRQHandler+0x280>)
 800161a:	4011      	ands	r1, r2
 800161c:	2900      	cmp	r1, #0
 800161e:	d099      	beq.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
 8001620:	05a7      	lsls	r7, r4, #22
 8001622:	d597      	bpl.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
  uint32_t CurrentMode        = hi2c->Mode;
 8001624:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001628:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  uint32_t Prev_State         = hi2c->PreviousState;
 800162a:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800162e:	f890 603d 	ldrb.w	r6, [r0, #61]	; 0x3d
  uint32_t CurrentMode        = hi2c->Mode;
 8001632:	b2c9      	uxtb	r1, r1
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8001634:	2e22      	cmp	r6, #34	; 0x22
 8001636:	f000 816d 	beq.w	8001914 <HAL_I2C_EV_IRQHandler+0x464>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800163a:	2100      	movs	r1, #0
 800163c:	910a      	str	r1, [sp, #40]	; 0x28
 800163e:	6959      	ldr	r1, [r3, #20]
 8001640:	910a      	str	r1, [sp, #40]	; 0x28
 8001642:	6999      	ldr	r1, [r3, #24]
 8001644:	910a      	str	r1, [sp, #40]	; 0x28
 8001646:	990a      	ldr	r1, [sp, #40]	; 0x28
 8001648:	e784      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 800164a:	493c      	ldr	r1, [pc, #240]	; (800173c <HAL_I2C_EV_IRQHandler+0x28c>)
 800164c:	4011      	ands	r1, r2
 800164e:	2900      	cmp	r1, #0
 8001650:	d18f      	bne.n	8001572 <HAL_I2C_EV_IRQHandler+0xc2>
}
 8001652:	b00d      	add	sp, #52	; 0x34
 8001654:	bdf0      	pop	{r4, r5, r6, r7, pc}
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001656:	4939      	ldr	r1, [pc, #228]	; (800173c <HAL_I2C_EV_IRQHandler+0x28c>)
 8001658:	4011      	ands	r1, r2
 800165a:	2900      	cmp	r1, #0
 800165c:	d1c5      	bne.n	80015ea <HAL_I2C_EV_IRQHandler+0x13a>
}
 800165e:	b00d      	add	sp, #52	; 0x34
 8001660:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if(((sr1itflags & I2C_FLAG_STOPF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001662:	4e39      	ldr	r6, [pc, #228]	; (8001748 <HAL_I2C_EV_IRQHandler+0x298>)
 8001664:	4016      	ands	r6, r2
 8001666:	2e00      	cmp	r6, #0
 8001668:	f43f af37 	beq.w	80014da <HAL_I2C_EV_IRQHandler+0x2a>
 800166c:	05a6      	lsls	r6, r4, #22
 800166e:	f57f af34 	bpl.w	80014da <HAL_I2C_EV_IRQHandler+0x2a>
  uint32_t CurrentState = hi2c->State;
 8001672:	f890 403d 	ldrb.w	r4, [r0, #61]	; 0x3d
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001676:	685a      	ldr	r2, [r3, #4]
  uint32_t CurrentState = hi2c->State;
 8001678:	b2e4      	uxtb	r4, r4
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800167a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800167e:	605a      	str	r2, [r3, #4]
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 8001680:	910b      	str	r1, [sp, #44]	; 0x2c
 8001682:	695a      	ldr	r2, [r3, #20]
 8001684:	920b      	str	r2, [sp, #44]	; 0x2c
 8001686:	681a      	ldr	r2, [r3, #0]
 8001688:	f042 0201 	orr.w	r2, r2, #1
 800168c:	601a      	str	r2, [r3, #0]
 800168e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001690:	681a      	ldr	r2, [r3, #0]
 8001692:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001696:	601a      	str	r2, [r3, #0]
  if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8001698:	685a      	ldr	r2, [r3, #4]
 800169a:	0512      	lsls	r2, r2, #20
 800169c:	d50e      	bpl.n	80016bc <HAL_I2C_EV_IRQHandler+0x20c>
    if((hi2c->State == HAL_I2C_STATE_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
 800169e:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 80016a2:	2a22      	cmp	r2, #34	; 0x22
 80016a4:	f000 8177 	beq.w	8001996 <HAL_I2C_EV_IRQHandler+0x4e6>
 80016a8:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 80016ac:	2a2a      	cmp	r2, #42	; 0x2a
 80016ae:	f000 8172 	beq.w	8001996 <HAL_I2C_EV_IRQHandler+0x4e6>
      hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmatx);
 80016b2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80016b4:	6812      	ldr	r2, [r2, #0]
 80016b6:	6852      	ldr	r2, [r2, #4]
 80016b8:	b292      	uxth	r2, r2
 80016ba:	8542      	strh	r2, [r0, #42]	; 0x2a
  if(hi2c->XferCount != 0U)
 80016bc:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80016be:	b292      	uxth	r2, r2
 80016c0:	b1e2      	cbz	r2, 80016fc <HAL_I2C_EV_IRQHandler+0x24c>
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 80016c2:	695a      	ldr	r2, [r3, #20]
 80016c4:	0757      	lsls	r7, r2, #29
 80016c6:	d509      	bpl.n	80016dc <HAL_I2C_EV_IRQHandler+0x22c>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80016c8:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80016ca:	691b      	ldr	r3, [r3, #16]
 80016cc:	1c51      	adds	r1, r2, #1
 80016ce:	6241      	str	r1, [r0, #36]	; 0x24
 80016d0:	7013      	strb	r3, [r2, #0]
      hi2c->XferCount--;
 80016d2:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80016d4:	6803      	ldr	r3, [r0, #0]
 80016d6:	3a01      	subs	r2, #1
 80016d8:	b292      	uxth	r2, r2
 80016da:	8542      	strh	r2, [r0, #42]	; 0x2a
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80016dc:	695a      	ldr	r2, [r3, #20]
 80016de:	0656      	lsls	r6, r2, #25
 80016e0:	d508      	bpl.n	80016f4 <HAL_I2C_EV_IRQHandler+0x244>
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80016e2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80016e4:	691b      	ldr	r3, [r3, #16]
 80016e6:	1c51      	adds	r1, r2, #1
 80016e8:	6241      	str	r1, [r0, #36]	; 0x24
 80016ea:	7013      	strb	r3, [r2, #0]
      hi2c->XferCount--;
 80016ec:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80016ee:	3b01      	subs	r3, #1
 80016f0:	b29b      	uxth	r3, r3
 80016f2:	8543      	strh	r3, [r0, #42]	; 0x2a
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80016f4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80016f6:	f043 0304 	orr.w	r3, r3, #4
 80016fa:	6403      	str	r3, [r0, #64]	; 0x40
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 80016fc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80016fe:	2b00      	cmp	r3, #0
 8001700:	f040 8126 	bne.w	8001950 <HAL_I2C_EV_IRQHandler+0x4a0>
    if((CurrentState == HAL_I2C_STATE_LISTEN ) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN) || \
 8001704:	f1a4 0228 	sub.w	r2, r4, #40	; 0x28
 8001708:	2a02      	cmp	r2, #2
 800170a:	f240 812d 	bls.w	8001968 <HAL_I2C_EV_IRQHandler+0x4b8>
      if((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800170e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001710:	2b22      	cmp	r3, #34	; 0x22
 8001712:	d002      	beq.n	800171a <HAL_I2C_EV_IRQHandler+0x26a>
 8001714:	2c22      	cmp	r4, #34	; 0x22
 8001716:	f47f af11 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
        hi2c->PreviousState = I2C_STATE_NONE;
 800171a:	2300      	movs	r3, #0
        hi2c->State = HAL_I2C_STATE_READY;
 800171c:	2220      	movs	r2, #32
        hi2c->PreviousState = I2C_STATE_NONE;
 800171e:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8001720:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001724:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 8001728:	f7ff fe14 	bl	8001354 <HAL_I2C_SlaveRxCpltCallback>
 800172c:	e706      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 800172e:	bf00      	nop
 8001730:	00010002 	.word	0x00010002
 8001734:	00100004 	.word	0x00100004
 8001738:	00010080 	.word	0x00010080
 800173c:	00010004 	.word	0x00010004
 8001740:	00010008 	.word	0x00010008
 8001744:	00010040 	.word	0x00010040
 8001748:	00010010 	.word	0x00010010
      if(((sr1itflags & I2C_FLAG_RXNE) != RESET) && ((itsources & I2C_IT_BUF) != RESET) && ((sr1itflags & I2C_FLAG_BTF) == RESET))
 800174c:	49a0      	ldr	r1, [pc, #640]	; (80019d0 <HAL_I2C_EV_IRQHandler+0x520>)
 800174e:	4011      	ands	r1, r2
 8001750:	2900      	cmp	r1, #0
 8001752:	d065      	beq.n	8001820 <HAL_I2C_EV_IRQHandler+0x370>
 8001754:	0561      	lsls	r1, r4, #21
 8001756:	d563      	bpl.n	8001820 <HAL_I2C_EV_IRQHandler+0x370>
 8001758:	499e      	ldr	r1, [pc, #632]	; (80019d4 <HAL_I2C_EV_IRQHandler+0x524>)
 800175a:	4011      	ands	r1, r2
 800175c:	2900      	cmp	r1, #0
 800175e:	d164      	bne.n	800182a <HAL_I2C_EV_IRQHandler+0x37a>
  uint32_t CurrentState = hi2c->State;
 8001760:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if(hi2c->XferCount != 0U)
 8001764:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
  uint32_t CurrentState = hi2c->State;
 8001766:	b2c9      	uxtb	r1, r1
  if(hi2c->XferCount != 0U)
 8001768:	b292      	uxth	r2, r2
 800176a:	2a00      	cmp	r2, #0
 800176c:	f43f aee6 	beq.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001770:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001772:	691b      	ldr	r3, [r3, #16]
 8001774:	1c54      	adds	r4, r2, #1
 8001776:	6244      	str	r4, [r0, #36]	; 0x24
 8001778:	7013      	strb	r3, [r2, #0]
    hi2c->XferCount--;
 800177a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 800177c:	3b01      	subs	r3, #1
 800177e:	b29b      	uxth	r3, r3
 8001780:	8543      	strh	r3, [r0, #42]	; 0x2a
    if((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8001782:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001784:	b29b      	uxth	r3, r3
 8001786:	2b00      	cmp	r3, #0
 8001788:	f47f aed8 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 800178c:	292a      	cmp	r1, #42	; 0x2a
 800178e:	f47f aed5 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8001792:	2422      	movs	r4, #34	; 0x22
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8001794:	2128      	movs	r1, #40	; 0x28
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001796:	6802      	ldr	r2, [r0, #0]
 8001798:	6853      	ldr	r3, [r2, #4]
 800179a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800179e:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 80017a0:	6304      	str	r4, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 80017a2:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 80017a6:	f7ff fdd5 	bl	8001354 <HAL_I2C_SlaveRxCpltCallback>
 80017aa:	e6c7      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  if(hi2c->Mode == HAL_I2C_MODE_MEM)
 80017ac:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
 80017b0:	2940      	cmp	r1, #64	; 0x40
 80017b2:	f000 80d2 	beq.w	800195a <HAL_I2C_EV_IRQHandler+0x4aa>
    if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80017b6:	6901      	ldr	r1, [r0, #16]
 80017b8:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 80017bc:	f000 809e 	beq.w	80018fc <HAL_I2C_EV_IRQHandler+0x44c>
      if(hi2c->EventCount == 0U)
 80017c0:	6d01      	ldr	r1, [r0, #80]	; 0x50
 80017c2:	2900      	cmp	r1, #0
 80017c4:	f040 80db 	bne.w	800197e <HAL_I2C_EV_IRQHandler+0x4ce>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 80017c8:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80017ca:	11c9      	asrs	r1, r1, #7
 80017cc:	f001 0106 	and.w	r1, r1, #6
 80017d0:	f041 01f0 	orr.w	r1, r1, #240	; 0xf0
 80017d4:	6119      	str	r1, [r3, #16]
 80017d6:	e6bd      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
 80017d8:	6999      	ldr	r1, [r3, #24]
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
 80017da:	699b      	ldr	r3, [r3, #24]
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TRA) == RESET)
 80017dc:	f081 0104 	eor.w	r1, r1, #4
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_DUALF) == RESET)
 80017e0:	061f      	lsls	r7, r3, #24
    SlaveAddrCode = hi2c->Init.OwnAddress1;
 80017e2:	bf54      	ite	pl
 80017e4:	8982      	ldrhpl	r2, [r0, #12]
    SlaveAddrCode = hi2c->Init.OwnAddress2;
 80017e6:	8b02      	ldrhmi	r2, [r0, #24]
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 80017e8:	f3c1 0180 	ubfx	r1, r1, #2, #1
  HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 80017ec:	f7ff fdb4 	bl	8001358 <HAL_I2C_AddrCallback>
  return HAL_OK;
 80017f0:	e6a4      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 80017f2:	4978      	ldr	r1, [pc, #480]	; (80019d4 <HAL_I2C_EV_IRQHandler+0x524>)
 80017f4:	4011      	ands	r1, r2
 80017f6:	2900      	cmp	r1, #0
 80017f8:	f43f aea0 	beq.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 80017fc:	05a4      	lsls	r4, r4, #22
 80017fe:	f57f ae9d 	bpl.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  if(hi2c->XferCount != 0U)
 8001802:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001804:	b292      	uxth	r2, r2
 8001806:	2a00      	cmp	r2, #0
 8001808:	f43f ae98 	beq.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    hi2c->Instance->DR = (*hi2c->pBuffPtr++);
 800180c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800180e:	1c51      	adds	r1, r2, #1
 8001810:	6241      	str	r1, [r0, #36]	; 0x24
 8001812:	7812      	ldrb	r2, [r2, #0]
 8001814:	611a      	str	r2, [r3, #16]
    hi2c->XferCount--;
 8001816:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001818:	3b01      	subs	r3, #1
 800181a:	b29b      	uxth	r3, r3
 800181c:	8543      	strh	r3, [r0, #42]	; 0x2a
 800181e:	e68d      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      else if(((sr1itflags & I2C_FLAG_BTF) != RESET) && ((itsources & I2C_IT_EVT) != RESET))
 8001820:	496c      	ldr	r1, [pc, #432]	; (80019d4 <HAL_I2C_EV_IRQHandler+0x524>)
 8001822:	4011      	ands	r1, r2
 8001824:	2900      	cmp	r1, #0
 8001826:	f43f ae89 	beq.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 800182a:	05a2      	lsls	r2, r4, #22
 800182c:	f57f ae86 	bpl.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  if(hi2c->XferCount != 0U)
 8001830:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001832:	b292      	uxth	r2, r2
 8001834:	2a00      	cmp	r2, #0
 8001836:	f43f ae81 	beq.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 800183a:	e6e3      	b.n	8001604 <HAL_I2C_EV_IRQHandler+0x154>
  uint32_t CurrentState       = hi2c->State;
 800183c:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8001840:	8d04      	ldrh	r4, [r0, #40]	; 0x28
  uint32_t CurrentMode        = hi2c->Mode;
 8001842:	f890 103e 	ldrb.w	r1, [r0, #62]	; 0x3e
  uint32_t CurrentState       = hi2c->State;
 8001846:	b2d2      	uxtb	r2, r2
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001848:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
  uint32_t CurrentMode        = hi2c->Mode;
 800184a:	b2c9      	uxtb	r1, r1
  if((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 800184c:	2c00      	cmp	r4, #0
 800184e:	f040 80bb 	bne.w	80019c8 <HAL_I2C_EV_IRQHandler+0x518>
 8001852:	2a21      	cmp	r2, #33	; 0x21
 8001854:	f000 8142 	beq.w	8001adc <HAL_I2C_EV_IRQHandler+0x62c>
  else if((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 8001858:	2940      	cmp	r1, #64	; 0x40
 800185a:	f47f ae6f 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 800185e:	2a22      	cmp	r2, #34	; 0x22
 8001860:	f47f ae6c 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    if(hi2c->XferCount == 0U)
 8001864:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 8001866:	b292      	uxth	r2, r2
 8001868:	2a00      	cmp	r2, #0
 800186a:	f000 8132 	beq.w	8001ad2 <HAL_I2C_EV_IRQHandler+0x622>
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 800186e:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8001872:	2a40      	cmp	r2, #64	; 0x40
 8001874:	d1ca      	bne.n	800180c <HAL_I2C_EV_IRQHandler+0x35c>
        if(hi2c->EventCount == 0)
 8001876:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001878:	2a00      	cmp	r2, #0
 800187a:	f040 81b3 	bne.w	8001be4 <HAL_I2C_EV_IRQHandler+0x734>
          if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 800187e:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8001880:	2a01      	cmp	r2, #1
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8001882:	6c82      	ldr	r2, [r0, #72]	; 0x48
          if(hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 8001884:	f000 81d8 	beq.w	8001c38 <HAL_I2C_EV_IRQHandler+0x788>
            hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8001888:	f3c2 2207 	ubfx	r2, r2, #8, #8
 800188c:	611a      	str	r2, [r3, #16]
            hi2c->EventCount++;
 800188e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001890:	3301      	adds	r3, #1
 8001892:	6503      	str	r3, [r0, #80]	; 0x50
 8001894:	e652      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
  if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8001896:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 800189a:	2a22      	cmp	r2, #34	; 0x22
 800189c:	f47f ae4e 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    tmp = hi2c->XferCount;
 80018a0:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 80018a2:	b292      	uxth	r2, r2
    if(tmp > 3U)
 80018a4:	2a03      	cmp	r2, #3
 80018a6:	f63f aead 	bhi.w	8001604 <HAL_I2C_EV_IRQHandler+0x154>
    else if((tmp == 2U) || (tmp == 3U))
 80018aa:	3a02      	subs	r2, #2
 80018ac:	2a01      	cmp	r2, #1
      if(hi2c->XferOptions != I2C_NEXT_FRAME)
 80018ae:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    else if((tmp == 2U) || (tmp == 3U))
 80018b0:	f240 8104 	bls.w	8001abc <HAL_I2C_EV_IRQHandler+0x60c>
      hi2c->PreviousState = I2C_STATE_NONE;
 80018b4:	2100      	movs	r1, #0
      hi2c->State = HAL_I2C_STATE_READY;
 80018b6:	2520      	movs	r5, #32
      if(hi2c->XferOptions != I2C_NEXT_FRAME)
 80018b8:	2a02      	cmp	r2, #2
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80018ba:	681a      	ldr	r2, [r3, #0]
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80018bc:	6a44      	ldr	r4, [r0, #36]	; 0x24
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80018be:	bf14      	ite	ne
 80018c0:	f422 6280 	bicne.w	r2, r2, #1024	; 0x400
        hi2c->Instance->CR1 |= I2C_CR1_ACK;
 80018c4:	f442 6280 	orreq.w	r2, r2, #1024	; 0x400
 80018c8:	601a      	str	r2, [r3, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80018ca:	685a      	ldr	r2, [r3, #4]
 80018cc:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80018d0:	605a      	str	r2, [r3, #4]
      (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 80018d2:	691b      	ldr	r3, [r3, #16]
 80018d4:	1c62      	adds	r2, r4, #1
 80018d6:	6242      	str	r2, [r0, #36]	; 0x24
 80018d8:	7023      	strb	r3, [r4, #0]
      hi2c->XferCount--;
 80018da:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80018dc:	3b01      	subs	r3, #1
 80018de:	b29b      	uxth	r3, r3
 80018e0:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
 80018e2:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d
      hi2c->PreviousState = I2C_STATE_NONE;
 80018e6:	6301      	str	r1, [r0, #48]	; 0x30
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 80018e8:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80018ec:	f880 103e 	strb.w	r1, [r0, #62]	; 0x3e
      if(hi2c->Mode == HAL_I2C_MODE_MEM)
 80018f0:	2b40      	cmp	r3, #64	; 0x40
 80018f2:	f000 80a5 	beq.w	8001a40 <HAL_I2C_EV_IRQHandler+0x590>
      HAL_I2C_MasterRxCpltCallback(hi2c);
 80018f6:	f7ff fd29 	bl	800134c <HAL_I2C_MasterRxCpltCallback>
 80018fa:	e61f      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      if(hi2c->State == HAL_I2C_STATE_BUSY_TX) 
 80018fc:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8001900:	2921      	cmp	r1, #33	; 0x21
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8001902:	6c41      	ldr	r1, [r0, #68]	; 0x44
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8001904:	bf16      	itet	ne
 8001906:	f041 0101 	orrne.w	r1, r1, #1
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800190a:	f001 01fe 	andeq.w	r1, r1, #254	; 0xfe
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 800190e:	b2c9      	uxtbne	r1, r1
 8001910:	6119      	str	r1, [r3, #16]
 8001912:	e61f      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
    if((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 8001914:	6d06      	ldr	r6, [r0, #80]	; 0x50
 8001916:	b916      	cbnz	r6, 800191e <HAL_I2C_EV_IRQHandler+0x46e>
 8001918:	2940      	cmp	r1, #64	; 0x40
 800191a:	f000 80f4 	beq.w	8001b06 <HAL_I2C_EV_IRQHandler+0x656>
    else if((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 800191e:	6d06      	ldr	r6, [r0, #80]	; 0x50
 8001920:	b926      	cbnz	r6, 800192c <HAL_I2C_EV_IRQHandler+0x47c>
 8001922:	6901      	ldr	r1, [r0, #16]
 8001924:	f5b1 4f40 	cmp.w	r1, #49152	; 0xc000
 8001928:	f000 80f4 	beq.w	8001b14 <HAL_I2C_EV_IRQHandler+0x664>
      if(hi2c->XferCount == 0U)
 800192c:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 800192e:	b289      	uxth	r1, r1
 8001930:	2900      	cmp	r1, #0
 8001932:	f040 809f 	bne.w	8001a74 <HAL_I2C_EV_IRQHandler+0x5c4>
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001936:	9102      	str	r1, [sp, #8]
 8001938:	6959      	ldr	r1, [r3, #20]
 800193a:	9102      	str	r1, [sp, #8]
 800193c:	6999      	ldr	r1, [r3, #24]
 800193e:	9102      	str	r1, [sp, #8]
 8001940:	9902      	ldr	r1, [sp, #8]
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001942:	6819      	ldr	r1, [r3, #0]
 8001944:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8001948:	6019      	str	r1, [r3, #0]
      hi2c->EventCount = 0U;
 800194a:	2100      	movs	r1, #0
 800194c:	6501      	str	r1, [r0, #80]	; 0x50
 800194e:	e601      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
}
 8001950:	b00d      	add	sp, #52	; 0x34
 8001952:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    I2C_ITError(hi2c);
 8001956:	f7ff bd0b 	b.w	8001370 <I2C_ITError>
    if(hi2c->EventCount == 0U)
 800195a:	6d01      	ldr	r1, [r0, #80]	; 0x50
 800195c:	bb09      	cbnz	r1, 80019a2 <HAL_I2C_EV_IRQHandler+0x4f2>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800195e:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8001960:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8001964:	6119      	str	r1, [r3, #16]
 8001966:	e5f5      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
      hi2c->State = HAL_I2C_STATE_READY;
 8001968:	2220      	movs	r2, #32
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800196a:	491b      	ldr	r1, [pc, #108]	; (80019d8 <HAL_I2C_EV_IRQHandler+0x528>)
 800196c:	62c1      	str	r1, [r0, #44]	; 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 800196e:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8001970:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001974:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8001978:	f7ff fcf0 	bl	800135c <HAL_I2C_ListenCpltCallback>
 800197c:	e5de      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      else if(hi2c->EventCount == 1U)
 800197e:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8001980:	2901      	cmp	r1, #1
 8001982:	f47f ade7 	bne.w	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 8001986:	6c41      	ldr	r1, [r0, #68]	; 0x44
 8001988:	11c9      	asrs	r1, r1, #7
 800198a:	f001 0106 	and.w	r1, r1, #6
 800198e:	f041 01f1 	orr.w	r1, r1, #241	; 0xf1
 8001992:	6119      	str	r1, [r3, #16]
 8001994:	e5de      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
      hi2c->XferCount = __HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 8001996:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8001998:	6812      	ldr	r2, [r2, #0]
 800199a:	6852      	ldr	r2, [r2, #4]
 800199c:	b292      	uxth	r2, r2
 800199e:	8542      	strh	r2, [r0, #42]	; 0x2a
 80019a0:	e68c      	b.n	80016bc <HAL_I2C_EV_IRQHandler+0x20c>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 80019a2:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80019a4:	f041 0101 	orr.w	r1, r1, #1
 80019a8:	b2c9      	uxtb	r1, r1
 80019aa:	6119      	str	r1, [r3, #16]
 80019ac:	e5d2      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
    if((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
 80019ae:	2904      	cmp	r1, #4
 80019b0:	d005      	beq.n	80019be <HAL_I2C_EV_IRQHandler+0x50e>
 80019b2:	2908      	cmp	r1, #8
 80019b4:	d003      	beq.n	80019be <HAL_I2C_EV_IRQHandler+0x50e>
 80019b6:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 80019ba:	f47f ae23 	bne.w	8001604 <HAL_I2C_EV_IRQHandler+0x154>
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80019be:	681a      	ldr	r2, [r3, #0]
 80019c0:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80019c4:	601a      	str	r2, [r3, #0]
 80019c6:	e61d      	b.n	8001604 <HAL_I2C_EV_IRQHandler+0x154>
  else if((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 80019c8:	2a21      	cmp	r2, #33	; 0x21
 80019ca:	f43f af4b 	beq.w	8001864 <HAL_I2C_EV_IRQHandler+0x3b4>
 80019ce:	e743      	b.n	8001858 <HAL_I2C_EV_IRQHandler+0x3a8>
 80019d0:	00010040 	.word	0x00010040
 80019d4:	00010004 	.word	0x00010004
 80019d8:	ffff0000 	.word	0xffff0000
    if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80019dc:	2904      	cmp	r1, #4
 80019de:	d064      	beq.n	8001aaa <HAL_I2C_EV_IRQHandler+0x5fa>
 80019e0:	2908      	cmp	r1, #8
 80019e2:	d062      	beq.n	8001aaa <HAL_I2C_EV_IRQHandler+0x5fa>
 80019e4:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 80019e8:	d05f      	beq.n	8001aaa <HAL_I2C_EV_IRQHandler+0x5fa>
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80019ea:	681a      	ldr	r2, [r3, #0]
      if(CurrentXferOptions != I2C_NEXT_FRAME)
 80019ec:	2902      	cmp	r1, #2
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 80019ee:	bf14      	ite	ne
 80019f0:	f422 6280 	bicne.w	r2, r2, #1024	; 0x400
        hi2c->Instance->CR1 |= I2C_CR1_ACK;
 80019f4:	f442 6280 	orreq.w	r2, r2, #1024	; 0x400
 80019f8:	601a      	str	r2, [r3, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 80019fa:	685a      	ldr	r2, [r3, #4]
 80019fc:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001a00:	605a      	str	r2, [r3, #4]
    hi2c->PreviousState = I2C_STATE_NONE;
 8001a02:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001a04:	2420      	movs	r4, #32
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001a06:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8001a08:	691b      	ldr	r3, [r3, #16]
 8001a0a:	1c4d      	adds	r5, r1, #1
 8001a0c:	6245      	str	r5, [r0, #36]	; 0x24
 8001a0e:	700b      	strb	r3, [r1, #0]
    hi2c->XferCount--;
 8001a10:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001a12:	6801      	ldr	r1, [r0, #0]
    hi2c->XferCount--;
 8001a14:	3b01      	subs	r3, #1
 8001a16:	b29b      	uxth	r3, r3
 8001a18:	8543      	strh	r3, [r0, #42]	; 0x2a
    (*hi2c->pBuffPtr++) = hi2c->Instance->DR;
 8001a1a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001a1c:	6909      	ldr	r1, [r1, #16]
 8001a1e:	1c5d      	adds	r5, r3, #1
 8001a20:	6245      	str	r5, [r0, #36]	; 0x24
 8001a22:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
 8001a24:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8001a26:	3b01      	subs	r3, #1
 8001a28:	b29b      	uxth	r3, r3
 8001a2a:	8543      	strh	r3, [r0, #42]	; 0x2a
    hi2c->State = HAL_I2C_STATE_READY;
 8001a2c:	f880 403d 	strb.w	r4, [r0, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
 8001a30:	6302      	str	r2, [r0, #48]	; 0x30
    if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8001a32:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001a36:	f880 203e 	strb.w	r2, [r0, #62]	; 0x3e
    if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8001a3a:	2b40      	cmp	r3, #64	; 0x40
 8001a3c:	f47f af5b 	bne.w	80018f6 <HAL_I2C_EV_IRQHandler+0x446>
      HAL_I2C_MemRxCpltCallback(hi2c);
 8001a40:	f7ff fc90 	bl	8001364 <HAL_I2C_MemRxCpltCallback>
 8001a44:	e57a      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
        hi2c->PreviousState = I2C_STATE_NONE;
 8001a46:	2100      	movs	r1, #0
        hi2c->State = HAL_I2C_STATE_READY;
 8001a48:	2420      	movs	r4, #32
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001a4a:	685a      	ldr	r2, [r3, #4]
 8001a4c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001a50:	605a      	str	r2, [r3, #4]
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001a52:	681a      	ldr	r2, [r3, #0]
 8001a54:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001a58:	601a      	str	r2, [r3, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 8001a5a:	6301      	str	r1, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8001a5c:	f880 403d 	strb.w	r4, [r0, #61]	; 0x3d
        if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8001a60:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001a64:	f880 103e 	strb.w	r1, [r0, #62]	; 0x3e
        if(hi2c->Mode == HAL_I2C_MODE_MEM)
 8001a68:	2b40      	cmp	r3, #64	; 0x40
 8001a6a:	f47f ada3 	bne.w	80015b4 <HAL_I2C_EV_IRQHandler+0x104>
          HAL_I2C_MemTxCpltCallback(hi2c);
 8001a6e:	f7ff fc77 	bl	8001360 <HAL_I2C_MemTxCpltCallback>
 8001a72:	e563      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      else if(hi2c->XferCount == 1U)   
 8001a74:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 8001a76:	b289      	uxth	r1, r1
 8001a78:	2901      	cmp	r1, #1
 8001a7a:	d059      	beq.n	8001b30 <HAL_I2C_EV_IRQHandler+0x680>
      else if(hi2c->XferCount == 2U)
 8001a7c:	8d41      	ldrh	r1, [r0, #42]	; 0x2a
 8001a7e:	b289      	uxth	r1, r1
 8001a80:	2902      	cmp	r1, #2
 8001a82:	d070      	beq.n	8001b66 <HAL_I2C_EV_IRQHandler+0x6b6>
        hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8001a84:	6819      	ldr	r1, [r3, #0]
 8001a86:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8001a8a:	6019      	str	r1, [r3, #0]
        if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8001a8c:	6859      	ldr	r1, [r3, #4]
 8001a8e:	0509      	lsls	r1, r1, #20
 8001a90:	d503      	bpl.n	8001a9a <HAL_I2C_EV_IRQHandler+0x5ea>
          hi2c->Instance->CR2 |= I2C_CR2_LAST;
 8001a92:	6859      	ldr	r1, [r3, #4]
 8001a94:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8001a98:	6059      	str	r1, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001a9a:	2100      	movs	r1, #0
 8001a9c:	9109      	str	r1, [sp, #36]	; 0x24
 8001a9e:	6959      	ldr	r1, [r3, #20]
 8001aa0:	9109      	str	r1, [sp, #36]	; 0x24
 8001aa2:	6999      	ldr	r1, [r3, #24]
 8001aa4:	9109      	str	r1, [sp, #36]	; 0x24
 8001aa6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8001aa8:	e74f      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8001aaa:	685a      	ldr	r2, [r3, #4]
 8001aac:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8001ab0:	605a      	str	r2, [r3, #4]
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001ab2:	681a      	ldr	r2, [r3, #0]
 8001ab4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001ab8:	601a      	str	r2, [r3, #0]
 8001aba:	e7a2      	b.n	8001a02 <HAL_I2C_EV_IRQHandler+0x552>
      if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001abc:	2a02      	cmp	r2, #2
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001abe:	681a      	ldr	r2, [r3, #0]
      if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001ac0:	f000 80a1 	beq.w	8001c06 <HAL_I2C_EV_IRQHandler+0x756>
        hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001ac4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001ac8:	601a      	str	r2, [r3, #0]
        hi2c->Instance->CR1 |= I2C_CR1_POS;
 8001aca:	681a      	ldr	r2, [r3, #0]
 8001acc:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001ad0:	601a      	str	r2, [r3, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8001ad2:	685a      	ldr	r2, [r3, #4]
 8001ad4:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001ad8:	605a      	str	r2, [r3, #4]
 8001ada:	e52f      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
    if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8001adc:	2d04      	cmp	r5, #4
 8001ade:	d0b2      	beq.n	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
 8001ae0:	2d08      	cmp	r5, #8
 8001ae2:	d0b0      	beq.n	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
 8001ae4:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
 8001ae8:	d0ad      	beq.n	8001a46 <HAL_I2C_EV_IRQHandler+0x596>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8001aea:	2511      	movs	r5, #17
      hi2c->State = HAL_I2C_STATE_READY;
 8001aec:	2120      	movs	r1, #32
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001aee:	685a      	ldr	r2, [r3, #4]
 8001af0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001af4:	605a      	str	r2, [r3, #4]
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8001af6:	6305      	str	r5, [r0, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8001af8:	f880 403e 	strb.w	r4, [r0, #62]	; 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 8001afc:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
      HAL_I2C_MasterTxCpltCallback(hi2c);
 8001b00:	f7ff fc22 	bl	8001348 <HAL_I2C_MasterTxCpltCallback>
 8001b04:	e51a      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b06:	9600      	str	r6, [sp, #0]
 8001b08:	6959      	ldr	r1, [r3, #20]
 8001b0a:	9100      	str	r1, [sp, #0]
 8001b0c:	6999      	ldr	r1, [r3, #24]
 8001b0e:	9100      	str	r1, [sp, #0]
 8001b10:	9900      	ldr	r1, [sp, #0]
 8001b12:	e51f      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b14:	9601      	str	r6, [sp, #4]
 8001b16:	6959      	ldr	r1, [r3, #20]
 8001b18:	9101      	str	r1, [sp, #4]
 8001b1a:	6999      	ldr	r1, [r3, #24]
 8001b1c:	9101      	str	r1, [sp, #4]
 8001b1e:	9901      	ldr	r1, [sp, #4]
      hi2c->Instance->CR1 |= I2C_CR1_START;
 8001b20:	6819      	ldr	r1, [r3, #0]
 8001b22:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8001b26:	6019      	str	r1, [r3, #0]
      hi2c->EventCount++;
 8001b28:	6d01      	ldr	r1, [r0, #80]	; 0x50
 8001b2a:	3101      	adds	r1, #1
 8001b2c:	6501      	str	r1, [r0, #80]	; 0x50
 8001b2e:	e511      	b.n	8001554 <HAL_I2C_EV_IRQHandler+0xa4>
        if(CurrentXferOptions == I2C_NO_OPTION_FRAME)
 8001b30:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8001b34:	d042      	beq.n	8001bbc <HAL_I2C_EV_IRQHandler+0x70c>
        else if((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 8001b36:	2f04      	cmp	r7, #4
 8001b38:	d030      	beq.n	8001b9c <HAL_I2C_EV_IRQHandler+0x6ec>
 8001b3a:	2f08      	cmp	r7, #8
 8001b3c:	d02e      	beq.n	8001b9c <HAL_I2C_EV_IRQHandler+0x6ec>
          && (Prev_State != I2C_STATE_MASTER_BUSY_RX))
 8001b3e:	f1bc 0f12 	cmp.w	ip, #18
 8001b42:	d02b      	beq.n	8001b9c <HAL_I2C_EV_IRQHandler+0x6ec>
          if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001b44:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8001b46:	2902      	cmp	r1, #2
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001b48:	6819      	ldr	r1, [r3, #0]
 8001b4a:	bf14      	ite	ne
 8001b4c:	f421 6180 	bicne.w	r1, r1, #1024	; 0x400
            hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8001b50:	f441 6180 	orreq.w	r1, r1, #1024	; 0x400
 8001b54:	6019      	str	r1, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b56:	2100      	movs	r1, #0
 8001b58:	9105      	str	r1, [sp, #20]
 8001b5a:	6959      	ldr	r1, [r3, #20]
 8001b5c:	9105      	str	r1, [sp, #20]
 8001b5e:	6999      	ldr	r1, [r3, #24]
 8001b60:	9105      	str	r1, [sp, #20]
 8001b62:	9905      	ldr	r1, [sp, #20]
 8001b64:	e6f1      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
        if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001b66:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b68:	2600      	movs	r6, #0
        if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001b6a:	2902      	cmp	r1, #2
          hi2c->Instance->CR1 |= I2C_CR1_POS;
 8001b6c:	6819      	ldr	r1, [r3, #0]
        if(hi2c->XferOptions != I2C_NEXT_FRAME)
 8001b6e:	d04e      	beq.n	8001c0e <HAL_I2C_EV_IRQHandler+0x75e>
          hi2c->Instance->CR1 |= I2C_CR1_POS;
 8001b70:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8001b74:	6019      	str	r1, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b76:	9607      	str	r6, [sp, #28]
 8001b78:	6959      	ldr	r1, [r3, #20]
 8001b7a:	9107      	str	r1, [sp, #28]
 8001b7c:	6999      	ldr	r1, [r3, #24]
 8001b7e:	9107      	str	r1, [sp, #28]
 8001b80:	9907      	ldr	r1, [sp, #28]
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001b82:	6819      	ldr	r1, [r3, #0]
 8001b84:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001b88:	6019      	str	r1, [r3, #0]
        if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8001b8a:	6859      	ldr	r1, [r3, #4]
 8001b8c:	050e      	lsls	r6, r1, #20
 8001b8e:	f57f aedc 	bpl.w	800194a <HAL_I2C_EV_IRQHandler+0x49a>
          hi2c->Instance->CR2 |= I2C_CR2_LAST;
 8001b92:	6859      	ldr	r1, [r3, #4]
 8001b94:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
 8001b98:	6059      	str	r1, [r3, #4]
 8001b9a:	e6d6      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001b9c:	2600      	movs	r6, #0
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001b9e:	6819      	ldr	r1, [r3, #0]
 8001ba0:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001ba4:	6019      	str	r1, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001ba6:	9606      	str	r6, [sp, #24]
 8001ba8:	6959      	ldr	r1, [r3, #20]
 8001baa:	9106      	str	r1, [sp, #24]
 8001bac:	6999      	ldr	r1, [r3, #24]
 8001bae:	9106      	str	r1, [sp, #24]
 8001bb0:	9906      	ldr	r1, [sp, #24]
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001bb2:	6819      	ldr	r1, [r3, #0]
 8001bb4:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8001bb8:	6019      	str	r1, [r3, #0]
 8001bba:	e6c6      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001bbc:	6819      	ldr	r1, [r3, #0]
 8001bbe:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001bc2:	6019      	str	r1, [r3, #0]
          if((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8001bc4:	6859      	ldr	r1, [r3, #4]
 8001bc6:	f411 6100 	ands.w	r1, r1, #2048	; 0x800
 8001bca:	d02a      	beq.n	8001c22 <HAL_I2C_EV_IRQHandler+0x772>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001bcc:	2600      	movs	r6, #0
            hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001bce:	6819      	ldr	r1, [r3, #0]
 8001bd0:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001bd4:	6019      	str	r1, [r3, #0]
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001bd6:	9603      	str	r6, [sp, #12]
 8001bd8:	6959      	ldr	r1, [r3, #20]
 8001bda:	9103      	str	r1, [sp, #12]
 8001bdc:	6999      	ldr	r1, [r3, #24]
 8001bde:	9103      	str	r1, [sp, #12]
 8001be0:	9903      	ldr	r1, [sp, #12]
 8001be2:	e6b2      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
        else if(hi2c->EventCount == 1)
 8001be4:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001be6:	2a01      	cmp	r2, #1
 8001be8:	d02c      	beq.n	8001c44 <HAL_I2C_EV_IRQHandler+0x794>
        else if(hi2c->EventCount == 2)
 8001bea:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001bec:	2a02      	cmp	r2, #2
 8001bee:	f47f aca5 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
          if(hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8001bf2:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8001bf6:	2a22      	cmp	r2, #34	; 0x22
 8001bf8:	d02b      	beq.n	8001c52 <HAL_I2C_EV_IRQHandler+0x7a2>
          else if(hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8001bfa:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
 8001bfe:	2a21      	cmp	r2, #33	; 0x21
 8001c00:	f47f ac9c 	bne.w	800153c <HAL_I2C_EV_IRQHandler+0x8c>
 8001c04:	e602      	b.n	800180c <HAL_I2C_EV_IRQHandler+0x35c>
        hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8001c06:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001c0a:	601a      	str	r2, [r3, #0]
 8001c0c:	e761      	b.n	8001ad2 <HAL_I2C_EV_IRQHandler+0x622>
          hi2c->Instance->CR1 |= I2C_CR1_ACK;
 8001c0e:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8001c12:	6019      	str	r1, [r3, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001c14:	9608      	str	r6, [sp, #32]
 8001c16:	6959      	ldr	r1, [r3, #20]
 8001c18:	9108      	str	r1, [sp, #32]
 8001c1a:	6999      	ldr	r1, [r3, #24]
 8001c1c:	9108      	str	r1, [sp, #32]
 8001c1e:	9908      	ldr	r1, [sp, #32]
 8001c20:	e7b3      	b.n	8001b8a <HAL_I2C_EV_IRQHandler+0x6da>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8001c22:	9104      	str	r1, [sp, #16]
 8001c24:	6959      	ldr	r1, [r3, #20]
 8001c26:	9104      	str	r1, [sp, #16]
 8001c28:	6999      	ldr	r1, [r3, #24]
 8001c2a:	9104      	str	r1, [sp, #16]
 8001c2c:	9904      	ldr	r1, [sp, #16]
            hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8001c2e:	6819      	ldr	r1, [r3, #0]
 8001c30:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8001c34:	6019      	str	r1, [r3, #0]
 8001c36:	e688      	b.n	800194a <HAL_I2C_EV_IRQHandler+0x49a>
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8001c38:	b2d2      	uxtb	r2, r2
 8001c3a:	611a      	str	r2, [r3, #16]
            hi2c->EventCount += 2;
 8001c3c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001c3e:	3302      	adds	r3, #2
 8001c40:	6503      	str	r3, [r0, #80]	; 0x50
 8001c42:	e47b      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
          hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8001c44:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8001c46:	b2d2      	uxtb	r2, r2
 8001c48:	611a      	str	r2, [r3, #16]
          hi2c->EventCount++;
 8001c4a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8001c4c:	3301      	adds	r3, #1
 8001c4e:	6503      	str	r3, [r0, #80]	; 0x50
 8001c50:	e474      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>
            hi2c->Instance->CR1 |= I2C_CR1_START;
 8001c52:	681a      	ldr	r2, [r3, #0]
 8001c54:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001c58:	601a      	str	r2, [r3, #0]
 8001c5a:	e46f      	b.n	800153c <HAL_I2C_EV_IRQHandler+0x8c>

08001c5c <HAL_I2C_ER_IRQHandler>:
{
 8001c5c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8001c5e:	6803      	ldr	r3, [r0, #0]
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c60:	4956      	ldr	r1, [pc, #344]	; (8001dbc <HAL_I2C_ER_IRQHandler+0x160>)
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8001c62:	695c      	ldr	r4, [r3, #20]
{
 8001c64:	b083      	sub	sp, #12
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c66:	420c      	tst	r4, r1
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 8001c68:	685a      	ldr	r2, [r3, #4]
  if(((sr1itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c6a:	d022      	beq.n	8001cb2 <HAL_I2C_ER_IRQHandler+0x56>
 8001c6c:	05d6      	lsls	r6, r2, #23
 8001c6e:	d520      	bpl.n	8001cb2 <HAL_I2C_ER_IRQHandler+0x56>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8001c70:	f46f 7580 	mvn.w	r5, #256	; 0x100
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8001c74:	6c01      	ldr	r1, [r0, #64]	; 0x40
  if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c76:	f414 3f81 	tst.w	r4, #66048	; 0x10200
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8001c7a:	f041 0101 	orr.w	r1, r1, #1
 8001c7e:	6401      	str	r1, [r0, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8001c80:	615d      	str	r5, [r3, #20]
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_SWRST);
 8001c82:	6819      	ldr	r1, [r3, #0]
 8001c84:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 8001c88:	6019      	str	r1, [r3, #0]
  if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c8a:	d048      	beq.n	8001d1e <HAL_I2C_ER_IRQHandler+0xc2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8001c8c:	f46f 7500 	mvn.w	r5, #512	; 0x200
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8001c90:	6c01      	ldr	r1, [r0, #64]	; 0x40
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c92:	f414 3f82 	tst.w	r4, #66560	; 0x10400
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8001c96:	f041 0102 	orr.w	r1, r1, #2
 8001c9a:	6401      	str	r1, [r0, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8001c9c:	615d      	str	r5, [r3, #20]
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001c9e:	d11d      	bne.n	8001cdc <HAL_I2C_ER_IRQHandler+0x80>
  if(((sr1itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001ca0:	f414 3f84 	tst.w	r4, #67584	; 0x10800
 8001ca4:	d001      	beq.n	8001caa <HAL_I2C_ER_IRQHandler+0x4e>
 8001ca6:	05d2      	lsls	r2, r2, #23
 8001ca8:	d431      	bmi.n	8001d0e <HAL_I2C_ER_IRQHandler+0xb2>
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8001caa:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001cac:	b963      	cbnz	r3, 8001cc8 <HAL_I2C_ER_IRQHandler+0x6c>
}
 8001cae:	b003      	add	sp, #12
 8001cb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((sr1itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001cb2:	f414 3f81 	tst.w	r4, #66048	; 0x10200
 8001cb6:	d00c      	beq.n	8001cd2 <HAL_I2C_ER_IRQHandler+0x76>
 8001cb8:	05d5      	lsls	r5, r2, #23
 8001cba:	d4e7      	bmi.n	8001c8c <HAL_I2C_ER_IRQHandler+0x30>
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001cbc:	f414 3f82 	tst.w	r4, #66560	; 0x10400
 8001cc0:	d0ee      	beq.n	8001ca0 <HAL_I2C_ER_IRQHandler+0x44>
  if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8001cc2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001cc4:	2b00      	cmp	r3, #0
 8001cc6:	d0f2      	beq.n	8001cae <HAL_I2C_ER_IRQHandler+0x52>
}
 8001cc8:	b003      	add	sp, #12
 8001cca:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    I2C_ITError(hi2c);
 8001cce:	f7ff bb4f 	b.w	8001370 <I2C_ITError>
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001cd2:	f414 3f82 	tst.w	r4, #66560	; 0x10400
 8001cd6:	d0e3      	beq.n	8001ca0 <HAL_I2C_ER_IRQHandler+0x44>
 8001cd8:	05d1      	lsls	r1, r2, #23
 8001cda:	d5e6      	bpl.n	8001caa <HAL_I2C_ER_IRQHandler+0x4e>
    tmp1 = hi2c->Mode;
 8001cdc:	f890 503e 	ldrb.w	r5, [r0, #62]	; 0x3e
    tmp2 = hi2c->XferCount;
 8001ce0:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
    tmp3 = hi2c->State;
 8001ce2:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
    if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8001ce6:	2d20      	cmp	r5, #32
    tmp4 = hi2c->PreviousState;
 8001ce8:	6b06      	ldr	r6, [r0, #48]	; 0x30
    tmp2 = hi2c->XferCount;
 8001cea:	b292      	uxth	r2, r2
    tmp3 = hi2c->State;
 8001cec:	b2c9      	uxtb	r1, r1
    if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8001cee:	d01a      	beq.n	8001d26 <HAL_I2C_ER_IRQHandler+0xca>
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8001cf0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8001cf2:	f042 0204 	orr.w	r2, r2, #4
 8001cf6:	6402      	str	r2, [r0, #64]	; 0x40
      if(hi2c->Mode == HAL_I2C_MODE_MASTER)
 8001cf8:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8001cfc:	2a10      	cmp	r2, #16
 8001cfe:	d03e      	beq.n	8001d7e <HAL_I2C_ER_IRQHandler+0x122>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001d00:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8001d04:	615a      	str	r2, [r3, #20]
  if(((sr1itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001d06:	f414 3f84 	tst.w	r4, #67584	; 0x10800
 8001d0a:	d0ce      	beq.n	8001caa <HAL_I2C_ER_IRQHandler+0x4e>
 8001d0c:	6803      	ldr	r3, [r0, #0]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8001d0e:	f46f 6100 	mvn.w	r1, #2048	; 0x800
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8001d12:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8001d14:	f042 0208 	orr.w	r2, r2, #8
 8001d18:	6402      	str	r2, [r0, #64]	; 0x40
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8001d1a:	6159      	str	r1, [r3, #20]
 8001d1c:	e7c5      	b.n	8001caa <HAL_I2C_ER_IRQHandler+0x4e>
  if(((sr1itflags & I2C_FLAG_AF) != RESET) && ((itsources & I2C_IT_ERR) != RESET))
 8001d1e:	f414 3f82 	tst.w	r4, #66560	; 0x10400
 8001d22:	d1db      	bne.n	8001cdc <HAL_I2C_ER_IRQHandler+0x80>
 8001d24:	e7bc      	b.n	8001ca0 <HAL_I2C_ER_IRQHandler+0x44>
    if((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8001d26:	2a00      	cmp	r2, #0
 8001d28:	d1e2      	bne.n	8001cf0 <HAL_I2C_ER_IRQHandler+0x94>
 8001d2a:	f001 02f7 	and.w	r2, r1, #247	; 0xf7
 8001d2e:	2a21      	cmp	r2, #33	; 0x21
 8001d30:	d003      	beq.n	8001d3a <HAL_I2C_ER_IRQHandler+0xde>
      ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 8001d32:	2928      	cmp	r1, #40	; 0x28
 8001d34:	d1dc      	bne.n	8001cf0 <HAL_I2C_ER_IRQHandler+0x94>
      ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 8001d36:	2e21      	cmp	r6, #33	; 0x21
 8001d38:	d1da      	bne.n	8001cf0 <HAL_I2C_ER_IRQHandler+0x94>
  uint32_t CurrentState       = hi2c->State;
 8001d3a:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8001d3e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  uint32_t CurrentState       = hi2c->State;
 8001d40:	b2d2      	uxtb	r2, r2
  if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8001d42:	2904      	cmp	r1, #4
 8001d44:	d020      	beq.n	8001d88 <HAL_I2C_ER_IRQHandler+0x12c>
 8001d46:	2908      	cmp	r1, #8
 8001d48:	d01e      	beq.n	8001d88 <HAL_I2C_ER_IRQHandler+0x12c>
  else if(CurrentState == HAL_I2C_STATE_BUSY_TX)
 8001d4a:	2a21      	cmp	r2, #33	; 0x21
 8001d4c:	d1d8      	bne.n	8001d00 <HAL_I2C_ER_IRQHandler+0xa4>
    hi2c->State = HAL_I2C_STATE_READY;
 8001d4e:	2620      	movs	r6, #32
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d50:	2500      	movs	r5, #0
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001d52:	f46f 6180 	mvn.w	r1, #1024	; 0x400
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001d56:	4f1a      	ldr	r7, [pc, #104]	; (8001dc0 <HAL_I2C_ER_IRQHandler+0x164>)
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001d58:	9001      	str	r0, [sp, #4]
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001d5a:	62c7      	str	r7, [r0, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001d5c:	6302      	str	r2, [r0, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
 8001d5e:	f880 603d 	strb.w	r6, [r0, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d62:	f880 503e 	strb.w	r5, [r0, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001d66:	685a      	ldr	r2, [r3, #4]
 8001d68:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001d6c:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001d6e:	6159      	str	r1, [r3, #20]
    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001d70:	681a      	ldr	r2, [r3, #0]
 8001d72:	400a      	ands	r2, r1
 8001d74:	601a      	str	r2, [r3, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001d76:	f7ff faeb 	bl	8001350 <HAL_I2C_SlaveTxCpltCallback>
 8001d7a:	9801      	ldr	r0, [sp, #4]
 8001d7c:	e7c3      	b.n	8001d06 <HAL_I2C_ER_IRQHandler+0xaa>
        SET_BIT(hi2c->Instance->CR1,I2C_CR1_STOP);
 8001d7e:	681a      	ldr	r2, [r3, #0]
 8001d80:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001d84:	601a      	str	r2, [r3, #0]
 8001d86:	e7bb      	b.n	8001d00 <HAL_I2C_ER_IRQHandler+0xa4>
  if(((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 8001d88:	2a28      	cmp	r2, #40	; 0x28
 8001d8a:	d1de      	bne.n	8001d4a <HAL_I2C_ER_IRQHandler+0xee>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001d8c:	f46f 6680 	mvn.w	r6, #1024	; 0x400
    hi2c->PreviousState = I2C_STATE_NONE;
 8001d90:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001d92:	2520      	movs	r5, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001d94:	4a0a      	ldr	r2, [pc, #40]	; (8001dc0 <HAL_I2C_ER_IRQHandler+0x164>)
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001d96:	9001      	str	r0, [sp, #4]
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001d98:	62c2      	str	r2, [r0, #44]	; 0x2c
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8001d9a:	685a      	ldr	r2, [r3, #4]
 8001d9c:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001da0:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001da2:	615e      	str	r6, [r3, #20]
    hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001da4:	681a      	ldr	r2, [r3, #0]
 8001da6:	4032      	ands	r2, r6
 8001da8:	601a      	str	r2, [r3, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 8001daa:	6301      	str	r1, [r0, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
 8001dac:	f880 503d 	strb.w	r5, [r0, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001db0:	f880 103e 	strb.w	r1, [r0, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 8001db4:	f7ff fad2 	bl	800135c <HAL_I2C_ListenCpltCallback>
 8001db8:	9801      	ldr	r0, [sp, #4]
 8001dba:	e7a4      	b.n	8001d06 <HAL_I2C_ER_IRQHandler+0xaa>
 8001dbc:	00010100 	.word	0x00010100
 8001dc0:	ffff0000 	.word	0xffff0000

08001dc4 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma: DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 8001dc4:	b538      	push	{r3, r4, r5, lr}
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Disable Acknowledge */
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;

  hi2c->XferCount = 0U;
 8001dc6:	2300      	movs	r3, #0
  I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8001dc8:	6a40      	ldr	r0, [r0, #36]	; 0x24
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001dca:	6802      	ldr	r2, [r0, #0]

  /* Reset XferAbortCallback */
  hi2c->hdmatx->XferAbortCallback = NULL;
 8001dcc:	6b45      	ldr	r5, [r0, #52]	; 0x34
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001dce:	6811      	ldr	r1, [r2, #0]
  hi2c->hdmarx->XferAbortCallback = NULL;
 8001dd0:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8001dd2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8001dd6:	6011      	str	r1, [r2, #0]
  hi2c->XferCount = 0U;
 8001dd8:	8543      	strh	r3, [r0, #42]	; 0x2a
  hi2c->hdmatx->XferAbortCallback = NULL;
 8001dda:	636b      	str	r3, [r5, #52]	; 0x34
  hi2c->hdmarx->XferAbortCallback = NULL;
 8001ddc:	6363      	str	r3, [r4, #52]	; 0x34

  /* Check if come from abort from user */
  if(hi2c->State == HAL_I2C_STATE_ABORT)
 8001dde:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
 8001de2:	2960      	cmp	r1, #96	; 0x60
  {
    hi2c->State = HAL_I2C_STATE_READY;
 8001de4:	f04f 0120 	mov.w	r1, #32
 8001de8:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001dec:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
  if(hi2c->State == HAL_I2C_STATE_ABORT)
 8001df0:	d006      	beq.n	8001e00 <I2C_DMAAbort+0x3c>
  {
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 8001df2:	6813      	ldr	r3, [r2, #0]
 8001df4:	f023 0301 	bic.w	r3, r3, #1
 8001df8:	6013      	str	r3, [r2, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    HAL_I2C_ErrorCallback(hi2c);
 8001dfa:	f7ff fab5 	bl	8001368 <HAL_I2C_ErrorCallback>
  }
}
 8001dfe:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001e00:	6403      	str	r3, [r0, #64]	; 0x40
    __HAL_I2C_DISABLE(hi2c);
 8001e02:	6813      	ldr	r3, [r2, #0]
 8001e04:	f023 0301 	bic.w	r3, r3, #1
 8001e08:	6013      	str	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 8001e0a:	f7ff faaf 	bl	800136c <HAL_I2C_AbortCpltCallback>
}
 8001e0e:	bd38      	pop	{r3, r4, r5, pc}

08001e10 <HAL_PCD_IRQHandler>:
  * @brief  This function handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{ 
 8001e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e14:	4604      	mov	r4, r0
 8001e16:	b083      	sub	sp, #12
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 8001e18:	6800      	ldr	r0, [r0, #0]
 8001e1a:	f001 fa59 	bl	80032d0 <USB_ReadInterrupts>
 8001e1e:	0407      	lsls	r7, r0, #16
 8001e20:	d444      	bmi.n	8001eac <HAL_PCD_IRQHandler+0x9c>
 8001e22:	6820      	ldr	r0, [r4, #0]
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    PCD_EP_ISR_Handler(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
 8001e24:	f001 fa54 	bl	80032d0 <USB_ReadInterrupts>
 8001e28:	0546      	lsls	r6, r0, #21
 8001e2a:	f100 81ef 	bmi.w	800220c <HAL_PCD_IRQHandler+0x3fc>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
    HAL_PCD_ResetCallback(hpcd);
    HAL_PCD_SetAddress(hpcd, 0U);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 8001e2e:	6820      	ldr	r0, [r4, #0]
 8001e30:	f001 fa4e 	bl	80032d0 <USB_ReadInterrupts>
 8001e34:	f410 4f80 	tst.w	r0, #16384	; 0x4000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 8001e38:	6820      	ldr	r0, [r4, #0]
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 8001e3a:	d007      	beq.n	8001e4c <HAL_PCD_IRQHandler+0x3c>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 8001e3c:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8001e40:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001e44:	041b      	lsls	r3, r3, #16
 8001e46:	0c1b      	lsrs	r3, r3, #16
 8001e48:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 8001e4c:	f001 fa40 	bl	80032d0 <USB_ReadInterrupts>
 8001e50:	f410 5f00 	tst.w	r0, #8192	; 0x2000
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 8001e54:	6820      	ldr	r0, [r4, #0]
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 8001e56:	d007      	beq.n	8001e68 <HAL_PCD_IRQHandler+0x58>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 8001e58:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8001e5c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001e60:	041b      	lsls	r3, r3, #16
 8001e62:	0c1b      	lsrs	r3, r3, #16
 8001e64:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
 8001e68:	f001 fa32 	bl	80032d0 <USB_ReadInterrupts>
 8001e6c:	04c5      	lsls	r5, r0, #19
 8001e6e:	f100 81a9 	bmi.w	80021c4 <HAL_PCD_IRQHandler+0x3b4>
 8001e72:	6820      	ldr	r0, [r4, #0]
    HAL_PCD_ResumeCallback(hpcd);

    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
 8001e74:	f001 fa2c 	bl	80032d0 <USB_ReadInterrupts>
 8001e78:	0500      	lsls	r0, r0, #20
 8001e7a:	f100 8183 	bmi.w	8002184 <HAL_PCD_IRQHandler+0x374>
    {
      HAL_PCD_SuspendCallback(hpcd);
    }
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
 8001e7e:	6820      	ldr	r0, [r4, #0]
 8001e80:	f001 fa26 	bl	80032d0 <USB_ReadInterrupts>
 8001e84:	0582      	lsls	r2, r0, #22
 8001e86:	f100 8170 	bmi.w	800216a <HAL_PCD_IRQHandler+0x35a>
  {
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
    HAL_PCD_SOFCallback(hpcd);
  }

  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
 8001e8a:	6820      	ldr	r0, [r4, #0]
 8001e8c:	f001 fa20 	bl	80032d0 <USB_ReadInterrupts>
 8001e90:	05c3      	lsls	r3, r0, #23
 8001e92:	d508      	bpl.n	8001ea6 <HAL_PCD_IRQHandler+0x96>
  {
    /* clear ESOF flag in ISTR */
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
 8001e94:	6822      	ldr	r2, [r4, #0]
 8001e96:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001e9a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001e9e:	041b      	lsls	r3, r3, #16
 8001ea0:	0c1b      	lsrs	r3, r3, #16
 8001ea2:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
  }
}
 8001ea6:	b003      	add	sp, #12
 8001ea8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static HAL_StatusTypeDef PCD_EP_ISR_Handler(PCD_HandleTypeDef *hpcd)
{
  PCD_EPTypeDef *ep = NULL;
  uint16_t count = 0;
  uint8_t epindex = 0;
  __IO uint16_t wIstr = 0;  
 8001eac:	2300      	movs	r3, #0
  __IO uint16_t wEPVal = 0;
  
  /* stay in loop while pending interrupts */
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8001eae:	6822      	ldr	r2, [r4, #0]
  __IO uint16_t wIstr = 0;  
 8001eb0:	f8ad 3004 	strh.w	r3, [sp, #4]
  __IO uint16_t wEPVal = 0;
 8001eb4:	f8ad 3006 	strh.w	r3, [sp, #6]
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8001eb8:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001ebc:	4610      	mov	r0, r2
 8001ebe:	b29b      	uxth	r3, r3
 8001ec0:	041e      	lsls	r6, r3, #16
 8001ec2:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001ec6:	d5ad      	bpl.n	8001e24 <HAL_PCD_IRQHandler+0x14>
  {
    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8001ec8:	f8bd 5004 	ldrh.w	r5, [sp, #4]
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
      {
        ep = &hpcd->IN_ep[epindex];
        
        /* clear int flag */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 8001ecc:	4ecc      	ldr	r6, [pc, #816]	; (8002200 <HAL_PCD_IRQHandler+0x3f0>)
    if (epindex == 0)
 8001ece:	f015 050f 	ands.w	r5, r5, #15
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 8001ed2:	4fcc      	ldr	r7, [pc, #816]	; (8002204 <HAL_PCD_IRQHandler+0x3f4>)
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001ed4:	f8df 8330 	ldr.w	r8, [pc, #816]	; 8002208 <HAL_PCD_IRQHandler+0x3f8>
    if (epindex == 0)
 8001ed8:	d11f      	bne.n	8001f1a <HAL_PCD_IRQHandler+0x10a>
      if ((wIstr & USB_ISTR_DIR) == 0)
 8001eda:	f8bd 1004 	ldrh.w	r1, [sp, #4]
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001ede:	8813      	ldrh	r3, [r2, #0]
      if ((wIstr & USB_ISTR_DIR) == 0)
 8001ee0:	f011 0110 	ands.w	r1, r1, #16
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001ee4:	b29b      	uxth	r3, r3
      if ((wIstr & USB_ISTR_DIR) == 0)
 8001ee6:	f000 80e0 	beq.w	80020aa <HAL_PCD_IRQHandler+0x29a>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 8001eea:	f8ad 3006 	strh.w	r3, [sp, #6]
        if ((wEPVal & USB_EP_SETUP) != 0U)
 8001eee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001ef2:	051d      	lsls	r5, r3, #20
 8001ef4:	f100 81a8 	bmi.w	8002248 <HAL_PCD_IRQHandler+0x438>
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8001ef8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001efc:	0418      	lsls	r0, r3, #16
 8001efe:	d45a      	bmi.n	8001fb6 <HAL_PCD_IRQHandler+0x1a6>
 8001f00:	4610      	mov	r0, r2
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0)
 8001f02:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8001f06:	b29b      	uxth	r3, r3
 8001f08:	f8ad 3004 	strh.w	r3, [sp, #4]
 8001f0c:	041b      	lsls	r3, r3, #16
 8001f0e:	d589      	bpl.n	8001e24 <HAL_PCD_IRQHandler+0x14>
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8001f10:	f8bd 5004 	ldrh.w	r5, [sp, #4]
    if (epindex == 0)
 8001f14:	f015 050f 	ands.w	r5, r5, #15
 8001f18:	d0df      	beq.n	8001eda <HAL_PCD_IRQHandler+0xca>
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 8001f1a:	f832 3025 	ldrh.w	r3, [r2, r5, lsl #2]
 8001f1e:	b29b      	uxth	r3, r3
 8001f20:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8001f24:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001f28:	0418      	lsls	r0, r3, #16
 8001f2a:	f100 8082 	bmi.w	8002032 <HAL_PCD_IRQHandler+0x222>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 8001f2e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8001f32:	0619      	lsls	r1, r3, #24
 8001f34:	d5e4      	bpl.n	8001f00 <HAL_PCD_IRQHandler+0xf0>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 8001f36:	f832 3025 	ldrh.w	r3, [r2, r5, lsl #2]
        
        /* IN double Buffering*/
        if (ep->doublebuffer == 0U)
 8001f3a:	eb04 1145 	add.w	r1, r4, r5, lsl #5
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 8001f3e:	b29b      	uxth	r3, r3
 8001f40:	4033      	ands	r3, r6
 8001f42:	f822 3025 	strh.w	r3, [r2, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 8001f46:	f891 3032 	ldrb.w	r3, [r1, #50]	; 0x32
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 8001f4a:	4610      	mov	r0, r2
        if (ep->doublebuffer == 0U)
 8001f4c:	ea4f 1945 	mov.w	r9, r5, lsl #5
 8001f50:	2b00      	cmp	r3, #0
 8001f52:	f040 80e8 	bne.w	8002126 <HAL_PCD_IRQHandler+0x316>
        {
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001f56:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8001f5a:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
 8001f5e:	b29b      	uxth	r3, r3
 8001f60:	3302      	adds	r3, #2
 8001f62:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8001f66:	f500 6c80 	add.w	ip, r0, #1024	; 0x400
 8001f6a:	f85c 3013 	ldr.w	r3, [ip, r3, lsl #1]
 8001f6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001f72:	644b      	str	r3, [r1, #68]	; 0x44
          if (ep->xfer_count != 0U)
 8001f74:	2b00      	cmp	r3, #0
 8001f76:	f040 8218 	bne.w	80023aa <HAL_PCD_IRQHandler+0x59a>
            }
          }
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
        }
        /*multi-packet on the NON control IN endpoint*/
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001f7a:	eb04 0209 	add.w	r2, r4, r9
 8001f7e:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8001f82:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
 8001f86:	b29b      	uxth	r3, r3
 8001f88:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8001f8c:	3302      	adds	r3, #2
 8001f8e:	f85c 3013 	ldr.w	r3, [ip, r3, lsl #1]
        ep->xfer_buff+=ep->xfer_count;
 8001f92:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001f94:	f3c3 0309 	ubfx	r3, r3, #0, #10
       
        /* Zero Length Packet? */
        if (ep->xfer_len == 0U)
 8001f98:	6c15      	ldr	r5, [r2, #64]	; 0x40
        ep->xfer_buff+=ep->xfer_count;
 8001f9a:	4419      	add	r1, r3
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8001f9c:	6453      	str	r3, [r2, #68]	; 0x44
        ep->xfer_buff+=ep->xfer_count;
 8001f9e:	63d1      	str	r1, [r2, #60]	; 0x3c
        if (ep->xfer_len == 0U)
 8001fa0:	2d00      	cmp	r5, #0
 8001fa2:	f040 80a8 	bne.w	80020f6 <HAL_PCD_IRQHandler+0x2e6>
        {
          /* TX COMPLETE */
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8001fa6:	4620      	mov	r0, r4
 8001fa8:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
 8001fac:	f002 ff3a 	bl	8004e24 <HAL_PCD_DataInStageCallback>
 8001fb0:	6822      	ldr	r2, [r4, #0]
 8001fb2:	4610      	mov	r0, r2
 8001fb4:	e7a5      	b.n	8001f02 <HAL_PCD_IRQHandler+0xf2>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8001fb6:	f640 738f 	movw	r3, #3983	; 0xf8f
 8001fba:	8811      	ldrh	r1, [r2, #0]
 8001fbc:	400b      	ands	r3, r1
 8001fbe:	8013      	strh	r3, [r2, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8001fc0:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8001fc4:	f894 1228 	ldrb.w	r1, [r4, #552]	; 0x228
 8001fc8:	b29b      	uxth	r3, r3
 8001fca:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8001fce:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8001fd2:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 8001fd6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8001fda:	f8c4 3244 	str.w	r3, [r4, #580]	; 0x244
          if (ep->xfer_count != 0U)
 8001fde:	2b00      	cmp	r3, #0
 8001fe0:	f040 81bb 	bne.w	800235a <HAL_PCD_IRQHandler+0x54a>
           HAL_PCD_DataOutStageCallback(hpcd, 0U);
 8001fe4:	2100      	movs	r1, #0
 8001fe6:	4620      	mov	r0, r4
 8001fe8:	f002 ff14 	bl	8004e14 <HAL_PCD_DataOutStageCallback>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 8001fec:	6822      	ldr	r2, [r4, #0]
 8001fee:	f8d4 1238 	ldr.w	r1, [r4, #568]	; 0x238
 8001ff2:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8001ff6:	293e      	cmp	r1, #62	; 0x3e
 8001ff8:	b29b      	uxth	r3, r3
 8001ffa:	4610      	mov	r0, r2
 8001ffc:	f103 0306 	add.w	r3, r3, #6
 8002000:	f502 6c80 	add.w	ip, r2, #1024	; 0x400
 8002004:	f200 8193 	bhi.w	800232e <HAL_PCD_IRQHandler+0x51e>
 8002008:	f3c1 054f 	ubfx	r5, r1, #1, #16
 800200c:	07c9      	lsls	r1, r1, #31
 800200e:	bf44      	itt	mi
 8002010:	3501      	addmi	r5, #1
 8002012:	b2ad      	uxthmi	r5, r5
 8002014:	02ad      	lsls	r5, r5, #10
 8002016:	b2ad      	uxth	r5, r5
 8002018:	f84c 5013 	str.w	r5, [ip, r3, lsl #1]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 800201c:	8813      	ldrh	r3, [r2, #0]
 800201e:	b29b      	uxth	r3, r3
 8002020:	403b      	ands	r3, r7
 8002022:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002026:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800202a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800202e:	8013      	strh	r3, [r2, #0]
 8002030:	e767      	b.n	8001f02 <HAL_PCD_IRQHandler+0xf2>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 8002032:	f640 738f 	movw	r3, #3983	; 0xf8f
 8002036:	f832 1025 	ldrh.w	r1, [r2, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 800203a:	eb04 1a45 	add.w	sl, r4, r5, lsl #5
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800203e:	400b      	ands	r3, r1
 8002040:	f822 3025 	strh.w	r3, [r2, r5, lsl #2]
        if (ep->doublebuffer == 0U)
 8002044:	f89a 3232 	ldrb.w	r3, [sl, #562]	; 0x232
 8002048:	ea4f 1945 	mov.w	r9, r5, lsl #5
 800204c:	2b00      	cmp	r3, #0
 800204e:	f040 811d 	bne.w	800228c <HAL_PCD_IRQHandler+0x47c>
          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002052:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8002056:	f89a 1228 	ldrb.w	r1, [sl, #552]	; 0x228
 800205a:	b29b      	uxth	r3, r3
 800205c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8002060:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8002064:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 8002068:	f3c3 0b09 	ubfx	fp, r3, #0, #10
          if (count != 0U)
 800206c:	f1bb 0f00 	cmp.w	fp, #0
 8002070:	f040 816a 	bne.w	8002348 <HAL_PCD_IRQHandler+0x538>
        ep->xfer_count+=count;
 8002074:	eb04 0309 	add.w	r3, r4, r9
 8002078:	f8d3 1244 	ldr.w	r1, [r3, #580]	; 0x244
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800207c:	e9d3 208f 	ldrd	r2, r0, [r3, #572]	; 0x23c
        ep->xfer_count+=count;
 8002080:	4459      	add	r1, fp
        ep->xfer_buff+=count;
 8002082:	445a      	add	r2, fp
        ep->xfer_count+=count;
 8002084:	f8c3 1244 	str.w	r1, [r3, #580]	; 0x244
        ep->xfer_buff+=count;
 8002088:	f8c3 223c 	str.w	r2, [r3, #572]	; 0x23c
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800208c:	b120      	cbz	r0, 8002098 <HAL_PCD_IRQHandler+0x288>
 800208e:	f8d3 1238 	ldr.w	r1, [r3, #568]	; 0x238
 8002092:	458b      	cmp	fp, r1
 8002094:	f080 8170 	bcs.w	8002378 <HAL_PCD_IRQHandler+0x568>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 8002098:	eb04 0209 	add.w	r2, r4, r9
 800209c:	f892 1228 	ldrb.w	r1, [r2, #552]	; 0x228
 80020a0:	4620      	mov	r0, r4
 80020a2:	f002 feb7 	bl	8004e14 <HAL_PCD_DataOutStageCallback>
 80020a6:	6822      	ldr	r2, [r4, #0]
 80020a8:	e741      	b.n	8001f2e <HAL_PCD_IRQHandler+0x11e>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 80020aa:	4033      	ands	r3, r6
 80020ac:	8013      	strh	r3, [r2, #0]
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80020ae:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 80020b2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80020b6:	b280      	uxth	r0, r0
 80020b8:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 80020bc:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 80020c0:	f8d0 3404 	ldr.w	r3, [r0, #1028]	; 0x404
        ep->xfer_buff += ep->xfer_count;
 80020c4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80020c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
        ep->xfer_buff += ep->xfer_count;
 80020ca:	441a      	add	r2, r3
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80020cc:	6463      	str	r3, [r4, #68]	; 0x44
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 80020ce:	4620      	mov	r0, r4
        ep->xfer_buff += ep->xfer_count;
 80020d0:	63e2      	str	r2, [r4, #60]	; 0x3c
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 80020d2:	f002 fea7 	bl	8004e24 <HAL_PCD_DataInStageCallback>
        if((hpcd->USB_Address > 0U)&& ( ep->xfer_len == 0U))
 80020d6:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80020da:	b313      	cbz	r3, 8002122 <HAL_PCD_IRQHandler+0x312>
 80020dc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80020de:	bb03      	cbnz	r3, 8002122 <HAL_PCD_IRQHandler+0x312>
          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
 80020e0:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
 80020e4:	6822      	ldr	r2, [r4, #0]
 80020e6:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80020ea:	f8a2 104c 	strh.w	r1, [r2, #76]	; 0x4c
 80020ee:	4610      	mov	r0, r2
          hpcd->USB_Address = 0U;
 80020f0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80020f4:	e705      	b.n	8001f02 <HAL_PCD_IRQHandler+0xf2>
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80020f6:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
  ep->xfer_count = 0U;
 80020fa:	f04f 0e00 	mov.w	lr, #0
 80020fe:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 8002102:	eb04 1342 	add.w	r3, r4, r2, lsl #5
  ep->is_in = 1U;
 8002106:	f04f 0c01 	mov.w	ip, #1
  ep->xfer_len = len;
 800210a:	e9c3 150f 	strd	r1, r5, [r3, #60]	; 0x3c
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800210e:	4619      	mov	r1, r3
  ep->num = ep_addr & 0x7FU;
 8002110:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    USB_EPStartXfer(hpcd->Instance , ep);
 8002114:	3128      	adds	r1, #40	; 0x28
  ep->xfer_count = 0U;
 8002116:	f8c3 e044 	str.w	lr, [r3, #68]	; 0x44
  ep->is_in = 1U;
 800211a:	f883 c029 	strb.w	ip, [r3, #41]	; 0x29
    USB_EPStartXfer(hpcd->Instance , ep);
 800211e:	f000 ff43 	bl	8002fa8 <USB_EPStartXfer>
 8002122:	6822      	ldr	r2, [r4, #0]
 8002124:	e6ec      	b.n	8001f00 <HAL_PCD_IRQHandler+0xf0>
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
 8002126:	f891 c028 	ldrb.w	ip, [r1, #40]	; 0x28
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800212a:	eb04 1545 	add.w	r5, r4, r5, lsl #5
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
 800212e:	f832 302c 	ldrh.w	r3, [r2, ip, lsl #2]
 8002132:	f013 0f40 	tst.w	r3, #64	; 0x40
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002136:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 800213a:	b29b      	uxth	r3, r3
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_TX)
 800213c:	f000 80c7 	beq.w	80022ce <HAL_PCD_IRQHandler+0x4be>
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002140:	3302      	adds	r3, #2
 8002142:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 8002146:	f502 6c80 	add.w	ip, r2, #1024	; 0x400
 800214a:	f85c 3013 	ldr.w	r3, [ip, r3, lsl #1]
 800214e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8002152:	646b      	str	r3, [r5, #68]	; 0x44
            if (ep->xfer_count != 0U)
 8002154:	2b00      	cmp	r3, #0
 8002156:	f000 80c6 	beq.w	80022e6 <HAL_PCD_IRQHandler+0x4d6>
              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
 800215a:	8dca      	ldrh	r2, [r1, #46]	; 0x2e
 800215c:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 800215e:	f001 f8bd 	bl	80032dc <USB_WritePMA>
 8002162:	6820      	ldr	r0, [r4, #0]
 8002164:	f500 6c80 	add.w	ip, r0, #1024	; 0x400
 8002168:	e0bd      	b.n	80022e6 <HAL_PCD_IRQHandler+0x4d6>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 800216a:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_SOFCallback(hpcd);
 800216c:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 800216e:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8002172:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002176:	041b      	lsls	r3, r3, #16
 8002178:	0c1b      	lsrs	r3, r3, #16
 800217a:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 800217e:	f002 fe59 	bl	8004e34 <HAL_PCD_SOFCallback>
 8002182:	e682      	b.n	8001e8a <HAL_PCD_IRQHandler+0x7a>
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 8002184:	6820      	ldr	r0, [r4, #0]
 8002186:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 800218a:	b29b      	uxth	r3, r3
 800218c:	f043 0308 	orr.w	r3, r3, #8
 8002190:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);  
 8002194:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8002198:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800219c:	041b      	lsls	r3, r3, #16
 800219e:	0c1b      	lsrs	r3, r3, #16
 80021a0:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
    hpcd->Instance->CNTR |= USB_CNTR_LP_MODE;
 80021a4:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 80021a8:	b29b      	uxth	r3, r3
 80021aa:	f043 0304 	orr.w	r3, r3, #4
 80021ae:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0U)
 80021b2:	f001 f88d 	bl	80032d0 <USB_ReadInterrupts>
 80021b6:	04c1      	lsls	r1, r0, #19
 80021b8:	f53f ae61 	bmi.w	8001e7e <HAL_PCD_IRQHandler+0x6e>
      HAL_PCD_SuspendCallback(hpcd);
 80021bc:	4620      	mov	r0, r4
 80021be:	f002 fe4f 	bl	8004e60 <HAL_PCD_SuspendCallback>
 80021c2:	e65c      	b.n	8001e7e <HAL_PCD_IRQHandler+0x6e>
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 80021c4:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_ResumeCallback(hpcd);
 80021c6:	4620      	mov	r0, r4
    hpcd->Instance->CNTR &= ~(USB_CNTR_LP_MODE);
 80021c8:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 80021cc:	f023 0304 	bic.w	r3, r3, #4
 80021d0:	041b      	lsls	r3, r3, #16
 80021d2:	0c1b      	lsrs	r3, r3, #16
 80021d4:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    hpcd->Instance->CNTR &= ~(USB_CNTR_FSUSP);
 80021d8:	f8b2 3040 	ldrh.w	r3, [r2, #64]	; 0x40
 80021dc:	f023 0308 	bic.w	r3, r3, #8
 80021e0:	041b      	lsls	r3, r3, #16
 80021e2:	0c1b      	lsrs	r3, r3, #16
 80021e4:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
    HAL_PCD_ResumeCallback(hpcd);
 80021e8:	f002 fe4a 	bl	8004e80 <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
 80021ec:	6820      	ldr	r0, [r4, #0]
 80021ee:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 80021f2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80021f6:	041b      	lsls	r3, r3, #16
 80021f8:	0c1b      	lsrs	r3, r3, #16
 80021fa:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80021fe:	e639      	b.n	8001e74 <HAL_PCD_IRQHandler+0x64>
 8002200:	ffff8f0f 	.word	0xffff8f0f
 8002204:	ffffbf8f 	.word	0xffffbf8f
 8002208:	ffff8000 	.word	0xffff8000
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800220c:	6822      	ldr	r2, [r4, #0]
    HAL_PCD_ResetCallback(hpcd);
 800220e:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8002210:	f8b2 3044 	ldrh.w	r3, [r2, #68]	; 0x44
 8002214:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002218:	041b      	lsls	r3, r3, #16
 800221a:	0c1b      	lsrs	r3, r3, #16
 800221c:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 8002220:	f002 fe0c 	bl	8004e3c <HAL_PCD_ResetCallback>
  __HAL_LOCK(hpcd);
 8002224:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
 8002228:	2b01      	cmp	r3, #1
 800222a:	f43f ae00 	beq.w	8001e2e <HAL_PCD_IRQHandler+0x1e>
  hpcd->USB_Address = address;
 800222e:	2500      	movs	r5, #0
  __HAL_LOCK(hpcd);
 8002230:	2301      	movs	r3, #1
  USB_SetDevAddress(hpcd->Instance, address);
 8002232:	4629      	mov	r1, r5
 8002234:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 8002236:	f884 3428 	strb.w	r3, [r4, #1064]	; 0x428
  hpcd->USB_Address = address;
 800223a:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
  USB_SetDevAddress(hpcd->Instance, address);
 800223e:	f001 f841 	bl	80032c4 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8002242:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
  return HAL_OK;
 8002246:	e5f2      	b.n	8001e2e <HAL_PCD_IRQHandler+0x1e>
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002248:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 800224c:	f894 1228 	ldrb.w	r1, [r4, #552]	; 0x228
 8002250:	b29b      	uxth	r3, r3
 8002252:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8002256:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800225a:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 800225e:	4610      	mov	r0, r2
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002260:	f3c3 0309 	ubfx	r3, r3, #0, #10
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 8002264:	f8b4 222c 	ldrh.w	r2, [r4, #556]	; 0x22c
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002268:	f8c4 3244 	str.w	r3, [r4, #580]	; 0x244
          USB_ReadPMA(hpcd->Instance, (uint8_t*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);       
 800226c:	f204 412c 	addw	r1, r4, #1068	; 0x42c
 8002270:	f001 f842 	bl	80032f8 <USB_ReadPMA>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8002274:	f640 738f 	movw	r3, #3983	; 0xf8f
 8002278:	6822      	ldr	r2, [r4, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 800227a:	4620      	mov	r0, r4
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 800227c:	8811      	ldrh	r1, [r2, #0]
 800227e:	400b      	ands	r3, r1
 8002280:	8013      	strh	r3, [r2, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 8002282:	f002 fdc1 	bl	8004e08 <HAL_PCD_SetupStageCallback>
 8002286:	6822      	ldr	r2, [r4, #0]
 8002288:	4610      	mov	r0, r2
 800228a:	e63a      	b.n	8001f02 <HAL_PCD_IRQHandler+0xf2>
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
 800228c:	f89a 3228 	ldrb.w	r3, [sl, #552]	; 0x228
 8002290:	f832 0023 	ldrh.w	r0, [r2, r3, lsl #2]
 8002294:	0099      	lsls	r1, r3, #2
 8002296:	f410 4f80 	tst.w	r0, #16384	; 0x4000
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800229a:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 800229e:	b280      	uxth	r0, r0
 80022a0:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 80022a4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
          if (PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX)
 80022a8:	d12d      	bne.n	8002306 <HAL_PCD_IRQHandler+0x4f6>
            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80022aa:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
 80022ae:	f3c3 0b09 	ubfx	fp, r3, #0, #10
            if (count != 0U)
 80022b2:	f1bb 0f00 	cmp.w	fp, #0
 80022b6:	f040 8088 	bne.w	80023ca <HAL_PCD_IRQHandler+0x5ba>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT);  
 80022ba:	f640 730f 	movw	r3, #3855	; 0xf0f
 80022be:	5a50      	ldrh	r0, [r2, r1]
 80022c0:	4003      	ands	r3, r0
 80022c2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80022c6:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80022ca:	5253      	strh	r3, [r2, r1]
 80022cc:	e6d2      	b.n	8002074 <HAL_PCD_IRQHandler+0x264>
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80022ce:	3306      	adds	r3, #6
 80022d0:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 80022d4:	f502 6c80 	add.w	ip, r2, #1024	; 0x400
 80022d8:	f85c 3013 	ldr.w	r3, [ip, r3, lsl #1]
 80022dc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80022e0:	646b      	str	r3, [r5, #68]	; 0x44
            if (ep->xfer_count != 0U)
 80022e2:	2b00      	cmp	r3, #0
 80022e4:	d169      	bne.n	80023ba <HAL_PCD_IRQHandler+0x5aa>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN);  
 80022e6:	f640 730f 	movw	r3, #3855	; 0xf0f
 80022ea:	eb04 0209 	add.w	r2, r4, r9
 80022ee:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 80022f2:	f830 1022 	ldrh.w	r1, [r0, r2, lsl #2]
 80022f6:	400b      	ands	r3, r1
 80022f8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80022fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002300:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8002304:	e639      	b.n	8001f7a <HAL_PCD_IRQHandler+0x16a>
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002306:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 800230a:	f3c3 0b09 	ubfx	fp, r3, #0, #10
            if (count != 0U)
 800230e:	f1bb 0f00 	cmp.w	fp, #0
 8002312:	d0d2      	beq.n	80022ba <HAL_PCD_IRQHandler+0x4aa>
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 8002314:	465b      	mov	r3, fp
 8002316:	4610      	mov	r0, r2
 8002318:	f8ba 222e 	ldrh.w	r2, [sl, #558]	; 0x22e
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800231c:	f8da 123c 	ldr.w	r1, [sl, #572]	; 0x23c
 8002320:	f000 ffea 	bl	80032f8 <USB_ReadPMA>
 8002324:	f89a 1228 	ldrb.w	r1, [sl, #552]	; 0x228
 8002328:	6822      	ldr	r2, [r4, #0]
 800232a:	0089      	lsls	r1, r1, #2
 800232c:	e7c5      	b.n	80022ba <HAL_PCD_IRQHandler+0x4aa>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800232e:	f3c1 154f 	ubfx	r5, r1, #5, #16
 8002332:	06c9      	lsls	r1, r1, #27
 8002334:	bf04      	itt	eq
 8002336:	f105 35ff 	addeq.w	r5, r5, #4294967295	; 0xffffffff
 800233a:	b2ad      	uxtheq	r5, r5
 800233c:	ea48 2585 	orr.w	r5, r8, r5, lsl #10
 8002340:	b2ad      	uxth	r5, r5
 8002342:	f84c 5013 	str.w	r5, [ip, r3, lsl #1]
 8002346:	e669      	b.n	800201c <HAL_PCD_IRQHandler+0x20c>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 8002348:	4610      	mov	r0, r2
 800234a:	465b      	mov	r3, fp
 800234c:	f8ba 222c 	ldrh.w	r2, [sl, #556]	; 0x22c
 8002350:	f8da 123c 	ldr.w	r1, [sl, #572]	; 0x23c
 8002354:	f000 ffd0 	bl	80032f8 <USB_ReadPMA>
 8002358:	e68c      	b.n	8002074 <HAL_PCD_IRQHandler+0x264>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 800235a:	4610      	mov	r0, r2
 800235c:	f8d4 123c 	ldr.w	r1, [r4, #572]	; 0x23c
 8002360:	f8b4 222c 	ldrh.w	r2, [r4, #556]	; 0x22c
 8002364:	f000 ffc8 	bl	80032f8 <USB_ReadPMA>
            ep->xfer_buff+=ep->xfer_count;
 8002368:	f8d4 323c 	ldr.w	r3, [r4, #572]	; 0x23c
 800236c:	f8d4 2244 	ldr.w	r2, [r4, #580]	; 0x244
 8002370:	4413      	add	r3, r2
 8002372:	f8c4 323c 	str.w	r3, [r4, #572]	; 0x23c
 8002376:	e635      	b.n	8001fe4 <HAL_PCD_IRQHandler+0x1d4>
  ep->xfer_count = 0U;
 8002378:	f04f 0e00 	mov.w	lr, #0
 800237c:	f893 c228 	ldrb.w	ip, [r3, #552]	; 0x228
 8002380:	f00c 0c7f 	and.w	ip, ip, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 8002384:	eb04 134c 	add.w	r3, r4, ip, lsl #5
 8002388:	f8c3 223c 	str.w	r2, [r3, #572]	; 0x23c
  ep->xfer_len = len;
 800238c:	f8c3 0240 	str.w	r0, [r3, #576]	; 0x240
  ep->num = ep_addr & 0x7FU;
 8002390:	f883 c228 	strb.w	ip, [r3, #552]	; 0x228
    USB_EPStartXfer(hpcd->Instance , ep);
 8002394:	6820      	ldr	r0, [r4, #0]
 8002396:	f503 710a 	add.w	r1, r3, #552	; 0x228
  ep->xfer_count = 0U;
 800239a:	f8c3 e244 	str.w	lr, [r3, #580]	; 0x244
  ep->is_in = 0U;
 800239e:	f883 e229 	strb.w	lr, [r3, #553]	; 0x229
    USB_EPStartXfer(hpcd->Instance , ep);
 80023a2:	f000 fe01 	bl	8002fa8 <USB_EPStartXfer>
 80023a6:	6822      	ldr	r2, [r4, #0]
 80023a8:	e5c1      	b.n	8001f2e <HAL_PCD_IRQHandler+0x11e>
            USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 80023aa:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 80023ac:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80023ae:	f000 ff95 	bl	80032dc <USB_WritePMA>
 80023b2:	6820      	ldr	r0, [r4, #0]
 80023b4:	f500 6c80 	add.w	ip, r0, #1024	; 0x400
 80023b8:	e5df      	b.n	8001f7a <HAL_PCD_IRQHandler+0x16a>
              USB_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80023ba:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
 80023bc:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80023be:	f000 ff8d 	bl	80032dc <USB_WritePMA>
 80023c2:	6820      	ldr	r0, [r4, #0]
 80023c4:	f500 6c80 	add.w	ip, r0, #1024	; 0x400
 80023c8:	e78d      	b.n	80022e6 <HAL_PCD_IRQHandler+0x4d6>
              USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 80023ca:	4610      	mov	r0, r2
 80023cc:	465b      	mov	r3, fp
 80023ce:	f8ba 2230 	ldrh.w	r2, [sl, #560]	; 0x230
 80023d2:	e7a3      	b.n	800231c <HAL_PCD_IRQHandler+0x50c>

080023d4 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 80023d4:	f890 2428 	ldrb.w	r2, [r0, #1064]	; 0x428
 80023d8:	2a01      	cmp	r2, #1
 80023da:	d00d      	beq.n	80023f8 <HAL_PCD_SetAddress+0x24>
 80023dc:	2201      	movs	r2, #1
{
 80023de:	b510      	push	{r4, lr}
 80023e0:	4604      	mov	r4, r0
  hpcd->USB_Address = address;
 80023e2:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
  __HAL_LOCK(hpcd);
 80023e6:	f880 2428 	strb.w	r2, [r0, #1064]	; 0x428
  USB_SetDevAddress(hpcd->Instance, address);
 80023ea:	6800      	ldr	r0, [r0, #0]
 80023ec:	f000 ff6a 	bl	80032c4 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 80023f0:	2000      	movs	r0, #0
 80023f2:	f884 0428 	strb.w	r0, [r4, #1064]	; 0x428
}
 80023f6:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 80023f8:	2002      	movs	r0, #2
}
 80023fa:	4770      	bx	lr

080023fc <HAL_PCD_EP_Open>:
{
 80023fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((ep_addr & 0x80U) == 0x80U)
 80023fe:	b24f      	sxtb	r7, r1
 8002400:	2f00      	cmp	r7, #0
{
 8002402:	460e      	mov	r6, r1
 8002404:	4605      	mov	r5, r0
  if ((ep_addr & 0x80U) == 0x80U)
 8002406:	db16      	blt.n	8002436 <HAL_PCD_EP_Open+0x3a>
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002408:	eb00 1441 	add.w	r4, r0, r1, lsl #5
 800240c:	f504 710a 	add.w	r1, r4, #552	; 0x228
  ep->is_in = (0x80U & ep_addr) != 0U;
 8002410:	0fff      	lsrs	r7, r7, #31
 8002412:	704f      	strb	r7, [r1, #1]
  ep->num   = ep_addr & 0x7FU;
 8002414:	700e      	strb	r6, [r1, #0]
  ep->maxpacket = ep_mps;
 8002416:	610a      	str	r2, [r1, #16]
  ep->type = ep_type;
 8002418:	70cb      	strb	r3, [r1, #3]
  __HAL_LOCK(hpcd);
 800241a:	f895 3428 	ldrb.w	r3, [r5, #1064]	; 0x428
 800241e:	2b01      	cmp	r3, #1
 8002420:	d010      	beq.n	8002444 <HAL_PCD_EP_Open+0x48>
 8002422:	2301      	movs	r3, #1
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8002424:	6828      	ldr	r0, [r5, #0]
  __HAL_LOCK(hpcd);
 8002426:	f885 3428 	strb.w	r3, [r5, #1064]	; 0x428
  USB_ActivateEndpoint(hpcd->Instance , ep);
 800242a:	f000 fc25 	bl	8002c78 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800242e:	2000      	movs	r0, #0
 8002430:	f885 0428 	strb.w	r0, [r5, #1064]	; 0x428
}
 8002434:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002436:	f001 067f 	and.w	r6, r1, #127	; 0x7f
 800243a:	eb00 1446 	add.w	r4, r0, r6, lsl #5
 800243e:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8002442:	e7e5      	b.n	8002410 <HAL_PCD_EP_Open+0x14>
  __HAL_LOCK(hpcd);
 8002444:	2002      	movs	r0, #2
}
 8002446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002448 <HAL_PCD_EP_Receive>:
{
 8002448:	b570      	push	{r4, r5, r6, lr}
  ep->xfer_count = 0U;
 800244a:	2600      	movs	r6, #0
 800244c:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 8002450:	eb00 1445 	add.w	r4, r0, r5, lsl #5
 8002454:	f8c4 223c 	str.w	r2, [r4, #572]	; 0x23c
    USB_EPStartXfer(hpcd->Instance , ep);
 8002458:	6800      	ldr	r0, [r0, #0]
  ep->xfer_len = len;
 800245a:	f8c4 3240 	str.w	r3, [r4, #576]	; 0x240
  ep->num = ep_addr & 0x7FU;
 800245e:	f884 5228 	strb.w	r5, [r4, #552]	; 0x228
    USB_EPStartXfer(hpcd->Instance , ep);
 8002462:	f504 710a 	add.w	r1, r4, #552	; 0x228
  ep->xfer_count = 0U;
 8002466:	f8c4 6244 	str.w	r6, [r4, #580]	; 0x244
  ep->is_in = 0U;
 800246a:	f884 6229 	strb.w	r6, [r4, #553]	; 0x229
    USB_EPStartXfer(hpcd->Instance , ep);
 800246e:	f000 fd9b 	bl	8002fa8 <USB_EPStartXfer>
}
 8002472:	4630      	mov	r0, r6
 8002474:	bd70      	pop	{r4, r5, r6, pc}
 8002476:	bf00      	nop

08002478 <HAL_PCD_EP_Transmit>:
{
 8002478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800247a:	f001 057f 	and.w	r5, r1, #127	; 0x7f
  ep->xfer_buff = pBuf;  
 800247e:	eb00 1445 	add.w	r4, r0, r5, lsl #5
  ep->xfer_count = 0U;
 8002482:	2600      	movs	r6, #0
  ep->is_in = 1U;
 8002484:	2701      	movs	r7, #1
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002486:	4621      	mov	r1, r4
    USB_EPStartXfer(hpcd->Instance , ep);
 8002488:	6800      	ldr	r0, [r0, #0]
  ep->xfer_len = len;
 800248a:	e9c4 230f 	strd	r2, r3, [r4, #60]	; 0x3c
  ep->num = ep_addr & 0x7FU;
 800248e:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
    USB_EPStartXfer(hpcd->Instance , ep);
 8002492:	3128      	adds	r1, #40	; 0x28
  ep->is_in = 1U;
 8002494:	f884 7029 	strb.w	r7, [r4, #41]	; 0x29
  ep->xfer_count = 0U;
 8002498:	6466      	str	r6, [r4, #68]	; 0x44
    USB_EPStartXfer(hpcd->Instance , ep);
 800249a:	f000 fd85 	bl	8002fa8 <USB_EPStartXfer>
}
 800249e:	4630      	mov	r0, r6
 80024a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80024a2:	bf00      	nop

080024a4 <HAL_PCD_EP_SetStall>:
{
 80024a4:	b538      	push	{r3, r4, r5, lr}
  if ((0x80U & ep_addr) == 0x80U)
 80024a6:	b24b      	sxtb	r3, r1
 80024a8:	2b00      	cmp	r3, #0
{
 80024aa:	460d      	mov	r5, r1
 80024ac:	4604      	mov	r4, r0
  if ((0x80U & ep_addr) == 0x80U)
 80024ae:	db16      	blt.n	80024de <HAL_PCD_EP_SetStall+0x3a>
    ep = &hpcd->OUT_ep[ep_addr];
 80024b0:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 80024b4:	f501 710a 	add.w	r1, r1, #552	; 0x228
  ep->is_stall = 1U;
 80024b8:	2201      	movs	r2, #1
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80024ba:	0fdb      	lsrs	r3, r3, #31
 80024bc:	704b      	strb	r3, [r1, #1]
  ep->num   = ep_addr & 0x7FU;
 80024be:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 80024c0:	708a      	strb	r2, [r1, #2]
  __HAL_LOCK(hpcd);
 80024c2:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
 80024c6:	4293      	cmp	r3, r2
 80024c8:	d015      	beq.n	80024f6 <HAL_PCD_EP_SetStall+0x52>
  USB_EPSetStall(hpcd->Instance , ep);
 80024ca:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd);
 80024cc:	f884 2428 	strb.w	r2, [r4, #1064]	; 0x428
  USB_EPSetStall(hpcd->Instance , ep);
 80024d0:	f000 fe6e 	bl	80031b0 <USB_EPSetStall>
  if((ep_addr & 0x7FU) == 0U)
 80024d4:	b14d      	cbz	r5, 80024ea <HAL_PCD_EP_SetStall+0x46>
  __HAL_UNLOCK(hpcd); 
 80024d6:	2000      	movs	r0, #0
 80024d8:	f884 0428 	strb.w	r0, [r4, #1064]	; 0x428
}
 80024dc:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80024de:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 80024e2:	eb00 1145 	add.w	r1, r0, r5, lsl #5
 80024e6:	3128      	adds	r1, #40	; 0x28
 80024e8:	e7e6      	b.n	80024b8 <HAL_PCD_EP_SetStall+0x14>
    USB_EP0_OutStart(hpcd->Instance, (uint8_t *)hpcd->Setup);
 80024ea:	6820      	ldr	r0, [r4, #0]
 80024ec:	f204 412c 	addw	r1, r4, #1068	; 0x42c
 80024f0:	f000 fef2 	bl	80032d8 <USB_EP0_OutStart>
 80024f4:	e7ef      	b.n	80024d6 <HAL_PCD_EP_SetStall+0x32>
  __HAL_LOCK(hpcd);
 80024f6:	2002      	movs	r0, #2
}
 80024f8:	bd38      	pop	{r3, r4, r5, pc}
 80024fa:	bf00      	nop

080024fc <HAL_PCD_EP_ClrStall>:
  if ((0x80U & ep_addr) == 0x80U)
 80024fc:	b24a      	sxtb	r2, r1
 80024fe:	2a00      	cmp	r2, #0
{
 8002500:	b538      	push	{r3, r4, r5, lr}
 8002502:	460b      	mov	r3, r1
 8002504:	4604      	mov	r4, r0
  if ((0x80U & ep_addr) == 0x80U)
 8002506:	db16      	blt.n	8002536 <HAL_PCD_EP_ClrStall+0x3a>
    ep = &hpcd->OUT_ep[ep_addr];
 8002508:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 800250c:	f501 710a 	add.w	r1, r1, #552	; 0x228
  ep->is_stall = 0U;
 8002510:	2500      	movs	r5, #0
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002512:	0fd2      	lsrs	r2, r2, #31
 8002514:	704a      	strb	r2, [r1, #1]
  ep->num   = ep_addr & 0x7FU;
 8002516:	700b      	strb	r3, [r1, #0]
  ep->is_stall = 0U;
 8002518:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd); 
 800251a:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
 800251e:	2b01      	cmp	r3, #1
 8002520:	d00f      	beq.n	8002542 <HAL_PCD_EP_ClrStall+0x46>
 8002522:	2301      	movs	r3, #1
  USB_EPClearStall(hpcd->Instance , ep);
 8002524:	6820      	ldr	r0, [r4, #0]
  __HAL_LOCK(hpcd); 
 8002526:	f884 3428 	strb.w	r3, [r4, #1064]	; 0x428
  USB_EPClearStall(hpcd->Instance , ep);
 800252a:	f000 fe7b 	bl	8003224 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 800252e:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
  return HAL_OK;
 8002532:	4628      	mov	r0, r5
}
 8002534:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002536:	f001 037f 	and.w	r3, r1, #127	; 0x7f
 800253a:	eb00 1143 	add.w	r1, r0, r3, lsl #5
 800253e:	3128      	adds	r1, #40	; 0x28
 8002540:	e7e6      	b.n	8002510 <HAL_PCD_EP_ClrStall+0x14>
  __HAL_LOCK(hpcd); 
 8002542:	2002      	movs	r0, #2
}
 8002544:	bd38      	pop	{r3, r4, r5, pc}
 8002546:	bf00      	nop

08002548 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800254c:	6803      	ldr	r3, [r0, #0]
{
 800254e:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002550:	07dd      	lsls	r5, r3, #31
{
 8002552:	b082      	sub	sp, #8
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002554:	d530      	bpl.n	80025b8 <HAL_RCC_OscConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
        
    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8002556:	49aa      	ldr	r1, [pc, #680]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002558:	684a      	ldr	r2, [r1, #4]
 800255a:	f002 020c 	and.w	r2, r2, #12
 800255e:	2a04      	cmp	r2, #4
 8002560:	f000 80d9 	beq.w	8002716 <HAL_RCC_OscConfig+0x1ce>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002564:	684a      	ldr	r2, [r1, #4]
 8002566:	f002 020c 	and.w	r2, r2, #12
 800256a:	2a08      	cmp	r2, #8
 800256c:	f000 80cf 	beq.w	800270e <HAL_RCC_OscConfig+0x1c6>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002570:	6863      	ldr	r3, [r4, #4]
 8002572:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002576:	f000 810e 	beq.w	8002796 <HAL_RCC_OscConfig+0x24e>
 800257a:	2b00      	cmp	r3, #0
 800257c:	f000 8126 	beq.w	80027cc <HAL_RCC_OscConfig+0x284>
 8002580:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002584:	f000 81b3 	beq.w	80028ee <HAL_RCC_OscConfig+0x3a6>
 8002588:	4b9d      	ldr	r3, [pc, #628]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 800258a:	681a      	ldr	r2, [r3, #0]
 800258c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002590:	601a      	str	r2, [r3, #0]
 8002592:	681a      	ldr	r2, [r3, #0]
 8002594:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002598:	601a      	str	r2, [r3, #0]

       /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800259a:	f7fe fb53 	bl	8000c44 <HAL_GetTick>
        
        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800259e:	4e98      	ldr	r6, [pc, #608]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
        tickstart = HAL_GetTick();
 80025a0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025a2:	e005      	b.n	80025b0 <HAL_RCC_OscConfig+0x68>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80025a4:	f7fe fb4e 	bl	8000c44 <HAL_GetTick>
 80025a8:	1b40      	subs	r0, r0, r5
 80025aa:	2864      	cmp	r0, #100	; 0x64
 80025ac:	f200 810a 	bhi.w	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80025b0:	6833      	ldr	r3, [r6, #0]
 80025b2:	039a      	lsls	r2, r3, #14
 80025b4:	d5f6      	bpl.n	80025a4 <HAL_RCC_OscConfig+0x5c>
 80025b6:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80025b8:	079f      	lsls	r7, r3, #30
 80025ba:	d528      	bpl.n	800260e <HAL_RCC_OscConfig+0xc6>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80025bc:	4a90      	ldr	r2, [pc, #576]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 80025be:	6851      	ldr	r1, [r2, #4]
 80025c0:	f011 0f0c 	tst.w	r1, #12
 80025c4:	f000 80b5 	beq.w	8002732 <HAL_RCC_OscConfig+0x1ea>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80025c8:	6851      	ldr	r1, [r2, #4]
 80025ca:	f001 010c 	and.w	r1, r1, #12
 80025ce:	2908      	cmp	r1, #8
 80025d0:	f000 80ab 	beq.w	800272a <HAL_RCC_OscConfig+0x1e2>
      }
    }
    else
    {
      /* Check the HSI State */
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80025d4:	6923      	ldr	r3, [r4, #16]
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	f000 813f 	beq.w	800285a <HAL_RCC_OscConfig+0x312>
      {
       /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80025dc:	2201      	movs	r2, #1
 80025de:	4b89      	ldr	r3, [pc, #548]	; (8002804 <HAL_RCC_OscConfig+0x2bc>)

        /* Get Start Tick */
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025e0:	4e87      	ldr	r6, [pc, #540]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
        __HAL_RCC_HSI_ENABLE();
 80025e2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80025e4:	f7fe fb2e 	bl	8000c44 <HAL_GetTick>
 80025e8:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025ea:	e005      	b.n	80025f8 <HAL_RCC_OscConfig+0xb0>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80025ec:	f7fe fb2a 	bl	8000c44 <HAL_GetTick>
 80025f0:	1b40      	subs	r0, r0, r5
 80025f2:	2802      	cmp	r0, #2
 80025f4:	f200 80e6 	bhi.w	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80025f8:	6833      	ldr	r3, [r6, #0]
 80025fa:	0798      	lsls	r0, r3, #30
 80025fc:	d5f6      	bpl.n	80025ec <HAL_RCC_OscConfig+0xa4>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80025fe:	6833      	ldr	r3, [r6, #0]
 8002600:	6962      	ldr	r2, [r4, #20]
 8002602:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002606:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800260a:	6033      	str	r3, [r6, #0]
 800260c:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800260e:	071a      	lsls	r2, r3, #28
 8002610:	d522      	bpl.n	8002658 <HAL_RCC_OscConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002612:	69a3      	ldr	r3, [r4, #24]
 8002614:	2b00      	cmp	r3, #0
 8002616:	f000 8097 	beq.w	8002748 <HAL_RCC_OscConfig+0x200>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800261a:	2201      	movs	r2, #1
 800261c:	4b7a      	ldr	r3, [pc, #488]	; (8002808 <HAL_RCC_OscConfig+0x2c0>)

      /* Get Start Tick */
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800261e:	4e78      	ldr	r6, [pc, #480]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
      __HAL_RCC_LSI_ENABLE();
 8002620:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002622:	f7fe fb0f 	bl	8000c44 <HAL_GetTick>
 8002626:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002628:	e005      	b.n	8002636 <HAL_RCC_OscConfig+0xee>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800262a:	f7fe fb0b 	bl	8000c44 <HAL_GetTick>
 800262e:	1b40      	subs	r0, r0, r5
 8002630:	2802      	cmp	r0, #2
 8002632:	f200 80c7 	bhi.w	80027c4 <HAL_RCC_OscConfig+0x27c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002636:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002638:	079b      	lsls	r3, r3, #30
 800263a:	d5f6      	bpl.n	800262a <HAL_RCC_OscConfig+0xe2>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800263c:	4b73      	ldr	r3, [pc, #460]	; (800280c <HAL_RCC_OscConfig+0x2c4>)
 800263e:	4a74      	ldr	r2, [pc, #464]	; (8002810 <HAL_RCC_OscConfig+0x2c8>)
 8002640:	681b      	ldr	r3, [r3, #0]
 8002642:	fba2 2303 	umull	r2, r3, r2, r3
 8002646:	0a5b      	lsrs	r3, r3, #9
 8002648:	9301      	str	r3, [sp, #4]
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 800264a:	bf00      	nop
  do 
  {
    __NOP();
  } 
  while (Delay --);
 800264c:	9b01      	ldr	r3, [sp, #4]
 800264e:	1e5a      	subs	r2, r3, #1
 8002650:	9201      	str	r2, [sp, #4]
 8002652:	2b00      	cmp	r3, #0
 8002654:	d1f9      	bne.n	800264a <HAL_RCC_OscConfig+0x102>
 8002656:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002658:	075d      	lsls	r5, r3, #29
 800265a:	d538      	bpl.n	80026ce <HAL_RCC_OscConfig+0x186>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800265c:	4b68      	ldr	r3, [pc, #416]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 800265e:	69da      	ldr	r2, [r3, #28]
 8002660:	00d0      	lsls	r0, r2, #3
 8002662:	f140 8081 	bpl.w	8002768 <HAL_RCC_OscConfig+0x220>
    FlagStatus       pwrclkchanged = RESET;
 8002666:	2500      	movs	r5, #0
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002668:	4b6a      	ldr	r3, [pc, #424]	; (8002814 <HAL_RCC_OscConfig+0x2cc>)
 800266a:	681a      	ldr	r2, [r3, #0]
 800266c:	05d1      	lsls	r1, r2, #23
 800266e:	f140 8098 	bpl.w	80027a2 <HAL_RCC_OscConfig+0x25a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002672:	68e3      	ldr	r3, [r4, #12]
 8002674:	2b01      	cmp	r3, #1
 8002676:	d00f      	beq.n	8002698 <HAL_RCC_OscConfig+0x150>
 8002678:	2b00      	cmp	r3, #0
 800267a:	f000 80cf 	beq.w	800281c <HAL_RCC_OscConfig+0x2d4>
 800267e:	2b05      	cmp	r3, #5
 8002680:	4b5f      	ldr	r3, [pc, #380]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002682:	6a1a      	ldr	r2, [r3, #32]
 8002684:	f000 80fa 	beq.w	800287c <HAL_RCC_OscConfig+0x334>
 8002688:	f022 0201 	bic.w	r2, r2, #1
 800268c:	621a      	str	r2, [r3, #32]
 800268e:	6a1a      	ldr	r2, [r3, #32]
 8002690:	f022 0204 	bic.w	r2, r2, #4
 8002694:	621a      	str	r2, [r3, #32]
 8002696:	e004      	b.n	80026a2 <HAL_RCC_OscConfig+0x15a>
 8002698:	4a59      	ldr	r2, [pc, #356]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 800269a:	6a13      	ldr	r3, [r2, #32]
 800269c:	f043 0301 	orr.w	r3, r3, #1
 80026a0:	6213      	str	r3, [r2, #32]
      tickstart = HAL_GetTick();
 80026a2:	f7fe facf 	bl	8000c44 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80026a6:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80026aa:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80026ac:	4f54      	ldr	r7, [pc, #336]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 80026ae:	e005      	b.n	80026bc <HAL_RCC_OscConfig+0x174>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80026b0:	f7fe fac8 	bl	8000c44 <HAL_GetTick>
 80026b4:	1b80      	subs	r0, r0, r6
 80026b6:	4540      	cmp	r0, r8
 80026b8:	f200 8084 	bhi.w	80027c4 <HAL_RCC_OscConfig+0x27c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80026bc:	6a3b      	ldr	r3, [r7, #32]
 80026be:	079b      	lsls	r3, r3, #30
 80026c0:	d5f6      	bpl.n	80026b0 <HAL_RCC_OscConfig+0x168>
    if(pwrclkchanged == SET)
 80026c2:	b125      	cbz	r5, 80026ce <HAL_RCC_OscConfig+0x186>
      __HAL_RCC_PWR_CLK_DISABLE();
 80026c4:	4a4e      	ldr	r2, [pc, #312]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 80026c6:	69d3      	ldr	r3, [r2, #28]
 80026c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80026cc:	61d3      	str	r3, [r2, #28]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80026ce:	69e3      	ldr	r3, [r4, #28]
 80026d0:	b1cb      	cbz	r3, 8002706 <HAL_RCC_OscConfig+0x1be>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80026d2:	4d4b      	ldr	r5, [pc, #300]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 80026d4:	686a      	ldr	r2, [r5, #4]
 80026d6:	f002 020c 	and.w	r2, r2, #12
 80026da:	2a08      	cmp	r2, #8
 80026dc:	d030      	beq.n	8002740 <HAL_RCC_OscConfig+0x1f8>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80026de:	2b02      	cmp	r3, #2
        __HAL_RCC_PLL_DISABLE();
 80026e0:	f04f 0200 	mov.w	r2, #0
 80026e4:	4b4c      	ldr	r3, [pc, #304]	; (8002818 <HAL_RCC_OscConfig+0x2d0>)
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80026e6:	f000 80d1 	beq.w	800288c <HAL_RCC_OscConfig+0x344>
        __HAL_RCC_PLL_DISABLE();
 80026ea:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80026ec:	f7fe faaa 	bl	8000c44 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80026f0:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80026f2:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80026f4:	e004      	b.n	8002700 <HAL_RCC_OscConfig+0x1b8>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80026f6:	f7fe faa5 	bl	8000c44 <HAL_GetTick>
 80026fa:	1b40      	subs	r0, r0, r5
 80026fc:	2802      	cmp	r0, #2
 80026fe:	d861      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002700:	6823      	ldr	r3, [r4, #0]
 8002702:	019b      	lsls	r3, r3, #6
 8002704:	d4f7      	bmi.n	80026f6 <HAL_RCC_OscConfig+0x1ae>
  return HAL_OK;
 8002706:	2000      	movs	r0, #0
}
 8002708:	b002      	add	sp, #8
 800270a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800270e:	684a      	ldr	r2, [r1, #4]
 8002710:	03d0      	lsls	r0, r2, #15
 8002712:	f57f af2d 	bpl.w	8002570 <HAL_RCC_OscConfig+0x28>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002716:	4a3a      	ldr	r2, [pc, #232]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002718:	6812      	ldr	r2, [r2, #0]
 800271a:	0391      	lsls	r1, r2, #14
 800271c:	f57f af4c 	bpl.w	80025b8 <HAL_RCC_OscConfig+0x70>
 8002720:	6862      	ldr	r2, [r4, #4]
 8002722:	2a00      	cmp	r2, #0
 8002724:	f47f af48 	bne.w	80025b8 <HAL_RCC_OscConfig+0x70>
 8002728:	e00a      	b.n	8002740 <HAL_RCC_OscConfig+0x1f8>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800272a:	6852      	ldr	r2, [r2, #4]
 800272c:	03d6      	lsls	r6, r2, #15
 800272e:	f53f af51 	bmi.w	80025d4 <HAL_RCC_OscConfig+0x8c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002732:	4a33      	ldr	r2, [pc, #204]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002734:	6812      	ldr	r2, [r2, #0]
 8002736:	0795      	lsls	r5, r2, #30
 8002738:	d521      	bpl.n	800277e <HAL_RCC_OscConfig+0x236>
 800273a:	6922      	ldr	r2, [r4, #16]
 800273c:	2a01      	cmp	r2, #1
 800273e:	d01e      	beq.n	800277e <HAL_RCC_OscConfig+0x236>
        return HAL_ERROR;
 8002740:	2001      	movs	r0, #1
}
 8002742:	b002      	add	sp, #8
 8002744:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8002748:	4a2f      	ldr	r2, [pc, #188]	; (8002808 <HAL_RCC_OscConfig+0x2c0>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800274a:	4e2d      	ldr	r6, [pc, #180]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
      __HAL_RCC_LSI_DISABLE();
 800274c:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 800274e:	f7fe fa79 	bl	8000c44 <HAL_GetTick>
 8002752:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002754:	e004      	b.n	8002760 <HAL_RCC_OscConfig+0x218>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002756:	f7fe fa75 	bl	8000c44 <HAL_GetTick>
 800275a:	1b40      	subs	r0, r0, r5
 800275c:	2802      	cmp	r0, #2
 800275e:	d831      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002760:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002762:	079f      	lsls	r7, r3, #30
 8002764:	d4f7      	bmi.n	8002756 <HAL_RCC_OscConfig+0x20e>
 8002766:	e776      	b.n	8002656 <HAL_RCC_OscConfig+0x10e>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002768:	69da      	ldr	r2, [r3, #28]
      pwrclkchanged = SET;
 800276a:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800276c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002770:	61da      	str	r2, [r3, #28]
 8002772:	69db      	ldr	r3, [r3, #28]
 8002774:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002778:	9300      	str	r3, [sp, #0]
 800277a:	9b00      	ldr	r3, [sp, #0]
      pwrclkchanged = SET;
 800277c:	e774      	b.n	8002668 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800277e:	4920      	ldr	r1, [pc, #128]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002780:	6960      	ldr	r0, [r4, #20]
 8002782:	680a      	ldr	r2, [r1, #0]
 8002784:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8002788:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800278c:	600a      	str	r2, [r1, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800278e:	071a      	lsls	r2, r3, #28
 8002790:	f57f af62 	bpl.w	8002658 <HAL_RCC_OscConfig+0x110>
 8002794:	e73d      	b.n	8002612 <HAL_RCC_OscConfig+0xca>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002796:	4a1a      	ldr	r2, [pc, #104]	; (8002800 <HAL_RCC_OscConfig+0x2b8>)
 8002798:	6813      	ldr	r3, [r2, #0]
 800279a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800279e:	6013      	str	r3, [r2, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80027a0:	e6fb      	b.n	800259a <HAL_RCC_OscConfig+0x52>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80027a2:	681a      	ldr	r2, [r3, #0]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80027a4:	461f      	mov	r7, r3
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80027a6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80027aa:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80027ac:	f7fe fa4a 	bl	8000c44 <HAL_GetTick>
 80027b0:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80027b2:	683b      	ldr	r3, [r7, #0]
 80027b4:	05da      	lsls	r2, r3, #23
 80027b6:	f53f af5c 	bmi.w	8002672 <HAL_RCC_OscConfig+0x12a>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80027ba:	f7fe fa43 	bl	8000c44 <HAL_GetTick>
 80027be:	1b80      	subs	r0, r0, r6
 80027c0:	2864      	cmp	r0, #100	; 0x64
 80027c2:	d9f6      	bls.n	80027b2 <HAL_RCC_OscConfig+0x26a>
            return HAL_TIMEOUT;
 80027c4:	2003      	movs	r0, #3
}
 80027c6:	b002      	add	sp, #8
 80027c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80027cc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80027d0:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80027d4:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80027d6:	461e      	mov	r6, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80027d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80027dc:	601a      	str	r2, [r3, #0]
 80027de:	681a      	ldr	r2, [r3, #0]
 80027e0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80027e4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80027e6:	f7fe fa2d 	bl	8000c44 <HAL_GetTick>
 80027ea:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80027ec:	e004      	b.n	80027f8 <HAL_RCC_OscConfig+0x2b0>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80027ee:	f7fe fa29 	bl	8000c44 <HAL_GetTick>
 80027f2:	1b40      	subs	r0, r0, r5
 80027f4:	2864      	cmp	r0, #100	; 0x64
 80027f6:	d8e5      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80027f8:	6833      	ldr	r3, [r6, #0]
 80027fa:	039b      	lsls	r3, r3, #14
 80027fc:	d4f7      	bmi.n	80027ee <HAL_RCC_OscConfig+0x2a6>
 80027fe:	e6da      	b.n	80025b6 <HAL_RCC_OscConfig+0x6e>
 8002800:	40021000 	.word	0x40021000
 8002804:	42420000 	.word	0x42420000
 8002808:	42420480 	.word	0x42420480
 800280c:	20000010 	.word	0x20000010
 8002810:	10624dd3 	.word	0x10624dd3
 8002814:	40007000 	.word	0x40007000
 8002818:	42420060 	.word	0x42420060
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800281c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002820:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8002824:	6a1a      	ldr	r2, [r3, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002826:	461f      	mov	r7, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002828:	f022 0201 	bic.w	r2, r2, #1
 800282c:	621a      	str	r2, [r3, #32]
 800282e:	6a1a      	ldr	r2, [r3, #32]
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002830:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002834:	f022 0204 	bic.w	r2, r2, #4
 8002838:	621a      	str	r2, [r3, #32]
      tickstart = HAL_GetTick();
 800283a:	f7fe fa03 	bl	8000c44 <HAL_GetTick>
 800283e:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002840:	e004      	b.n	800284c <HAL_RCC_OscConfig+0x304>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002842:	f7fe f9ff 	bl	8000c44 <HAL_GetTick>
 8002846:	1b80      	subs	r0, r0, r6
 8002848:	4540      	cmp	r0, r8
 800284a:	d8bb      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800284c:	6a3b      	ldr	r3, [r7, #32]
 800284e:	0798      	lsls	r0, r3, #30
 8002850:	d4f7      	bmi.n	8002842 <HAL_RCC_OscConfig+0x2fa>
    if(pwrclkchanged == SET)
 8002852:	2d00      	cmp	r5, #0
 8002854:	f43f af3b 	beq.w	80026ce <HAL_RCC_OscConfig+0x186>
 8002858:	e734      	b.n	80026c4 <HAL_RCC_OscConfig+0x17c>
        __HAL_RCC_HSI_DISABLE();
 800285a:	4a2b      	ldr	r2, [pc, #172]	; (8002908 <HAL_RCC_OscConfig+0x3c0>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800285c:	4e2b      	ldr	r6, [pc, #172]	; (800290c <HAL_RCC_OscConfig+0x3c4>)
        __HAL_RCC_HSI_DISABLE();
 800285e:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002860:	f7fe f9f0 	bl	8000c44 <HAL_GetTick>
 8002864:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002866:	e004      	b.n	8002872 <HAL_RCC_OscConfig+0x32a>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002868:	f7fe f9ec 	bl	8000c44 <HAL_GetTick>
 800286c:	1b40      	subs	r0, r0, r5
 800286e:	2802      	cmp	r0, #2
 8002870:	d8a8      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002872:	6833      	ldr	r3, [r6, #0]
 8002874:	0799      	lsls	r1, r3, #30
 8002876:	d4f7      	bmi.n	8002868 <HAL_RCC_OscConfig+0x320>
 8002878:	6823      	ldr	r3, [r4, #0]
 800287a:	e6c8      	b.n	800260e <HAL_RCC_OscConfig+0xc6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800287c:	f042 0204 	orr.w	r2, r2, #4
 8002880:	621a      	str	r2, [r3, #32]
 8002882:	6a1a      	ldr	r2, [r3, #32]
 8002884:	f042 0201 	orr.w	r2, r2, #1
 8002888:	621a      	str	r2, [r3, #32]
 800288a:	e70a      	b.n	80026a2 <HAL_RCC_OscConfig+0x15a>
        __HAL_RCC_PLL_DISABLE();
 800288c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800288e:	f7fe f9d9 	bl	8000c44 <HAL_GetTick>
 8002892:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002894:	e004      	b.n	80028a0 <HAL_RCC_OscConfig+0x358>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002896:	f7fe f9d5 	bl	8000c44 <HAL_GetTick>
 800289a:	1b80      	subs	r0, r0, r6
 800289c:	2802      	cmp	r0, #2
 800289e:	d891      	bhi.n	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80028a0:	682b      	ldr	r3, [r5, #0]
 80028a2:	0199      	lsls	r1, r3, #6
 80028a4:	d4f7      	bmi.n	8002896 <HAL_RCC_OscConfig+0x34e>
        if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 80028a6:	6a23      	ldr	r3, [r4, #32]
 80028a8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80028ac:	d105      	bne.n	80028ba <HAL_RCC_OscConfig+0x372>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 80028ae:	686a      	ldr	r2, [r5, #4]
 80028b0:	68a1      	ldr	r1, [r4, #8]
 80028b2:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80028b6:	430a      	orrs	r2, r1
 80028b8:	606a      	str	r2, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80028ba:	2001      	movs	r0, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80028bc:	4d13      	ldr	r5, [pc, #76]	; (800290c <HAL_RCC_OscConfig+0x3c4>)
 80028be:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80028c0:	686a      	ldr	r2, [r5, #4]
 80028c2:	430b      	orrs	r3, r1
 80028c4:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
        __HAL_RCC_PLL_ENABLE();
 80028c8:	4911      	ldr	r1, [pc, #68]	; (8002910 <HAL_RCC_OscConfig+0x3c8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80028ca:	4313      	orrs	r3, r2
 80028cc:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80028ce:	6008      	str	r0, [r1, #0]
        tickstart = HAL_GetTick();
 80028d0:	f7fe f9b8 	bl	8000c44 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80028d4:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80028d6:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80028d8:	e005      	b.n	80028e6 <HAL_RCC_OscConfig+0x39e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80028da:	f7fe f9b3 	bl	8000c44 <HAL_GetTick>
 80028de:	1b40      	subs	r0, r0, r5
 80028e0:	2802      	cmp	r0, #2
 80028e2:	f63f af6f 	bhi.w	80027c4 <HAL_RCC_OscConfig+0x27c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80028e6:	6823      	ldr	r3, [r4, #0]
 80028e8:	019a      	lsls	r2, r3, #6
 80028ea:	d5f6      	bpl.n	80028da <HAL_RCC_OscConfig+0x392>
 80028ec:	e70b      	b.n	8002706 <HAL_RCC_OscConfig+0x1be>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80028ee:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80028f2:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 80028f6:	681a      	ldr	r2, [r3, #0]
 80028f8:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80028fc:	601a      	str	r2, [r3, #0]
 80028fe:	681a      	ldr	r2, [r3, #0]
 8002900:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002904:	601a      	str	r2, [r3, #0]
 8002906:	e648      	b.n	800259a <HAL_RCC_OscConfig+0x52>
 8002908:	42420000 	.word	0x42420000
 800290c:	40021000 	.word	0x40021000
 8002910:	42420060 	.word	0x42420060

08002914 <HAL_RCC_ClockConfig>:
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002914:	4a6a      	ldr	r2, [pc, #424]	; (8002ac0 <HAL_RCC_ClockConfig+0x1ac>)
{
 8002916:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800291a:	6813      	ldr	r3, [r2, #0]
{
 800291c:	460c      	mov	r4, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800291e:	f003 0307 	and.w	r3, r3, #7
 8002922:	428b      	cmp	r3, r1
{
 8002924:	4605      	mov	r5, r0
 8002926:	b086      	sub	sp, #24
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002928:	d20d      	bcs.n	8002946 <HAL_RCC_ClockConfig+0x32>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800292a:	6813      	ldr	r3, [r2, #0]
 800292c:	f023 0307 	bic.w	r3, r3, #7
 8002930:	430b      	orrs	r3, r1
 8002932:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002934:	6813      	ldr	r3, [r2, #0]
 8002936:	f003 0307 	and.w	r3, r3, #7
 800293a:	428b      	cmp	r3, r1
 800293c:	d003      	beq.n	8002946 <HAL_RCC_ClockConfig+0x32>
      return HAL_ERROR;
 800293e:	2001      	movs	r0, #1
}
 8002940:	b006      	add	sp, #24
 8002942:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002946:	682b      	ldr	r3, [r5, #0]
 8002948:	0798      	lsls	r0, r3, #30
 800294a:	d514      	bpl.n	8002976 <HAL_RCC_ClockConfig+0x62>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800294c:	0759      	lsls	r1, r3, #29
 800294e:	d504      	bpl.n	800295a <HAL_RCC_ClockConfig+0x46>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002950:	495c      	ldr	r1, [pc, #368]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 8002952:	684a      	ldr	r2, [r1, #4]
 8002954:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 8002958:	604a      	str	r2, [r1, #4]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800295a:	071a      	lsls	r2, r3, #28
 800295c:	d504      	bpl.n	8002968 <HAL_RCC_ClockConfig+0x54>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800295e:	4959      	ldr	r1, [pc, #356]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 8002960:	684a      	ldr	r2, [r1, #4]
 8002962:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 8002966:	604a      	str	r2, [r1, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002968:	4956      	ldr	r1, [pc, #344]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 800296a:	68a8      	ldr	r0, [r5, #8]
 800296c:	684a      	ldr	r2, [r1, #4]
 800296e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002972:	4302      	orrs	r2, r0
 8002974:	604a      	str	r2, [r1, #4]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002976:	07db      	lsls	r3, r3, #31
 8002978:	d524      	bpl.n	80029c4 <HAL_RCC_ClockConfig+0xb0>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800297a:	686a      	ldr	r2, [r5, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800297c:	4b51      	ldr	r3, [pc, #324]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800297e:	2a01      	cmp	r2, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002980:	681b      	ldr	r3, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002982:	f000 8090 	beq.w	8002aa6 <HAL_RCC_ClockConfig+0x192>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002986:	2a02      	cmp	r2, #2
 8002988:	f000 8089 	beq.w	8002a9e <HAL_RCC_ClockConfig+0x18a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800298c:	0798      	lsls	r0, r3, #30
 800298e:	d5d6      	bpl.n	800293e <HAL_RCC_ClockConfig+0x2a>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002990:	4e4c      	ldr	r6, [pc, #304]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002992:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002996:	6873      	ldr	r3, [r6, #4]
 8002998:	f023 0303 	bic.w	r3, r3, #3
 800299c:	4313      	orrs	r3, r2
 800299e:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 80029a0:	f7fe f950 	bl	8000c44 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80029a4:	686b      	ldr	r3, [r5, #4]
    tickstart = HAL_GetTick();
 80029a6:	4607      	mov	r7, r0
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80029a8:	2b01      	cmp	r3, #1
 80029aa:	d067      	beq.n	8002a7c <HAL_RCC_ClockConfig+0x168>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80029ac:	2b02      	cmp	r3, #2
 80029ae:	d105      	bne.n	80029bc <HAL_RCC_ClockConfig+0xa8>
 80029b0:	e06f      	b.n	8002a92 <HAL_RCC_ClockConfig+0x17e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80029b2:	f7fe f947 	bl	8000c44 <HAL_GetTick>
 80029b6:	1bc3      	subs	r3, r0, r7
 80029b8:	4543      	cmp	r3, r8
 80029ba:	d878      	bhi.n	8002aae <HAL_RCC_ClockConfig+0x19a>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80029bc:	6873      	ldr	r3, [r6, #4]
 80029be:	f013 0f0c 	tst.w	r3, #12
 80029c2:	d1f6      	bne.n	80029b2 <HAL_RCC_ClockConfig+0x9e>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80029c4:	4a3e      	ldr	r2, [pc, #248]	; (8002ac0 <HAL_RCC_ClockConfig+0x1ac>)
 80029c6:	6813      	ldr	r3, [r2, #0]
 80029c8:	f003 0307 	and.w	r3, r3, #7
 80029cc:	42a3      	cmp	r3, r4
 80029ce:	d909      	bls.n	80029e4 <HAL_RCC_ClockConfig+0xd0>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80029d0:	6813      	ldr	r3, [r2, #0]
 80029d2:	f023 0307 	bic.w	r3, r3, #7
 80029d6:	4323      	orrs	r3, r4
 80029d8:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80029da:	6813      	ldr	r3, [r2, #0]
 80029dc:	f003 0307 	and.w	r3, r3, #7
 80029e0:	42a3      	cmp	r3, r4
 80029e2:	d1ac      	bne.n	800293e <HAL_RCC_ClockConfig+0x2a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80029e4:	682b      	ldr	r3, [r5, #0]
 80029e6:	0759      	lsls	r1, r3, #29
 80029e8:	d506      	bpl.n	80029f8 <HAL_RCC_ClockConfig+0xe4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80029ea:	4936      	ldr	r1, [pc, #216]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 80029ec:	68e8      	ldr	r0, [r5, #12]
 80029ee:	684a      	ldr	r2, [r1, #4]
 80029f0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 80029f4:	4302      	orrs	r2, r0
 80029f6:	604a      	str	r2, [r1, #4]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80029f8:	071a      	lsls	r2, r3, #28
 80029fa:	d507      	bpl.n	8002a0c <HAL_RCC_ClockConfig+0xf8>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80029fc:	4a31      	ldr	r2, [pc, #196]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 80029fe:	6929      	ldr	r1, [r5, #16]
 8002a00:	6853      	ldr	r3, [r2, #4]
 8002a02:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002a06:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002a0a:	6053      	str	r3, [r2, #4]
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002a0c:	f240 2201 	movw	r2, #513	; 0x201
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8002a10:	4b2d      	ldr	r3, [pc, #180]	; (8002ac8 <HAL_RCC_ClockConfig+0x1b4>)
 8002a12:	ac06      	add	r4, sp, #24
  const uint8_t aPredivFactorTable[2] = {1, 2};
 8002a14:	f8ad 2004 	strh.w	r2, [sp, #4]
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8002a18:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002a1a:	e904 000f 	stmdb	r4, {r0, r1, r2, r3}
  tmpreg = RCC->CFGR;
 8002a1e:	4929      	ldr	r1, [pc, #164]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 8002a20:	684a      	ldr	r2, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8002a22:	f002 030c 	and.w	r3, r2, #12
 8002a26:	2b08      	cmp	r3, #8
 8002a28:	d010      	beq.n	8002a4c <HAL_RCC_ClockConfig+0x138>
      sysclockfreq = HSE_VALUE;
 8002a2a:	4b28      	ldr	r3, [pc, #160]	; (8002acc <HAL_RCC_ClockConfig+0x1b8>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002a2c:	4a25      	ldr	r2, [pc, #148]	; (8002ac4 <HAL_RCC_ClockConfig+0x1b0>)
 8002a2e:	4828      	ldr	r0, [pc, #160]	; (8002ad0 <HAL_RCC_ClockConfig+0x1bc>)
 8002a30:	6852      	ldr	r2, [r2, #4]
 8002a32:	4928      	ldr	r1, [pc, #160]	; (8002ad4 <HAL_RCC_ClockConfig+0x1c0>)
 8002a34:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8002a38:	5c82      	ldrb	r2, [r0, r2]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002a3a:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002a3c:	40d3      	lsrs	r3, r2
 8002a3e:	600b      	str	r3, [r1, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002a40:	f7fe f8ca 	bl	8000bd8 <HAL_InitTick>
  return HAL_OK;
 8002a44:	2000      	movs	r0, #0
}
 8002a46:	b006      	add	sp, #24
 8002a48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8002a4c:	f3c2 4383 	ubfx	r3, r2, #18, #4
 8002a50:	4423      	add	r3, r4
 8002a52:	f813 0c10 	ldrb.w	r0, [r3, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8002a56:	03d3      	lsls	r3, r2, #15
 8002a58:	d52d      	bpl.n	8002ab6 <HAL_RCC_ClockConfig+0x1a2>
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002a5a:	684a      	ldr	r2, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8002a5c:	4b1b      	ldr	r3, [pc, #108]	; (8002acc <HAL_RCC_ClockConfig+0x1b8>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002a5e:	f3c2 4240 	ubfx	r2, r2, #17, #1
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8002a62:	fb03 f300 	mul.w	r3, r3, r0
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002a66:	4422      	add	r2, r4
 8002a68:	f812 2c14 	ldrb.w	r2, [r2, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8002a6c:	fbb3 f3f2 	udiv	r3, r3, r2
 8002a70:	e7dc      	b.n	8002a2c <HAL_RCC_ClockConfig+0x118>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a72:	f7fe f8e7 	bl	8000c44 <HAL_GetTick>
 8002a76:	1bc0      	subs	r0, r0, r7
 8002a78:	4540      	cmp	r0, r8
 8002a7a:	d818      	bhi.n	8002aae <HAL_RCC_ClockConfig+0x19a>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002a7c:	6873      	ldr	r3, [r6, #4]
 8002a7e:	f003 030c 	and.w	r3, r3, #12
 8002a82:	2b04      	cmp	r3, #4
 8002a84:	d1f5      	bne.n	8002a72 <HAL_RCC_ClockConfig+0x15e>
 8002a86:	e79d      	b.n	80029c4 <HAL_RCC_ClockConfig+0xb0>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002a88:	f7fe f8dc 	bl	8000c44 <HAL_GetTick>
 8002a8c:	1bc0      	subs	r0, r0, r7
 8002a8e:	4540      	cmp	r0, r8
 8002a90:	d80d      	bhi.n	8002aae <HAL_RCC_ClockConfig+0x19a>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002a92:	6873      	ldr	r3, [r6, #4]
 8002a94:	f003 030c 	and.w	r3, r3, #12
 8002a98:	2b08      	cmp	r3, #8
 8002a9a:	d1f5      	bne.n	8002a88 <HAL_RCC_ClockConfig+0x174>
 8002a9c:	e792      	b.n	80029c4 <HAL_RCC_ClockConfig+0xb0>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002a9e:	019e      	lsls	r6, r3, #6
 8002aa0:	f53f af76 	bmi.w	8002990 <HAL_RCC_ClockConfig+0x7c>
 8002aa4:	e74b      	b.n	800293e <HAL_RCC_ClockConfig+0x2a>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002aa6:	039f      	lsls	r7, r3, #14
 8002aa8:	f53f af72 	bmi.w	8002990 <HAL_RCC_ClockConfig+0x7c>
 8002aac:	e747      	b.n	800293e <HAL_RCC_ClockConfig+0x2a>
          return HAL_TIMEOUT;
 8002aae:	2003      	movs	r0, #3
}
 8002ab0:	b006      	add	sp, #24
 8002ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8002ab6:	4b08      	ldr	r3, [pc, #32]	; (8002ad8 <HAL_RCC_ClockConfig+0x1c4>)
 8002ab8:	fb03 f300 	mul.w	r3, r3, r0
 8002abc:	e7b6      	b.n	8002a2c <HAL_RCC_ClockConfig+0x118>
 8002abe:	bf00      	nop
 8002ac0:	40022000 	.word	0x40022000
 8002ac4:	40021000 	.word	0x40021000
 8002ac8:	08014884 	.word	0x08014884
 8002acc:	007a1200 	.word	0x007a1200
 8002ad0:	080148ec 	.word	0x080148ec
 8002ad4:	20000010 	.word	0x20000010
 8002ad8:	003d0900 	.word	0x003d0900

08002adc <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002adc:	4b04      	ldr	r3, [pc, #16]	; (8002af0 <HAL_RCC_GetPCLK2Freq+0x14>)
 8002ade:	4905      	ldr	r1, [pc, #20]	; (8002af4 <HAL_RCC_GetPCLK2Freq+0x18>)
 8002ae0:	685b      	ldr	r3, [r3, #4]
  return SystemCoreClock;
 8002ae2:	4a05      	ldr	r2, [pc, #20]	; (8002af8 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002ae4:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8002ae8:	5ccb      	ldrb	r3, [r1, r3]
 8002aea:	6810      	ldr	r0, [r2, #0]
} 
 8002aec:	40d8      	lsrs	r0, r3
 8002aee:	4770      	bx	lr
 8002af0:	40021000 	.word	0x40021000
 8002af4:	080148fc 	.word	0x080148fc
 8002af8:	20000010 	.word	0x20000010

08002afc <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002afc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002b00:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*------------------------------- RTC/LCD Configuration ------------------------*/ 
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8002b02:	6800      	ldr	r0, [r0, #0]
{
 8002b04:	b082      	sub	sp, #8
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8002b06:	07c3      	lsls	r3, r0, #31
 8002b08:	d52a      	bpl.n	8002b60 <HAL_RCCEx_PeriphCLKConfig+0x64>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002b0a:	4b39      	ldr	r3, [pc, #228]	; (8002bf0 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8002b0c:	69da      	ldr	r2, [r3, #28]
 8002b0e:	00d7      	lsls	r7, r2, #3
 8002b10:	d53d      	bpl.n	8002b8e <HAL_RCCEx_PeriphCLKConfig+0x92>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002b12:	4b38      	ldr	r3, [pc, #224]	; (8002bf4 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
    FlagStatus       pwrclkchanged = RESET;
 8002b14:	2500      	movs	r5, #0
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002b16:	681a      	ldr	r2, [r3, #0]
 8002b18:	05d6      	lsls	r6, r2, #23
 8002b1a:	d546      	bpl.n	8002baa <HAL_RCCEx_PeriphCLKConfig+0xae>
        }
      }
    }
      
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002b1c:	4e34      	ldr	r6, [pc, #208]	; (8002bf0 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8002b1e:	6a33      	ldr	r3, [r6, #32]
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002b20:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8002b24:	d00f      	beq.n	8002b46 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8002b26:	6861      	ldr	r1, [r4, #4]
 8002b28:	f401 7240 	and.w	r2, r1, #768	; 0x300
 8002b2c:	429a      	cmp	r2, r3
 8002b2e:	d00b      	beq.n	8002b48 <HAL_RCCEx_PeriphCLKConfig+0x4c>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8002b30:	2701      	movs	r7, #1
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002b32:	2000      	movs	r0, #0
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002b34:	6a33      	ldr	r3, [r6, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 8002b36:	4a30      	ldr	r2, [pc, #192]	; (8002bf8 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002b38:	f423 7140 	bic.w	r1, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002b3c:	6017      	str	r7, [r2, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002b3e:	6010      	str	r0, [r2, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 8002b40:	6231      	str	r1, [r6, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8002b42:	07d9      	lsls	r1, r3, #31
 8002b44:	d445      	bmi.n	8002bd2 <HAL_RCCEx_PeriphCLKConfig+0xd6>
 8002b46:	6861      	ldr	r1, [r4, #4]
            return HAL_TIMEOUT;
          }      
        }  
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 8002b48:	4a29      	ldr	r2, [pc, #164]	; (8002bf0 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8002b4a:	6a13      	ldr	r3, [r2, #32]
 8002b4c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002b50:	430b      	orrs	r3, r1
 8002b52:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8002b54:	b11d      	cbz	r5, 8002b5e <HAL_RCCEx_PeriphCLKConfig+0x62>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8002b56:	69d3      	ldr	r3, [r2, #28]
 8002b58:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002b5c:	61d3      	str	r3, [r2, #28]
 8002b5e:	6820      	ldr	r0, [r4, #0]
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8002b60:	0783      	lsls	r3, r0, #30
 8002b62:	d506      	bpl.n	8002b72 <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
    
    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002b64:	4922      	ldr	r1, [pc, #136]	; (8002bf0 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8002b66:	68a3      	ldr	r3, [r4, #8]
 8002b68:	684a      	ldr	r2, [r1, #4]
 8002b6a:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002b6e:	431a      	orrs	r2, r3
 8002b70:	604a      	str	r2, [r1, #4]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8002b72:	f010 0010 	ands.w	r0, r0, #16
 8002b76:	d007      	beq.n	8002b88 <HAL_RCCEx_PeriphCLKConfig+0x8c>
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 8002b78:	2000      	movs	r0, #0
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002b7a:	4a1d      	ldr	r2, [pc, #116]	; (8002bf0 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 8002b7c:	68e1      	ldr	r1, [r4, #12]
 8002b7e:	6853      	ldr	r3, [r2, #4]
 8002b80:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8002b84:	430b      	orrs	r3, r1
 8002b86:	6053      	str	r3, [r2, #4]
}
 8002b88:	b002      	add	sp, #8
 8002b8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8002b8e:	69da      	ldr	r2, [r3, #28]
      pwrclkchanged = SET;
 8002b90:	2501      	movs	r5, #1
    __HAL_RCC_PWR_CLK_ENABLE();
 8002b92:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002b96:	61da      	str	r2, [r3, #28]
 8002b98:	69db      	ldr	r3, [r3, #28]
 8002b9a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002b9e:	9301      	str	r3, [sp, #4]
 8002ba0:	9b01      	ldr	r3, [sp, #4]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002ba2:	4b14      	ldr	r3, [pc, #80]	; (8002bf4 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002ba4:	681a      	ldr	r2, [r3, #0]
 8002ba6:	05d6      	lsls	r6, r2, #23
 8002ba8:	d4b8      	bmi.n	8002b1c <HAL_RCCEx_PeriphCLKConfig+0x20>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002baa:	681a      	ldr	r2, [r3, #0]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002bac:	461f      	mov	r7, r3
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002bae:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002bb2:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002bb4:	f7fe f846 	bl	8000c44 <HAL_GetTick>
 8002bb8:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002bba:	683b      	ldr	r3, [r7, #0]
 8002bbc:	05d8      	lsls	r0, r3, #23
 8002bbe:	d4ad      	bmi.n	8002b1c <HAL_RCCEx_PeriphCLKConfig+0x20>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002bc0:	f7fe f840 	bl	8000c44 <HAL_GetTick>
 8002bc4:	1b83      	subs	r3, r0, r6
 8002bc6:	2b64      	cmp	r3, #100	; 0x64
 8002bc8:	d9f7      	bls.n	8002bba <HAL_RCCEx_PeriphCLKConfig+0xbe>
          return HAL_TIMEOUT;
 8002bca:	2003      	movs	r0, #3
}
 8002bcc:	b002      	add	sp, #8
 8002bce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        tickstart = HAL_GetTick();
 8002bd2:	f7fe f837 	bl	8000c44 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002bd6:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8002bda:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002bdc:	e004      	b.n	8002be8 <HAL_RCCEx_PeriphCLKConfig+0xec>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002bde:	f7fe f831 	bl	8000c44 <HAL_GetTick>
 8002be2:	1bc0      	subs	r0, r0, r7
 8002be4:	4540      	cmp	r0, r8
 8002be6:	d8f0      	bhi.n	8002bca <HAL_RCCEx_PeriphCLKConfig+0xce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002be8:	6a33      	ldr	r3, [r6, #32]
 8002bea:	079a      	lsls	r2, r3, #30
 8002bec:	d5f7      	bpl.n	8002bde <HAL_RCCEx_PeriphCLKConfig+0xe2>
 8002bee:	e7aa      	b.n	8002b46 <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8002bf0:	40021000 	.word	0x40021000
 8002bf4:	40007000 	.word	0x40007000
 8002bf8:	42420440 	.word	0x42420440

08002bfc <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0U;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002bfc:	4a1d      	ldr	r2, [pc, #116]	; (8002c74 <TIM_Base_SetConfig+0x78>)
  tmpcr1 = TIMx->CR1;
 8002bfe:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002c00:	4290      	cmp	r0, r2
 8002c02:	d021      	beq.n	8002c48 <TIM_Base_SetConfig+0x4c>
 8002c04:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
{
 8002c08:	b430      	push	{r4, r5}
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002c0a:	d014      	beq.n	8002c36 <TIM_Base_SetConfig+0x3a>
 8002c0c:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8002c10:	4290      	cmp	r0, r2
 8002c12:	d010      	beq.n	8002c36 <TIM_Base_SetConfig+0x3a>
 8002c14:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8002c18:	4290      	cmp	r0, r2
 8002c1a:	d00c      	beq.n	8002c36 <TIM_Base_SetConfig+0x3a>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  tmpcr1 &= ~TIM_CR1_ARPE;
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8002c1c:	694d      	ldr	r5, [r1, #20]
  tmpcr1 &= ~TIM_CR1_ARPE;
 8002c1e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8002c22:	432b      	orrs	r3, r5

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002c24:	688c      	ldr	r4, [r1, #8]

  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002c26:	680a      	ldr	r2, [r1, #0]
  TIMx->CR1 = tmpcr1;
 8002c28:	6003      	str	r3, [r0, #0]
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8002c2a:	2301      	movs	r3, #1
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002c2c:	62c4      	str	r4, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002c2e:	6282      	str	r2, [r0, #40]	; 0x28
}
 8002c30:	bc30      	pop	{r4, r5}
  TIMx->EGR = TIM_EGR_UG;
 8002c32:	6143      	str	r3, [r0, #20]
}
 8002c34:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8002c36:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002c38:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002c3c:	4313      	orrs	r3, r2
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002c3e:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8002c40:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002c44:	4313      	orrs	r3, r2
 8002c46:	e7e9      	b.n	8002c1c <TIM_Base_SetConfig+0x20>
    tmpcr1 |= Structure->CounterMode;
 8002c48:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002c4a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002c4e:	4313      	orrs	r3, r2
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002c50:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8002c52:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002c56:	4313      	orrs	r3, r2
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8002c58:	694a      	ldr	r2, [r1, #20]
  tmpcr1 &= ~TIM_CR1_ARPE;
 8002c5a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 8002c5e:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8002c60:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002c62:	688b      	ldr	r3, [r1, #8]
 8002c64:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002c66:	680b      	ldr	r3, [r1, #0]
 8002c68:	6283      	str	r3, [r0, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8002c6a:	690b      	ldr	r3, [r1, #16]
 8002c6c:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8002c6e:	2301      	movs	r3, #1
 8002c70:	6143      	str	r3, [r0, #20]
 8002c72:	4770      	bx	lr
 8002c74:	40012c00 	.word	0x40012c00

08002c78 <USB_ActivateEndpoint>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  /* initialize Endpoint */
  switch (ep->type)
 8002c78:	78cb      	ldrb	r3, [r1, #3]
{
 8002c7a:	b470      	push	{r4, r5, r6}
 8002c7c:	2b03      	cmp	r3, #3
 8002c7e:	d812      	bhi.n	8002ca6 <USB_ActivateEndpoint+0x2e>
 8002c80:	e8df f013 	tbh	[pc, r3, lsl #1]
 8002c84:	015a0004 	.word	0x015a0004
 8002c88:	014c0168 	.word	0x014c0168
  {
  case EP_TYPE_CTRL:
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_CONTROL);
 8002c8c:	780a      	ldrb	r2, [r1, #0]
 8002c8e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002c92:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8002c96:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002c9a:	041b      	lsls	r3, r3, #16
 8002c9c:	0c1b      	lsrs	r3, r3, #16
 8002c9e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002ca2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
  default:
      break;
  } 
  
  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 8002ca6:	f640 720f 	movw	r2, #3855	; 0xf0f
 8002caa:	780c      	ldrb	r4, [r1, #0]
 8002cac:	f830 3024 	ldrh.w	r3, [r0, r4, lsl #2]
 8002cb0:	4013      	ands	r3, r2
 8002cb2:	4323      	orrs	r3, r4
 8002cb4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002cb8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002cbc:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
  
  if (ep->doublebuffer == 0) 
 8002cc0:	7a8b      	ldrb	r3, [r1, #10]
 8002cc2:	bb4b      	cbnz	r3, 8002d18 <USB_ActivateEndpoint+0xa0>
  {
    if (ep->is_in)
 8002cc4:	784b      	ldrb	r3, [r1, #1]
 8002cc6:	2b00      	cmp	r3, #0
 8002cc8:	f000 80e0 	beq.w	8002e8c <USB_ActivateEndpoint+0x214>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8002ccc:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002cd0:	780d      	ldrb	r5, [r1, #0]
 8002cd2:	888c      	ldrh	r4, [r1, #4]
 8002cd4:	b29b      	uxth	r3, r3
 8002cd6:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8002cda:	0864      	lsrs	r4, r4, #1
 8002cdc:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002ce0:	0064      	lsls	r4, r4, #1
 8002ce2:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002ce6:	780b      	ldrb	r3, [r1, #0]
 8002ce8:	f830 5023 	ldrh.w	r5, [r0, r3, lsl #2]
 8002cec:	eb00 0483 	add.w	r4, r0, r3, lsl #2
 8002cf0:	066d      	lsls	r5, r5, #25
 8002cf2:	f100 813b 	bmi.w	8002f6c <USB_ActivateEndpoint+0x2f4>
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK); 
 8002cf6:	8823      	ldrh	r3, [r4, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
    }
  }
  
  return HAL_OK;
}
 8002cf8:	2000      	movs	r0, #0
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK); 
 8002cfa:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002cfe:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002d02:	041b      	lsls	r3, r3, #16
 8002d04:	0c1b      	lsrs	r3, r3, #16
 8002d06:	f083 0320 	eor.w	r3, r3, #32
 8002d0a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002d0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d12:	8023      	strh	r3, [r4, #0]
}
 8002d14:	bc70      	pop	{r4, r5, r6}
 8002d16:	4770      	bx	lr
    PCD_SET_EP_DBUF(USBx, ep->num);
 8002d18:	f640 630f 	movw	r3, #3599	; 0xe0f
 8002d1c:	780c      	ldrb	r4, [r1, #0]
 8002d1e:	f500 6580 	add.w	r5, r0, #1024	; 0x400
 8002d22:	f830 6024 	ldrh.w	r6, [r0, r4, lsl #2]
 8002d26:	4033      	ands	r3, r6
 8002d28:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8002d2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002d30:	f820 3024 	strh.w	r3, [r0, r4, lsl #2]
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num,ep->pmaaddr0, ep->pmaaddr1);
 8002d34:	f8b0 4050 	ldrh.w	r4, [r0, #80]	; 0x50
 8002d38:	88ce      	ldrh	r6, [r1, #6]
 8002d3a:	780b      	ldrb	r3, [r1, #0]
 8002d3c:	b2a4      	uxth	r4, r4
 8002d3e:	0876      	lsrs	r6, r6, #1
 8002d40:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 8002d44:	0076      	lsls	r6, r6, #1
 8002d46:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002d4a:	f845 6014 	str.w	r6, [r5, r4, lsl #1]
 8002d4e:	890c      	ldrh	r4, [r1, #8]
 8002d50:	780e      	ldrb	r6, [r1, #0]
 8002d52:	b29b      	uxth	r3, r3
 8002d54:	3304      	adds	r3, #4
 8002d56:	0864      	lsrs	r4, r4, #1
 8002d58:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8002d5c:	0064      	lsls	r4, r4, #1
 8002d5e:	f845 4013 	str.w	r4, [r5, r3, lsl #1]
    if (ep->is_in==0)
 8002d62:	784b      	ldrb	r3, [r1, #1]
 8002d64:	2b00      	cmp	r3, #0
 8002d66:	d149      	bne.n	8002dfc <USB_ActivateEndpoint+0x184>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002d68:	780b      	ldrb	r3, [r1, #0]
 8002d6a:	f830 5023 	ldrh.w	r5, [r0, r3, lsl #2]
 8002d6e:	eb00 0483 	add.w	r4, r0, r3, lsl #2
 8002d72:	046d      	lsls	r5, r5, #17
 8002d74:	d50b      	bpl.n	8002d8e <USB_ActivateEndpoint+0x116>
 8002d76:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8002d7a:	4022      	ands	r2, r4
 8002d7c:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002d80:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002d84:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 8002d88:	780c      	ldrb	r4, [r1, #0]
 8002d8a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002d8e:	8823      	ldrh	r3, [r4, #0]
 8002d90:	065e      	lsls	r6, r3, #25
 8002d92:	d50b      	bpl.n	8002dac <USB_ActivateEndpoint+0x134>
 8002d94:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002d98:	8822      	ldrh	r2, [r4, #0]
 8002d9a:	4013      	ands	r3, r2
 8002d9c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002da0:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002da4:	8023      	strh	r3, [r4, #0]
 8002da6:	780c      	ldrb	r4, [r1, #0]
 8002da8:	eb00 0484 	add.w	r4, r0, r4, lsl #2
      PCD_TX_DTOG(USBx, ep->num);
 8002dac:	f640 720f 	movw	r2, #3855	; 0xf0f
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002db0:	f248 0580 	movw	r5, #32896	; 0x8080
      PCD_TX_DTOG(USBx, ep->num);
 8002db4:	8823      	ldrh	r3, [r4, #0]
 8002db6:	401a      	ands	r2, r3
 8002db8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002dbc:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8002dc0:	8022      	strh	r2, [r4, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002dc2:	780a      	ldrb	r2, [r1, #0]
 8002dc4:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002dc8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002dcc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002dd0:	041b      	lsls	r3, r3, #16
 8002dd2:	0c1b      	lsrs	r3, r3, #16
 8002dd4:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002dd8:	432b      	orrs	r3, r5
 8002dda:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8002dde:	780a      	ldrb	r2, [r1, #0]
 8002de0:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002de4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002de8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002dec:	041b      	lsls	r3, r3, #16
 8002dee:	0c1b      	lsrs	r3, r3, #16
 8002df0:	432b      	orrs	r3, r5
 8002df2:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8002df6:	bc70      	pop	{r4, r5, r6}
 8002df8:	2000      	movs	r0, #0
 8002dfa:	4770      	bx	lr
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002dfc:	780b      	ldrb	r3, [r1, #0]
 8002dfe:	f830 5023 	ldrh.w	r5, [r0, r3, lsl #2]
 8002e02:	eb00 0483 	add.w	r4, r0, r3, lsl #2
 8002e06:	046d      	lsls	r5, r5, #17
 8002e08:	d50b      	bpl.n	8002e22 <USB_ActivateEndpoint+0x1aa>
 8002e0a:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8002e0e:	4022      	ands	r2, r4
 8002e10:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002e14:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002e18:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 8002e1c:	780c      	ldrb	r4, [r1, #0]
 8002e1e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002e22:	8823      	ldrh	r3, [r4, #0]
 8002e24:	065b      	lsls	r3, r3, #25
 8002e26:	d50b      	bpl.n	8002e40 <USB_ActivateEndpoint+0x1c8>
 8002e28:	f640 730f 	movw	r3, #3855	; 0xf0f
 8002e2c:	8822      	ldrh	r2, [r4, #0]
 8002e2e:	4013      	ands	r3, r2
 8002e30:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002e34:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002e38:	8023      	strh	r3, [r4, #0]
 8002e3a:	780c      	ldrb	r4, [r1, #0]
 8002e3c:	eb00 0484 	add.w	r4, r0, r4, lsl #2
      PCD_RX_DTOG(USBx, ep->num);
 8002e40:	f640 720f 	movw	r2, #3855	; 0xf0f
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8002e44:	f248 0580 	movw	r5, #32896	; 0x8080
      PCD_RX_DTOG(USBx, ep->num);
 8002e48:	8823      	ldrh	r3, [r4, #0]
 8002e4a:	401a      	ands	r2, r3
 8002e4c:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002e50:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002e54:	8022      	strh	r2, [r4, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 8002e56:	780a      	ldrb	r2, [r1, #0]
 8002e58:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002e5c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8002e60:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8002e64:	041b      	lsls	r3, r3, #16
 8002e66:	0c1b      	lsrs	r3, r3, #16
 8002e68:	432b      	orrs	r3, r5
 8002e6a:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 8002e6e:	780a      	ldrb	r2, [r1, #0]
 8002e70:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002e74:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002e78:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002e7c:	041b      	lsls	r3, r3, #16
 8002e7e:	0c1b      	lsrs	r3, r3, #16
 8002e80:	432b      	orrs	r3, r5
 8002e82:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8002e86:	bc70      	pop	{r4, r5, r6}
 8002e88:	2000      	movs	r0, #0
 8002e8a:	4770      	bx	lr
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8002e8c:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002e90:	888c      	ldrh	r4, [r1, #4]
 8002e92:	780b      	ldrb	r3, [r1, #0]
 8002e94:	b292      	uxth	r2, r2
 8002e96:	3204      	adds	r2, #4
 8002e98:	0864      	lsrs	r4, r4, #1
 8002e9a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8002e9e:	0064      	lsls	r4, r4, #1
 8002ea0:	f500 6580 	add.w	r5, r0, #1024	; 0x400
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8002ea4:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 8002ea8:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8002eac:	690a      	ldr	r2, [r1, #16]
 8002eae:	780c      	ldrb	r4, [r1, #0]
 8002eb0:	b29b      	uxth	r3, r3
 8002eb2:	3306      	adds	r3, #6
 8002eb4:	2a3e      	cmp	r2, #62	; 0x3e
 8002eb6:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8002eba:	d864      	bhi.n	8002f86 <USB_ActivateEndpoint+0x30e>
 8002ebc:	f3c2 044f 	ubfx	r4, r2, #1, #16
 8002ec0:	07d2      	lsls	r2, r2, #31
 8002ec2:	bf44      	itt	mi
 8002ec4:	3401      	addmi	r4, #1
 8002ec6:	b2a4      	uxthmi	r4, r4
 8002ec8:	02a4      	lsls	r4, r4, #10
 8002eca:	b2a4      	uxth	r4, r4
 8002ecc:	f845 4013 	str.w	r4, [r5, r3, lsl #1]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 8002ed0:	780b      	ldrb	r3, [r1, #0]
 8002ed2:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8002ed6:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8002eda:	0466      	lsls	r6, r4, #17
 8002edc:	d50d      	bpl.n	8002efa <USB_ActivateEndpoint+0x282>
 8002ede:	f640 720f 	movw	r2, #3855	; 0xf0f
 8002ee2:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8002ee6:	4022      	ands	r2, r4
 8002ee8:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002eec:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002ef0:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 8002ef4:	780a      	ldrb	r2, [r1, #0]
 8002ef6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002efa:	8813      	ldrh	r3, [r2, #0]
}
 8002efc:	2000      	movs	r0, #0
 8002efe:	bc70      	pop	{r4, r5, r6}
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002f00:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002f04:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002f08:	041b      	lsls	r3, r3, #16
 8002f0a:	0c1b      	lsrs	r3, r3, #16
 8002f0c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002f10:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002f14:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002f18:	8013      	strh	r3, [r2, #0]
}
 8002f1a:	4770      	bx	lr
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_INTERRUPT);
 8002f1c:	780a      	ldrb	r2, [r1, #0]
 8002f1e:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002f22:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8002f26:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002f2a:	041b      	lsls	r3, r3, #16
 8002f2c:	0c1b      	lsrs	r3, r3, #16
 8002f2e:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
 8002f32:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 8002f36:	e6b6      	b.n	8002ca6 <USB_ActivateEndpoint+0x2e>
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_ISOCHRONOUS);
 8002f38:	780a      	ldrb	r2, [r1, #0]
 8002f3a:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002f3e:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8002f42:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002f46:	041b      	lsls	r3, r3, #16
 8002f48:	0c1b      	lsrs	r3, r3, #16
 8002f4a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002f4e:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 8002f52:	e6a8      	b.n	8002ca6 <USB_ActivateEndpoint+0x2e>
    PCD_SET_EPTYPE(USBx, ep->num, USB_EP_BULK);
 8002f54:	780a      	ldrb	r2, [r1, #0]
 8002f56:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002f5a:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8002f5e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002f62:	041b      	lsls	r3, r3, #16
 8002f64:	0c1b      	lsrs	r3, r3, #16
 8002f66:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    break;
 8002f6a:	e69c      	b.n	8002ca6 <USB_ActivateEndpoint+0x2e>
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 8002f6c:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8002f70:	4022      	ands	r2, r4
 8002f72:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002f76:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8002f7a:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 8002f7e:	780c      	ldrb	r4, [r1, #0]
 8002f80:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 8002f84:	e6b7      	b.n	8002cf6 <USB_ActivateEndpoint+0x7e>
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 8002f86:	f3c2 144f 	ubfx	r4, r2, #5, #16
 8002f8a:	06d6      	lsls	r6, r2, #27
 8002f8c:	bf04      	itt	eq
 8002f8e:	f104 32ff 	addeq.w	r2, r4, #4294967295	; 0xffffffff
 8002f92:	b294      	uxtheq	r4, r2
 8002f94:	4a03      	ldr	r2, [pc, #12]	; (8002fa4 <USB_ActivateEndpoint+0x32c>)
 8002f96:	ea42 2284 	orr.w	r2, r2, r4, lsl #10
 8002f9a:	b292      	uxth	r2, r2
 8002f9c:	f845 2013 	str.w	r2, [r5, r3, lsl #1]
 8002fa0:	e796      	b.n	8002ed0 <USB_ActivateEndpoint+0x258>
 8002fa2:	bf00      	nop
 8002fa4:	ffff8000 	.word	0xffff8000

08002fa8 <USB_EPStartXfer>:
{
  uint16_t pmabuffer = 0;
  uint32_t len = ep->xfer_len;
  
  /* IN endpoint */
  if (ep->is_in == 1)
 8002fa8:	784a      	ldrb	r2, [r1, #1]
{
 8002faa:	b4f0      	push	{r4, r5, r6, r7}
  if (ep->is_in == 1)
 8002fac:	2a01      	cmp	r2, #1
  uint32_t len = ep->xfer_len;
 8002fae:	698b      	ldr	r3, [r1, #24]
  if (ep->is_in == 1)
 8002fb0:	d05e      	beq.n	8003070 <USB_EPStartXfer+0xc8>
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
  }
  else /* OUT endpoint */
  {
    /* Multi packet transfer*/
    if (ep->xfer_len > ep->maxpacket)
 8002fb2:	690c      	ldr	r4, [r1, #16]
 8002fb4:	429c      	cmp	r4, r3
      ep->xfer_len-=len; 
    }
    else
    {
      len=ep->xfer_len;
      ep->xfer_len =0;
 8002fb6:	bf2e      	itee	cs
 8002fb8:	2500      	movcs	r5, #0
      ep->xfer_len-=len; 
 8002fba:	1b1d      	subcc	r5, r3, r4
 8002fbc:	4623      	movcc	r3, r4
    }
    
    /* configure and validate Rx endpoint */
    if (ep->doublebuffer == 0) 
 8002fbe:	7a8c      	ldrb	r4, [r1, #10]
 8002fc0:	618d      	str	r5, [r1, #24]
 8002fc2:	bb64      	cbnz	r4, 800301e <USB_EPStartXfer+0x76>
    {
      /*Set RX buffer count*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8002fc4:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8002fc8:	780c      	ldrb	r4, [r1, #0]
 8002fca:	b292      	uxth	r2, r2
 8002fcc:	3206      	adds	r2, #6
 8002fce:	2b3e      	cmp	r3, #62	; 0x3e
 8002fd0:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8002fd4:	f500 6580 	add.w	r5, r0, #1024	; 0x400
 8002fd8:	f240 80b2 	bls.w	8003140 <USB_EPStartXfer+0x198>
 8002fdc:	f3c3 144f 	ubfx	r4, r3, #5, #16
 8002fe0:	06de      	lsls	r6, r3, #27
 8002fe2:	bf04      	itt	eq
 8002fe4:	f104 33ff 	addeq.w	r3, r4, #4294967295	; 0xffffffff
 8002fe8:	b29c      	uxtheq	r4, r3
 8002fea:	4b70      	ldr	r3, [pc, #448]	; (80031ac <USB_EPStartXfer+0x204>)
 8002fec:	ea43 2384 	orr.w	r3, r3, r4, lsl #10
 8002ff0:	b29b      	uxth	r3, r3
 8002ff2:	f845 3012 	str.w	r3, [r5, r2, lsl #1]
    {
      /*Set the Double buffer counter*/
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
    }
    
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002ff6:	780a      	ldrb	r2, [r1, #0]
  }
  
  return HAL_OK;
}
 8002ff8:	bcf0      	pop	{r4, r5, r6, r7}
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8002ffa:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8002ffe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003002:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003006:	041b      	lsls	r3, r3, #16
 8003008:	0c1b      	lsrs	r3, r3, #16
 800300a:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800300e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003012:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003016:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 800301a:	2000      	movs	r0, #0
 800301c:	4770      	bx	lr
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 800301e:	2a00      	cmp	r2, #0
 8003020:	d1e9      	bne.n	8002ff6 <USB_EPStartXfer+0x4e>
 8003022:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 8003026:	780c      	ldrb	r4, [r1, #0]
 8003028:	b292      	uxth	r2, r2
 800302a:	3202      	adds	r2, #2
 800302c:	2b3e      	cmp	r3, #62	; 0x3e
 800302e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8003032:	f500 6580 	add.w	r5, r0, #1024	; 0x400
 8003036:	f240 809d 	bls.w	8003174 <USB_EPStartXfer+0x1cc>
 800303a:	f3c3 164f 	ubfx	r6, r3, #5, #16
 800303e:	06df      	lsls	r7, r3, #27
 8003040:	bf04      	itt	eq
 8003042:	f106 34ff 	addeq.w	r4, r6, #4294967295	; 0xffffffff
 8003046:	b2a6      	uxtheq	r6, r4
 8003048:	4c58      	ldr	r4, [pc, #352]	; (80031ac <USB_EPStartXfer+0x204>)
 800304a:	ea44 2486 	orr.w	r4, r4, r6, lsl #10
 800304e:	b2a4      	uxth	r4, r4
 8003050:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
 8003054:	784a      	ldrb	r2, [r1, #1]
 8003056:	2a00      	cmp	r2, #0
 8003058:	f040 809a 	bne.w	8003190 <USB_EPStartXfer+0x1e8>
 800305c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8003060:	780a      	ldrb	r2, [r1, #0]
 8003062:	b29b      	uxth	r3, r3
 8003064:	3306      	adds	r3, #6
 8003066:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800306a:	f845 4013 	str.w	r4, [r5, r3, lsl #1]
 800306e:	e7c2      	b.n	8002ff6 <USB_EPStartXfer+0x4e>
    if (ep->xfer_len > ep->maxpacket)
 8003070:	690a      	ldr	r2, [r1, #16]
 8003072:	429a      	cmp	r2, r3
      ep->xfer_len =0;
 8003074:	bf2e      	itee	cs
 8003076:	2400      	movcs	r4, #0
      ep->xfer_len-=len; 
 8003078:	1a9c      	subcc	r4, r3, r2
 800307a:	4613      	movcc	r3, r2
    if (ep->doublebuffer == 0) 
 800307c:	7a8a      	ldrb	r2, [r1, #10]
 800307e:	618c      	str	r4, [r1, #24]
 8003080:	b9ca      	cbnz	r2, 80030b6 <USB_EPStartXfer+0x10e>
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8003082:	b29a      	uxth	r2, r3
  uint32_t index = 0, temp1 = 0, temp2 = 0;
  uint16_t *pdwVal = NULL;
  
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8003084:	888c      	ldrh	r4, [r1, #4]
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 8003086:	3201      	adds	r2, #1
 8003088:	f500 6780 	add.w	r7, r0, #1024	; 0x400
  for (index = nbytes; index != 0; index--)
 800308c:	1052      	asrs	r2, r2, #1
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, len);
 800308e:	694d      	ldr	r5, [r1, #20]
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8003090:	eb07 0444 	add.w	r4, r7, r4, lsl #1
  for (index = nbytes; index != 0; index--)
 8003094:	d005      	beq.n	80030a2 <USB_EPStartXfer+0xfa>
  {
    temp1 = (uint16_t) * pbUsrBuf;
 8003096:	f835 6b02 	ldrh.w	r6, [r5], #2
  for (index = nbytes; index != 0; index--)
 800309a:	3a01      	subs	r2, #1
    pbUsrBuf++;
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
    *pdwVal++ = temp2;
 800309c:	f824 6b04 	strh.w	r6, [r4], #4
  for (index = nbytes; index != 0; index--)
 80030a0:	d1f9      	bne.n	8003096 <USB_EPStartXfer+0xee>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 80030a2:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 80030a6:	780c      	ldrb	r4, [r1, #0]
 80030a8:	b292      	uxth	r2, r2
 80030aa:	3202      	adds	r2, #2
 80030ac:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80030b0:	f847 3012 	str.w	r3, [r7, r2, lsl #1]
 80030b4:	e030      	b.n	8003118 <USB_EPStartXfer+0x170>
      if (PCD_GET_ENDPOINT(USBx, ep->num)& USB_EP_DTOG_TX)
 80030b6:	780d      	ldrb	r5, [r1, #0]
 80030b8:	f830 2025 	ldrh.w	r2, [r0, r5, lsl #2]
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80030bc:	f8b0 4050 	ldrh.w	r4, [r0, #80]	; 0x50
      if (PCD_GET_ENDPOINT(USBx, ep->num)& USB_EP_DTOG_TX)
 80030c0:	f012 0f40 	tst.w	r2, #64	; 0x40
        PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 80030c4:	b2a4      	uxth	r4, r4
 80030c6:	f104 0402 	add.w	r4, r4, #2
 80030ca:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 80030ce:	f500 6280 	add.w	r2, r0, #1024	; 0x400
 80030d2:	bf12      	itee	ne
 80030d4:	f842 3014 	strne.w	r3, [r2, r4, lsl #1]
        pmabuffer = ep->pmaaddr0;
 80030d8:	88cd      	ldrheq	r5, [r1, #6]
        PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 80030da:	f842 3014 	streq.w	r3, [r2, r4, lsl #1]
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 80030de:	b29b      	uxth	r3, r3
        pmabuffer = ep->pmaaddr1;
 80030e0:	bf18      	it	ne
 80030e2:	890d      	ldrhne	r5, [r1, #8]
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 80030e4:	3301      	adds	r3, #1
  for (index = nbytes; index != 0; index--)
 80030e6:	105b      	asrs	r3, r3, #1
      USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, len);
 80030e8:	694c      	ldr	r4, [r1, #20]
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 80030ea:	eb02 0245 	add.w	r2, r2, r5, lsl #1
  for (index = nbytes; index != 0; index--)
 80030ee:	d005      	beq.n	80030fc <USB_EPStartXfer+0x154>
    temp1 = (uint16_t) * pbUsrBuf;
 80030f0:	f834 5b02 	ldrh.w	r5, [r4], #2
  for (index = nbytes; index != 0; index--)
 80030f4:	3b01      	subs	r3, #1
    *pdwVal++ = temp2;
 80030f6:	f822 5b04 	strh.w	r5, [r2], #4
  for (index = nbytes; index != 0; index--)
 80030fa:	d1f9      	bne.n	80030f0 <USB_EPStartXfer+0x148>
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 80030fc:	784b      	ldrb	r3, [r1, #1]
 80030fe:	bb53      	cbnz	r3, 8003156 <USB_EPStartXfer+0x1ae>
 8003100:	f640 730f 	movw	r3, #3855	; 0xf0f
 8003104:	780a      	ldrb	r2, [r1, #0]
 8003106:	f830 4022 	ldrh.w	r4, [r0, r2, lsl #2]
 800310a:	4023      	ands	r3, r4
 800310c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003110:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8003114:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8003118:	780a      	ldrb	r2, [r1, #0]
}
 800311a:	bcf0      	pop	{r4, r5, r6, r7}
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 800311c:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003120:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003124:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003128:	041b      	lsls	r3, r3, #16
 800312a:	0c1b      	lsrs	r3, r3, #16
 800312c:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8003130:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003134:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003138:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 800313c:	2000      	movs	r0, #0
 800313e:	4770      	bx	lr
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 8003140:	f3c3 044f 	ubfx	r4, r3, #1, #16
 8003144:	07db      	lsls	r3, r3, #31
 8003146:	bf44      	itt	mi
 8003148:	3401      	addmi	r4, #1
 800314a:	b2a4      	uxthmi	r4, r4
 800314c:	02a4      	lsls	r4, r4, #10
 800314e:	b2a4      	uxth	r4, r4
 8003150:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
 8003154:	e74f      	b.n	8002ff6 <USB_EPStartXfer+0x4e>
      PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 8003156:	2b01      	cmp	r3, #1
 8003158:	d1de      	bne.n	8003118 <USB_EPStartXfer+0x170>
 800315a:	f640 730f 	movw	r3, #3855	; 0xf0f
 800315e:	780a      	ldrb	r2, [r1, #0]
 8003160:	f830 4022 	ldrh.w	r4, [r0, r2, lsl #2]
 8003164:	4023      	ands	r3, r4
 8003166:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800316a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800316e:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
 8003172:	e7d1      	b.n	8003118 <USB_EPStartXfer+0x170>
      PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 8003174:	f3c3 044f 	ubfx	r4, r3, #1, #16
 8003178:	07de      	lsls	r6, r3, #31
 800317a:	bf44      	itt	mi
 800317c:	3401      	addmi	r4, #1
 800317e:	b2a4      	uxthmi	r4, r4
 8003180:	02a4      	lsls	r4, r4, #10
 8003182:	b2a4      	uxth	r4, r4
 8003184:	f845 4012 	str.w	r4, [r5, r2, lsl #1]
 8003188:	784a      	ldrb	r2, [r1, #1]
 800318a:	2a00      	cmp	r2, #0
 800318c:	f43f af66 	beq.w	800305c <USB_EPStartXfer+0xb4>
 8003190:	2a01      	cmp	r2, #1
 8003192:	f47f af30 	bne.w	8002ff6 <USB_EPStartXfer+0x4e>
 8003196:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
 800319a:	780c      	ldrb	r4, [r1, #0]
 800319c:	b292      	uxth	r2, r2
 800319e:	3202      	adds	r2, #2
 80031a0:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80031a4:	f845 3012 	str.w	r3, [r5, r2, lsl #1]
 80031a8:	e725      	b.n	8002ff6 <USB_EPStartXfer+0x4e>
 80031aa:	bf00      	nop
 80031ac:	ffff8000 	.word	0xffff8000

080031b0 <USB_EPSetStall>:
  if (ep->num == 0)
 80031b0:	780a      	ldrb	r2, [r1, #0]
 80031b2:	b98a      	cbnz	r2, 80031d8 <USB_EPSetStall+0x28>
    PCD_SET_EP_TXRX_STATUS(USBx, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL); 
 80031b4:	8803      	ldrh	r3, [r0, #0]
 80031b6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80031ba:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80031be:	041b      	lsls	r3, r3, #16
 80031c0:	0c1b      	lsrs	r3, r3, #16
 80031c2:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80031c6:	f083 0310 	eor.w	r3, r3, #16
 80031ca:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80031ce:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031d2:	8003      	strh	r3, [r0, #0]
}
 80031d4:	2000      	movs	r0, #0
 80031d6:	4770      	bx	lr
    if (ep->is_in)
 80031d8:	784b      	ldrb	r3, [r1, #1]
 80031da:	b18b      	cbz	r3, 8003200 <USB_EPSetStall+0x50>
      PCD_SET_EP_TX_STATUS(USBx, ep->num , USB_EP_TX_STALL); 
 80031dc:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 80031e0:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80031e4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80031e8:	041b      	lsls	r3, r3, #16
 80031ea:	0c1b      	lsrs	r3, r3, #16
 80031ec:	f083 0310 	eor.w	r3, r3, #16
 80031f0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80031f4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031f8:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 80031fc:	2000      	movs	r0, #0
 80031fe:	4770      	bx	lr
      PCD_SET_EP_RX_STATUS(USBx, ep->num , USB_EP_RX_STALL);
 8003200:	f830 3022 	ldrh.w	r3, [r0, r2, lsl #2]
 8003204:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003208:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800320c:	041b      	lsls	r3, r3, #16
 800320e:	0c1b      	lsrs	r3, r3, #16
 8003210:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8003214:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003218:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800321c:	f820 3022 	strh.w	r3, [r0, r2, lsl #2]
}
 8003220:	2000      	movs	r0, #0
 8003222:	4770      	bx	lr

08003224 <USB_EPClearStall>:
  if (ep->is_in)
 8003224:	784b      	ldrb	r3, [r1, #1]
{
 8003226:	b410      	push	{r4}
  if (ep->is_in)
 8003228:	b1bb      	cbz	r3, 800325a <USB_EPClearStall+0x36>
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800322a:	780b      	ldrb	r3, [r1, #0]
 800322c:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8003230:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8003234:	0664      	lsls	r4, r4, #25
 8003236:	d436      	bmi.n	80032a6 <USB_EPClearStall+0x82>
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8003238:	8813      	ldrh	r3, [r2, #0]
}
 800323a:	2000      	movs	r0, #0
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 800323c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003240:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003244:	041b      	lsls	r3, r3, #16
 8003246:	0c1b      	lsrs	r3, r3, #16
 8003248:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 800324c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003250:	f043 0380 	orr.w	r3, r3, #128	; 0x80
}
 8003254:	bc10      	pop	{r4}
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 8003256:	8013      	strh	r3, [r2, #0]
}
 8003258:	4770      	bx	lr
    PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800325a:	780b      	ldrb	r3, [r1, #0]
 800325c:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8003260:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8003264:	0464      	lsls	r4, r4, #17
 8003266:	d50d      	bpl.n	8003284 <USB_EPClearStall+0x60>
 8003268:	f640 720f 	movw	r2, #3855	; 0xf0f
 800326c:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 8003270:	4022      	ands	r2, r4
 8003272:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8003276:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800327a:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 800327e:	780a      	ldrb	r2, [r1, #0]
 8003280:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003284:	8813      	ldrh	r3, [r2, #0]
}
 8003286:	2000      	movs	r0, #0
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 8003288:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800328c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003290:	041b      	lsls	r3, r3, #16
 8003292:	0c1b      	lsrs	r3, r3, #16
 8003294:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8003298:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800329c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
}
 80032a0:	bc10      	pop	{r4}
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 80032a2:	8013      	strh	r3, [r2, #0]
}
 80032a4:	4770      	bx	lr
    PCD_CLEAR_TX_DTOG(USBx, ep->num);
 80032a6:	f640 720f 	movw	r2, #3855	; 0xf0f
 80032aa:	f830 4023 	ldrh.w	r4, [r0, r3, lsl #2]
 80032ae:	4022      	ands	r2, r4
 80032b0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80032b4:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 80032b8:	f820 2023 	strh.w	r2, [r0, r3, lsl #2]
 80032bc:	780a      	ldrb	r2, [r1, #0]
 80032be:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80032c2:	e7b9      	b.n	8003238 <USB_EPClearStall+0x14>

080032c4 <USB_SetDevAddress>:
  if(address == 0) 
 80032c4:	b911      	cbnz	r1, 80032cc <USB_SetDevAddress+0x8>
   USBx->DADDR = USB_DADDR_EF;
 80032c6:	2380      	movs	r3, #128	; 0x80
 80032c8:	f8a0 304c 	strh.w	r3, [r0, #76]	; 0x4c
}
 80032cc:	2000      	movs	r0, #0
 80032ce:	4770      	bx	lr

080032d0 <USB_ReadInterrupts>:
  tmpreg = USBx->ISTR;
 80032d0:	f8b0 0044 	ldrh.w	r0, [r0, #68]	; 0x44
}
 80032d4:	b280      	uxth	r0, r0
 80032d6:	4770      	bx	lr

080032d8 <USB_EP0_OutStart>:
}
 80032d8:	2000      	movs	r0, #0
 80032da:	4770      	bx	lr

080032dc <USB_WritePMA>:
  uint32_t nbytes = (wNBytes + 1) >> 1;   /* nbytes = (wNBytes + 1) / 2 */
 80032dc:	3301      	adds	r3, #1
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 80032de:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  for (index = nbytes; index != 0; index--)
 80032e2:	105b      	asrs	r3, r3, #1
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 80032e4:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (index = nbytes; index != 0; index--)
 80032e8:	d005      	beq.n	80032f6 <USB_WritePMA+0x1a>
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 80032ea:	f831 0b02 	ldrh.w	r0, [r1], #2
  for (index = nbytes; index != 0; index--)
 80032ee:	3b01      	subs	r3, #1
    *pdwVal++ = temp2;
 80032f0:	f822 0b04 	strh.w	r0, [r2], #4
  for (index = nbytes; index != 0; index--)
 80032f4:	d1f9      	bne.n	80032ea <USB_WritePMA+0xe>
    pdwVal++;
    pbUsrBuf++;
  }
}
 80032f6:	4770      	bx	lr

080032f8 <USB_ReadPMA>:
  * @param  wNBytes : number of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t nbytes = (wNBytes + 1) >> 1;/* /2*/
 80032f8:	3301      	adds	r3, #1
  uint32_t index = 0;
  uint32_t *pdwVal = NULL;
  
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 80032fa:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  for (index = nbytes; index != 0; index--)
 80032fe:	105b      	asrs	r3, r3, #1
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400);
 8003300:	eb00 0242 	add.w	r2, r0, r2, lsl #1
  for (index = nbytes; index != 0; index--)
 8003304:	d006      	beq.n	8003314 <USB_ReadPMA+0x1c>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8003306:	6810      	ldr	r0, [r2, #0]
  for (index = nbytes; index != 0; index--)
 8003308:	3b01      	subs	r3, #1
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 800330a:	f102 0204 	add.w	r2, r2, #4
 800330e:	f821 0b02 	strh.w	r0, [r1], #2
  for (index = nbytes; index != 0; index--)
 8003312:	d1f8      	bne.n	8003306 <USB_ReadPMA+0xe>
    pbUsrBuf++;
  }
}
 8003314:	4770      	bx	lr
 8003316:	bf00      	nop

08003318 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8003318:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 800331a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800331e:	b11b      	cbz	r3, 8003328 <USBD_SetClassConfig+0x10>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8003320:	681b      	ldr	r3, [r3, #0]
 8003322:	4798      	blx	r3
 8003324:	b900      	cbnz	r0, 8003328 <USBD_SetClassConfig+0x10>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 8003326:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8003328:	2002      	movs	r0, #2
}
 800332a:	bd08      	pop	{r3, pc}

0800332c <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800332c:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 800332e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003332:	685b      	ldr	r3, [r3, #4]
 8003334:	4798      	blx	r3
  return USBD_OK;
}
 8003336:	2000      	movs	r0, #0
 8003338:	bd08      	pop	{r3, pc}
 800333a:	bf00      	nop

0800333c <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800333c:	b538      	push	{r3, r4, r5, lr}
 800333e:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8003340:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8003344:	4628      	mov	r0, r5
 8003346:	f000 facb 	bl	80038e0 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 800334a:	2001      	movs	r0, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 800334c:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
  pdev->ep0_data_len = pdev->request.wLength;
 8003350:	f8b4 220e 	ldrh.w	r2, [r4, #526]	; 0x20e
 8003354:	f001 031f 	and.w	r3, r1, #31
  switch (pdev->request.bmRequest & 0x1F) 
 8003358:	4283      	cmp	r3, r0
  pdev->ep0_data_len = pdev->request.wLength;
 800335a:	e9c4 027d 	strd	r0, r2, [r4, #500]	; 0x1f4
  switch (pdev->request.bmRequest & 0x1F) 
 800335e:	d009      	beq.n	8003374 <USBD_LL_SetupStage+0x38>
 8003360:	2b02      	cmp	r3, #2
 8003362:	d013      	beq.n	800338c <USBD_LL_SetupStage+0x50>
 8003364:	b163      	cbz	r3, 8003380 <USBD_LL_SetupStage+0x44>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8003366:	4620      	mov	r0, r4
 8003368:	f001 0180 	and.w	r1, r1, #128	; 0x80
 800336c:	f001 fd9c 	bl	8004ea8 <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 8003370:	2000      	movs	r0, #0
 8003372:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8003374:	4629      	mov	r1, r5
 8003376:	4620      	mov	r0, r4
 8003378:	f000 fa28 	bl	80037cc <USBD_StdItfReq>
}
 800337c:	2000      	movs	r0, #0
 800337e:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdDevReq (pdev, &pdev->request);
 8003380:	4629      	mov	r1, r5
 8003382:	4620      	mov	r0, r4
 8003384:	f000 f8d6 	bl	8003534 <USBD_StdDevReq>
}
 8003388:	2000      	movs	r0, #0
 800338a:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdEPReq(pdev, &pdev->request);   
 800338c:	4629      	mov	r1, r5
 800338e:	4620      	mov	r0, r4
 8003390:	f000 fa3a 	bl	8003808 <USBD_StdEPReq>
}
 8003394:	2000      	movs	r0, #0
 8003396:	bd38      	pop	{r3, r4, r5, pc}

08003398 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8003398:	b510      	push	{r4, lr}
 800339a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 800339c:	b931      	cbnz	r1, 80033ac <USBD_LL_DataOutStage+0x14>
 800339e:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 80033a0:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 80033a4:	2a03      	cmp	r2, #3
 80033a6:	d00d      	beq.n	80033c4 <USBD_LL_DataOutStage+0x2c>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 80033a8:	2000      	movs	r0, #0
 80033aa:	bd10      	pop	{r4, pc}
  else if((pdev->pClass->DataOut != NULL)&&
 80033ac:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80033b0:	699b      	ldr	r3, [r3, #24]
 80033b2:	2b00      	cmp	r3, #0
 80033b4:	d0f8      	beq.n	80033a8 <USBD_LL_DataOutStage+0x10>
 80033b6:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80033ba:	2a03      	cmp	r2, #3
 80033bc:	d1f4      	bne.n	80033a8 <USBD_LL_DataOutStage+0x10>
    pdev->pClass->DataOut(pdev, epnum); 
 80033be:	4798      	blx	r3
}
 80033c0:	2000      	movs	r0, #0
 80033c2:	bd10      	pop	{r4, pc}
      if(pep->rem_length > pep->maxpacket)
 80033c4:	e9d0 1243 	ldrd	r1, r2, [r0, #268]	; 0x10c
 80033c8:	4291      	cmp	r1, r2
 80033ca:	d80d      	bhi.n	80033e8 <USBD_LL_DataOutStage+0x50>
        if((pdev->pClass->EP0_RxReady != NULL)&&
 80033cc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80033d0:	691b      	ldr	r3, [r3, #16]
 80033d2:	b123      	cbz	r3, 80033de <USBD_LL_DataOutStage+0x46>
 80033d4:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80033d8:	2a03      	cmp	r2, #3
 80033da:	d100      	bne.n	80033de <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev); 
 80033dc:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 80033de:	4620      	mov	r0, r4
 80033e0:	f000 fab4 	bl	800394c <USBD_CtlSendStatus>
}
 80033e4:	2000      	movs	r0, #0
 80033e6:	bd10      	pop	{r4, pc}
        pep->rem_length -=  pep->maxpacket;
 80033e8:	1a89      	subs	r1, r1, r2
                            MIN(pep->rem_length ,pep->maxpacket));
 80033ea:	428a      	cmp	r2, r1
 80033ec:	bf28      	it	cs
 80033ee:	460a      	movcs	r2, r1
        pep->rem_length -=  pep->maxpacket;
 80033f0:	f8c0 110c 	str.w	r1, [r0, #268]	; 0x10c
        USBD_CtlContinueRx (pdev, 
 80033f4:	b292      	uxth	r2, r2
 80033f6:	4619      	mov	r1, r3
 80033f8:	f000 fa9e 	bl	8003938 <USBD_CtlContinueRx>
 80033fc:	e7d4      	b.n	80033a8 <USBD_LL_DataOutStage+0x10>
 80033fe:	bf00      	nop

08003400 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8003400:	b570      	push	{r4, r5, r6, lr}
 8003402:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8003404:	b951      	cbnz	r1, 800341c <USBD_LL_DataInStage+0x1c>
 8003406:	4613      	mov	r3, r2
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8003408:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 800340c:	2a02      	cmp	r2, #2
 800340e:	d016      	beq.n	800343e <USBD_LL_DataInStage+0x3e>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8003410:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003414:	2b01      	cmp	r3, #1
 8003416:	d00d      	beq.n	8003434 <USBD_LL_DataInStage+0x34>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8003418:	2000      	movs	r0, #0
 800341a:	bd70      	pop	{r4, r5, r6, pc}
  else if((pdev->pClass->DataIn != NULL)&& 
 800341c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003420:	695b      	ldr	r3, [r3, #20]
 8003422:	2b00      	cmp	r3, #0
 8003424:	d0f8      	beq.n	8003418 <USBD_LL_DataInStage+0x18>
 8003426:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800342a:	2a03      	cmp	r2, #3
 800342c:	d1f4      	bne.n	8003418 <USBD_LL_DataInStage+0x18>
    pdev->pClass->DataIn(pdev, epnum); 
 800342e:	4798      	blx	r3
}
 8003430:	2000      	movs	r0, #0
 8003432:	bd70      	pop	{r4, r5, r6, pc}
      pdev->dev_test_mode = 0;
 8003434:	2300      	movs	r3, #0
 8003436:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
}
 800343a:	2000      	movs	r0, #0
 800343c:	bd70      	pop	{r4, r5, r6, pc}
      if(pep->rem_length > pep->maxpacket)
 800343e:	e9d0 2607 	ldrd	r2, r6, [r0, #28]
 8003442:	42b2      	cmp	r2, r6
 8003444:	d821      	bhi.n	800348a <USBD_LL_DataInStage+0x8a>
        if((pep->total_length % pep->maxpacket == 0) &&
 8003446:	6983      	ldr	r3, [r0, #24]
 8003448:	fbb3 f5f6 	udiv	r5, r3, r6
 800344c:	fb06 3515 	mls	r5, r6, r5, r3
 8003450:	b95d      	cbnz	r5, 800346a <USBD_LL_DataInStage+0x6a>
 8003452:	429e      	cmp	r6, r3
 8003454:	d809      	bhi.n	800346a <USBD_LL_DataInStage+0x6a>
           (pep->total_length >= pep->maxpacket) &&
 8003456:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 800345a:	4293      	cmp	r3, r2
 800345c:	d205      	bcs.n	800346a <USBD_LL_DataInStage+0x6a>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 800345e:	462a      	mov	r2, r5
 8003460:	f000 fa60 	bl	8003924 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8003464:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
 8003468:	e016      	b.n	8003498 <USBD_LL_DataInStage+0x98>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 800346a:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800346e:	68db      	ldr	r3, [r3, #12]
 8003470:	b11b      	cbz	r3, 800347a <USBD_LL_DataInStage+0x7a>
 8003472:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8003476:	2a03      	cmp	r2, #3
 8003478:	d015      	beq.n	80034a6 <USBD_LL_DataInStage+0xa6>
          USBD_CtlReceiveStatus(pdev);
 800347a:	4620      	mov	r0, r4
 800347c:	f000 fa72 	bl	8003964 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1)
 8003480:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003484:	2b01      	cmp	r3, #1
 8003486:	d1c7      	bne.n	8003418 <USBD_LL_DataInStage+0x18>
 8003488:	e7d4      	b.n	8003434 <USBD_LL_DataInStage+0x34>
        pep->rem_length -=  pep->maxpacket;
 800348a:	1b92      	subs	r2, r2, r6
 800348c:	460d      	mov	r5, r1
 800348e:	61c2      	str	r2, [r0, #28]
        USBD_CtlContinueSendData (pdev, 
 8003490:	4619      	mov	r1, r3
 8003492:	b292      	uxth	r2, r2
 8003494:	f000 fa46 	bl	8003924 <USBD_CtlContinueSendData>
        USBD_LL_PrepareReceive (pdev,
 8003498:	462b      	mov	r3, r5
 800349a:	462a      	mov	r2, r5
 800349c:	4629      	mov	r1, r5
 800349e:	4620      	mov	r0, r4
 80034a0:	f001 fd4a 	bl	8004f38 <USBD_LL_PrepareReceive>
 80034a4:	e7b4      	b.n	8003410 <USBD_LL_DataInStage+0x10>
            pdev->pClass->EP0_TxSent(pdev); 
 80034a6:	4620      	mov	r0, r4
 80034a8:	4798      	blx	r3
 80034aa:	e7e6      	b.n	800347a <USBD_LL_DataInStage+0x7a>

080034ac <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80034ac:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80034ae:	2200      	movs	r2, #0
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80034b0:	2540      	movs	r5, #64	; 0x40
{
 80034b2:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 80034b4:	4611      	mov	r1, r2
 80034b6:	462b      	mov	r3, r5
 80034b8:	f001 fce6 	bl	8004e88 <USBD_LL_OpenEP>
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 80034bc:	462b      	mov	r3, r5
 80034be:	2200      	movs	r2, #0
 80034c0:	4620      	mov	r0, r4
 80034c2:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80034c4:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  USBD_LL_OpenEP(pdev,
 80034c8:	f001 fcde 	bl	8004e88 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80034cc:	2201      	movs	r2, #1
  
  if (pdev->pClassData) 
 80034ce:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80034d2:	6225      	str	r5, [r4, #32]
  pdev->dev_state = USBD_STATE_DEFAULT;
 80034d4:	f884 21fc 	strb.w	r2, [r4, #508]	; 0x1fc
  if (pdev->pClassData) 
 80034d8:	b12b      	cbz	r3, 80034e6 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80034da:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80034de:	4620      	mov	r0, r4
 80034e0:	7921      	ldrb	r1, [r4, #4]
 80034e2:	685b      	ldr	r3, [r3, #4]
 80034e4:	4798      	blx	r3
 
  
  return USBD_OK;
}
 80034e6:	2000      	movs	r0, #0
 80034e8:	bd38      	pop	{r3, r4, r5, pc}
 80034ea:	bf00      	nop

080034ec <USBD_LL_SetSpeed>:
*         Handle Reset event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
 80034ec:	4603      	mov	r3, r0
  pdev->dev_speed = speed;
  return USBD_OK;
}
 80034ee:	2000      	movs	r0, #0
  pdev->dev_speed = speed;
 80034f0:	7419      	strb	r1, [r3, #16]
}
 80034f2:	4770      	bx	lr

080034f4 <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
 80034f4:	4603      	mov	r3, r0
  pdev->dev_old_state =  pdev->dev_state;
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 80034f6:	2204      	movs	r2, #4
  pdev->dev_old_state =  pdev->dev_state;
 80034f8:	f890 11fc 	ldrb.w	r1, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 80034fc:	2000      	movs	r0, #0
  pdev->dev_old_state =  pdev->dev_state;
 80034fe:	f883 11fd 	strb.w	r1, [r3, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8003502:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
}
 8003506:	4770      	bx	lr

08003508 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 8003508:	4603      	mov	r3, r0
  pdev->dev_state = pdev->dev_old_state;  
 800350a:	f890 21fd 	ldrb.w	r2, [r0, #509]	; 0x1fd
  return USBD_OK;
}
 800350e:	2000      	movs	r0, #0
  pdev->dev_state = pdev->dev_old_state;  
 8003510:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
}
 8003514:	4770      	bx	lr
 8003516:	bf00      	nop

08003518 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8003518:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800351c:	2a03      	cmp	r2, #3
 800351e:	d001      	beq.n	8003524 <USBD_LL_SOF+0xc>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 8003520:	2000      	movs	r0, #0
 8003522:	4770      	bx	lr
{
 8003524:	b508      	push	{r3, lr}
    if(pdev->pClass->SOF != NULL)
 8003526:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800352a:	69db      	ldr	r3, [r3, #28]
 800352c:	b103      	cbz	r3, 8003530 <USBD_LL_SOF+0x18>
      pdev->pClass->SOF(pdev);
 800352e:	4798      	blx	r3
}
 8003530:	2000      	movs	r0, #0
 8003532:	bd08      	pop	{r3, pc}

08003534 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8003534:	b530      	push	{r4, r5, lr}
 8003536:	784b      	ldrb	r3, [r1, #1]
 8003538:	460d      	mov	r5, r1
 800353a:	4604      	mov	r4, r0
 800353c:	b083      	sub	sp, #12
 800353e:	2b09      	cmp	r3, #9
 8003540:	d80b      	bhi.n	800355a <USBD_StdDevReq+0x26>
 8003542:	e8df f003 	tbb	[pc, r3]
 8003546:	4835      	.short	0x4835
 8003548:	050a580a 	.word	0x050a580a
 800354c:	157b0a65 	.word	0x157b0a65
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8003550:	888b      	ldrh	r3, [r1, #4]
 8003552:	b913      	cbnz	r3, 800355a <USBD_StdDevReq+0x26>
 8003554:	88cb      	ldrh	r3, [r1, #6]
 8003556:	2b00      	cmp	r3, #0
 8003558:	d07d      	beq.n	8003656 <USBD_StdDevReq+0x122>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 800355a:	2180      	movs	r1, #128	; 0x80
 800355c:	4620      	mov	r0, r4
 800355e:	f001 fca3 	bl	8004ea8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8003562:	4620      	mov	r0, r4
 8003564:	2100      	movs	r1, #0
 8003566:	f001 fc9f 	bl	8004ea8 <USBD_LL_StallEP>
}
 800356a:	2000      	movs	r0, #0
 800356c:	b003      	add	sp, #12
 800356e:	bd30      	pop	{r4, r5, pc}
  cfgidx = (uint8_t)(req->wValue);                 
 8003570:	7889      	ldrb	r1, [r1, #2]
 8003572:	4d95      	ldr	r5, [pc, #596]	; (80037c8 <USBD_StdDevReq+0x294>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003574:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);                 
 8003576:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003578:	d8ef      	bhi.n	800355a <USBD_StdDevReq+0x26>
    switch (pdev->dev_state) 
 800357a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800357e:	2b02      	cmp	r3, #2
 8003580:	f000 8080 	beq.w	8003684 <USBD_StdDevReq+0x150>
 8003584:	2b03      	cmp	r3, #3
 8003586:	d1e8      	bne.n	800355a <USBD_StdDevReq+0x26>
      if (cfgidx == 0) 
 8003588:	2900      	cmp	r1, #0
 800358a:	f000 8112 	beq.w	80037b2 <USBD_StdDevReq+0x27e>
      else  if (cfgidx != pdev->dev_config) 
 800358e:	6841      	ldr	r1, [r0, #4]
 8003590:	2901      	cmp	r1, #1
 8003592:	d009      	beq.n	80035a8 <USBD_StdDevReq+0x74>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8003594:	b2c9      	uxtb	r1, r1
 8003596:	f7ff fec9 	bl	800332c <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 800359a:	7829      	ldrb	r1, [r5, #0]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 800359c:	4620      	mov	r0, r4
        pdev->dev_config = cfgidx;
 800359e:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 80035a0:	f7ff feba 	bl	8003318 <USBD_SetClassConfig>
 80035a4:	2802      	cmp	r0, #2
 80035a6:	d0d8      	beq.n	800355a <USBD_StdDevReq+0x26>
      USBD_CtlSendStatus(pdev);
 80035a8:	4620      	mov	r0, r4
 80035aa:	f000 f9cf 	bl	800394c <USBD_CtlSendStatus>
 80035ae:	e7dc      	b.n	800356a <USBD_StdDevReq+0x36>
  switch (pdev->dev_state) 
 80035b0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80035b4:	3b02      	subs	r3, #2
 80035b6:	2b01      	cmp	r3, #1
 80035b8:	d8cf      	bhi.n	800355a <USBD_StdDevReq+0x26>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80035ba:	2201      	movs	r2, #1
    if (pdev->dev_remote_wakeup) 
 80035bc:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 80035c0:	60c2      	str	r2, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 80035c2:	b10b      	cbz	r3, 80035c8 <USBD_StdDevReq+0x94>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 80035c4:	2303      	movs	r3, #3
 80035c6:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 80035c8:	2202      	movs	r2, #2
 80035ca:	4620      	mov	r0, r4
 80035cc:	f104 010c 	add.w	r1, r4, #12
 80035d0:	f000 f99a 	bl	8003908 <USBD_CtlSendData>
    break;
 80035d4:	e7c9      	b.n	800356a <USBD_StdDevReq+0x36>
  switch (pdev->dev_state)
 80035d6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80035da:	3b02      	subs	r3, #2
 80035dc:	2b01      	cmp	r3, #1
 80035de:	d8bc      	bhi.n	800355a <USBD_StdDevReq+0x26>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80035e0:	884b      	ldrh	r3, [r1, #2]
 80035e2:	2b01      	cmp	r3, #1
 80035e4:	d1c1      	bne.n	800356a <USBD_StdDevReq+0x36>
      pdev->dev_remote_wakeup = 0; 
 80035e6:	2200      	movs	r2, #0
      pdev->pClass->Setup (pdev, req);   
 80035e8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
      pdev->dev_remote_wakeup = 0; 
 80035ec:	f8c0 2204 	str.w	r2, [r0, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80035f0:	689b      	ldr	r3, [r3, #8]
 80035f2:	4798      	blx	r3
 80035f4:	e7d8      	b.n	80035a8 <USBD_StdDevReq+0x74>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80035f6:	884b      	ldrh	r3, [r1, #2]
 80035f8:	2b01      	cmp	r3, #1
 80035fa:	d1b6      	bne.n	800356a <USBD_StdDevReq+0x36>
    pdev->pClass->Setup (pdev, req);   
 80035fc:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
    pdev->dev_remote_wakeup = 1;  
 8003600:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
    pdev->pClass->Setup (pdev, req);   
 8003604:	6893      	ldr	r3, [r2, #8]
 8003606:	4798      	blx	r3
    USBD_CtlSendStatus(pdev);
 8003608:	4620      	mov	r0, r4
 800360a:	f000 f99f 	bl	800394c <USBD_CtlSendStatus>
 800360e:	e7ac      	b.n	800356a <USBD_StdDevReq+0x36>
    USBD_GetDescriptor (pdev, req) ;
 8003610:	884a      	ldrh	r2, [r1, #2]
  switch (req->wValue >> 8)
 8003612:	0a13      	lsrs	r3, r2, #8
 8003614:	3b01      	subs	r3, #1
 8003616:	2b06      	cmp	r3, #6
 8003618:	d89f      	bhi.n	800355a <USBD_StdDevReq+0x26>
 800361a:	a101      	add	r1, pc, #4	; (adr r1, 8003620 <USBD_StdDevReq+0xec>)
 800361c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8003620:	080036ab 	.word	0x080036ab
 8003624:	08003721 	.word	0x08003721
 8003628:	0800370f 	.word	0x0800370f
 800362c:	0800355b 	.word	0x0800355b
 8003630:	0800355b 	.word	0x0800355b
 8003634:	080036f9 	.word	0x080036f9
 8003638:	080036df 	.word	0x080036df
  if (req->wLength != 1) 
 800363c:	88ca      	ldrh	r2, [r1, #6]
 800363e:	2a01      	cmp	r2, #1
 8003640:	d18b      	bne.n	800355a <USBD_StdDevReq+0x26>
    switch (pdev->dev_state )  
 8003642:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003646:	2b02      	cmp	r3, #2
 8003648:	d028      	beq.n	800369c <USBD_StdDevReq+0x168>
 800364a:	2b03      	cmp	r3, #3
 800364c:	d185      	bne.n	800355a <USBD_StdDevReq+0x26>
      USBD_CtlSendData (pdev, 
 800364e:	1d01      	adds	r1, r0, #4
 8003650:	f000 f95a 	bl	8003908 <USBD_CtlSendData>
      break;
 8003654:	e789      	b.n	800356a <USBD_StdDevReq+0x36>
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003656:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800365a:	2b03      	cmp	r3, #3
 800365c:	f43f af7d 	beq.w	800355a <USBD_StdDevReq+0x26>
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003660:	788d      	ldrb	r5, [r1, #2]
 8003662:	f005 057f 	and.w	r5, r5, #127	; 0x7f
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8003666:	4629      	mov	r1, r5
      pdev->dev_address = dev_addr;
 8003668:	f880 51fe 	strb.w	r5, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 800366c:	f001 fc48 	bl	8004f00 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8003670:	4620      	mov	r0, r4
 8003672:	f000 f96b 	bl	800394c <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 8003676:	2d00      	cmp	r5, #0
 8003678:	f000 808e 	beq.w	8003798 <USBD_StdDevReq+0x264>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 800367c:	2302      	movs	r3, #2
 800367e:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 8003682:	e772      	b.n	800356a <USBD_StdDevReq+0x36>
      if (cfgidx) 
 8003684:	2900      	cmp	r1, #0
 8003686:	d08f      	beq.n	80035a8 <USBD_StdDevReq+0x74>
        pdev->dev_config = cfgidx;
 8003688:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800368a:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 800368c:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 800368e:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003692:	f7ff fe41 	bl	8003318 <USBD_SetClassConfig>
 8003696:	2802      	cmp	r0, #2
 8003698:	d186      	bne.n	80035a8 <USBD_StdDevReq+0x74>
 800369a:	e75e      	b.n	800355a <USBD_StdDevReq+0x26>
      pdev->dev_default_config = 0;
 800369c:	2300      	movs	r3, #0
 800369e:	4601      	mov	r1, r0
 80036a0:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 80036a4:	f000 f930 	bl	8003908 <USBD_CtlSendData>
      break;
 80036a8:	e75f      	b.n	800356a <USBD_StdDevReq+0x36>
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80036aa:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80036ae:	f10d 0106 	add.w	r1, sp, #6
 80036b2:	681b      	ldr	r3, [r3, #0]
 80036b4:	7c00      	ldrb	r0, [r0, #16]
 80036b6:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 80036b8:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80036bc:	2a00      	cmp	r2, #0
 80036be:	f43f af54 	beq.w	800356a <USBD_StdDevReq+0x36>
 80036c2:	88eb      	ldrh	r3, [r5, #6]
 80036c4:	2b00      	cmp	r3, #0
 80036c6:	f43f af50 	beq.w	800356a <USBD_StdDevReq+0x36>
    len = MIN(len , req->wLength);
 80036ca:	429a      	cmp	r2, r3
 80036cc:	bf28      	it	cs
 80036ce:	461a      	movcs	r2, r3
    USBD_CtlSendData (pdev, 
 80036d0:	4601      	mov	r1, r0
 80036d2:	4620      	mov	r0, r4
    len = MIN(len , req->wLength);
 80036d4:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 80036d8:	f000 f916 	bl	8003908 <USBD_CtlSendData>
 80036dc:	e745      	b.n	800356a <USBD_StdDevReq+0x36>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80036de:	7c03      	ldrb	r3, [r0, #16]
 80036e0:	2b00      	cmp	r3, #0
 80036e2:	f47f af3a 	bne.w	800355a <USBD_StdDevReq+0x26>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 80036e6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80036ea:	f10d 0006 	add.w	r0, sp, #6
 80036ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80036f0:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 80036f2:	2307      	movs	r3, #7
 80036f4:	7043      	strb	r3, [r0, #1]
      break; 
 80036f6:	e7df      	b.n	80036b8 <USBD_StdDevReq+0x184>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 80036f8:	7c03      	ldrb	r3, [r0, #16]
 80036fa:	2b00      	cmp	r3, #0
 80036fc:	f47f af2d 	bne.w	800355a <USBD_StdDevReq+0x26>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8003700:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003704:	f10d 0006 	add.w	r0, sp, #6
 8003708:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800370a:	4798      	blx	r3
      break;
 800370c:	e7d4      	b.n	80036b8 <USBD_StdDevReq+0x184>
    switch ((uint8_t)(req->wValue))
 800370e:	b2d2      	uxtb	r2, r2
 8003710:	2a05      	cmp	r2, #5
 8003712:	f63f af22 	bhi.w	800355a <USBD_StdDevReq+0x26>
 8003716:	e8df f002 	tbb	[pc, r2]
 800371a:	171f      	.short	0x171f
 800371c:	0f37272f 	.word	0x0f37272f
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8003720:	7c03      	ldrb	r3, [r0, #16]
 8003722:	2b00      	cmp	r3, #0
 8003724:	d13c      	bne.n	80037a0 <USBD_StdDevReq+0x26c>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8003726:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800372a:	f10d 0006 	add.w	r0, sp, #6
 800372e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003730:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8003732:	2302      	movs	r3, #2
 8003734:	7043      	strb	r3, [r0, #1]
 8003736:	e7bf      	b.n	80036b8 <USBD_StdDevReq+0x184>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8003738:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800373c:	f10d 0106 	add.w	r1, sp, #6
 8003740:	699b      	ldr	r3, [r3, #24]
 8003742:	7c00      	ldrb	r0, [r0, #16]
 8003744:	4798      	blx	r3
      break;
 8003746:	e7b7      	b.n	80036b8 <USBD_StdDevReq+0x184>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8003748:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800374c:	f10d 0106 	add.w	r1, sp, #6
 8003750:	689b      	ldr	r3, [r3, #8]
 8003752:	7c00      	ldrb	r0, [r0, #16]
 8003754:	4798      	blx	r3
      break;
 8003756:	e7af      	b.n	80036b8 <USBD_StdDevReq+0x184>
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8003758:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800375c:	f10d 0106 	add.w	r1, sp, #6
 8003760:	685b      	ldr	r3, [r3, #4]
 8003762:	7c00      	ldrb	r0, [r0, #16]
 8003764:	4798      	blx	r3
      break;
 8003766:	e7a7      	b.n	80036b8 <USBD_StdDevReq+0x184>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8003768:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800376c:	f10d 0106 	add.w	r1, sp, #6
 8003770:	691b      	ldr	r3, [r3, #16]
 8003772:	7c00      	ldrb	r0, [r0, #16]
 8003774:	4798      	blx	r3
      break;
 8003776:	e79f      	b.n	80036b8 <USBD_StdDevReq+0x184>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8003778:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800377c:	f10d 0106 	add.w	r1, sp, #6
 8003780:	68db      	ldr	r3, [r3, #12]
 8003782:	7c00      	ldrb	r0, [r0, #16]
 8003784:	4798      	blx	r3
      break;
 8003786:	e797      	b.n	80036b8 <USBD_StdDevReq+0x184>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8003788:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800378c:	f10d 0106 	add.w	r1, sp, #6
 8003790:	695b      	ldr	r3, [r3, #20]
 8003792:	7c00      	ldrb	r0, [r0, #16]
 8003794:	4798      	blx	r3
      break;
 8003796:	e78f      	b.n	80036b8 <USBD_StdDevReq+0x184>
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8003798:	2301      	movs	r3, #1
 800379a:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 800379e:	e6e4      	b.n	800356a <USBD_StdDevReq+0x36>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 80037a0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80037a4:	f10d 0006 	add.w	r0, sp, #6
 80037a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80037aa:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 80037ac:	2302      	movs	r3, #2
 80037ae:	7043      	strb	r3, [r0, #1]
 80037b0:	e782      	b.n	80036b8 <USBD_StdDevReq+0x184>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80037b2:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;          
 80037b4:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80037b6:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        USBD_ClrClassConfig(pdev , cfgidx);
 80037ba:	f7ff fdb7 	bl	800332c <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 80037be:	4620      	mov	r0, r4
 80037c0:	f000 f8c4 	bl	800394c <USBD_CtlSendStatus>
 80037c4:	e6d1      	b.n	800356a <USBD_StdDevReq+0x36>
 80037c6:	bf00      	nop
 80037c8:	200000a4 	.word	0x200000a4

080037cc <USBD_StdItfReq>:
{
 80037cc:	b538      	push	{r3, r4, r5, lr}
  switch (pdev->dev_state) 
 80037ce:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
 80037d2:	4604      	mov	r4, r0
  switch (pdev->dev_state) 
 80037d4:	2b03      	cmp	r3, #3
 80037d6:	d10d      	bne.n	80037f4 <USBD_StdItfReq+0x28>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 80037d8:	790b      	ldrb	r3, [r1, #4]
 80037da:	460d      	mov	r5, r1
 80037dc:	2b01      	cmp	r3, #1
 80037de:	d809      	bhi.n	80037f4 <USBD_StdItfReq+0x28>
      pdev->pClass->Setup (pdev, req); 
 80037e0:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80037e4:	689b      	ldr	r3, [r3, #8]
 80037e6:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 80037e8:	88eb      	ldrh	r3, [r5, #6]
 80037ea:	b95b      	cbnz	r3, 8003804 <USBD_StdItfReq+0x38>
         USBD_CtlSendStatus(pdev);
 80037ec:	4620      	mov	r0, r4
 80037ee:	f000 f8ad 	bl	800394c <USBD_CtlSendStatus>
 80037f2:	e007      	b.n	8003804 <USBD_StdItfReq+0x38>
  USBD_LL_StallEP(pdev , 0x80);
 80037f4:	2180      	movs	r1, #128	; 0x80
 80037f6:	4620      	mov	r0, r4
 80037f8:	f001 fb56 	bl	8004ea8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80037fc:	4620      	mov	r0, r4
 80037fe:	2100      	movs	r1, #0
 8003800:	f001 fb52 	bl	8004ea8 <USBD_LL_StallEP>
}
 8003804:	2000      	movs	r0, #0
 8003806:	bd38      	pop	{r3, r4, r5, pc}

08003808 <USBD_StdEPReq>:
{
 8003808:	b570      	push	{r4, r5, r6, lr}
  if ((req->bmRequest & 0x60) == 0x20)
 800380a:	780b      	ldrb	r3, [r1, #0]
{
 800380c:	4605      	mov	r5, r0
  if ((req->bmRequest & 0x60) == 0x20)
 800380e:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8003812:	2b20      	cmp	r3, #32
  ep_addr  = LOBYTE(req->wIndex);   
 8003814:	888a      	ldrh	r2, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 8003816:	d009      	beq.n	800382c <USBD_StdEPReq+0x24>
  switch (req->bRequest) 
 8003818:	784b      	ldrb	r3, [r1, #1]
 800381a:	460c      	mov	r4, r1
 800381c:	2b01      	cmp	r3, #1
 800381e:	b2d6      	uxtb	r6, r2
 8003820:	d026      	beq.n	8003870 <USBD_StdEPReq+0x68>
 8003822:	2b03      	cmp	r3, #3
 8003824:	d03c      	beq.n	80038a0 <USBD_StdEPReq+0x98>
 8003826:	b13b      	cbz	r3, 8003838 <USBD_StdEPReq+0x30>
}
 8003828:	2000      	movs	r0, #0
 800382a:	bd70      	pop	{r4, r5, r6, pc}
    pdev->pClass->Setup (pdev, req);
 800382c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003830:	689b      	ldr	r3, [r3, #8]
 8003832:	4798      	blx	r3
}
 8003834:	2000      	movs	r0, #0
 8003836:	bd70      	pop	{r4, r5, r6, pc}
    switch (pdev->dev_state) 
 8003838:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800383c:	2b02      	cmp	r3, #2
 800383e:	d048      	beq.n	80038d2 <USBD_StdEPReq+0xca>
 8003840:	2b03      	cmp	r3, #3
 8003842:	d13c      	bne.n	80038be <USBD_StdEPReq+0xb6>
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003844:	f006 047f 	and.w	r4, r6, #127	; 0x7f
 8003848:	eb00 1404 	add.w	r4, r0, r4, lsl #4
 800384c:	0613      	lsls	r3, r2, #24
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 800384e:	4631      	mov	r1, r6
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003850:	bf4c      	ite	mi
 8003852:	3414      	addmi	r4, #20
 8003854:	f504 7482 	addpl.w	r4, r4, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8003858:	f001 fb42 	bl	8004ee0 <USBD_LL_IsStallEP>
 800385c:	3800      	subs	r0, #0
 800385e:	bf18      	it	ne
 8003860:	2001      	movne	r0, #1
      USBD_CtlSendData (pdev,
 8003862:	4621      	mov	r1, r4
 8003864:	6020      	str	r0, [r4, #0]
 8003866:	2202      	movs	r2, #2
 8003868:	4628      	mov	r0, r5
 800386a:	f000 f84d 	bl	8003908 <USBD_CtlSendData>
      break;
 800386e:	e7db      	b.n	8003828 <USBD_StdEPReq+0x20>
    switch (pdev->dev_state) 
 8003870:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003874:	2b02      	cmp	r3, #2
 8003876:	d02c      	beq.n	80038d2 <USBD_StdEPReq+0xca>
 8003878:	2b03      	cmp	r3, #3
 800387a:	d120      	bne.n	80038be <USBD_StdEPReq+0xb6>
      if (req->wValue == USB_FEATURE_EP_HALT)
 800387c:	884b      	ldrh	r3, [r1, #2]
 800387e:	2b00      	cmp	r3, #0
 8003880:	d1d2      	bne.n	8003828 <USBD_StdEPReq+0x20>
        if ((ep_addr & 0x7F) != 0x00) 
 8003882:	0671      	lsls	r1, r6, #25
 8003884:	d008      	beq.n	8003898 <USBD_StdEPReq+0x90>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003886:	4631      	mov	r1, r6
 8003888:	f001 fb1c 	bl	8004ec4 <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 800388c:	f8d5 3214 	ldr.w	r3, [r5, #532]	; 0x214
 8003890:	4621      	mov	r1, r4
 8003892:	4628      	mov	r0, r5
 8003894:	689b      	ldr	r3, [r3, #8]
 8003896:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8003898:	4628      	mov	r0, r5
 800389a:	f000 f857 	bl	800394c <USBD_CtlSendStatus>
 800389e:	e7c3      	b.n	8003828 <USBD_StdEPReq+0x20>
    switch (pdev->dev_state) 
 80038a0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80038a4:	2b02      	cmp	r3, #2
 80038a6:	d014      	beq.n	80038d2 <USBD_StdEPReq+0xca>
 80038a8:	2b03      	cmp	r3, #3
 80038aa:	d108      	bne.n	80038be <USBD_StdEPReq+0xb6>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80038ac:	884b      	ldrh	r3, [r1, #2]
 80038ae:	2b00      	cmp	r3, #0
 80038b0:	d1ec      	bne.n	800388c <USBD_StdEPReq+0x84>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 80038b2:	0673      	lsls	r3, r6, #25
 80038b4:	d0ea      	beq.n	800388c <USBD_StdEPReq+0x84>
          USBD_LL_StallEP(pdev , ep_addr);
 80038b6:	4631      	mov	r1, r6
 80038b8:	f001 faf6 	bl	8004ea8 <USBD_LL_StallEP>
      pdev->pClass->Setup (pdev, req);   
 80038bc:	e7e6      	b.n	800388c <USBD_StdEPReq+0x84>
  USBD_LL_StallEP(pdev , 0x80);
 80038be:	2180      	movs	r1, #128	; 0x80
 80038c0:	4628      	mov	r0, r5
 80038c2:	f001 faf1 	bl	8004ea8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80038c6:	4628      	mov	r0, r5
 80038c8:	2100      	movs	r1, #0
 80038ca:	f001 faed 	bl	8004ea8 <USBD_LL_StallEP>
}
 80038ce:	2000      	movs	r0, #0
 80038d0:	bd70      	pop	{r4, r5, r6, pc}
      if ((ep_addr & 0x7F) != 0x00) 
 80038d2:	0672      	lsls	r2, r6, #25
 80038d4:	d0a8      	beq.n	8003828 <USBD_StdEPReq+0x20>
        USBD_LL_StallEP(pdev , ep_addr);
 80038d6:	4631      	mov	r1, r6
 80038d8:	f001 fae6 	bl	8004ea8 <USBD_LL_StallEP>
 80038dc:	e7a4      	b.n	8003828 <USBD_StdEPReq+0x20>
 80038de:	bf00      	nop

080038e0 <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 80038e0:	780b      	ldrb	r3, [r1, #0]
 80038e2:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 80038e4:	784b      	ldrb	r3, [r1, #1]
 80038e6:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 80038e8:	78ca      	ldrb	r2, [r1, #3]
 80038ea:	788b      	ldrb	r3, [r1, #2]
 80038ec:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80038f0:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 80038f2:	794a      	ldrb	r2, [r1, #5]
 80038f4:	790b      	ldrb	r3, [r1, #4]
 80038f6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80038fa:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 80038fc:	79ca      	ldrb	r2, [r1, #7]
 80038fe:	798b      	ldrb	r3, [r1, #6]
 8003900:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003904:	80c3      	strh	r3, [r0, #6]
}
 8003906:	4770      	bx	lr

08003908 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8003908:	b538      	push	{r3, r4, r5, lr}
 800390a:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 800390c:	2502      	movs	r5, #2
{
 800390e:	460a      	mov	r2, r1
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 8003910:	e9c0 3306 	strd	r3, r3, [r0, #24]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003914:	2100      	movs	r1, #0
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8003916:	f8c0 51f4 	str.w	r5, [r0, #500]	; 0x1f4
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 800391a:	f001 faff 	bl	8004f1c <USBD_LL_Transmit>
  
  return USBD_OK;
}
 800391e:	2000      	movs	r0, #0
 8003920:	bd38      	pop	{r3, r4, r5, pc}
 8003922:	bf00      	nop

08003924 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8003924:	b510      	push	{r4, lr}
 8003926:	460c      	mov	r4, r1
 8003928:	4613      	mov	r3, r2
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 800392a:	2100      	movs	r1, #0
 800392c:	4622      	mov	r2, r4
 800392e:	f001 faf5 	bl	8004f1c <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003932:	2000      	movs	r0, #0
 8003934:	bd10      	pop	{r4, pc}
 8003936:	bf00      	nop

08003938 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003938:	b510      	push	{r4, lr}
 800393a:	460c      	mov	r4, r1
 800393c:	4613      	mov	r3, r2

  USBD_LL_PrepareReceive (pdev,
 800393e:	2100      	movs	r1, #0
 8003940:	4622      	mov	r2, r4
 8003942:	f001 faf9 	bl	8004f38 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8003946:	2000      	movs	r0, #0
 8003948:	bd10      	pop	{r4, pc}
 800394a:	bf00      	nop

0800394c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 800394c:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800394e:	2204      	movs	r2, #4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8003950:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003952:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8003956:	4619      	mov	r1, r3
 8003958:	461a      	mov	r2, r3
 800395a:	f001 fadf 	bl	8004f1c <USBD_LL_Transmit>
  
  return USBD_OK;
}
 800395e:	2000      	movs	r0, #0
 8003960:	bd08      	pop	{r3, pc}
 8003962:	bf00      	nop

08003964 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8003964:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8003966:	2205      	movs	r2, #5
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8003968:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 800396a:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  USBD_LL_PrepareReceive ( pdev,
 800396e:	4619      	mov	r1, r3
 8003970:	461a      	mov	r2, r3
 8003972:	f001 fae1 	bl	8004f38 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8003976:	2000      	movs	r0, #0
 8003978:	bd08      	pop	{r3, pc}
 800397a:	bf00      	nop

0800397c <stepperEnable>:
}

// Enable/disable stepper motors
static void stepperEnable (axes_signals_t enable)
{
    enable.mask ^= settings.steppers.enable_invert.mask;
 800397c:	4b04      	ldr	r3, [pc, #16]	; (8003990 <stepperEnable+0x14>)
#if TRINAMIC_ENABLE && TRINAMIC_I2C
    axes_signals_t tmc_enable = trinamic_stepper_enable(enable);
#else
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 800397e:	4a05      	ldr	r2, [pc, #20]	; (8003994 <stepperEnable+0x18>)
    enable.mask ^= settings.steppers.enable_invert.mask;
 8003980:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
 8003984:	4043      	eors	r3, r0
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 8003986:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800398a:	7013      	strb	r3, [r2, #0]
#endif
}
 800398c:	4770      	bx	lr
 800398e:	bf00      	nop
 8003990:	20002620 	.word	0x20002620
 8003994:	422181a4 	.word	0x422181a4

08003998 <stepperWakeUp>:
// Starts stepper driver ISR timer and forces a stepper driver interrupt callback
static void stepperWakeUp (void)
{
    stepperEnable((axes_signals_t){AXES_BITMASK});

    STEPPER_TIMER->ARR = 5000; // delay to allow drivers time to wake up
 8003998:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    STEPPER_TIMER->EGR = TIM_EGR_UG;
 800399c:	2101      	movs	r1, #1
    STEPPER_TIMER->ARR = 5000; // delay to allow drivers time to wake up
 800399e:	f241 3088 	movw	r0, #5000	; 0x1388
    enable.mask ^= settings.steppers.enable_invert.mask;
 80039a2:	4b08      	ldr	r3, [pc, #32]	; (80039c4 <stepperWakeUp+0x2c>)
{
 80039a4:	b410      	push	{r4}
    enable.mask ^= settings.steppers.enable_invert.mask;
 80039a6:	f893 30b6 	ldrb.w	r3, [r3, #182]	; 0xb6
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 80039aa:	4c07      	ldr	r4, [pc, #28]	; (80039c8 <stepperWakeUp+0x30>)
    enable.mask ^= settings.steppers.enable_invert.mask;
 80039ac:	f083 0307 	eor.w	r3, r3, #7
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 80039b0:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80039b4:	7023      	strb	r3, [r4, #0]
    STEPPER_TIMER->ARR = 5000; // delay to allow drivers time to wake up
 80039b6:	62d0      	str	r0, [r2, #44]	; 0x2c
    STEPPER_TIMER->EGR = TIM_EGR_UG;
 80039b8:	6151      	str	r1, [r2, #20]
    STEPPER_TIMER->CR1 |= TIM_CR1_CEN;
 80039ba:	6813      	ldr	r3, [r2, #0]

//    hal.stepper_interrupt_callback();   // and start the show
}
 80039bc:	bc10      	pop	{r4}
    STEPPER_TIMER->CR1 |= TIM_CR1_CEN;
 80039be:	430b      	orrs	r3, r1
 80039c0:	6013      	str	r3, [r2, #0]
}
 80039c2:	4770      	bx	lr
 80039c4:	20002620 	.word	0x20002620
 80039c8:	422181a4 	.word	0x422181a4

080039cc <stepperGoIdle>:

// Disables stepper driver interrupts
static void stepperGoIdle (bool clear_signals)
{
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 80039cc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    STEPPER_TIMER->CNT = 0;
 80039d0:	2100      	movs	r1, #0
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 80039d2:	681a      	ldr	r2, [r3, #0]
 80039d4:	f022 0201 	bic.w	r2, r2, #1
 80039d8:	601a      	str	r2, [r3, #0]
    STEPPER_TIMER->CNT = 0;
 80039da:	6259      	str	r1, [r3, #36]	; 0x24
}
 80039dc:	4770      	bx	lr
 80039de:	bf00      	nop

080039e0 <stepperCyclesPerTickPrescaled>:

// Sets up stepper driver interrupt timeout, "Normal" version
static void stepperCyclesPerTickPrescaled (uint32_t cycles_per_tick)
{
    // Set timer prescaling for normal step generation
    if (cycles_per_tick < (1UL << 16)) { // < 65536  (1.1ms @ 72MHz)
 80039e0:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
        STEPPER_TIMER->PSC = 0; // DIV 1
 80039e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    if (cycles_per_tick < (1UL << 16)) { // < 65536  (1.1ms @ 72MHz)
 80039e8:	d207      	bcs.n	80039fa <stepperCyclesPerTickPrescaled+0x1a>
        STEPPER_TIMER->PSC = 0; // DIV 1
 80039ea:	2200      	movs	r2, #0
 80039ec:	629a      	str	r2, [r3, #40]	; 0x28
        cycles_per_tick = cycles_per_tick >> 3;
    } else {
        STEPPER_TIMER->PSC = 63; // DIV64
        cycles_per_tick = cycles_per_tick >> 6;
    }
    STEPPER_TIMER->ARR = (uint16_t)(cycles_per_tick - 1);
 80039ee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80039f2:	3801      	subs	r0, #1
 80039f4:	b280      	uxth	r0, r0
 80039f6:	62d8      	str	r0, [r3, #44]	; 0x2c
}
 80039f8:	4770      	bx	lr
    } else if (cycles_per_tick < (1UL << 19)) { // < 524288 (8.8ms @ 72MHz)
 80039fa:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
        STEPPER_TIMER->PSC = 7; // DIV 8
 80039fe:	bf35      	itete	cc
 8003a00:	2207      	movcc	r2, #7
        STEPPER_TIMER->PSC = 63; // DIV64
 8003a02:	223f      	movcs	r2, #63	; 0x3f
        cycles_per_tick = cycles_per_tick >> 3;
 8003a04:	08c0      	lsrcc	r0, r0, #3
        cycles_per_tick = cycles_per_tick >> 6;
 8003a06:	0980      	lsrcs	r0, r0, #6
        STEPPER_TIMER->PSC = 63; // DIV64
 8003a08:	629a      	str	r2, [r3, #40]	; 0x28
        cycles_per_tick = cycles_per_tick >> 6;
 8003a0a:	e7f0      	b.n	80039ee <stepperCyclesPerTickPrescaled+0xe>

08003a0c <stepperPulseStart>:

// Sets stepper direction and pulse pins and starts a step pulse
// When delayed pulse the step register is written in the step delay interrupt handler
static void stepperPulseStart (stepper_t *stepper)
{
    if(stepper->new_block) {
 8003a0c:	7b03      	ldrb	r3, [r0, #12]
{
 8003a0e:	b430      	push	{r4, r5}
    if(stepper->new_block) {
 8003a10:	b15b      	cbz	r3, 8003a2a <stepperPulseStart+0x1e>
        stepper->new_block = false;
 8003a12:	2100      	movs	r1, #0
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8003a14:	4a0e      	ldr	r2, [pc, #56]	; (8003a50 <stepperPulseStart+0x44>)
 8003a16:	7b85      	ldrb	r5, [r0, #14]
 8003a18:	4c0e      	ldr	r4, [pc, #56]	; (8003a54 <stepperPulseStart+0x48>)
 8003a1a:	68d3      	ldr	r3, [r2, #12]
 8003a1c:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 8003a20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003a24:	4323      	orrs	r3, r4
        stepper->new_block = false;
 8003a26:	7301      	strb	r1, [r0, #12]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8003a28:	60d3      	str	r3, [r2, #12]
        stepperSetDirOutputs(stepper->dir_outbits);
    }

    if(stepper->step_outbits.value) {
 8003a2a:	7b42      	ldrb	r2, [r0, #13]
 8003a2c:	b172      	cbz	r2, 8003a4c <stepperPulseStart+0x40>
        stepperSetStepOutputs(stepper->step_outbits);
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003a2e:	2001      	movs	r0, #1
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8003a30:	4907      	ldr	r1, [pc, #28]	; (8003a50 <stepperPulseStart+0x44>)
 8003a32:	4c09      	ldr	r4, [pc, #36]	; (8003a58 <stepperPulseStart+0x4c>)
 8003a34:	68cb      	ldr	r3, [r1, #12]
 8003a36:	f854 4022 	ldr.w	r4, [r4, r2, lsl #2]
 8003a3a:	f023 030e 	bic.w	r3, r3, #14
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003a3e:	4a07      	ldr	r2, [pc, #28]	; (8003a5c <stepperPulseStart+0x50>)
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8003a40:	4323      	orrs	r3, r4
 8003a42:	60cb      	str	r3, [r1, #12]
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003a44:	6150      	str	r0, [r2, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 8003a46:	6813      	ldr	r3, [r2, #0]
 8003a48:	4303      	orrs	r3, r0
 8003a4a:	6013      	str	r3, [r2, #0]
    }
}
 8003a4c:	bc30      	pop	{r4, r5}
 8003a4e:	4770      	bx	lr
 8003a50:	40010800 	.word	0x40010800
 8003a54:	200000a8 	.word	0x200000a8
 8003a58:	20000118 	.word	0x20000118
 8003a5c:	40000400 	.word	0x40000400

08003a60 <limitsGetState>:
    uint32_t bits = LIMIT_PORT->IDR;
    signals.x = (bits & X_LIMIT_BIT) != 0;
    signals.y = (bits & Y_LIMIT_BIT) != 0;
    signals.z = (bits & Z_LIMIT_BIT) != 0;
#else
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 8003a60:	4b04      	ldr	r3, [pc, #16]	; (8003a74 <limitsGetState+0x14>)
#endif

    if (settings.limits.invert.mask)
 8003a62:	4a05      	ldr	r2, [pc, #20]	; (8003a78 <limitsGetState+0x18>)
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 8003a64:	689b      	ldr	r3, [r3, #8]
        signals.value ^= settings.limits.invert.mask;
 8003a66:	f892 00d5 	ldrb.w	r0, [r2, #213]	; 0xd5
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 8003a6a:	0a9b      	lsrs	r3, r3, #10
 8003a6c:	f003 031c 	and.w	r3, r3, #28

    return signals;
}
 8003a70:	4058      	eors	r0, r3
 8003a72:	4770      	bx	lr
 8003a74:	40010c00 	.word	0x40010c00
 8003a78:	20002620 	.word	0x20002620

08003a7c <systemGetState>:
    signals.reset = BITBAND_PERI(CONTROL_PORT->IDR, CONTROL_RESET_PIN);
    signals.safety_door_ajar = BITBAND_PERI(CONTROL_PORT->IDR, CONTROL_SAFETY_DOOR_PIN);
    signals.feed_hold = BITBAND_PERI(CONTROL_PORT->IDR, CONTROL_FEED_HOLD_PIN);
    signals.cycle_start = BITBAND_PERI(CONTROL_PORT->IDR, CONTROL_CYCLE_START_PIN);
#elif CONTROL_INMODE == GPIO_MAP
    uint32_t bits = CONTROL_PORT->IDR;
 8003a7c:	4b05      	ldr	r3, [pc, #20]	; (8003a94 <systemGetState+0x18>)
    signals.cycle_start = (bits & CONTROL_CYCLE_START_BIT) != 0;
#else
    signals.value = (uint8_t)((CONTROL_PORT->IDR & CONTROL_MASK) >> CONTROL_INMODE);
#endif

    if(settings.control_invert.mask)
 8003a7e:	4a06      	ldr	r2, [pc, #24]	; (8003a98 <systemGetState+0x1c>)
    uint32_t bits = CONTROL_PORT->IDR;
 8003a80:	689b      	ldr	r3, [r3, #8]
    if(settings.control_invert.mask)
 8003a82:	f892 2041 	ldrb.w	r2, [r2, #65]	; 0x41
    signals.reset = (bits & CONTROL_RESET_BIT) != 0;
 8003a86:	f3c3 1343 	ubfx	r3, r3, #5, #4
 8003a8a:	4618      	mov	r0, r3
    if(settings.control_invert.mask)
 8003a8c:	b10a      	cbz	r2, 8003a92 <systemGetState+0x16>
        signals.value ^= settings.control_invert.mask;
 8003a8e:	ea82 0003 	eor.w	r0, r2, r3

    return signals;
}
 8003a92:	4770      	bx	lr
 8003a94:	40010c00 	.word	0x40010c00
 8003a98:	20002620 	.word	0x20002620

08003a9c <probeConfigureInvertMask>:
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
static void probeConfigureInvertMask(bool is_probe_away)
{
  probe_invert = settings.flags.invert_probe_pin;

  if (is_probe_away)
 8003a9c:	b938      	cbnz	r0, 8003aae <probeConfigureInvertMask+0x12>
  probe_invert = settings.flags.invert_probe_pin;
 8003a9e:	4b06      	ldr	r3, [pc, #24]	; (8003ab8 <probeConfigureInvertMask+0x1c>)
 8003aa0:	4a06      	ldr	r2, [pc, #24]	; (8003abc <probeConfigureInvertMask+0x20>)
 8003aa2:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 8003aa6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8003aaa:	7013      	strb	r3, [r2, #0]
 8003aac:	4770      	bx	lr
	  probe_invert ^= PROBE_BIT;
 8003aae:	2201      	movs	r2, #1
 8003ab0:	4b02      	ldr	r3, [pc, #8]	; (8003abc <probeConfigureInvertMask+0x20>)
 8003ab2:	701a      	strb	r2, [r3, #0]
}
 8003ab4:	4770      	bx	lr
 8003ab6:	bf00      	nop
 8003ab8:	20002620 	.word	0x20002620
 8003abc:	200000c9 	.word	0x200000c9

08003ac0 <probeGetState>:

// Returns the probe pin state. Triggered = true.
bool probeGetState (void)
{
    return ((PROBE_PORT->IDR & PROBE_BIT) != 0)  ^ probe_invert;
 8003ac0:	4b03      	ldr	r3, [pc, #12]	; (8003ad0 <probeGetState+0x10>)
 8003ac2:	4a04      	ldr	r2, [pc, #16]	; (8003ad4 <probeGetState+0x14>)
 8003ac4:	689b      	ldr	r3, [r3, #8]
 8003ac6:	7810      	ldrb	r0, [r2, #0]
 8003ac8:	f3c3 13c0 	ubfx	r3, r3, #7, #1
}
 8003acc:	4058      	eors	r0, r3
 8003ace:	4770      	bx	lr
 8003ad0:	40010800 	.word	0x40010800
 8003ad4:	200000c9 	.word	0x200000c9

08003ad8 <spindleGetState>:
}

// Returns spindle state in a spindle_state_t variable
static spindle_state_t spindleGetState (void)
{
    spindle_state_t state = {0};
 8003ad8:	f04f 0000 	mov.w	r0, #0

    state.on = (SPINDLE_ENABLE_PORT->IDR & SPINDLE_ENABLE_BIT) != 0;
 8003adc:	490d      	ldr	r1, [pc, #52]	; (8003b14 <spindleGetState+0x3c>)
    state.ccw = hal.driver_cap.spindle_dir && (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 8003ade:	4b0e      	ldr	r3, [pc, #56]	; (8003b18 <spindleGetState+0x40>)
    state.on = (SPINDLE_ENABLE_PORT->IDR & SPINDLE_ENABLE_BIT) != 0;
 8003ae0:	688a      	ldr	r2, [r1, #8]
    state.ccw = hal.driver_cap.spindle_dir && (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 8003ae2:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
    state.on = (SPINDLE_ENABLE_PORT->IDR & SPINDLE_ENABLE_BIT) != 0;
 8003ae6:	f3c2 0240 	ubfx	r2, r2, #1, #1
    state.ccw = hal.driver_cap.spindle_dir && (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 8003aea:	f013 0308 	ands.w	r3, r3, #8
 8003aee:	bf18      	it	ne
 8003af0:	688b      	ldrne	r3, [r1, #8]
    state.on = (SPINDLE_ENABLE_PORT->IDR & SPINDLE_ENABLE_BIT) != 0;
 8003af2:	f362 0000 	bfi	r0, r2, #0, #1
    state.value ^= settings.spindle.invert.mask;
 8003af6:	4909      	ldr	r1, [pc, #36]	; (8003b1c <spindleGetState+0x44>)
    if(pwmEnabled)
 8003af8:	4a09      	ldr	r2, [pc, #36]	; (8003b20 <spindleGetState+0x48>)
    state.value ^= settings.spindle.invert.mask;
 8003afa:	f891 10b2 	ldrb.w	r1, [r1, #178]	; 0xb2
    state.ccw = hal.driver_cap.spindle_dir && (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 8003afe:	bf18      	it	ne
 8003b00:	f003 0301 	andne.w	r3, r3, #1
    if(pwmEnabled)
 8003b04:	7812      	ldrb	r2, [r2, #0]
    state.ccw = hal.driver_cap.spindle_dir && (SPINDLE_DIRECTION_PORT->IDR & SPINDLE_DIRECTION_BIT) != 0;
 8003b06:	f363 0041 	bfi	r0, r3, #1, #1
    state.value ^= settings.spindle.invert.mask;
 8003b0a:	4048      	eors	r0, r1
    if(pwmEnabled)
 8003b0c:	b10a      	cbz	r2, 8003b12 <spindleGetState+0x3a>
        state.value = On;
 8003b0e:	f04f 0001 	mov.w	r0, #1

    return state;
}
 8003b12:	4770      	bx	lr
 8003b14:	40010c00 	.word	0x40010c00
 8003b18:	200024bc 	.word	0x200024bc
 8003b1c:	20002620 	.word	0x20002620
 8003b20:	200000ca 	.word	0x200000ca

08003b24 <coolantSetState>:
// end spindle code

// Start/stop coolant (and mist if enabled)
static void coolantSetState (coolant_state_t mode)
{
    mode.value ^= settings.coolant_invert.mask;
 8003b24:	4b06      	ldr	r3, [pc, #24]	; (8003b40 <coolantSetState+0x1c>)
    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = mode.flood;
 8003b26:	4907      	ldr	r1, [pc, #28]	; (8003b44 <coolantSetState+0x20>)
    mode.value ^= settings.coolant_invert.mask;
 8003b28:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = mode.mist;
 8003b2c:	4a06      	ldr	r2, [pc, #24]	; (8003b48 <coolantSetState+0x24>)
    mode.value ^= settings.coolant_invert.mask;
 8003b2e:	4058      	eors	r0, r3
    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = mode.flood;
 8003b30:	f3c0 0300 	ubfx	r3, r0, #0, #1
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = mode.mist;
 8003b34:	f3c0 0040 	ubfx	r0, r0, #1, #1
    BITBAND_PERI(COOLANT_FLOOD_PORT->ODR, COOLANT_FLOOD_PIN) = mode.flood;
 8003b38:	700b      	strb	r3, [r1, #0]
    BITBAND_PERI(COOLANT_MIST_PORT->ODR, COOLANT_MIST_PIN) = mode.mist;
 8003b3a:	7010      	strb	r0, [r2, #0]
}
 8003b3c:	4770      	bx	lr
 8003b3e:	bf00      	nop
 8003b40:	20002620 	.word	0x20002620
 8003b44:	4221818c 	.word	0x4221818c
 8003b48:	42218190 	.word	0x42218190

08003b4c <coolantGetState>:

// Returns coolant state in a coolant_state_t variable
static coolant_state_t coolantGetState (void)
{
    coolant_state_t state = {0};
 8003b4c:	f04f 0300 	mov.w	r3, #0

    state.flood = (COOLANT_FLOOD_PORT->IDR & COOLANT_FLOOD_BIT) != 0;
 8003b50:	4a07      	ldr	r2, [pc, #28]	; (8003b70 <coolantGetState+0x24>)
    state.mist  = (COOLANT_MIST_PORT->IDR & COOLANT_MIST_BIT) != 0;
    state.value ^= settings.coolant_invert.mask;
 8003b52:	4808      	ldr	r0, [pc, #32]	; (8003b74 <coolantGetState+0x28>)
    state.flood = (COOLANT_FLOOD_PORT->IDR & COOLANT_FLOOD_BIT) != 0;
 8003b54:	6891      	ldr	r1, [r2, #8]
    state.mist  = (COOLANT_MIST_PORT->IDR & COOLANT_MIST_BIT) != 0;
 8003b56:	6892      	ldr	r2, [r2, #8]
    state.flood = (COOLANT_FLOOD_PORT->IDR & COOLANT_FLOOD_BIT) != 0;
 8003b58:	f3c1 01c0 	ubfx	r1, r1, #3, #1
    state.value ^= settings.coolant_invert.mask;
 8003b5c:	f890 0043 	ldrb.w	r0, [r0, #67]	; 0x43
    state.mist  = (COOLANT_MIST_PORT->IDR & COOLANT_MIST_BIT) != 0;
 8003b60:	f3c2 1200 	ubfx	r2, r2, #4, #1
    state.flood = (COOLANT_FLOOD_PORT->IDR & COOLANT_FLOOD_BIT) != 0;
 8003b64:	f361 0300 	bfi	r3, r1, #0, #1
    state.mist  = (COOLANT_MIST_PORT->IDR & COOLANT_MIST_BIT) != 0;
 8003b68:	f362 0341 	bfi	r3, r2, #1, #1

    return state;
}
 8003b6c:	4058      	eors	r0, r3
 8003b6e:	4770      	bx	lr
 8003b70:	40010c00 	.word	0x40010c00
 8003b74:	20002620 	.word	0x20002620

08003b78 <bitsSetAtomic>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003b78:	b672      	cpsid	i

// Helper functions for setting/clearing/inverting individual bits atomically (uninterruptable)
static void bitsSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
    __disable_irq();
    *ptr |= bits;
 8003b7a:	6803      	ldr	r3, [r0, #0]
 8003b7c:	4319      	orrs	r1, r3
 8003b7e:	6001      	str	r1, [r0, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8003b80:	b662      	cpsie	i
    __enable_irq();
}
 8003b82:	4770      	bx	lr

08003b84 <bitsClearAtomic>:

static uint_fast16_t bitsClearAtomic (volatile uint_fast16_t *ptr, uint_fast16_t bits)
{
 8003b84:	4603      	mov	r3, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8003b86:	b672      	cpsid	i
    __disable_irq();
    uint_fast16_t prev = *ptr;
 8003b88:	6800      	ldr	r0, [r0, #0]
    *ptr &= ~bits;
 8003b8a:	681a      	ldr	r2, [r3, #0]
 8003b8c:	ea22 0101 	bic.w	r1, r2, r1
 8003b90:	6019      	str	r1, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8003b92:	b662      	cpsie	i
    __enable_irq();
    return prev;
}
 8003b94:	4770      	bx	lr
 8003b96:	bf00      	nop

08003b98 <valueSetAtomic>:

static uint_fast16_t valueSetAtomic (volatile uint_fast16_t *ptr, uint_fast16_t value)
{
 8003b98:	4603      	mov	r3, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8003b9a:	b672      	cpsid	i
    __disable_irq();
    uint_fast16_t prev = *ptr;
 8003b9c:	6800      	ldr	r0, [r0, #0]
    *ptr = value;
 8003b9e:	6019      	str	r1, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8003ba0:	b662      	cpsie	i
    __enable_irq();
    return prev;
}
 8003ba2:	4770      	bx	lr

08003ba4 <spindleGetPWM>:
{
 8003ba4:	4601      	mov	r1, r0
    return spindle_compute_pwm_value(&spindle_pwm, rpm, false);
 8003ba6:	2200      	movs	r2, #0
 8003ba8:	4801      	ldr	r0, [pc, #4]	; (8003bb0 <spindleGetPWM+0xc>)
 8003baa:	f00b b98f 	b.w	800eecc <spindle_compute_pwm_value>
 8003bae:	bf00      	nop
 8003bb0:	200000cc 	.word	0x200000cc

08003bb4 <driver_delay>:
    if((delay.ms = ms) > 0) {
 8003bb4:	4b0a      	ldr	r3, [pc, #40]	; (8003be0 <driver_delay+0x2c>)
 8003bb6:	6018      	str	r0, [r3, #0]
 8003bb8:	b178      	cbz	r0, 8003bda <driver_delay+0x26>
        SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 8003bba:	4a0a      	ldr	r2, [pc, #40]	; (8003be4 <driver_delay+0x30>)
        if(!(delay.callback = callback))
 8003bbc:	6059      	str	r1, [r3, #4]
        SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 8003bbe:	6810      	ldr	r0, [r2, #0]
 8003bc0:	f020 0001 	bic.w	r0, r0, #1
 8003bc4:	6010      	str	r0, [r2, #0]
        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
 8003bc6:	6810      	ldr	r0, [r2, #0]
 8003bc8:	f040 0001 	orr.w	r0, r0, #1
 8003bcc:	6010      	str	r0, [r2, #0]
        if(!(delay.callback = callback))
 8003bce:	b101      	cbz	r1, 8003bd2 <driver_delay+0x1e>
}
 8003bd0:	4770      	bx	lr
            while(delay.ms);
 8003bd2:	681a      	ldr	r2, [r3, #0]
 8003bd4:	2a00      	cmp	r2, #0
 8003bd6:	d1fc      	bne.n	8003bd2 <driver_delay+0x1e>
 8003bd8:	4770      	bx	lr
    } else if(callback)
 8003bda:	2900      	cmp	r1, #0
 8003bdc:	d0f8      	beq.n	8003bd0 <driver_delay+0x1c>
        callback();
 8003bde:	4708      	bx	r1
 8003be0:	20000008 	.word	0x20000008
 8003be4:	e000e010 	.word	0xe000e010

08003be8 <stepperPulseStartDelayed>:
    if(stepper->new_block) {
 8003be8:	7b03      	ldrb	r3, [r0, #12]
{
 8003bea:	b430      	push	{r4, r5}
    if(stepper->new_block) {
 8003bec:	b15b      	cbz	r3, 8003c06 <stepperPulseStartDelayed+0x1e>
        stepper->new_block = false;
 8003bee:	2100      	movs	r1, #0
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8003bf0:	4a0b      	ldr	r2, [pc, #44]	; (8003c20 <stepperPulseStartDelayed+0x38>)
 8003bf2:	7b85      	ldrb	r5, [r0, #14]
 8003bf4:	4c0b      	ldr	r4, [pc, #44]	; (8003c24 <stepperPulseStartDelayed+0x3c>)
 8003bf6:	68d3      	ldr	r3, [r2, #12]
 8003bf8:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
 8003bfc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003c00:	4323      	orrs	r3, r4
        stepper->new_block = false;
 8003c02:	7301      	strb	r1, [r0, #12]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8003c04:	60d3      	str	r3, [r2, #12]
    if(stepper->step_outbits.value) {
 8003c06:	7b43      	ldrb	r3, [r0, #13]
 8003c08:	b13b      	cbz	r3, 8003c1a <stepperPulseStartDelayed+0x32>
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003c0a:	2101      	movs	r1, #1
 8003c0c:	4a06      	ldr	r2, [pc, #24]	; (8003c28 <stepperPulseStartDelayed+0x40>)
        next_step_outbits = stepper->step_outbits; // Store out_bits
 8003c0e:	4807      	ldr	r0, [pc, #28]	; (8003c2c <stepperPulseStartDelayed+0x44>)
 8003c10:	7003      	strb	r3, [r0, #0]
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003c12:	6151      	str	r1, [r2, #20]
        PULSE_TIMER->CR1 |= TIM_CR1_CEN;
 8003c14:	6813      	ldr	r3, [r2, #0]
 8003c16:	430b      	orrs	r3, r1
 8003c18:	6013      	str	r3, [r2, #0]
}
 8003c1a:	bc30      	pop	{r4, r5}
 8003c1c:	4770      	bx	lr
 8003c1e:	bf00      	nop
 8003c20:	40010800 	.word	0x40010800
 8003c24:	200000a8 	.word	0x200000a8
 8003c28:	40000400 	.word	0x40000400
 8003c2c:	200000c8 	.word	0x200000c8

08003c30 <limitsEnable>:
    if(on && settings.limits.flags.hard_enabled) {
 8003c30:	b170      	cbz	r0, 8003c50 <limitsEnable+0x20>
 8003c32:	4b0a      	ldr	r3, [pc, #40]	; (8003c5c <limitsEnable+0x2c>)
 8003c34:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
 8003c38:	07db      	lsls	r3, r3, #31
 8003c3a:	d509      	bpl.n	8003c50 <limitsEnable+0x20>
        EXTI->PR |= LIMIT_MASK;     // Clear any pending limit interrupts
 8003c3c:	4b08      	ldr	r3, [pc, #32]	; (8003c60 <limitsEnable+0x30>)
 8003c3e:	695a      	ldr	r2, [r3, #20]
 8003c40:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
 8003c44:	615a      	str	r2, [r3, #20]
        EXTI->IMR |= LIMIT_MASK;    // and enable
 8003c46:	681a      	ldr	r2, [r3, #0]
 8003c48:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
 8003c4c:	601a      	str	r2, [r3, #0]
}
 8003c4e:	4770      	bx	lr
        EXTI->IMR &= ~LIMIT_MASK;
 8003c50:	4a03      	ldr	r2, [pc, #12]	; (8003c60 <limitsEnable+0x30>)
 8003c52:	6813      	ldr	r3, [r2, #0]
 8003c54:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003c58:	6013      	str	r3, [r2, #0]
}
 8003c5a:	4770      	bx	lr
 8003c5c:	20002620 	.word	0x20002620
 8003c60:	40010400 	.word	0x40010400

08003c64 <spindleSetState>:
    if (!state.on)
 8003c64:	07c2      	lsls	r2, r0, #31
 8003c66:	d407      	bmi.n	8003c78 <spindleSetState+0x14>
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 8003c68:	4b0e      	ldr	r3, [pc, #56]	; (8003ca4 <spindleSetState+0x40>)
 8003c6a:	4a0f      	ldr	r2, [pc, #60]	; (8003ca8 <spindleSetState+0x44>)
 8003c6c:	f893 30b2 	ldrb.w	r3, [r3, #178]	; 0xb2
 8003c70:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8003c74:	7013      	strb	r3, [r2, #0]
}
 8003c76:	4770      	bx	lr
    if(hal.driver_cap.spindle_dir)
 8003c78:	4b0c      	ldr	r3, [pc, #48]	; (8003cac <spindleSetState+0x48>)
        BITBAND_PERI(SPINDLE_DIRECTION_PORT->ODR, SPINDLE_DIRECTION_PIN) = ccw ^ settings.spindle.invert.ccw;
 8003c7a:	4a0a      	ldr	r2, [pc, #40]	; (8003ca4 <spindleSetState+0x40>)
    if(hal.driver_cap.spindle_dir)
 8003c7c:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 8003c80:	071b      	lsls	r3, r3, #28
 8003c82:	d506      	bpl.n	8003c92 <spindleSetState+0x2e>
        BITBAND_PERI(SPINDLE_DIRECTION_PORT->ODR, SPINDLE_DIRECTION_PIN) = ccw ^ settings.spindle.invert.ccw;
 8003c84:	f892 30b2 	ldrb.w	r3, [r2, #178]	; 0xb2
 8003c88:	4909      	ldr	r1, [pc, #36]	; (8003cb0 <spindleSetState+0x4c>)
 8003c8a:	4058      	eors	r0, r3
 8003c8c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8003c90:	7008      	strb	r0, [r1, #0]
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = !settings.spindle.invert.on;
 8003c92:	f892 30b2 	ldrb.w	r3, [r2, #178]	; 0xb2
 8003c96:	4a04      	ldr	r2, [pc, #16]	; (8003ca8 <spindleSetState+0x44>)
 8003c98:	43db      	mvns	r3, r3
 8003c9a:	f003 0301 	and.w	r3, r3, #1
 8003c9e:	7013      	strb	r3, [r2, #0]
}
 8003ca0:	4770      	bx	lr
 8003ca2:	bf00      	nop
 8003ca4:	20002620 	.word	0x20002620
 8003ca8:	42218184 	.word	0x42218184
 8003cac:	200024bc 	.word	0x200024bc
 8003cb0:	42218180 	.word	0x42218180

08003cb4 <spindle_set_speed>:
    if (pwm_value == spindle_pwm.off_value) {
 8003cb4:	4b1b      	ldr	r3, [pc, #108]	; (8003d24 <spindle_set_speed+0x70>)
 8003cb6:	685a      	ldr	r2, [r3, #4]
 8003cb8:	4282      	cmp	r2, r0
 8003cba:	d013      	beq.n	8003ce4 <spindle_set_speed+0x30>
        if(!pwmEnabled)
 8003cbc:	4a1a      	ldr	r2, [pc, #104]	; (8003d28 <spindle_set_speed+0x74>)
 8003cbe:	7813      	ldrb	r3, [r2, #0]
 8003cc0:	b93b      	cbnz	r3, 8003cd2 <spindle_set_speed+0x1e>
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = !settings.spindle.invert.on;
 8003cc2:	4b1a      	ldr	r3, [pc, #104]	; (8003d2c <spindle_set_speed+0x78>)
 8003cc4:	491a      	ldr	r1, [pc, #104]	; (8003d30 <spindle_set_speed+0x7c>)
 8003cc6:	f893 30b2 	ldrb.w	r3, [r3, #178]	; 0xb2
 8003cca:	43db      	mvns	r3, r3
 8003ccc:	f003 0301 	and.w	r3, r3, #1
 8003cd0:	700b      	strb	r3, [r1, #0]
        pwmEnabled = true;
 8003cd2:	2101      	movs	r1, #1
        SPINDLE_PWM_TIMER->CCR1 = pwm_value;
 8003cd4:	4b17      	ldr	r3, [pc, #92]	; (8003d34 <spindle_set_speed+0x80>)
        pwmEnabled = true;
 8003cd6:	7011      	strb	r1, [r2, #0]
        SPINDLE_PWM_TIMER->CCR1 = pwm_value;
 8003cd8:	6358      	str	r0, [r3, #52]	; 0x34
        SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 8003cda:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003cdc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003ce0:	645a      	str	r2, [r3, #68]	; 0x44
 8003ce2:	4770      	bx	lr
{
 8003ce4:	b410      	push	{r4}
        pwmEnabled = false;
 8003ce6:	2400      	movs	r4, #0
        if(settings.spindle.disable_with_zero_speed)
 8003ce8:	4a10      	ldr	r2, [pc, #64]	; (8003d2c <spindle_set_speed+0x78>)
        pwmEnabled = false;
 8003cea:	480f      	ldr	r0, [pc, #60]	; (8003d28 <spindle_set_speed+0x74>)
        if(settings.spindle.disable_with_zero_speed)
 8003cec:	f892 10b3 	ldrb.w	r1, [r2, #179]	; 0xb3
        pwmEnabled = false;
 8003cf0:	7004      	strb	r4, [r0, #0]
        if(settings.spindle.disable_with_zero_speed)
 8003cf2:	b129      	cbz	r1, 8003d00 <spindle_set_speed+0x4c>
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 8003cf4:	f892 20b2 	ldrb.w	r2, [r2, #178]	; 0xb2
 8003cf8:	490d      	ldr	r1, [pc, #52]	; (8003d30 <spindle_set_speed+0x7c>)
 8003cfa:	f3c2 0200 	ubfx	r2, r2, #0, #1
 8003cfe:	700a      	strb	r2, [r1, #0]
        if(spindle_pwm.always_on) {
 8003d00:	7d5a      	ldrb	r2, [r3, #21]
 8003d02:	b932      	cbnz	r2, 8003d12 <spindle_set_speed+0x5e>
        	SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
 8003d04:	4a0b      	ldr	r2, [pc, #44]	; (8003d34 <spindle_set_speed+0x80>)
}
 8003d06:	bc10      	pop	{r4}
        	SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
 8003d08:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8003d0a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003d0e:	6453      	str	r3, [r2, #68]	; 0x44
}
 8003d10:	4770      	bx	lr
            SPINDLE_PWM_TIMER->CCR1 = spindle_pwm.off_value;
 8003d12:	685a      	ldr	r2, [r3, #4]
 8003d14:	4b07      	ldr	r3, [pc, #28]	; (8003d34 <spindle_set_speed+0x80>)
}
 8003d16:	bc10      	pop	{r4}
            SPINDLE_PWM_TIMER->CCR1 = spindle_pwm.off_value;
 8003d18:	635a      	str	r2, [r3, #52]	; 0x34
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 8003d1a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8003d1c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003d20:	645a      	str	r2, [r3, #68]	; 0x44
}
 8003d22:	4770      	bx	lr
 8003d24:	200000cc 	.word	0x200000cc
 8003d28:	200000ca 	.word	0x200000ca
 8003d2c:	20002620 	.word	0x20002620
 8003d30:	42218184 	.word	0x42218184
 8003d34:	40012c00 	.word	0x40012c00

08003d38 <settings_changed.part.0>:

// Configures peripherals when settings are initialized or changed
void settings_changed (settings_t *settings)
 8003d38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003d3c:	4604      	mov	r4, r0

    if(IOInitDone) {

        GPIO_InitTypeDef GPIO_Init;

        GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 8003d3e:	2003      	movs	r0, #3
    enable.mask ^= settings.steppers.enable_invert.mask;
 8003d40:	4ac0      	ldr	r2, [pc, #768]	; (8004044 <settings_changed.part.0+0x30c>)
 8003d42:	f894 30b7 	ldrb.w	r3, [r4, #183]	; 0xb7
 8003d46:	f892 20b6 	ldrb.w	r2, [r2, #182]	; 0xb6
        trinamic_configure();
      #endif

        stepperEnable(settings->steppers.deenergize);

        if(hal.driver_cap.variable_spindle) {
 8003d4a:	4ebf      	ldr	r6, [pc, #764]	; (8004048 <settings_changed.part.0+0x310>)
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 8003d4c:	49bf      	ldr	r1, [pc, #764]	; (800404c <settings_changed.part.0+0x314>)
    enable.mask ^= settings.steppers.enable_invert.mask;
 8003d4e:	4053      	eors	r3, r2
        if(hal.driver_cap.variable_spindle) {
 8003d50:	f896 2144 	ldrb.w	r2, [r6, #324]	; 0x144
void settings_changed (settings_t *settings)
 8003d54:	b08a      	sub	sp, #40	; 0x28
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 8003d56:	f3c3 0300 	ubfx	r3, r3, #0, #1
        GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 8003d5a:	9003      	str	r0, [sp, #12]
    BITBAND_PERI(STEPPERS_DISABLE_PORT->ODR, STEPPERS_DISABLE_PIN) = enable.x;
 8003d5c:	700b      	strb	r3, [r1, #0]
        if(hal.driver_cap.variable_spindle) {
 8003d5e:	0791      	lsls	r1, r2, #30
 8003d60:	f140 8131 	bpl.w	8003fc6 <settings_changed.part.0+0x28e>

        	hal.spindle_set_state = spindleSetStateVariable;

            SPINDLE_PWM_TIMER->CR1 &= ~TIM_CR1_CEN;
 8003d64:	4aba      	ldr	r2, [pc, #744]	; (8004050 <settings_changed.part.0+0x318>)
        	hal.spindle_set_state = spindleSetStateVariable;
 8003d66:	4fbb      	ldr	r7, [pc, #748]	; (8004054 <settings_changed.part.0+0x31c>)
            SPINDLE_PWM_TIMER->CR1 &= ~TIM_CR1_CEN;
 8003d68:	6813      	ldr	r3, [r2, #0]

        	spindle_precompute_pwm_values(&spindle_pwm, SystemCoreClock / (settings->spindle.pwm_freq > 200.0f ? 1 : 25));
 8003d6a:	4dbb      	ldr	r5, [pc, #748]	; (8004058 <settings_changed.part.0+0x320>)
            SPINDLE_PWM_TIMER->CR1 &= ~TIM_CR1_CEN;
 8003d6c:	f023 0301 	bic.w	r3, r3, #1
 8003d70:	6013      	str	r3, [r2, #0]
        	spindle_precompute_pwm_values(&spindle_pwm, SystemCoreClock / (settings->spindle.pwm_freq > 200.0f ? 1 : 25));
 8003d72:	49ba      	ldr	r1, [pc, #744]	; (800405c <settings_changed.part.0+0x324>)
 8003d74:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
        	hal.spindle_set_state = spindleSetStateVariable;
 8003d76:	6337      	str	r7, [r6, #48]	; 0x30
        	spindle_precompute_pwm_values(&spindle_pwm, SystemCoreClock / (settings->spindle.pwm_freq > 200.0f ? 1 : 25));
 8003d78:	682d      	ldr	r5, [r5, #0]
 8003d7a:	f7fc fec7 	bl	8000b0c <__aeabi_fcmpgt>
 8003d7e:	2800      	cmp	r0, #0
 8003d80:	f000 818a 	beq.w	8004098 <settings_changed.part.0+0x360>

            TIM_Base_InitTypeDef timerInitStructure = {
 8003d84:	2700      	movs	r7, #0
        	spindle_precompute_pwm_values(&spindle_pwm, SystemCoreClock / (settings->spindle.pwm_freq > 200.0f ? 1 : 25));
 8003d86:	4629      	mov	r1, r5
 8003d88:	48b5      	ldr	r0, [pc, #724]	; (8004060 <settings_changed.part.0+0x328>)
 8003d8a:	f00b f82b 	bl	800ede4 <spindle_precompute_pwm_values>
                .Prescaler = (settings->spindle.pwm_freq > 200.0f ? 1 : 25) - 1,
 8003d8e:	49b3      	ldr	r1, [pc, #716]	; (800405c <settings_changed.part.0+0x324>)
 8003d90:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
            TIM_Base_InitTypeDef timerInitStructure = {
 8003d92:	e9cd 7707 	strd	r7, r7, [sp, #28]
 8003d96:	9705      	str	r7, [sp, #20]
 8003d98:	9709      	str	r7, [sp, #36]	; 0x24
                .Prescaler = (settings->spindle.pwm_freq > 200.0f ? 1 : 25) - 1,
 8003d9a:	f7fc feb7 	bl	8000b0c <__aeabi_fcmpgt>
 8003d9e:	42b8      	cmp	r0, r7
 8003da0:	bf14      	ite	ne
 8003da2:	463a      	movne	r2, r7
 8003da4:	2218      	moveq	r2, #24
                .CounterMode = TIM_COUNTERMODE_UP,
                .Period = spindle_pwm.period - 1,
 8003da6:	4bae      	ldr	r3, [pc, #696]	; (8004060 <settings_changed.part.0+0x328>)
                .ClockDivision = TIM_CLOCKDIVISION_DIV1,
                .RepetitionCounter = 0
            };

            TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 8003da8:	4da9      	ldr	r5, [pc, #676]	; (8004050 <settings_changed.part.0+0x318>)
                .Period = spindle_pwm.period - 1,
 8003daa:	681b      	ldr	r3, [r3, #0]
            TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 8003dac:	4628      	mov	r0, r5
                .Period = spindle_pwm.period - 1,
 8003dae:	3b01      	subs	r3, #1
            TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 8003db0:	a904      	add	r1, sp, #16
            TIM_Base_InitTypeDef timerInitStructure = {
 8003db2:	9204      	str	r2, [sp, #16]
 8003db4:	9306      	str	r3, [sp, #24]
            TIM_Base_SetConfig(SPINDLE_PWM_TIMER, &timerInitStructure);
 8003db6:	f7fe ff21 	bl	8002bfc <TIM_Base_SetConfig>

            SPINDLE_PWM_TIMER->CCER &= ~TIM_CCER_CC1E;
 8003dba:	6a2b      	ldr	r3, [r5, #32]
            SPINDLE_PWM_TIMER->CCMR1 &= ~(TIM_CCMR1_OC1M|TIM_CCMR1_CC1S);
            SPINDLE_PWM_TIMER->CCMR1 |= TIM_CCMR1_OC1M_1|TIM_CCMR1_OC1M_2;
            SPINDLE_PWM_TIMER->CCR1 = 0;
            if(settings->spindle.invert.pwm) {
 8003dbc:	f894 20b2 	ldrb.w	r2, [r4, #178]	; 0xb2
            SPINDLE_PWM_TIMER->CCER &= ~TIM_CCER_CC1E;
 8003dc0:	f023 0301 	bic.w	r3, r3, #1
 8003dc4:	622b      	str	r3, [r5, #32]
            SPINDLE_PWM_TIMER->CCMR1 &= ~(TIM_CCMR1_OC1M|TIM_CCMR1_CC1S);
 8003dc6:	69ab      	ldr	r3, [r5, #24]
            if(settings->spindle.invert.pwm) {
 8003dc8:	0752      	lsls	r2, r2, #29
            SPINDLE_PWM_TIMER->CCMR1 &= ~(TIM_CCMR1_OC1M|TIM_CCMR1_CC1S);
 8003dca:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8003dce:	61ab      	str	r3, [r5, #24]
            SPINDLE_PWM_TIMER->CCMR1 |= TIM_CCMR1_OC1M_1|TIM_CCMR1_OC1M_2;
 8003dd0:	69ab      	ldr	r3, [r5, #24]
 8003dd2:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8003dd6:	61ab      	str	r3, [r5, #24]
            SPINDLE_PWM_TIMER->CCR1 = 0;
 8003dd8:	636f      	str	r7, [r5, #52]	; 0x34
                SPINDLE_PWM_TIMER->CCER |= TIM_CCER_CC1P;
 8003dda:	6a2b      	ldr	r3, [r5, #32]
            if(settings->spindle.invert.pwm) {
 8003ddc:	f100 8154 	bmi.w	8004088 <settings_changed.part.0+0x350>
            	SPINDLE_PWM_TIMER->CR2 |= TIM_CR2_OIS1;
            } else {
                SPINDLE_PWM_TIMER->CCER &= ~TIM_CCER_CC1P;
 8003de0:	f023 0302 	bic.w	r3, r3, #2
 8003de4:	622b      	str	r3, [r5, #32]
            	SPINDLE_PWM_TIMER->CR2 &= ~TIM_CR2_OIS1;
 8003de6:	686b      	ldr	r3, [r5, #4]
 8003de8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003dec:	606b      	str	r3, [r5, #4]
            }
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_OSSR|TIM_BDTR_OSSI;
 8003dee:	4b98      	ldr	r3, [pc, #608]	; (8004050 <settings_changed.part.0+0x318>)
 8003df0:	f896 2144 	ldrb.w	r2, [r6, #324]	; 0x144
 8003df4:	6c59      	ldr	r1, [r3, #68]	; 0x44
            SPINDLE_PWM_TIMER->CR1 |= TIM_CR1_CEN;

        } else
            hal.spindle_set_state = spindleSetState;

        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds) {
 8003df6:	f012 0f20 	tst.w	r2, #32
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_OSSR|TIM_BDTR_OSSI;
 8003dfa:	f441 6140 	orr.w	r1, r1, #3072	; 0xc00
 8003dfe:	6459      	str	r1, [r3, #68]	; 0x44
            SPINDLE_PWM_TIMER->CCER |= TIM_CCER_CC1E;
 8003e00:	6a19      	ldr	r1, [r3, #32]
            hal.stepper_pulse_start = &stepperPulseStartDelayed;
            PULSE_TIMER->DIER |= TIM_DIER_CC1IE; // Enable CC1 interrupt
 8003e02:	4a98      	ldr	r2, [pc, #608]	; (8004064 <settings_changed.part.0+0x32c>)
            SPINDLE_PWM_TIMER->CCER |= TIM_CCER_CC1E;
 8003e04:	f041 0101 	orr.w	r1, r1, #1
 8003e08:	6219      	str	r1, [r3, #32]
            SPINDLE_PWM_TIMER->CR1 |= TIM_CR1_CEN;
 8003e0a:	6819      	ldr	r1, [r3, #0]
 8003e0c:	f041 0101 	orr.w	r1, r1, #1
 8003e10:	6019      	str	r1, [r3, #0]
        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds) {
 8003e12:	f894 10b9 	ldrb.w	r1, [r4, #185]	; 0xb9
 8003e16:	f040 80df 	bne.w	8003fd8 <settings_changed.part.0+0x2a0>
        } else {
            hal.stepper_pulse_start = &stepperPulseStart;
            PULSE_TIMER->DIER &= ~TIM_DIER_CC1IE; // Disable CC1 interrupt
 8003e1a:	68d3      	ldr	r3, [r2, #12]
            hal.stepper_pulse_start = &stepperPulseStart;
 8003e1c:	4892      	ldr	r0, [pc, #584]	; (8004068 <settings_changed.part.0+0x330>)
            PULSE_TIMER->DIER &= ~TIM_DIER_CC1IE; // Disable CC1 interrupt
 8003e1e:	f023 0302 	bic.w	r3, r3, #2
            hal.stepper_pulse_start = &stepperPulseStart;
 8003e22:	65b0      	str	r0, [r6, #88]	; 0x58
            PULSE_TIMER->DIER &= ~TIM_DIER_CC1IE; // Disable CC1 interrupt
 8003e24:	60d3      	str	r3, [r2, #12]
         *  Control pins config  *
         *************************/

        control_signals_t control_ire;

        control_ire.mask = ~(settings->control_disable_pullup.mask ^ settings->control_invert.mask);
 8003e26:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003e2a:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003e2e:	2601      	movs	r6, #1
        control_ire.mask = ~(settings->control_disable_pullup.mask ^ settings->control_invert.mask);
 8003e30:	405d      	eors	r5, r3
 8003e32:	43ed      	mvns	r5, r5
        PULSE_TIMER->ARR = settings->steppers.pulse_microseconds + settings->steppers.pulse_delay_microseconds - 1;
 8003e34:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
 8003e38:	4a8a      	ldr	r2, [pc, #552]	; (8004064 <settings_changed.part.0+0x32c>)
 8003e3a:	440b      	add	r3, r1
 8003e3c:	3b01      	subs	r3, #1

        HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);
 8003e3e:	2017      	movs	r0, #23
        PULSE_TIMER->ARR = settings->steppers.pulse_microseconds + settings->steppers.pulse_delay_microseconds - 1;
 8003e40:	62d3      	str	r3, [r2, #44]	; 0x2c
        PULSE_TIMER->CCR1 = settings->steppers.pulse_delay_microseconds;
 8003e42:	6351      	str	r1, [r2, #52]	; 0x34
        PULSE_TIMER->EGR = TIM_EGR_UG;
 8003e44:	6156      	str	r6, [r2, #20]
        HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);
 8003e46:	f7fc ff59 	bl	8000cfc <HAL_NVIC_DisableIRQ>
        control_ire.mask = ~(settings->control_disable_pullup.mask ^ settings->control_invert.mask);
 8003e4a:	b2ed      	uxtb	r5, r5

        GPIO_Init.Pin = CONTROL_RESET_BIT;
        GPIO_Init.Mode = control_ire.reset ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e4c:	4e87      	ldr	r6, [pc, #540]	; (800406c <settings_changed.part.0+0x334>)
 8003e4e:	4f88      	ldr	r7, [pc, #544]	; (8004070 <settings_changed.part.0+0x338>)
        GPIO_Init.Pull = settings->control_disable_pullup.reset ? GPIO_NOPULL : GPIO_PULLUP;
 8003e50:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
        GPIO_Init.Mode = control_ire.reset ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e54:	f015 0f01 	tst.w	r5, #1
 8003e58:	bf14      	ite	ne
 8003e5a:	4630      	movne	r0, r6
 8003e5c:	4638      	moveq	r0, r7
        GPIO_Init.Pull = settings->control_disable_pullup.reset ? GPIO_NOPULL : GPIO_PULLUP;
 8003e5e:	43db      	mvns	r3, r3
        GPIO_Init.Pin = CONTROL_RESET_BIT;
 8003e60:	2220      	movs	r2, #32
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e62:	4669      	mov	r1, sp
        GPIO_Init.Pull = settings->control_disable_pullup.reset ? GPIO_NOPULL : GPIO_PULLUP;
 8003e64:	f003 0301 	and.w	r3, r3, #1
        GPIO_Init.Mode = control_ire.reset ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e68:	9001      	str	r0, [sp, #4]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e6a:	4882      	ldr	r0, [pc, #520]	; (8004074 <settings_changed.part.0+0x33c>)
        GPIO_Init.Pull = settings->control_disable_pullup.reset ? GPIO_NOPULL : GPIO_PULLUP;
 8003e6c:	9302      	str	r3, [sp, #8]
        GPIO_Init.Pin = CONTROL_RESET_BIT;
 8003e6e:	9200      	str	r2, [sp, #0]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e70:	f7fd f968 	bl	8001144 <HAL_GPIO_Init>

        GPIO_Init.Pin = CONTROL_FEED_HOLD_BIT;
        GPIO_Init.Mode = control_ire.feed_hold ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e74:	f015 0f02 	tst.w	r5, #2
 8003e78:	bf14      	ite	ne
 8003e7a:	4631      	movne	r1, r6
 8003e7c:	4639      	moveq	r1, r7
        GPIO_Init.Pin = CONTROL_FEED_HOLD_BIT;
 8003e7e:	2240      	movs	r2, #64	; 0x40
        GPIO_Init.Pull = settings->control_disable_pullup.feed_hold ? GPIO_NOPULL : GPIO_PULLUP;
 8003e80:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e84:	487b      	ldr	r0, [pc, #492]	; (8004074 <settings_changed.part.0+0x33c>)
        GPIO_Init.Pull = settings->control_disable_pullup.feed_hold ? GPIO_NOPULL : GPIO_PULLUP;
 8003e86:	f083 0302 	eor.w	r3, r3, #2
 8003e8a:	f3c3 0340 	ubfx	r3, r3, #1, #1
        GPIO_Init.Mode = control_ire.feed_hold ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e8e:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e90:	4669      	mov	r1, sp
        GPIO_Init.Pull = settings->control_disable_pullup.feed_hold ? GPIO_NOPULL : GPIO_PULLUP;
 8003e92:	9302      	str	r3, [sp, #8]
        GPIO_Init.Pin = CONTROL_FEED_HOLD_BIT;
 8003e94:	9200      	str	r2, [sp, #0]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003e96:	f7fd f955 	bl	8001144 <HAL_GPIO_Init>

        GPIO_Init.Pin = CONTROL_CYCLE_START_BIT;
        GPIO_Init.Mode = control_ire.cycle_start ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003e9a:	f015 0f04 	tst.w	r5, #4
 8003e9e:	bf14      	ite	ne
 8003ea0:	4631      	movne	r1, r6
 8003ea2:	4639      	moveq	r1, r7
        GPIO_Init.Pin = CONTROL_CYCLE_START_BIT;
 8003ea4:	2280      	movs	r2, #128	; 0x80
        GPIO_Init.Pull = settings->control_disable_pullup.cycle_start ? GPIO_NOPULL : GPIO_PULLUP;
 8003ea6:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003eaa:	4872      	ldr	r0, [pc, #456]	; (8004074 <settings_changed.part.0+0x33c>)
        GPIO_Init.Pull = settings->control_disable_pullup.cycle_start ? GPIO_NOPULL : GPIO_PULLUP;
 8003eac:	f083 0304 	eor.w	r3, r3, #4
 8003eb0:	f3c3 0380 	ubfx	r3, r3, #2, #1
        GPIO_Init.Mode = control_ire.cycle_start ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003eb4:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003eb6:	4669      	mov	r1, sp
        GPIO_Init.Pull = settings->control_disable_pullup.cycle_start ? GPIO_NOPULL : GPIO_PULLUP;
 8003eb8:	9302      	str	r3, [sp, #8]
        GPIO_Init.Pin = CONTROL_CYCLE_START_BIT;
 8003eba:	9200      	str	r2, [sp, #0]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003ebc:	f7fd f942 	bl	8001144 <HAL_GPIO_Init>

        GPIO_Init.Pin = CONTROL_SAFETY_DOOR_BIT;
        GPIO_Init.Mode = control_ire.safety_door_ajar ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003ec0:	f015 0f08 	tst.w	r5, #8
 8003ec4:	bf14      	ite	ne
 8003ec6:	4635      	movne	r5, r6
 8003ec8:	463d      	moveq	r5, r7
        GPIO_Init.Pin = CONTROL_SAFETY_DOOR_BIT;
 8003eca:	f44f 7280 	mov.w	r2, #256	; 0x100
        GPIO_Init.Pull = settings->control_disable_pullup.safety_door_ajar ? GPIO_NOPULL : GPIO_PULLUP;
 8003ece:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003ed2:	4669      	mov	r1, sp
        GPIO_Init.Pull = settings->control_disable_pullup.safety_door_ajar ? GPIO_NOPULL : GPIO_PULLUP;
 8003ed4:	f083 0308 	eor.w	r3, r3, #8
 8003ed8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003edc:	4865      	ldr	r0, [pc, #404]	; (8004074 <settings_changed.part.0+0x33c>)
        GPIO_Init.Pull = settings->control_disable_pullup.safety_door_ajar ? GPIO_NOPULL : GPIO_PULLUP;
 8003ede:	e9cd 5301 	strd	r5, r3, [sp, #4]
        GPIO_Init.Pin = CONTROL_SAFETY_DOOR_BIT;
 8003ee2:	9200      	str	r2, [sp, #0]
        HAL_GPIO_Init(CONTROL_PORT, &GPIO_Init);
 8003ee4:	f7fd f92e 	bl	8001144 <HAL_GPIO_Init>

        __HAL_GPIO_EXTI_CLEAR_IT(CONTROL_MASK);
 8003ee8:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8003eec:	f8df 8194 	ldr.w	r8, [pc, #404]	; 8004084 <settings_changed.part.0+0x34c>

        HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 2);
 8003ef0:	2202      	movs	r2, #2
        __HAL_GPIO_EXTI_CLEAR_IT(CONTROL_MASK);
 8003ef2:	f8c8 3014 	str.w	r3, [r8, #20]
        HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 2);
 8003ef6:	2100      	movs	r1, #0
 8003ef8:	2017      	movs	r0, #23
 8003efa:	f7fc febb 	bl	8000c74 <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8003efe:	2017      	movs	r0, #23
 8003f00:	f7fc fef0 	bl	8000ce4 <HAL_NVIC_EnableIRQ>

        /***********************
         *  Limit pins config  *
         ***********************/

        if (settings->limits.flags.hard_enabled) {
 8003f04:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
 8003f08:	07db      	lsls	r3, r3, #31
 8003f0a:	d56f      	bpl.n	8003fec <settings_changed.part.0+0x2b4>

            axes_signals_t limit_ire;

            limit_ire.mask = ~(settings->limits.disable_pullup.mask ^ settings->limits.invert.mask);
 8003f0c:	f894 30d5 	ldrb.w	r3, [r4, #213]	; 0xd5
 8003f10:	f894 50d6 	ldrb.w	r5, [r4, #214]	; 0xd6

            HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 8003f14:	2028      	movs	r0, #40	; 0x28
            limit_ire.mask = ~(settings->limits.disable_pullup.mask ^ settings->limits.invert.mask);
 8003f16:	405d      	eors	r5, r3
 8003f18:	43ed      	mvns	r5, r5
            HAL_NVIC_DisableIRQ(EXTI15_10_IRQn);
 8003f1a:	f7fc feef 	bl	8000cfc <HAL_NVIC_DisableIRQ>
            limit_ire.mask = ~(settings->limits.disable_pullup.mask ^ settings->limits.invert.mask);
 8003f1e:	b2ed      	uxtb	r5, r5

            GPIO_Init.Pin = X_LIMIT_BIT;
            GPIO_Init.Mode = limit_ire.x ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003f20:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            GPIO_Init.Mode = limit_ire.x ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003f24:	f015 0f01 	tst.w	r5, #1
 8003f28:	bf14      	ite	ne
 8003f2a:	4631      	movne	r1, r6
 8003f2c:	4639      	moveq	r1, r7
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003f2e:	43db      	mvns	r3, r3
            GPIO_Init.Pin = X_LIMIT_BIT;
 8003f30:	f44f 5280 	mov.w	r2, #4096	; 0x1000
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003f34:	f003 0301 	and.w	r3, r3, #1
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f38:	484e      	ldr	r0, [pc, #312]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Mode = limit_ire.x ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003f3a:	9101      	str	r1, [sp, #4]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f3c:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003f3e:	9302      	str	r3, [sp, #8]
            GPIO_Init.Pin = X_LIMIT_BIT;
 8003f40:	9200      	str	r2, [sp, #0]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f42:	f7fd f8ff 	bl	8001144 <HAL_GPIO_Init>

            GPIO_Init.Pin = Y_LIMIT_BIT;
            GPIO_Init.Mode = limit_ire.y ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003f46:	f015 0f02 	tst.w	r5, #2
 8003f4a:	bf14      	ite	ne
 8003f4c:	4631      	movne	r1, r6
 8003f4e:	4639      	moveq	r1, r7
            GPIO_Init.Pin = Y_LIMIT_BIT;
 8003f50:	f44f 5200 	mov.w	r2, #8192	; 0x2000
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 8003f54:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f58:	4846      	ldr	r0, [pc, #280]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 8003f5a:	f083 0302 	eor.w	r3, r3, #2
 8003f5e:	f3c3 0340 	ubfx	r3, r3, #1, #1
            GPIO_Init.Mode = limit_ire.y ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003f62:	9101      	str	r1, [sp, #4]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f64:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 8003f66:	9302      	str	r3, [sp, #8]
            GPIO_Init.Pin = Y_LIMIT_BIT;
 8003f68:	9200      	str	r2, [sp, #0]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f6a:	f7fd f8eb 	bl	8001144 <HAL_GPIO_Init>

            GPIO_Init.Pin = Z_LIMIT_BIT;
            GPIO_Init.Mode = limit_ire.z ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
 8003f6e:	f015 0f04 	tst.w	r5, #4
 8003f72:	bf08      	it	eq
 8003f74:	463e      	moveq	r6, r7
            GPIO_Init.Pin = Z_LIMIT_BIT;
 8003f76:	f44f 4280 	mov.w	r2, #16384	; 0x4000
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 8003f7a:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f7e:	483d      	ldr	r0, [pc, #244]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 8003f80:	f083 0304 	eor.w	r3, r3, #4
 8003f84:	f3c3 0380 	ubfx	r3, r3, #2, #1
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f88:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 8003f8a:	e9cd 6301 	strd	r6, r3, [sp, #4]
            GPIO_Init.Pin = Z_LIMIT_BIT;
 8003f8e:	9200      	str	r2, [sp, #0]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003f90:	f7fd f8d8 	bl	8001144 <HAL_GPIO_Init>
            GPIO_Init.Pin = A_LIMIT_BIT;
            GPIO_Init.Mode = limit_ire.a ? GPIO_MODE_IT_RISING : GPIO_MODE_IT_FALLING;
            GPIO_Init.Pull = settings->limits.disable_pullup.a ? GPIO_NOPULL : GPIO_PULLUP;
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
#endif
            __HAL_GPIO_EXTI_CLEAR_IT(LIMIT_MASK);
 8003f94:	f44f 43e0 	mov.w	r3, #28672	; 0x7000

            HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8003f98:	2028      	movs	r0, #40	; 0x28
            __HAL_GPIO_EXTI_CLEAR_IT(LIMIT_MASK);
 8003f9a:	f8c8 3014 	str.w	r3, [r8, #20]
            HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8003f9e:	f7fc fea1 	bl	8000ce4 <HAL_NVIC_EnableIRQ>

        /**********************
         *  Probe pin config  *
         **********************/

        GPIO_Init.Pin = PROBE_BIT;
 8003fa2:	2680      	movs	r6, #128	; 0x80
 8003fa4:	2700      	movs	r7, #0
        GPIO_Init.Mode = GPIO_MODE_INPUT;
        GPIO_Init.Pull = settings->flags.disable_probe_pullup ? GPIO_NOPULL : GPIO_PULLUP;
 8003fa6:	f894 30bc 	ldrb.w	r3, [r4, #188]	; 0xbc
        HAL_GPIO_Init(PROBE_PORT, &GPIO_Init);
 8003faa:	4669      	mov	r1, sp
        GPIO_Init.Pull = settings->flags.disable_probe_pullup ? GPIO_NOPULL : GPIO_PULLUP;
 8003fac:	f083 0308 	eor.w	r3, r3, #8
 8003fb0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
        HAL_GPIO_Init(PROBE_PORT, &GPIO_Init);
 8003fb4:	4830      	ldr	r0, [pc, #192]	; (8004078 <settings_changed.part.0+0x340>)
        GPIO_Init.Pin = PROBE_BIT;
 8003fb6:	e9cd 6700 	strd	r6, r7, [sp]
        GPIO_Init.Pull = settings->flags.disable_probe_pullup ? GPIO_NOPULL : GPIO_PULLUP;
 8003fba:	9302      	str	r3, [sp, #8]
        HAL_GPIO_Init(PROBE_PORT, &GPIO_Init);
 8003fbc:	f7fd f8c2 	bl	8001144 <HAL_GPIO_Init>
        HAL_GPIO_Init(KEYPAD_PORT, &GPIO_Init);

        HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
#endif
    }
}
 8003fc0:	b00a      	add	sp, #40	; 0x28
 8003fc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            hal.spindle_set_state = spindleSetState;
 8003fc6:	4b2d      	ldr	r3, [pc, #180]	; (800407c <settings_changed.part.0+0x344>)
        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds) {
 8003fc8:	f012 0f20 	tst.w	r2, #32
 8003fcc:	f894 10b9 	ldrb.w	r1, [r4, #185]	; 0xb9
            PULSE_TIMER->DIER |= TIM_DIER_CC1IE; // Enable CC1 interrupt
 8003fd0:	4a24      	ldr	r2, [pc, #144]	; (8004064 <settings_changed.part.0+0x32c>)
            hal.spindle_set_state = spindleSetState;
 8003fd2:	6333      	str	r3, [r6, #48]	; 0x30
        if(hal.driver_cap.step_pulse_delay && settings->steppers.pulse_delay_microseconds) {
 8003fd4:	f43f af21 	beq.w	8003e1a <settings_changed.part.0+0xe2>
 8003fd8:	2900      	cmp	r1, #0
 8003fda:	f43f af1e 	beq.w	8003e1a <settings_changed.part.0+0xe2>
            PULSE_TIMER->DIER |= TIM_DIER_CC1IE; // Enable CC1 interrupt
 8003fde:	68d3      	ldr	r3, [r2, #12]
            hal.stepper_pulse_start = &stepperPulseStartDelayed;
 8003fe0:	4827      	ldr	r0, [pc, #156]	; (8004080 <settings_changed.part.0+0x348>)
            PULSE_TIMER->DIER |= TIM_DIER_CC1IE; // Enable CC1 interrupt
 8003fe2:	f043 0302 	orr.w	r3, r3, #2
            hal.stepper_pulse_start = &stepperPulseStartDelayed;
 8003fe6:	65b0      	str	r0, [r6, #88]	; 0x58
            PULSE_TIMER->DIER |= TIM_DIER_CC1IE; // Enable CC1 interrupt
 8003fe8:	60d3      	str	r3, [r2, #12]
 8003fea:	e71c      	b.n	8003e26 <settings_changed.part.0+0xee>
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003fec:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            GPIO_Init.Pin = X_LIMIT_BIT;
 8003ff0:	f44f 5680 	mov.w	r6, #4096	; 0x1000
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003ff4:	43db      	mvns	r3, r3
            GPIO_Init.Pin = X_LIMIT_BIT;
 8003ff6:	2700      	movs	r7, #0
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003ff8:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8003ffa:	f003 0301 	and.w	r3, r3, #1
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8003ffe:	481d      	ldr	r0, [pc, #116]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Pull = settings->limits.disable_pullup.x ? GPIO_NOPULL : GPIO_PULLUP;
 8004000:	9302      	str	r3, [sp, #8]
            GPIO_Init.Pin = X_LIMIT_BIT;
 8004002:	e9cd 6700 	strd	r6, r7, [sp]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8004006:	f7fd f89d 	bl	8001144 <HAL_GPIO_Init>
            GPIO_Init.Pin = Y_LIMIT_BIT;
 800400a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 800400e:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8004012:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 8004014:	f083 0302 	eor.w	r3, r3, #2
 8004018:	f3c3 0340 	ubfx	r3, r3, #1, #1
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 800401c:	4815      	ldr	r0, [pc, #84]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Pull = settings->limits.disable_pullup.y ? GPIO_NOPULL : GPIO_PULLUP;
 800401e:	9302      	str	r3, [sp, #8]
            GPIO_Init.Pin = Y_LIMIT_BIT;
 8004020:	9200      	str	r2, [sp, #0]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8004022:	f7fd f88f 	bl	8001144 <HAL_GPIO_Init>
            GPIO_Init.Pin = Z_LIMIT_BIT;
 8004026:	f44f 4280 	mov.w	r2, #16384	; 0x4000
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 800402a:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 800402e:	4669      	mov	r1, sp
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 8004030:	f083 0304 	eor.w	r3, r3, #4
 8004034:	f3c3 0380 	ubfx	r3, r3, #2, #1
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 8004038:	480e      	ldr	r0, [pc, #56]	; (8004074 <settings_changed.part.0+0x33c>)
            GPIO_Init.Pull = settings->limits.disable_pullup.z ? GPIO_NOPULL : GPIO_PULLUP;
 800403a:	9302      	str	r3, [sp, #8]
            GPIO_Init.Pin = Z_LIMIT_BIT;
 800403c:	9200      	str	r2, [sp, #0]
            HAL_GPIO_Init(LIMIT_PORT, &GPIO_Init);
 800403e:	f7fd f881 	bl	8001144 <HAL_GPIO_Init>
 8004042:	e7ae      	b.n	8003fa2 <settings_changed.part.0+0x26a>
 8004044:	20002620 	.word	0x20002620
 8004048:	200024bc 	.word	0x200024bc
 800404c:	422181a4 	.word	0x422181a4
 8004050:	40012c00 	.word	0x40012c00
 8004054:	080044c9 	.word	0x080044c9
 8004058:	20000010 	.word	0x20000010
 800405c:	43480000 	.word	0x43480000
 8004060:	200000cc 	.word	0x200000cc
 8004064:	40000400 	.word	0x40000400
 8004068:	08003a0d 	.word	0x08003a0d
 800406c:	10110000 	.word	0x10110000
 8004070:	10210000 	.word	0x10210000
 8004074:	40010c00 	.word	0x40010c00
 8004078:	40010800 	.word	0x40010800
 800407c:	08003c65 	.word	0x08003c65
 8004080:	08003be9 	.word	0x08003be9
 8004084:	40010400 	.word	0x40010400
                SPINDLE_PWM_TIMER->CCER |= TIM_CCER_CC1P;
 8004088:	f043 0302 	orr.w	r3, r3, #2
 800408c:	622b      	str	r3, [r5, #32]
            	SPINDLE_PWM_TIMER->CR2 |= TIM_CR2_OIS1;
 800408e:	686b      	ldr	r3, [r5, #4]
 8004090:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004094:	606b      	str	r3, [r5, #4]
 8004096:	e6aa      	b.n	8003dee <settings_changed.part.0+0xb6>
 8004098:	4b02      	ldr	r3, [pc, #8]	; (80040a4 <settings_changed.part.0+0x36c>)
 800409a:	fba3 3505 	umull	r3, r5, r3, r5
 800409e:	08ed      	lsrs	r5, r5, #3
 80040a0:	e670      	b.n	8003d84 <settings_changed.part.0+0x4c>
 80040a2:	bf00      	nop
 80040a4:	51eb851f 	.word	0x51eb851f

080040a8 <settings_changed>:
{
 80040a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 80040ac:	6c41      	ldr	r1, [r0, #68]	; 0x44
{
 80040ae:	4606      	mov	r6, r0
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 80040b0:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80040b2:	f7fc fd0d 	bl	8000ad0 <__aeabi_fcmplt>
 80040b6:	3800      	subs	r0, #0
 80040b8:	bf18      	it	ne
 80040ba:	2001      	movne	r0, #1
 80040bc:	4a3b      	ldr	r2, [pc, #236]	; (80041ac <settings_changed+0x104>)
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040be:	f896 50b4 	ldrb.w	r5, [r6, #180]	; 0xb4
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 80040c2:	f892 7144 	ldrb.w	r7, [r2, #324]	; 0x144
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040c6:	4c3a      	ldr	r4, [pc, #232]	; (80041b0 <settings_changed+0x108>)
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 80040c8:	f360 0741 	bfi	r7, r0, #1, #1
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040cc:	f085 0006 	eor.w	r0, r5, #6
 80040d0:	f854 e020 	ldr.w	lr, [r4, r0, lsl #2]
 80040d4:	f085 0005 	eor.w	r0, r5, #5
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80040d8:	f896 30b5 	ldrb.w	r3, [r6, #181]	; 0xb5
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040dc:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 80040e0:	f085 0c07 	eor.w	ip, r5, #7
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 80040e4:	f882 7144 	strb.w	r7, [r2, #324]	; 0x144
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040e8:	4a32      	ldr	r2, [pc, #200]	; (80041b4 <settings_changed+0x10c>)
 80040ea:	f854 802c 	ldr.w	r8, [r4, ip, lsl #2]
 80040ee:	f085 0704 	eor.w	r7, r5, #4
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80040f2:	4931      	ldr	r1, [pc, #196]	; (80041b8 <settings_changed+0x110>)
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80040f4:	f854 c027 	ldr.w	ip, [r4, r7, lsl #2]
 80040f8:	f8c2 e018 	str.w	lr, [r2, #24]
 80040fc:	6150      	str	r0, [r2, #20]
 80040fe:	f085 0e02 	eor.w	lr, r5, #2
 8004102:	f085 0001 	eor.w	r0, r5, #1
 8004106:	f085 0703 	eor.w	r7, r5, #3
 800410a:	f854 7027 	ldr.w	r7, [r4, r7, lsl #2]
 800410e:	f854 902e 	ldr.w	r9, [r4, lr, lsl #2]
 8004112:	f8c2 801c 	str.w	r8, [r2, #28]
 8004116:	f854 8020 	ldr.w	r8, [r4, r0, lsl #2]
 800411a:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800411e:	f083 0407 	eor.w	r4, r3, #7
 8004122:	f851 e024 	ldr.w	lr, [r1, r4, lsl #2]
 8004126:	f083 0406 	eor.w	r4, r3, #6
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800412a:	f8c2 c010 	str.w	ip, [r2, #16]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800412e:	f851 c024 	ldr.w	ip, [r1, r4, lsl #2]
 8004132:	f083 0405 	eor.w	r4, r3, #5
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 8004136:	60d7      	str	r7, [r2, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004138:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 800413c:	f083 0404 	eor.w	r4, r3, #4
 8004140:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 8004144:	f083 0403 	eor.w	r4, r3, #3
 8004148:	f851 4024 	ldr.w	r4, [r1, r4, lsl #2]
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800414c:	6010      	str	r0, [r2, #0]
 800414e:	f8c2 9008 	str.w	r9, [r2, #8]
 8004152:	f8c2 8004 	str.w	r8, [r2, #4]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004156:	4a19      	ldr	r2, [pc, #100]	; (80041bc <settings_changed+0x114>)
 8004158:	e9c2 5704 	strd	r5, r7, [r2, #16]
 800415c:	e9c2 ce06 	strd	ip, lr, [r2, #24]
 8004160:	60d4      	str	r4, [r2, #12]
 8004162:	f851 7023 	ldr.w	r7, [r1, r3, lsl #2]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8004166:	4d16      	ldr	r5, [pc, #88]	; (80041c0 <settings_changed+0x118>)
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004168:	6017      	str	r7, [r2, #0]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800416a:	68ec      	ldr	r4, [r5, #12]
    if(IOInitDone) {
 800416c:	f8df c054 	ldr.w	ip, [pc, #84]	; 80041c4 <settings_changed+0x11c>
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8004170:	f024 040e 	bic.w	r4, r4, #14
 8004174:	4304      	orrs	r4, r0
 8004176:	60ec      	str	r4, [r5, #12]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8004178:	68e8      	ldr	r0, [r5, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800417a:	f083 0402 	eor.w	r4, r3, #2
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 800417e:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 8004182:	4338      	orrs	r0, r7
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004184:	f083 0301 	eor.w	r3, r3, #1
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8004188:	60e8      	str	r0, [r5, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800418a:	f851 0024 	ldr.w	r0, [r1, r4, lsl #2]
 800418e:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    if(IOInitDone) {
 8004192:	f89c 3000 	ldrb.w	r3, [ip]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004196:	e9c2 1001 	strd	r1, r0, [r2, #4]
    if(IOInitDone) {
 800419a:	b123      	cbz	r3, 80041a6 <settings_changed+0xfe>
 800419c:	4630      	mov	r0, r6
}
 800419e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80041a2:	f7ff bdc9 	b.w	8003d38 <settings_changed.part.0>
 80041a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80041aa:	bf00      	nop
 80041ac:	200024bc 	.word	0x200024bc
 80041b0:	080148cc 	.word	0x080148cc
 80041b4:	20000118 	.word	0x20000118
 80041b8:	080148ac 	.word	0x080148ac
 80041bc:	200000a8 	.word	0x200000a8
 80041c0:	40010800 	.word	0x40010800
 80041c4:	200000a5 	.word	0x200000a5

080041c8 <driver_setup>:
// Initializes MCU peripherals for Grbl use
static bool driver_setup (settings_t *settings)
{
  //    Interrupt_disableSleepOnIsrExit();

    __HAL_RCC_TIM1_CLK_ENABLE();
 80041c8:	4bb1      	ldr	r3, [pc, #708]	; (8004490 <driver_setup+0x2c8>)
{
 80041ca:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    __HAL_RCC_TIM1_CLK_ENABLE();
 80041ce:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_TIM3_CLK_ENABLE();
    __HAL_RCC_TIM4_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_Init;

    GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 80041d0:	2403      	movs	r4, #3
    }
#endif

 // Stepper init

    GPIO_Init.Pin = STEPPERS_DISABLE_MASK;
 80041d2:	f44f 7600 	mov.w	r6, #512	; 0x200
 80041d6:	2701      	movs	r7, #1
    __HAL_RCC_TIM1_CLK_ENABLE();
 80041d8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80041dc:	619a      	str	r2, [r3, #24]
 80041de:	699a      	ldr	r2, [r3, #24]
{
 80041e0:	b089      	sub	sp, #36	; 0x24
    __HAL_RCC_TIM1_CLK_ENABLE();
 80041e2:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 80041e6:	9200      	str	r2, [sp, #0]
 80041e8:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_TIM2_CLK_ENABLE();
 80041ea:	69da      	ldr	r2, [r3, #28]
{
 80041ec:	4605      	mov	r5, r0
    __HAL_RCC_TIM2_CLK_ENABLE();
 80041ee:	f042 0201 	orr.w	r2, r2, #1
 80041f2:	61da      	str	r2, [r3, #28]
 80041f4:	69da      	ldr	r2, [r3, #28]
    HAL_GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_Init);
 80041f6:	48a7      	ldr	r0, [pc, #668]	; (8004494 <driver_setup+0x2cc>)
    __HAL_RCC_TIM2_CLK_ENABLE();
 80041f8:	f002 0201 	and.w	r2, r2, #1
 80041fc:	9201      	str	r2, [sp, #4]
 80041fe:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_TIM3_CLK_ENABLE();
 8004200:	69da      	ldr	r2, [r3, #28]
    HAL_GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_Init);
 8004202:	a904      	add	r1, sp, #16
    __HAL_RCC_TIM3_CLK_ENABLE();
 8004204:	f042 0202 	orr.w	r2, r2, #2
 8004208:	61da      	str	r2, [r3, #28]
 800420a:	69da      	ldr	r2, [r3, #28]
    STEPPER_TIMER->CNT = 0;
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;

    // Single-shot 1 us per tick
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 800420c:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 80044c4 <driver_setup+0x2fc>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8004210:	f002 0202 	and.w	r2, r2, #2
 8004214:	9202      	str	r2, [sp, #8]
 8004216:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_TIM4_CLK_ENABLE();
 8004218:	69da      	ldr	r2, [r3, #28]
 800421a:	f042 0204 	orr.w	r2, r2, #4
 800421e:	61da      	str	r2, [r3, #28]
 8004220:	69db      	ldr	r3, [r3, #28]
    GPIO_Init.Pin = STEPPERS_DISABLE_MASK;
 8004222:	e9cd 6704 	strd	r6, r7, [sp, #16]
    __HAL_RCC_TIM4_CLK_ENABLE();
 8004226:	f003 0304 	and.w	r3, r3, #4
 800422a:	9303      	str	r3, [sp, #12]
 800422c:	9b03      	ldr	r3, [sp, #12]
    GPIO_Init.Speed = GPIO_SPEED_FREQ_HIGH;
 800422e:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(STEPPERS_DISABLE_PORT, &GPIO_Init);
 8004230:	f7fc ff88 	bl	8001144 <HAL_GPIO_Init>
    GPIO_Init.Pin = STEP_MASK;
 8004234:	230e      	movs	r3, #14
    HAL_GPIO_Init(STEP_PORT, &GPIO_Init);
 8004236:	4898      	ldr	r0, [pc, #608]	; (8004498 <driver_setup+0x2d0>)
 8004238:	a904      	add	r1, sp, #16
    GPIO_Init.Pin = STEP_MASK;
 800423a:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(STEP_PORT, &GPIO_Init);
 800423c:	f7fc ff82 	bl	8001144 <HAL_GPIO_Init>
    GPIO_Init.Pin = DIRECTION_MASK;
 8004240:	2370      	movs	r3, #112	; 0x70
    HAL_GPIO_Init(DIRECTION_PORT, &GPIO_Init);
 8004242:	4895      	ldr	r0, [pc, #596]	; (8004498 <driver_setup+0x2d0>)
 8004244:	a904      	add	r1, sp, #16
    GPIO_Init.Pin = DIRECTION_MASK;
 8004246:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(DIRECTION_PORT, &GPIO_Init);
 8004248:	f7fc ff7c 	bl	8001144 <HAL_GPIO_Init>
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 800424c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    STEPPER_TIMER->CNT = 0;
 8004250:	2000      	movs	r0, #0
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004252:	f04f 0c10 	mov.w	ip, #16
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8004256:	f04f 5600 	mov.w	r6, #536870912	; 0x20000000
 800425a:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 800425e:	680b      	ldr	r3, [r1, #0]
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 8004260:	4f8e      	ldr	r7, [pc, #568]	; (800449c <driver_setup+0x2d4>)
    STEPPER_TIMER->CR1 &= ~TIM_CR1_CEN;
 8004262:	f023 0301 	bic.w	r3, r3, #1
 8004266:	600b      	str	r3, [r1, #0]
    STEPPER_TIMER->SR &= ~TIM_SR_UIF;
 8004268:	690a      	ldr	r2, [r1, #16]
 800426a:	f022 0201 	bic.w	r2, r2, #1
 800426e:	610a      	str	r2, [r1, #16]
    STEPPER_TIMER->CNT = 0;
 8004270:	6248      	str	r0, [r1, #36]	; 0x24
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;
 8004272:	68cb      	ldr	r3, [r1, #12]
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 8004274:	693a      	ldr	r2, [r7, #16]
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;
 8004276:	f043 0301 	orr.w	r3, r3, #1
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 800427a:	fba8 e202 	umull	lr, r2, r8, r2
    STEPPER_TIMER->DIER |= TIM_DIER_UIE;
 800427e:	60cb      	str	r3, [r1, #12]
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 8004280:	4b87      	ldr	r3, [pc, #540]	; (80044a0 <driver_setup+0x2d8>)
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 8004282:	0c92      	lsrs	r2, r2, #18
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 8004284:	6819      	ldr	r1, [r3, #0]
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 8004286:	3a01      	subs	r2, #1
    PULSE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 8004288:	f441 7127 	orr.w	r1, r1, #668	; 0x29c
 800428c:	6019      	str	r1, [r3, #0]
    PULSE_TIMER->PSC = hal.f_step_timer / 1000000UL - 1;
 800428e:	629a      	str	r2, [r3, #40]	; 0x28
    PULSE_TIMER->SR &= ~(TIM_SR_UIF|TIM_SR_CC1IF);
 8004290:	691a      	ldr	r2, [r3, #16]
 8004292:	f022 0203 	bic.w	r2, r2, #3
 8004296:	611a      	str	r2, [r3, #16]
    PULSE_TIMER->CNT = 0;
 8004298:	6258      	str	r0, [r3, #36]	; 0x24
    PULSE_TIMER->DIER |= TIM_DIER_UIE;
 800429a:	68d9      	ldr	r1, [r3, #12]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800429c:	4a81      	ldr	r2, [pc, #516]	; (80044a4 <driver_setup+0x2dc>)
 800429e:	f041 0101 	orr.w	r1, r1, #1
 80042a2:	60d9      	str	r1, [r3, #12]
 80042a4:	f882 031d 	strb.w	r0, [r2, #797]	; 0x31d
 80042a8:	f882 c31c 	strb.w	ip, [r2, #796]	; 0x31c
    NVIC_EnableIRQ(TIM3_IRQn);
    NVIC_EnableIRQ(TIM2_IRQn);

 // Limit pins init

    if (settings->limits.flags.hard_enabled)
 80042ac:	f895 30d4 	ldrb.w	r3, [r5, #212]	; 0xd4
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80042b0:	6016      	str	r6, [r2, #0]
 80042b2:	07d9      	lsls	r1, r3, #31
 80042b4:	6014      	str	r4, [r2, #0]
 80042b6:	f100 80bb 	bmi.w	8004430 <driver_setup+0x268>
        HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0x02, 0x02);

 // Control pins init

    if(hal.driver_cap.software_debounce) {
 80042ba:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 80042be:	06da      	lsls	r2, r3, #27
 80042c0:	f100 80c0 	bmi.w	8004444 <driver_setup+0x27c>
        HAL_NVIC_EnableIRQ(TIM4_IRQn); // Enable debounce interrupt
    }

 // Spindle init

    GPIO_Init.Pin = SPINDLE_DIRECTION_BIT;
 80042c4:	2301      	movs	r3, #1
    HAL_GPIO_Init(SPINDLE_DIRECTION_PORT, &GPIO_Init);
 80042c6:	4873      	ldr	r0, [pc, #460]	; (8004494 <driver_setup+0x2cc>)
 80042c8:	a904      	add	r1, sp, #16
    GPIO_Init.Pin = SPINDLE_DIRECTION_BIT;
 80042ca:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(SPINDLE_DIRECTION_PORT, &GPIO_Init);
 80042cc:	f7fc ff3a 	bl	8001144 <HAL_GPIO_Init>

    GPIO_Init.Pin = SPINDLE_ENABLE_BIT;
 80042d0:	2302      	movs	r3, #2
    HAL_GPIO_Init(SPINDLE_ENABLE_PORT, &GPIO_Init);
 80042d2:	4870      	ldr	r0, [pc, #448]	; (8004494 <driver_setup+0x2cc>)
 80042d4:	a904      	add	r1, sp, #16
    GPIO_Init.Pin = SPINDLE_ENABLE_BIT;
 80042d6:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(SPINDLE_ENABLE_PORT, &GPIO_Init);
 80042d8:	f7fc ff34 	bl	8001144 <HAL_GPIO_Init>

    if(hal.driver_cap.variable_spindle) {
 80042dc:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 80042e0:	079b      	lsls	r3, r3, #30
 80042e2:	f100 80ca 	bmi.w	800447a <driver_setup+0x2b2>

 // Coolant init

    GPIO_Init.Mode = GPIO_MODE_OUTPUT_PP;

    GPIO_Init.Pin = COOLANT_FLOOD_BIT;
 80042e6:	2208      	movs	r2, #8
 80042e8:	2301      	movs	r3, #1
    HAL_GPIO_Init(COOLANT_FLOOD_PORT, &GPIO_Init);
 80042ea:	486a      	ldr	r0, [pc, #424]	; (8004494 <driver_setup+0x2cc>)
 80042ec:	a904      	add	r1, sp, #16
    GPIO_Init.Pin = COOLANT_FLOOD_BIT;
 80042ee:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(COOLANT_FLOOD_PORT, &GPIO_Init);
 80042f2:	f7fc ff27 	bl	8001144 <HAL_GPIO_Init>

    GPIO_Init.Pin = COOLANT_MIST_BIT;
 80042f6:	2310      	movs	r3, #16
    HAL_GPIO_Init(COOLANT_MIST_PORT, &GPIO_Init);
 80042f8:	4866      	ldr	r0, [pc, #408]	; (8004494 <driver_setup+0x2cc>)
 80042fa:	eb0d 0103 	add.w	r1, sp, r3
    GPIO_Init.Pin = COOLANT_MIST_BIT;
 80042fe:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(COOLANT_MIST_PORT, &GPIO_Init);
 8004300:	f7fc ff20 	bl	8001144 <HAL_GPIO_Init>

    trinamic_init();

#endif

    IOInitDone = settings->version == 15;
 8004304:	f8d5 8000 	ldr.w	r8, [r5]
 8004308:	4e67      	ldr	r6, [pc, #412]	; (80044a8 <driver_setup+0x2e0>)
 800430a:	f1a8 030f 	sub.w	r3, r8, #15
 800430e:	fab3 f383 	clz	r3, r3
 8004312:	095b      	lsrs	r3, r3, #5
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 8004314:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8004316:	6ca8      	ldr	r0, [r5, #72]	; 0x48
    IOInitDone = settings->version == 15;
 8004318:	7033      	strb	r3, [r6, #0]
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 800431a:	f7fc fbd9 	bl	8000ad0 <__aeabi_fcmplt>
 800431e:	3800      	subs	r0, #0
 8004320:	bf18      	it	ne
 8004322:	2001      	movne	r0, #1
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 8004324:	f895 c0b4 	ldrb.w	ip, [r5, #180]	; 0xb4
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 8004328:	f897 1144 	ldrb.w	r1, [r7, #324]	; 0x144
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800432c:	4c5f      	ldr	r4, [pc, #380]	; (80044ac <driver_setup+0x2e4>)
 800432e:	f08c 0907 	eor.w	r9, ip, #7
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 8004332:	f360 0141 	bfi	r1, r0, #1, #1
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 8004336:	f08c 0e06 	eor.w	lr, ip, #6
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 800433a:	f895 30b5 	ldrb.w	r3, [r5, #181]	; 0xb5
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800433e:	f854 a029 	ldr.w	sl, [r4, r9, lsl #2]
 8004342:	f854 e02e 	ldr.w	lr, [r4, lr, lsl #2]
    hal.driver_cap.variable_spindle = settings->spindle.rpm_min < settings->spindle.rpm_max;
 8004346:	f887 1144 	strb.w	r1, [r7, #324]	; 0x144
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800434a:	4959      	ldr	r1, [pc, #356]	; (80044b0 <driver_setup+0x2e8>)
 800434c:	f08c 0005 	eor.w	r0, ip, #5
 8004350:	f854 b020 	ldr.w	fp, [r4, r0, lsl #2]
 8004354:	e9c1 ea06 	strd	lr, sl, [r1, #24]
 8004358:	f08c 0004 	eor.w	r0, ip, #4
 800435c:	f08c 0e02 	eor.w	lr, ip, #2
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004360:	4a54      	ldr	r2, [pc, #336]	; (80044b4 <driver_setup+0x2ec>)
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 8004362:	f854 9020 	ldr.w	r9, [r4, r0, lsl #2]
 8004366:	f854 a02e 	ldr.w	sl, [r4, lr, lsl #2]
 800436a:	f08c 0003 	eor.w	r0, ip, #3
 800436e:	f08c 0e01 	eor.w	lr, ip, #1
 8004372:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 8004376:	f8c1 b014 	str.w	fp, [r1, #20]
 800437a:	f854 b02e 	ldr.w	fp, [r4, lr, lsl #2]
 800437e:	f854 e02c 	ldr.w	lr, [r4, ip, lsl #2]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004382:	f083 0407 	eor.w	r4, r3, #7
 8004386:	f852 c024 	ldr.w	ip, [r2, r4, lsl #2]
 800438a:	f083 0406 	eor.w	r4, r3, #6
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 800438e:	f8c1 9010 	str.w	r9, [r1, #16]
 8004392:	60c8      	str	r0, [r1, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 8004394:	f852 9024 	ldr.w	r9, [r2, r4, lsl #2]
 8004398:	f083 0005 	eor.w	r0, r3, #5
 800439c:	f083 0404 	eor.w	r4, r3, #4
 80043a0:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80043a4:	f8c1 a008 	str.w	sl, [r1, #8]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043a8:	f852 a024 	ldr.w	sl, [r2, r4, lsl #2]
 80043ac:	4c42      	ldr	r4, [pc, #264]	; (80044b8 <driver_setup+0x2f0>)
        step_outmap[i] = c_step_outmap[i ^ settings->steppers.step_invert.value];
 80043ae:	e9c1 eb00 	strd	lr, fp, [r1]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043b2:	f083 0103 	eor.w	r1, r3, #3
 80043b6:	e9c4 9c06 	strd	r9, ip, [r4, #24]
 80043ba:	e9c4 a004 	strd	sl, r0, [r4, #16]
 80043be:	f852 9021 	ldr.w	r9, [r2, r1, lsl #2]
 80043c2:	f852 c023 	ldr.w	ip, [r2, r3, lsl #2]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80043c6:	4834      	ldr	r0, [pc, #208]	; (8004498 <driver_setup+0x2d0>)
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043c8:	f8c4 c000 	str.w	ip, [r4]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80043cc:	68c1      	ldr	r1, [r0, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043ce:	f8c4 900c 	str.w	r9, [r4, #12]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80043d2:	f021 010e 	bic.w	r1, r1, #14
 80043d6:	ea41 010e 	orr.w	r1, r1, lr
 80043da:	60c1      	str	r1, [r0, #12]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 80043dc:	68c1      	ldr	r1, [r0, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043de:	f083 0e02 	eor.w	lr, r3, #2
 80043e2:	f083 0301 	eor.w	r3, r3, #1
 80043e6:	f852 e02e 	ldr.w	lr, [r2, lr, lsl #2]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 80043ea:	f021 0170 	bic.w	r1, r1, #112	; 0x70
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043ee:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 80043f2:	ea41 010c 	orr.w	r1, r1, ip
    if(IOInitDone) {
 80043f6:	f1b8 0f0f 	cmp.w	r8, #15
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 80043fa:	60c1      	str	r1, [r0, #12]
        dir_outmap[i] = c_dir_outmap[i ^ settings->steppers.dir_invert.value];
 80043fc:	e9c4 2e01 	strd	r2, lr, [r4, #4]
    if(IOInitDone) {
 8004400:	d102      	bne.n	8004408 <driver_setup+0x240>
 8004402:	4628      	mov	r0, r5
 8004404:	f7ff fc98 	bl	8003d38 <settings_changed.part.0>

    settings_changed(settings);

    hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 8004408:	2100      	movs	r1, #0
 800440a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800440c:	f04f 0000 	mov.w	r0, #0
 8004410:	4798      	blx	r3
    hal.coolant_set_state((coolant_state_t){0});
 8004412:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004414:	f04f 0000 	mov.w	r0, #0
 8004418:	4798      	blx	r3
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 800441a:	4a1f      	ldr	r2, [pc, #124]	; (8004498 <driver_setup+0x2d0>)
 800441c:	6821      	ldr	r1, [r4, #0]
 800441e:	68d3      	ldr	r3, [r2, #12]
    stepperSetDirOutputs((axes_signals_t){0});

    return IOInitDone;
}
 8004420:	7830      	ldrb	r0, [r6, #0]
    DIRECTION_PORT->ODR = (DIRECTION_PORT->ODR & ~DIRECTION_MASK) | dir_outmap[dir_outbits.value];
 8004422:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8004426:	430b      	orrs	r3, r1
 8004428:	60d3      	str	r3, [r2, #12]
}
 800442a:	b009      	add	sp, #36	; 0x24
 800442c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0x02, 0x02);
 8004430:	2202      	movs	r2, #2
 8004432:	2028      	movs	r0, #40	; 0x28
 8004434:	4611      	mov	r1, r2
 8004436:	f7fc fc1d 	bl	8000c74 <HAL_NVIC_SetPriority>
    if(hal.driver_cap.software_debounce) {
 800443a:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 800443e:	06da      	lsls	r2, r3, #27
 8004440:	f57f af40 	bpl.w	80042c4 <driver_setup+0xfc>
        DEBOUNCE_TIMER->ARR = 400; // 40 ms timeout
 8004444:	f44f 74c8 	mov.w	r4, #400	; 0x190
        DEBOUNCE_TIMER->PSC = hal.f_step_timer / 10000UL - 1;
 8004448:	693a      	ldr	r2, [r7, #16]
 800444a:	491c      	ldr	r1, [pc, #112]	; (80044bc <driver_setup+0x2f4>)
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 800444c:	4b1c      	ldr	r3, [pc, #112]	; (80044c0 <driver_setup+0x2f8>)
        DEBOUNCE_TIMER->PSC = hal.f_step_timer / 10000UL - 1;
 800444e:	fba1 1202 	umull	r1, r2, r1, r2
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 8004452:	6819      	ldr	r1, [r3, #0]
        DEBOUNCE_TIMER->PSC = hal.f_step_timer / 10000UL - 1;
 8004454:	0b52      	lsrs	r2, r2, #13
 8004456:	3a01      	subs	r2, #1
        DEBOUNCE_TIMER->CR1 |= TIM_CR1_OPM|TIM_CR1_DIR|TIM_CR1_CKD_1|TIM_CR1_ARPE|TIM_CR1_URS;
 8004458:	f441 7127 	orr.w	r1, r1, #668	; 0x29c
 800445c:	6019      	str	r1, [r3, #0]
        DEBOUNCE_TIMER->PSC = hal.f_step_timer / 10000UL - 1;
 800445e:	629a      	str	r2, [r3, #40]	; 0x28
        DEBOUNCE_TIMER->SR &= ~TIM_SR_UIF;
 8004460:	691a      	ldr	r2, [r3, #16]
        HAL_NVIC_EnableIRQ(TIM4_IRQn); // Enable debounce interrupt
 8004462:	201e      	movs	r0, #30
        DEBOUNCE_TIMER->SR &= ~TIM_SR_UIF;
 8004464:	f022 0201 	bic.w	r2, r2, #1
 8004468:	611a      	str	r2, [r3, #16]
        DEBOUNCE_TIMER->ARR = 400; // 40 ms timeout
 800446a:	62dc      	str	r4, [r3, #44]	; 0x2c
        DEBOUNCE_TIMER->DIER |= TIM_DIER_UIE;
 800446c:	68da      	ldr	r2, [r3, #12]
 800446e:	f042 0201 	orr.w	r2, r2, #1
 8004472:	60da      	str	r2, [r3, #12]
        HAL_NVIC_EnableIRQ(TIM4_IRQn); // Enable debounce interrupt
 8004474:	f7fc fc36 	bl	8000ce4 <HAL_NVIC_EnableIRQ>
 8004478:	e724      	b.n	80042c4 <driver_setup+0xfc>
        GPIO_Init.Pin = SPINDLE_PWM_BIT;
 800447a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800447e:	2302      	movs	r3, #2
        HAL_GPIO_Init(SPINDLE_PWM_PORT, &GPIO_Init);
 8004480:	4805      	ldr	r0, [pc, #20]	; (8004498 <driver_setup+0x2d0>)
 8004482:	a904      	add	r1, sp, #16
        GPIO_Init.Pin = SPINDLE_PWM_BIT;
 8004484:	e9cd 2304 	strd	r2, r3, [sp, #16]
        HAL_GPIO_Init(SPINDLE_PWM_PORT, &GPIO_Init);
 8004488:	f7fc fe5c 	bl	8001144 <HAL_GPIO_Init>
 800448c:	e72b      	b.n	80042e6 <driver_setup+0x11e>
 800448e:	bf00      	nop
 8004490:	40021000 	.word	0x40021000
 8004494:	40010c00 	.word	0x40010c00
 8004498:	40010800 	.word	0x40010800
 800449c:	200024bc 	.word	0x200024bc
 80044a0:	40000400 	.word	0x40000400
 80044a4:	e000e100 	.word	0xe000e100
 80044a8:	200000a5 	.word	0x200000a5
 80044ac:	080148cc 	.word	0x080148cc
 80044b0:	20000118 	.word	0x20000118
 80044b4:	080148ac 	.word	0x080148ac
 80044b8:	200000a8 	.word	0x200000a8
 80044bc:	d1b71759 	.word	0xd1b71759
 80044c0:	40000800 	.word	0x40000800
 80044c4:	431bde83 	.word	0x431bde83

080044c8 <spindleSetStateVariable>:
{
 80044c8:	b538      	push	{r3, r4, r5, lr}
 80044ca:	4604      	mov	r4, r0
    if (!state.on || rpm == 0.0f) {
 80044cc:	07e2      	lsls	r2, r4, #31
 80044ce:	d505      	bpl.n	80044dc <spindleSetStateVariable+0x14>
 80044d0:	460d      	mov	r5, r1
 80044d2:	2100      	movs	r1, #0
 80044d4:	4628      	mov	r0, r5
 80044d6:	f7fc faf1 	bl	8000abc <__aeabi_fcmpeq>
 80044da:	b1d8      	cbz	r0, 8004514 <spindleSetStateVariable+0x4c>
        pwmEnabled = false;
 80044dc:	2000      	movs	r0, #0
        if(settings.spindle.disable_with_zero_speed)
 80044de:	4b1f      	ldr	r3, [pc, #124]	; (800455c <spindleSetStateVariable+0x94>)
        pwmEnabled = false;
 80044e0:	491f      	ldr	r1, [pc, #124]	; (8004560 <spindleSetStateVariable+0x98>)
        if(settings.spindle.disable_with_zero_speed)
 80044e2:	f893 20b3 	ldrb.w	r2, [r3, #179]	; 0xb3
        pwmEnabled = false;
 80044e6:	7008      	strb	r0, [r1, #0]
        if(settings.spindle.disable_with_zero_speed)
 80044e8:	b12a      	cbz	r2, 80044f6 <spindleSetStateVariable+0x2e>
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 80044ea:	f893 20b2 	ldrb.w	r2, [r3, #178]	; 0xb2
 80044ee:	491d      	ldr	r1, [pc, #116]	; (8004564 <spindleSetStateVariable+0x9c>)
 80044f0:	f3c2 0200 	ubfx	r2, r2, #0, #1
 80044f4:	700a      	strb	r2, [r1, #0]
        if(spindle_pwm.always_on) {
 80044f6:	4a1c      	ldr	r2, [pc, #112]	; (8004568 <spindleSetStateVariable+0xa0>)
 80044f8:	7d51      	ldrb	r1, [r2, #21]
 80044fa:	bb09      	cbnz	r1, 8004540 <spindleSetStateVariable+0x78>
        	SPINDLE_PWM_TIMER->BDTR &= ~TIM_BDTR_MOE; // Set PWM output low
 80044fc:	491b      	ldr	r1, [pc, #108]	; (800456c <spindleSetStateVariable+0xa4>)
 80044fe:	6c4a      	ldr	r2, [r1, #68]	; 0x44
 8004500:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8004504:	644a      	str	r2, [r1, #68]	; 0x44
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 8004506:	f893 30b2 	ldrb.w	r3, [r3, #178]	; 0xb2
 800450a:	4a16      	ldr	r2, [pc, #88]	; (8004564 <spindleSetStateVariable+0x9c>)
 800450c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8004510:	7013      	strb	r3, [r2, #0]
}
 8004512:	bd38      	pop	{r3, r4, r5, pc}
    if(hal.driver_cap.spindle_dir)
 8004514:	4b16      	ldr	r3, [pc, #88]	; (8004570 <spindleSetStateVariable+0xa8>)
 8004516:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 800451a:	071b      	lsls	r3, r3, #28
 800451c:	d507      	bpl.n	800452e <spindleSetStateVariable+0x66>
        BITBAND_PERI(SPINDLE_DIRECTION_PORT->ODR, SPINDLE_DIRECTION_PIN) = ccw ^ settings.spindle.invert.ccw;
 800451e:	4a0f      	ldr	r2, [pc, #60]	; (800455c <spindleSetStateVariable+0x94>)
 8004520:	4b14      	ldr	r3, [pc, #80]	; (8004574 <spindleSetStateVariable+0xac>)
 8004522:	f892 00b2 	ldrb.w	r0, [r2, #178]	; 0xb2
 8004526:	4044      	eors	r4, r0
 8004528:	f3c4 0440 	ubfx	r4, r4, #1, #1
 800452c:	701c      	strb	r4, [r3, #0]
        spindle_set_speed(spindle_compute_pwm_value(&spindle_pwm, rpm, false));
 800452e:	4629      	mov	r1, r5
 8004530:	2200      	movs	r2, #0
 8004532:	480d      	ldr	r0, [pc, #52]	; (8004568 <spindleSetStateVariable+0xa0>)
 8004534:	f00a fcca 	bl	800eecc <spindle_compute_pwm_value>
}
 8004538:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        spindle_set_speed(spindle_compute_pwm_value(&spindle_pwm, rpm, false));
 800453c:	f7ff bbba 	b.w	8003cb4 <spindle_set_speed>
            SPINDLE_PWM_TIMER->CCR1 = spindle_pwm.off_value;
 8004540:	6851      	ldr	r1, [r2, #4]
 8004542:	4a0a      	ldr	r2, [pc, #40]	; (800456c <spindleSetStateVariable+0xa4>)
 8004544:	6351      	str	r1, [r2, #52]	; 0x34
            SPINDLE_PWM_TIMER->BDTR |= TIM_BDTR_MOE;
 8004546:	6c51      	ldr	r1, [r2, #68]	; 0x44
 8004548:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 800454c:	6451      	str	r1, [r2, #68]	; 0x44
    BITBAND_PERI(SPINDLE_ENABLE_PORT->ODR, SPINDLE_ENABLE_PIN) = settings.spindle.invert.on;
 800454e:	f893 30b2 	ldrb.w	r3, [r3, #178]	; 0xb2
 8004552:	4a04      	ldr	r2, [pc, #16]	; (8004564 <spindleSetStateVariable+0x9c>)
 8004554:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8004558:	7013      	strb	r3, [r2, #0]
}
 800455a:	bd38      	pop	{r3, r4, r5, pc}
 800455c:	20002620 	.word	0x20002620
 8004560:	200000ca 	.word	0x200000ca
 8004564:	42218184 	.word	0x42218184
 8004568:	200000cc 	.word	0x200000cc
 800456c:	40012c00 	.word	0x40012c00
 8004570:	200024bc 	.word	0x200024bc
 8004574:	42218180 	.word	0x42218180

08004578 <driver_init>:

// Initialize HAL pointers, setup serial comms and enable EEPROM
// NOTE: Grbl is not yet configured (from EEPROM data), driver_setup() will be called when done

bool driver_init (void)
{
 8004578:	b538      	push	{r3, r4, r5, lr}
    // GPIO_PinRemapConfig(GPIO_Remap_SWJ_Disable, ENABLE); // ??? Disable JTAG and SWD!?? Bug?

#if USB_ENABLE
    usbInit();
#else
    serialInit();
 800457a:	f000 fa2f 	bl	80049dc <serialInit>

    hal.info = "STM32F103C8";
    hal.driver_version = "200417";
    hal.driver_setup = driver_setup;
    hal.f_step_timer = SystemCoreClock;
    hal.rx_buffer_size = RX_BUFFER_SIZE;
 800457e:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hal.f_step_timer = SystemCoreClock;
 8004582:	4a2e      	ldr	r2, [pc, #184]	; (800463c <driver_init+0xc4>)
    hal.info = "STM32F103C8";
 8004584:	4b2e      	ldr	r3, [pc, #184]	; (8004640 <driver_init+0xc8>)
    hal.f_step_timer = SystemCoreClock;
 8004586:	6814      	ldr	r4, [r2, #0]
    hal.driver_version = "200417";
 8004588:	492e      	ldr	r1, [pc, #184]	; (8004644 <driver_init+0xcc>)
    hal.info = "STM32F103C8";
 800458a:	4a2f      	ldr	r2, [pc, #188]	; (8004648 <driver_init+0xd0>)
    hal.f_step_timer = SystemCoreClock;
 800458c:	611c      	str	r4, [r3, #16]
    hal.info = "STM32F103C8";
 800458e:	605a      	str	r2, [r3, #4]
    hal.driver_version = "200417";
 8004590:	6099      	str	r1, [r3, #8]
    hal.rx_buffer_size = RX_BUFFER_SIZE;
 8004592:	6158      	str	r0, [r3, #20]
    hal.driver_setup = driver_setup;
 8004594:	4c2d      	ldr	r4, [pc, #180]	; (800464c <driver_init+0xd4>)
    hal.delay_ms = &driver_delay;
 8004596:	4a2e      	ldr	r2, [pc, #184]	; (8004650 <driver_init+0xd8>)
    hal.settings_changed = settings_changed;
 8004598:	492e      	ldr	r1, [pc, #184]	; (8004654 <driver_init+0xdc>)

    hal.stepper_wake_up = stepperWakeUp;
    hal.stepper_go_idle = stepperGoIdle;
 800459a:	482f      	ldr	r0, [pc, #188]	; (8004658 <driver_init+0xe0>)
    hal.driver_setup = driver_setup;
 800459c:	619c      	str	r4, [r3, #24]
    hal.delay_ms = &driver_delay;
 800459e:	62da      	str	r2, [r3, #44]	; 0x2c
    hal.settings_changed = settings_changed;
 80045a0:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
    hal.stepper_go_idle = stepperGoIdle;
 80045a4:	6498      	str	r0, [r3, #72]	; 0x48
    hal.stepper_wake_up = stepperWakeUp;
 80045a6:	4c2d      	ldr	r4, [pc, #180]	; (800465c <driver_init+0xe4>)
    hal.stepper_enable = stepperEnable;
 80045a8:	4a2d      	ldr	r2, [pc, #180]	; (8004660 <driver_init+0xe8>)
    hal.stepper_cycles_per_tick = stepperCyclesPerTickPrescaled;
 80045aa:	492e      	ldr	r1, [pc, #184]	; (8004664 <driver_init+0xec>)
    hal.stepper_pulse_start = stepperPulseStart;

    hal.limits_enable = limitsEnable;
 80045ac:	482e      	ldr	r0, [pc, #184]	; (8004668 <driver_init+0xf0>)
    hal.stepper_wake_up = stepperWakeUp;
 80045ae:	645c      	str	r4, [r3, #68]	; 0x44
    hal.stepper_enable = stepperEnable;
 80045b0:	64da      	str	r2, [r3, #76]	; 0x4c
    hal.stepper_cycles_per_tick = stepperCyclesPerTickPrescaled;
 80045b2:	6559      	str	r1, [r3, #84]	; 0x54
    hal.limits_enable = limitsEnable;
 80045b4:	61d8      	str	r0, [r3, #28]
    hal.stepper_pulse_start = stepperPulseStart;
 80045b6:	4c2d      	ldr	r4, [pc, #180]	; (800466c <driver_init+0xf4>)
    hal.limits_get_state = limitsGetState;
 80045b8:	4a2d      	ldr	r2, [pc, #180]	; (8004670 <driver_init+0xf8>)

    hal.coolant_set_state = coolantSetState;
 80045ba:	492e      	ldr	r1, [pc, #184]	; (8004674 <driver_init+0xfc>)
    hal.coolant_get_state = coolantGetState;

    hal.probe_get_state = probeGetState;
 80045bc:	482e      	ldr	r0, [pc, #184]	; (8004678 <driver_init+0x100>)
    hal.stepper_pulse_start = stepperPulseStart;
 80045be:	659c      	str	r4, [r3, #88]	; 0x58
    hal.limits_get_state = limitsGetState;
 80045c0:	621a      	str	r2, [r3, #32]
    hal.coolant_set_state = coolantSetState;
 80045c2:	6259      	str	r1, [r3, #36]	; 0x24
    hal.probe_get_state = probeGetState;
 80045c4:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
    hal.coolant_get_state = coolantGetState;
 80045c8:	4c2c      	ldr	r4, [pc, #176]	; (800467c <driver_init+0x104>)
    hal.probe_configure_invert_mask = probeConfigureInvertMask;
 80045ca:	4a2d      	ldr	r2, [pc, #180]	; (8004680 <driver_init+0x108>)

    hal.spindle_set_state = spindleSetState;
 80045cc:	492d      	ldr	r1, [pc, #180]	; (8004684 <driver_init+0x10c>)
    hal.spindle_get_state = spindleGetState;
#ifdef SPINDLE_PWM_DIRECT
    hal.spindle_get_pwm = spindleGetPWM;
 80045ce:	482e      	ldr	r0, [pc, #184]	; (8004688 <driver_init+0x110>)
    hal.coolant_get_state = coolantGetState;
 80045d0:	629c      	str	r4, [r3, #40]	; 0x28
    hal.probe_configure_invert_mask = probeConfigureInvertMask;
 80045d2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    hal.spindle_set_state = spindleSetState;
 80045d6:	6319      	str	r1, [r3, #48]	; 0x30
    hal.spindle_get_pwm = spindleGetPWM;
 80045d8:	6398      	str	r0, [r3, #56]	; 0x38
    hal.spindle_get_state = spindleGetState;
 80045da:	4c2c      	ldr	r4, [pc, #176]	; (800468c <driver_init+0x114>)
    hal.spindle_update_pwm = spindle_set_speed;
 80045dc:	4a2c      	ldr	r2, [pc, #176]	; (8004690 <driver_init+0x118>)
#else
    hal.spindle_update_rpm = spindleUpdateRPM;
#endif

    hal.system_control_get_state = systemGetState;
 80045de:	492d      	ldr	r1, [pc, #180]	; (8004694 <driver_init+0x11c>)

    hal.set_bits_atomic = bitsSetAtomic;
    hal.clear_bits_atomic = bitsClearAtomic;
 80045e0:	482d      	ldr	r0, [pc, #180]	; (8004698 <driver_init+0x120>)
    hal.spindle_get_state = spindleGetState;
 80045e2:	635c      	str	r4, [r3, #52]	; 0x34
    hal.spindle_update_pwm = spindle_set_speed;
 80045e4:	63da      	str	r2, [r3, #60]	; 0x3c
    hal.system_control_get_state = systemGetState;
 80045e6:	6419      	str	r1, [r3, #64]	; 0x40
    hal.clear_bits_atomic = bitsClearAtomic;
 80045e8:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
    hal.set_bits_atomic = bitsSetAtomic;
 80045ec:	4c2b      	ldr	r4, [pc, #172]	; (800469c <driver_init+0x124>)
    hal.set_value_atomic = valueSetAtomic;
 80045ee:	4a2c      	ldr	r2, [pc, #176]	; (80046a0 <driver_init+0x128>)
    hal.stream.get_rx_buffer_available = usbRxFree;
    hal.stream.reset_read_buffer = usbRxFlush;
    hal.stream.cancel_read_buffer = usbRxCancel;
    hal.stream.suspend_read = usbSuspendInput;
#else
    hal.stream.read = serialGetC;
 80045f0:	492c      	ldr	r1, [pc, #176]	; (80046a4 <driver_init+0x12c>)
    hal.stream.write = serialWriteS;
    hal.stream.write_all = serialWriteS;
    hal.stream.get_rx_buffer_available = serialRxFree;
    hal.stream.reset_read_buffer = serialRxFlush;
 80045f2:	482d      	ldr	r0, [pc, #180]	; (80046a8 <driver_init+0x130>)
    hal.set_bits_atomic = bitsSetAtomic;
 80045f4:	f8c3 4080 	str.w	r4, [r3, #128]	; 0x80
    hal.set_value_atomic = valueSetAtomic;
 80045f8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    hal.stream.read = serialGetC;
 80045fc:	66d9      	str	r1, [r3, #108]	; 0x6c
    hal.stream.reset_read_buffer = serialRxFlush;
 80045fe:	6718      	str	r0, [r3, #112]	; 0x70
    hal.stream.get_rx_buffer_available = serialRxFree;
 8004600:	4c2a      	ldr	r4, [pc, #168]	; (80046ac <driver_init+0x134>)
    hal.stream.write = serialWriteS;
 8004602:	4a2b      	ldr	r2, [pc, #172]	; (80046b0 <driver_init+0x138>)
    hal.stream.cancel_read_buffer = serialRxCancel;
 8004604:	492b      	ldr	r1, [pc, #172]	; (80046b4 <driver_init+0x13c>)
    hal.stream.suspend_read = serialSuspendInput;
 8004606:	482c      	ldr	r0, [pc, #176]	; (80046b8 <driver_init+0x140>)
    hal.stream.write_all = serialWriteS;
 8004608:	e9c3 2219 	strd	r2, r2, [r3, #100]	; 0x64
    hal.stream.get_rx_buffer_available = serialRxFree;
 800460c:	661c      	str	r4, [r3, #96]	; 0x60
    hal.stream.cancel_read_buffer = serialRxCancel;
 800460e:	6759      	str	r1, [r3, #116]	; 0x74
    hal.stream.suspend_read = serialSuspendInput;
 8004610:	6798      	str	r0, [r3, #120]	; 0x78
    hal.driver_cap.sd_card = On;
#endif

    // No need to move version check before init.
    // Compiler will fail any signature mismatch for existing entries.
    return hal.version == 6;
 8004612:	6818      	ldr	r0, [r3, #0]
    hal.eeprom.type = EEPROM_Emulated;
 8004614:	2502      	movs	r5, #2
}
 8004616:	f1a0 0006 	sub.w	r0, r0, #6
 800461a:	fab0 f080 	clz	r0, r0
    hal.driver_cap.mist_control = On;
 800461e:	f8d3 1144 	ldr.w	r1, [r3, #324]	; 0x144
 8004622:	4a26      	ldr	r2, [pc, #152]	; (80046bc <driver_init+0x144>)
    hal.eeprom.memcpy_from_flash = memcpy_from_flash;
 8004624:	4c26      	ldr	r4, [pc, #152]	; (80046c0 <driver_init+0x148>)
    hal.driver_cap.mist_control = On;
 8004626:	430a      	orrs	r2, r1
    hal.eeprom.memcpy_to_flash = memcpy_to_flash;
 8004628:	4926      	ldr	r1, [pc, #152]	; (80046c4 <driver_init+0x14c>)
    hal.eeprom.type = EEPROM_Emulated;
 800462a:	f883 50f4 	strb.w	r5, [r3, #244]	; 0xf4
    hal.eeprom.memcpy_to_flash = memcpy_to_flash;
 800462e:	e9c3 4143 	strd	r4, r1, [r3, #268]	; 0x10c
    hal.driver_cap.mist_control = On;
 8004632:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
}
 8004636:	0940      	lsrs	r0, r0, #5
 8004638:	bd38      	pop	{r3, r4, r5, pc}
 800463a:	bf00      	nop
 800463c:	20000010 	.word	0x20000010
 8004640:	200024bc 	.word	0x200024bc
 8004644:	080148a4 	.word	0x080148a4
 8004648:	08014898 	.word	0x08014898
 800464c:	080041c9 	.word	0x080041c9
 8004650:	08003bb5 	.word	0x08003bb5
 8004654:	080040a9 	.word	0x080040a9
 8004658:	080039cd 	.word	0x080039cd
 800465c:	08003999 	.word	0x08003999
 8004660:	0800397d 	.word	0x0800397d
 8004664:	080039e1 	.word	0x080039e1
 8004668:	08003c31 	.word	0x08003c31
 800466c:	08003a0d 	.word	0x08003a0d
 8004670:	08003a61 	.word	0x08003a61
 8004674:	08003b25 	.word	0x08003b25
 8004678:	08003ac1 	.word	0x08003ac1
 800467c:	08003b4d 	.word	0x08003b4d
 8004680:	08003a9d 	.word	0x08003a9d
 8004684:	08003c65 	.word	0x08003c65
 8004688:	08003ba5 	.word	0x08003ba5
 800468c:	08003ad9 	.word	0x08003ad9
 8004690:	08003cb5 	.word	0x08003cb5
 8004694:	08003a7d 	.word	0x08003a7d
 8004698:	08003b85 	.word	0x08003b85
 800469c:	08003b79 	.word	0x08003b79
 80046a0:	08003b99 	.word	0x08003b99
 80046a4:	080049ad 	.word	0x080049ad
 80046a8:	08004b1d 	.word	0x08004b1d
 80046ac:	08004b01 	.word	0x08004b01
 80046b0:	08004b4d 	.word	0x08004b4d
 80046b4:	08004b2d 	.word	0x08004b2d
 80046b8:	08004ba9 	.word	0x08004ba9
 80046bc:	002007ff 	.word	0x002007ff
 80046c0:	0800483d 	.word	0x0800483d
 80046c4:	08004859 	.word	0x08004859

080046c8 <TIM2_IRQHandler>:
/* interrupt handlers */

// Main stepper driver
void TIM2_IRQHandler(void)
{
    if ((STEPPER_TIMER->SR & TIM_SR_UIF) != 0)                  // check interrupt source
 80046c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80046cc:	691a      	ldr	r2, [r3, #16]
 80046ce:	07d2      	lsls	r2, r2, #31
 80046d0:	d508      	bpl.n	80046e4 <TIM2_IRQHandler+0x1c>
    {
        STEPPER_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag
 80046d2:	f06f 0001 	mvn.w	r0, #1
        STEPPER_TIMER->CNT = 0;
 80046d6:	2100      	movs	r1, #0
        hal.stepper_interrupt_callback();
 80046d8:	4a03      	ldr	r2, [pc, #12]	; (80046e8 <TIM2_IRQHandler+0x20>)
        STEPPER_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag
 80046da:	6118      	str	r0, [r3, #16]
        hal.stepper_interrupt_callback();
 80046dc:	f8d2 2134 	ldr.w	r2, [r2, #308]	; 0x134
        STEPPER_TIMER->CNT = 0;
 80046e0:	6259      	str	r1, [r3, #36]	; 0x24
        hal.stepper_interrupt_callback();
 80046e2:	4710      	bx	r2
    }
}
 80046e4:	4770      	bx	lr
 80046e6:	bf00      	nop
 80046e8:	200024bc 	.word	0x200024bc

080046ec <TIM3_IRQHandler>:
// This interrupt is enabled when Grbl sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
void TIM3_IRQHandler(void)
{
    if ((PULSE_TIMER->SR & TIM_SR_CC1IF) != 0)          // Delayed step pulse?
 80046ec:	4b10      	ldr	r3, [pc, #64]	; (8004730 <TIM3_IRQHandler+0x44>)
 80046ee:	691a      	ldr	r2, [r3, #16]
 80046f0:	f012 0f02 	tst.w	r2, #2
    {
        PULSE_TIMER->SR &= ~(TIM_SR_UIF|TIM_SR_CC1IF);  // Clear UIF & CC1IF flags and
 80046f4:	691a      	ldr	r2, [r3, #16]
    if ((PULSE_TIMER->SR & TIM_SR_CC1IF) != 0)          // Delayed step pulse?
 80046f6:	d00e      	beq.n	8004716 <TIM3_IRQHandler+0x2a>
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 80046f8:	490e      	ldr	r1, [pc, #56]	; (8004734 <TIM3_IRQHandler+0x48>)
        PULSE_TIMER->SR &= ~(TIM_SR_UIF|TIM_SR_CC1IF);  // Clear UIF & CC1IF flags and
 80046fa:	f022 0203 	bic.w	r2, r2, #3
 80046fe:	611a      	str	r2, [r3, #16]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 8004700:	4a0d      	ldr	r2, [pc, #52]	; (8004738 <TIM3_IRQHandler+0x4c>)
 8004702:	7808      	ldrb	r0, [r1, #0]
 8004704:	490d      	ldr	r1, [pc, #52]	; (800473c <TIM3_IRQHandler+0x50>)
 8004706:	68d3      	ldr	r3, [r2, #12]
 8004708:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 800470c:	f023 030e 	bic.w	r3, r3, #14
 8004710:	430b      	orrs	r3, r1
 8004712:	60d3      	str	r3, [r2, #12]
 8004714:	4770      	bx	lr
 8004716:	4908      	ldr	r1, [pc, #32]	; (8004738 <TIM3_IRQHandler+0x4c>)
        stepperSetStepOutputs(next_step_outbits);       // begin step pulse
    } else {
        PULSE_TIMER->SR &= ~TIM_SR_UIF;                 // Clear UIF flag and
 8004718:	f022 0201 	bic.w	r2, r2, #1
 800471c:	611a      	str	r2, [r3, #16]
	STEP_PORT->ODR = (STEP_PORT->ODR & ~STEP_MASK) | step_outmap[step_outbits.value];
 800471e:	4a07      	ldr	r2, [pc, #28]	; (800473c <TIM3_IRQHandler+0x50>)
 8004720:	68cb      	ldr	r3, [r1, #12]
 8004722:	6812      	ldr	r2, [r2, #0]
 8004724:	f023 030e 	bic.w	r3, r3, #14
 8004728:	4313      	orrs	r3, r2
 800472a:	60cb      	str	r3, [r1, #12]
        stepperSetStepOutputs((axes_signals_t){0});     // end step pulse
    }
}
 800472c:	4770      	bx	lr
 800472e:	bf00      	nop
 8004730:	40000400 	.word	0x40000400
 8004734:	200000c8 	.word	0x200000c8
 8004738:	40010800 	.word	0x40010800
 800473c:	20000118 	.word	0x20000118

08004740 <TIM4_IRQHandler>:

// Debounce timer interrupt handler
void TIM4_IRQHandler (void)
{
    DEBOUNCE_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag;
 8004740:	f06f 0101 	mvn.w	r1, #1
 8004744:	4a08      	ldr	r2, [pc, #32]	; (8004768 <TIM4_IRQHandler+0x28>)
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 8004746:	4b09      	ldr	r3, [pc, #36]	; (800476c <TIM4_IRQHandler+0x2c>)
    DEBOUNCE_TIMER->SR = ~TIM_SR_UIF; // clear UIF flag;
 8004748:	6111      	str	r1, [r2, #16]
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 800474a:	689b      	ldr	r3, [r3, #8]
    if (settings.limits.invert.mask)
 800474c:	4a08      	ldr	r2, [pc, #32]	; (8004770 <TIM4_IRQHandler+0x30>)
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 800474e:	0a9b      	lsrs	r3, r3, #10
    if (settings.limits.invert.mask)
 8004750:	f892 00d5 	ldrb.w	r0, [r2, #213]	; 0xd5
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 8004754:	f003 031c 	and.w	r3, r3, #28

    axes_signals_t state = (axes_signals_t)limitsGetState();

    if(state.value) //TODO: add check for limit switches having same state as when limit_isr were invoked?
 8004758:	4283      	cmp	r3, r0
 800475a:	d004      	beq.n	8004766 <TIM4_IRQHandler+0x26>
        hal.limit_interrupt_callback(state);
 800475c:	4a05      	ldr	r2, [pc, #20]	; (8004774 <TIM4_IRQHandler+0x34>)
 800475e:	4058      	eors	r0, r3
 8004760:	f8d2 3138 	ldr.w	r3, [r2, #312]	; 0x138
 8004764:	4718      	bx	r3
}
 8004766:	4770      	bx	lr
 8004768:	40000800 	.word	0x40000800
 800476c:	40010c00 	.word	0x40010c00
 8004770:	20002620 	.word	0x20002620
 8004774:	200024bc 	.word	0x200024bc

08004778 <EXTI15_10_IRQHandler>:
void EXTI15_10_IRQHandler(void)
{
#if KEYPAD_ENABLE
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(LIMIT_MASK|KEYPAD_STROBE_BIT);
#else
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(LIMIT_MASK);
 8004778:	4a0f      	ldr	r2, [pc, #60]	; (80047b8 <EXTI15_10_IRQHandler+0x40>)
 800477a:	6953      	ldr	r3, [r2, #20]
#endif
    if(ifg) {
 800477c:	f413 43e0 	ands.w	r3, r3, #28672	; 0x7000
 8004780:	d00d      	beq.n	800479e <EXTI15_10_IRQHandler+0x26>
        if(ifg & KEYPAD_STROBE_BIT)
            keypad_keyclick_handler(BITBAND_PERI(KEYPAD_PORT->IDR, KEYPAD_STROBE_PIN));
        if(ifg & LIMIT_MASK) {
#endif

        if(hal.driver_cap.software_debounce) {
 8004782:	490e      	ldr	r1, [pc, #56]	; (80047bc <EXTI15_10_IRQHandler+0x44>)
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 8004784:	6153      	str	r3, [r2, #20]
        if(hal.driver_cap.software_debounce) {
 8004786:	f891 3144 	ldrb.w	r3, [r1, #324]	; 0x144
 800478a:	06db      	lsls	r3, r3, #27
 800478c:	d508      	bpl.n	80047a0 <EXTI15_10_IRQHandler+0x28>
            DEBOUNCE_TIMER->EGR = TIM_EGR_UG;
 800478e:	2201      	movs	r2, #1
 8004790:	4b0b      	ldr	r3, [pc, #44]	; (80047c0 <EXTI15_10_IRQHandler+0x48>)
 8004792:	615a      	str	r2, [r3, #20]
            DEBOUNCE_TIMER->CR1 |= TIM_CR1_CEN; // Start debounce timer (40ms)
 8004794:	681a      	ldr	r2, [r3, #0]
 8004796:	f042 0201 	orr.w	r2, r2, #1
 800479a:	601a      	str	r2, [r3, #0]
 800479c:	4770      	bx	lr

#if KEYPAD_ENABLE
        }
#endif
    }
}
 800479e:	4770      	bx	lr
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 80047a0:	4b08      	ldr	r3, [pc, #32]	; (80047c4 <EXTI15_10_IRQHandler+0x4c>)
    if (settings.limits.invert.mask)
 80047a2:	4a09      	ldr	r2, [pc, #36]	; (80047c8 <EXTI15_10_IRQHandler+0x50>)
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 80047a4:	689b      	ldr	r3, [r3, #8]
        signals.value ^= settings.limits.invert.mask;
 80047a6:	f892 00d5 	ldrb.w	r0, [r2, #213]	; 0xd5
    signals.value = (uint8_t)((LIMIT_PORT->IDR & LIMIT_MASK) >> LIMIT_INMODE);
 80047aa:	0a9b      	lsrs	r3, r3, #10
 80047ac:	f003 031c 	and.w	r3, r3, #28
            hal.limit_interrupt_callback(limitsGetState());
 80047b0:	f8d1 2138 	ldr.w	r2, [r1, #312]	; 0x138
 80047b4:	4058      	eors	r0, r3
 80047b6:	4710      	bx	r2
 80047b8:	40010400 	.word	0x40010400
 80047bc:	200024bc 	.word	0x200024bc
 80047c0:	40000800 	.word	0x40000800
 80047c4:	40010c00 	.word	0x40010c00
 80047c8:	20002620 	.word	0x20002620

080047cc <EXTI9_5_IRQHandler>:

void EXTI9_5_IRQHandler(void)
{
    uint32_t ifg = __HAL_GPIO_EXTI_GET_IT(CONTROL_MASK);
 80047cc:	4a0a      	ldr	r2, [pc, #40]	; (80047f8 <EXTI9_5_IRQHandler+0x2c>)
 80047ce:	6953      	ldr	r3, [r2, #20]

    if(ifg) {
 80047d0:	f413 73f0 	ands.w	r3, r3, #480	; 0x1e0
 80047d4:	d100      	bne.n	80047d8 <EXTI9_5_IRQHandler+0xc>

        __HAL_GPIO_EXTI_CLEAR_IT(ifg);

        hal.control_interrupt_callback(systemGetState());
    }
}
 80047d6:	4770      	bx	lr
    uint32_t bits = CONTROL_PORT->IDR;
 80047d8:	4908      	ldr	r1, [pc, #32]	; (80047fc <EXTI9_5_IRQHandler+0x30>)
        __HAL_GPIO_EXTI_CLEAR_IT(ifg);
 80047da:	6153      	str	r3, [r2, #20]
    if(settings.control_invert.mask)
 80047dc:	4a08      	ldr	r2, [pc, #32]	; (8004800 <EXTI9_5_IRQHandler+0x34>)
    uint32_t bits = CONTROL_PORT->IDR;
 80047de:	688b      	ldr	r3, [r1, #8]
    if(settings.control_invert.mask)
 80047e0:	f892 2041 	ldrb.w	r2, [r2, #65]	; 0x41
        hal.control_interrupt_callback(systemGetState());
 80047e4:	4907      	ldr	r1, [pc, #28]	; (8004804 <EXTI9_5_IRQHandler+0x38>)
    signals.reset = (bits & CONTROL_RESET_BIT) != 0;
 80047e6:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80047ea:	4618      	mov	r0, r3
        hal.control_interrupt_callback(systemGetState());
 80047ec:	f8d1 113c 	ldr.w	r1, [r1, #316]	; 0x13c
    if(settings.control_invert.mask)
 80047f0:	b10a      	cbz	r2, 80047f6 <EXTI9_5_IRQHandler+0x2a>
        signals.value ^= settings.control_invert.mask;
 80047f2:	ea82 0003 	eor.w	r0, r2, r3
        hal.control_interrupt_callback(systemGetState());
 80047f6:	4708      	bx	r1
 80047f8:	40010400 	.word	0x40010400
 80047fc:	40010c00 	.word	0x40010c00
 8004800:	20002620 	.word	0x20002620
 8004804:	200024bc 	.word	0x200024bc

08004808 <HAL_IncTick>:

// Interrupt handler for 1 ms interval timer
void HAL_IncTick(void)
{
 8004808:	b538      	push	{r3, r4, r5, lr}
    if(!(--fatfs_ticks)) {
        disk_timerproc();
        fatfs_ticks = 10;
    }
#endif
    uwTick += uwTickFreq;
 800480a:	4a09      	ldr	r2, [pc, #36]	; (8004830 <HAL_IncTick+0x28>)
 800480c:	4b09      	ldr	r3, [pc, #36]	; (8004834 <HAL_IncTick+0x2c>)
 800480e:	6811      	ldr	r1, [r2, #0]
 8004810:	781b      	ldrb	r3, [r3, #0]

    if(delay.ms && !(--delay.ms)) {
 8004812:	4c09      	ldr	r4, [pc, #36]	; (8004838 <HAL_IncTick+0x30>)
    uwTick += uwTickFreq;
 8004814:	440b      	add	r3, r1
 8004816:	6013      	str	r3, [r2, #0]
    if(delay.ms && !(--delay.ms)) {
 8004818:	6823      	ldr	r3, [r4, #0]
 800481a:	b13b      	cbz	r3, 800482c <HAL_IncTick+0x24>
 800481c:	6825      	ldr	r5, [r4, #0]
 800481e:	3d01      	subs	r5, #1
 8004820:	6025      	str	r5, [r4, #0]
 8004822:	b91d      	cbnz	r5, 800482c <HAL_IncTick+0x24>
        if(delay.callback) {
 8004824:	6863      	ldr	r3, [r4, #4]
 8004826:	b10b      	cbz	r3, 800482c <HAL_IncTick+0x24>
            delay.callback();
 8004828:	4798      	blx	r3
            delay.callback = NULL;
 800482a:	6065      	str	r5, [r4, #4]
        }
    }
}
 800482c:	bd38      	pop	{r3, r4, r5, pc}
 800482e:	bf00      	nop
 8004830:	20001ef8 	.word	0x20001ef8
 8004834:	20000000 	.word	0x20000000
 8004838:	20000008 	.word	0x20000008

0800483c <memcpy_from_flash>:
#include "stm32f1xx_hal_flash_ex.h"

static const uint8_t *flash_target = (uint8_t *)(FLASH_BANK1_END - FLASH_PAGE_SIZE + 1);    // Last page start adress

bool memcpy_from_flash (uint8_t *dest)
{
 800483c:	b508      	push	{r3, lr}
    memcpy(dest, flash_target, hal.eeprom.size);
 800483e:	4b04      	ldr	r3, [pc, #16]	; (8004850 <memcpy_from_flash+0x14>)
 8004840:	4904      	ldr	r1, [pc, #16]	; (8004854 <memcpy_from_flash+0x18>)
 8004842:	f8b3 20f6 	ldrh.w	r2, [r3, #246]	; 0xf6
 8004846:	f00d fa0f 	bl	8011c68 <memcpy>
    return true;
}
 800484a:	2001      	movs	r0, #1
 800484c:	bd08      	pop	{r3, pc}
 800484e:	bf00      	nop
 8004850:	200024bc 	.word	0x200024bc
 8004854:	0801fc00 	.word	0x0801fc00

08004858 <memcpy_to_flash>:

bool memcpy_to_flash (uint8_t *source)
{
 8004858:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (!memcmp(source, flash_target, hal.eeprom.size))
 800485a:	4c20      	ldr	r4, [pc, #128]	; (80048dc <memcpy_to_flash+0x84>)
{
 800485c:	b087      	sub	sp, #28
    if (!memcmp(source, flash_target, hal.eeprom.size))
 800485e:	4920      	ldr	r1, [pc, #128]	; (80048e0 <memcpy_to_flash+0x88>)
 8004860:	f8b4 20f6 	ldrh.w	r2, [r4, #246]	; 0xf6
{
 8004864:	4606      	mov	r6, r0
    if (!memcmp(source, flash_target, hal.eeprom.size))
 8004866:	f00d f9f1 	bl	8011c4c <memcmp>
 800486a:	b910      	cbnz	r0, 8004872 <memcpy_to_flash+0x1a>
        return true;
 800486c:	2001      	movs	r0, #1
    }

    HAL_FLASH_Lock();

    return status == HAL_OK;
}
 800486e:	b007      	add	sp, #28
 8004870:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_FLASH_Unlock();
 8004872:	f7fc fb91 	bl	8000f98 <HAL_FLASH_Unlock>
    FLASH_EraseInitTypeDef erase = {
 8004876:	2000      	movs	r0, #0
 8004878:	2101      	movs	r1, #1
 800487a:	2301      	movs	r3, #1
 800487c:	4a18      	ldr	r2, [pc, #96]	; (80048e0 <memcpy_to_flash+0x88>)
 800487e:	e9cd 0102 	strd	r0, r1, [sp, #8]
    HAL_StatusTypeDef status = HAL_FLASHEx_Erase(&erase, &error);
 8004882:	a901      	add	r1, sp, #4
 8004884:	a802      	add	r0, sp, #8
    FLASH_EraseInitTypeDef erase = {
 8004886:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_StatusTypeDef status = HAL_FLASHEx_Erase(&erase, &error);
 800488a:	f7fc fbf9 	bl	8001080 <HAL_FLASHEx_Erase>
    uint32_t address = (uint32_t)flash_target, remaining = (uint32_t)hal.eeprom.size;
 800488e:	f8b4 70f6 	ldrh.w	r7, [r4, #246]	; 0xf6
    HAL_StatusTypeDef status = HAL_FLASHEx_Erase(&erase, &error);
 8004892:	4605      	mov	r5, r0
    while(remaining && status == HAL_OK) {
 8004894:	b1df      	cbz	r7, 80048ce <memcpy_to_flash+0x76>
 8004896:	b9d0      	cbnz	r0, 80048ce <memcpy_to_flash+0x76>
 8004898:	f107 6700 	add.w	r7, r7, #134217728	; 0x8000000
    uint32_t address = (uint32_t)flash_target, remaining = (uint32_t)hal.eeprom.size;
 800489c:	4c10      	ldr	r4, [pc, #64]	; (80048e0 <memcpy_to_flash+0x88>)
 800489e:	f507 37fe 	add.w	r7, r7, #130048	; 0x1fc00
 80048a2:	3604      	adds	r6, #4
 80048a4:	e001      	b.n	80048aa <memcpy_to_flash+0x52>
 80048a6:	3604      	adds	r6, #4
    while(remaining && status == HAL_OK) {
 80048a8:	b988      	cbnz	r0, 80048ce <memcpy_to_flash+0x76>
        status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, address, *data++);
 80048aa:	4621      	mov	r1, r4
 80048ac:	2300      	movs	r3, #0
 80048ae:	f836 2c04 	ldrh.w	r2, [r6, #-4]
 80048b2:	2001      	movs	r0, #1
 80048b4:	f7fc fa92 	bl	8000ddc <HAL_FLASH_Program>
        status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, address + 2, *data++);
 80048b8:	1ca1      	adds	r1, r4, #2
 80048ba:	2300      	movs	r3, #0
 80048bc:	2001      	movs	r0, #1
 80048be:	f836 2c02 	ldrh.w	r2, [r6, #-2]
 80048c2:	f7fc fa8b 	bl	8000ddc <HAL_FLASH_Program>
        address += 4;
 80048c6:	3404      	adds	r4, #4
    while(remaining && status == HAL_OK) {
 80048c8:	42bc      	cmp	r4, r7
        status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_HALFWORD, address + 2, *data++);
 80048ca:	4605      	mov	r5, r0
    while(remaining && status == HAL_OK) {
 80048cc:	d1eb      	bne.n	80048a6 <memcpy_to_flash+0x4e>
    HAL_FLASH_Lock();
 80048ce:	f7fc fb77 	bl	8000fc0 <HAL_FLASH_Lock>
    return status == HAL_OK;
 80048d2:	fab5 f085 	clz	r0, r5
 80048d6:	0940      	lsrs	r0, r0, #5
}
 80048d8:	b007      	add	sp, #28
 80048da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80048dc:	200024bc 	.word	0x200024bc
 80048e0:	0801fc00 	.word	0x0801fc00

080048e4 <SystemClock_Config>:
/*
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
 80048e4:	b5f0      	push	{r4, r5, r6, r7, lr}

    /** Initializes the CPU, AHB and APB busses clocks */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80048e6:	2101      	movs	r1, #1
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80048e8:	2400      	movs	r4, #0
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80048ea:	2502      	movs	r5, #2
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80048ec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 80048f0:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80048f4:	2601      	movs	r6, #1
 80048f6:	f44f 3780 	mov.w	r7, #65536	; 0x10000
{
 80048fa:	b095      	sub	sp, #84	; 0x54
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80048fc:	a80a      	add	r0, sp, #40	; 0x28
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80048fe:	e9cd 670a 	strd	r6, r7, [sp, #40]	; 0x28
    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8004902:	e9cd 5211 	strd	r5, r2, [sp, #68]	; 0x44
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8004906:	910e      	str	r1, [sp, #56]	; 0x38
    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8004908:	9313      	str	r3, [sp, #76]	; 0x4c
        Error_Handler();

    /** Initializes the CPU, AHB and APB busses clocks */
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 800490a:	260f      	movs	r6, #15
 800490c:	2702      	movs	r7, #2
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800490e:	e9cd 440f 	strd	r4, r4, [sp, #60]	; 0x3c
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8004912:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8004916:	e9cd 4407 	strd	r4, r4, [sp, #28]
    RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 800491a:	e9cd 4401 	strd	r4, r4, [sp, #4]
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800491e:	940d      	str	r4, [sp, #52]	; 0x34
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8004920:	9404      	str	r4, [sp, #16]
    RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8004922:	9400      	str	r4, [sp, #0]
    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 8004924:	940c      	str	r4, [sp, #48]	; 0x30
    RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8004926:	9403      	str	r4, [sp, #12]
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8004928:	f7fd fe0e 	bl	8002548 <HAL_RCC_OscConfig>
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 800492c:	2200      	movs	r2, #0
 800492e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8004932:	4629      	mov	r1, r5
 8004934:	a804      	add	r0, sp, #16
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
 8004936:	e9cd 2306 	strd	r2, r3, [sp, #24]
 800493a:	e9cd 6704 	strd	r6, r7, [sp, #16]
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800493e:	9408      	str	r4, [sp, #32]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8004940:	f7fd ffe8 	bl	8002914 <HAL_RCC_ClockConfig>
        Error_Handler();

    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8004944:	2310      	movs	r3, #16
    PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8004946:	4668      	mov	r0, sp
    PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
 8004948:	9403      	str	r4, [sp, #12]
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 800494a:	9300      	str	r3, [sp, #0]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800494c:	f7fe f8d6 	bl	8002afc <HAL_RCCEx_PeriphCLKConfig>
        Error_Handler();
}
 8004950:	b015      	add	sp, #84	; 0x54
 8004952:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004954 <main>:
{
 8004954:	b500      	push	{lr}
 8004956:	b085      	sub	sp, #20
    HAL_Init();
 8004958:	f7fc f962 	bl	8000c20 <HAL_Init>
    SystemClock_Config();
 800495c:	f7ff ffc2 	bl	80048e4 <SystemClock_Config>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004960:	4b10      	ldr	r3, [pc, #64]	; (80049a4 <main+0x50>)
 8004962:	699a      	ldr	r2, [r3, #24]
 8004964:	f042 0204 	orr.w	r2, r2, #4
 8004968:	619a      	str	r2, [r3, #24]
 800496a:	699a      	ldr	r2, [r3, #24]
 800496c:	f002 0204 	and.w	r2, r2, #4
 8004970:	9201      	str	r2, [sp, #4]
 8004972:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004974:	699a      	ldr	r2, [r3, #24]
 8004976:	f042 0208 	orr.w	r2, r2, #8
 800497a:	619a      	str	r2, [r3, #24]
 800497c:	699a      	ldr	r2, [r3, #24]
 800497e:	f002 0208 	and.w	r2, r2, #8
 8004982:	9202      	str	r2, [sp, #8]
 8004984:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8004986:	699a      	ldr	r2, [r3, #24]
 8004988:	f042 0210 	orr.w	r2, r2, #16
 800498c:	619a      	str	r2, [r3, #24]
 800498e:	699b      	ldr	r3, [r3, #24]
 8004990:	f003 0310 	and.w	r3, r3, #16
 8004994:	9303      	str	r3, [sp, #12]
 8004996:	9b03      	ldr	r3, [sp, #12]
    grbl_enter();
 8004998:	f003 fd60 	bl	800845c <grbl_enter>
}
 800499c:	2000      	movs	r0, #0
 800499e:	b005      	add	sp, #20
 80049a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80049a4:	40021000 	.word	0x40021000

080049a8 <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 80049a8:	4770      	bx	lr
 80049aa:	bf00      	nop

080049ac <serialGetC>:
//
// serialGetC - returns -1 if no data available
//
int16_t serialGetC (void)
{
    uint16_t bptr = rxbuf.tail;
 80049ac:	4a08      	ldr	r2, [pc, #32]	; (80049d0 <serialGetC+0x24>)
 80049ae:	6853      	ldr	r3, [r2, #4]

    if(bptr == rxbuf.head)
 80049b0:	6810      	ldr	r0, [r2, #0]
 80049b2:	b299      	uxth	r1, r3
 80049b4:	4288      	cmp	r0, r1
    uint16_t bptr = rxbuf.tail;
 80049b6:	460b      	mov	r3, r1
    if(bptr == rxbuf.head)
 80049b8:	d007      	beq.n	80049ca <serialGetC+0x1e>
        return -1; // no data available else EOF

    char data = rxbuf.data[bptr++];             // Get next character, increment tmp pointer
 80049ba:	4411      	add	r1, r2
 80049bc:	7a88      	ldrb	r0, [r1, #10]
 80049be:	3301      	adds	r3, #1
    rxbuf.tail = bptr & (RX_BUFFER_SIZE - 1);   // and update pointer
 80049c0:	f3c3 0309 	ubfx	r3, r3, #0, #10

    return (int16_t)data;
 80049c4:	b200      	sxth	r0, r0
    rxbuf.tail = bptr & (RX_BUFFER_SIZE - 1);   // and update pointer
 80049c6:	6053      	str	r3, [r2, #4]
    return (int16_t)data;
 80049c8:	4770      	bx	lr
        return -1; // no data available else EOF
 80049ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80049ce:	4770      	bx	lr
 80049d0:	20000340 	.word	0x20000340

080049d4 <serialGetNull>:

// "dummy" version of serialGetC
static int16_t serialGetNull (void)
{
    return -1;
}
 80049d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80049d8:	4770      	bx	lr
 80049da:	bf00      	nop

080049dc <serialInit>:
{
 80049dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    GPIO_InitStructure.Pin = GPIO_PIN_9;
 80049e0:	f44f 7400 	mov.w	r4, #512	; 0x200
 80049e4:	2502      	movs	r5, #2
    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
 80049e6:	2703      	movs	r7, #3
    __HAL_RCC_USART1_CLK_ENABLE();
 80049e8:	4b3f      	ldr	r3, [pc, #252]	; (8004ae8 <serialInit+0x10c>)
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 80049ea:	4e40      	ldr	r6, [pc, #256]	; (8004aec <serialInit+0x110>)
    __HAL_RCC_USART1_CLK_ENABLE();
 80049ec:	699a      	ldr	r2, [r3, #24]
{
 80049ee:	b087      	sub	sp, #28
    __HAL_RCC_USART1_CLK_ENABLE();
 80049f0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80049f4:	619a      	str	r2, [r3, #24]
 80049f6:	699b      	ldr	r3, [r3, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 80049f8:	4630      	mov	r0, r6
    __HAL_RCC_USART1_CLK_ENABLE();
 80049fa:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80049fe:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a00:	a902      	add	r1, sp, #8
    GPIO_InitStructure.Pin = GPIO_PIN_9;
 8004a02:	e9cd 4502 	strd	r4, r5, [sp, #8]
    __HAL_RCC_USART1_CLK_ENABLE();
 8004a06:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStructure.Pull = GPIO_NOPULL;
 8004a08:	2500      	movs	r5, #0
    GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
 8004a0a:	9705      	str	r7, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a0c:	f7fc fb9a 	bl	8001144 <HAL_GPIO_Init>
    GPIO_InitStructure.Pin = GPIO_PIN_10;
 8004a10:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8004a14:	2300      	movs	r3, #0
    USART1->CR1 |= (USART_CR1_RE|USART_CR1_TE);
 8004a16:	4c36      	ldr	r4, [pc, #216]	; (8004af0 <serialInit+0x114>)
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a18:	a902      	add	r1, sp, #8
 8004a1a:	4630      	mov	r0, r6
    GPIO_InitStructure.Pin = GPIO_PIN_10;
 8004a1c:	e9cd 2302 	strd	r2, r3, [sp, #8]
    GPIO_InitStructure.Pull = GPIO_NOPULL;
 8004a20:	9504      	str	r5, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 8004a22:	f7fc fb8f 	bl	8001144 <HAL_GPIO_Init>
    USART1->CR1 |= (USART_CR1_RE|USART_CR1_TE);
 8004a26:	68e3      	ldr	r3, [r4, #12]
 8004a28:	f043 030c 	orr.w	r3, r3, #12
 8004a2c:	60e3      	str	r3, [r4, #12]
    USART1->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), 115200);
 8004a2e:	f7fe f855 	bl	8002adc <HAL_RCC_GetPCLK2Freq>
 8004a32:	4606      	mov	r6, r0
 8004a34:	f7fe f852 	bl	8002adc <HAL_RCC_GetPCLK2Freq>
 8004a38:	4680      	mov	r8, r0
 8004a3a:	f7fe f84f 	bl	8002adc <HAL_RCC_GetPCLK2Freq>
 8004a3e:	4607      	mov	r7, r0
 8004a40:	f7fe f84c 	bl	8002adc <HAL_RCC_GetPCLK2Freq>
 8004a44:	4681      	mov	r9, r0
 8004a46:	f7fe f849 	bl	8002adc <HAL_RCC_GetPCLK2Freq>
 8004a4a:	2264      	movs	r2, #100	; 0x64
 8004a4c:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8004a50:	4928      	ldr	r1, [pc, #160]	; (8004af4 <serialInit+0x118>)
 8004a52:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8004a56:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004a5a:	0b7f      	lsrs	r7, r7, #13
 8004a5c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004a60:	fba1 7307 	umull	r7, r3, r1, r7
 8004a64:	0b40      	lsrs	r0, r0, #13
 8004a66:	fba1 0700 	umull	r0, r7, r1, r0
 8004a6a:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8004a6e:	4822      	ldr	r0, [pc, #136]	; (8004af8 <serialInit+0x11c>)
 8004a70:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 8004a74:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 8004a78:	fba0 c808 	umull	ip, r8, r0, r8
 8004a7c:	fb02 f303 	mul.w	r3, r2, r3
 8004a80:	eb09 0989 	add.w	r9, r9, r9, lsl #2
 8004a84:	fb02 f207 	mul.w	r2, r2, r7
 8004a88:	fba0 0909 	umull	r0, r9, r0, r9
 8004a8c:	ebc3 4398 	rsb	r3, r3, r8, lsr #18
 8004a90:	481a      	ldr	r0, [pc, #104]	; (8004afc <serialInit+0x120>)
 8004a92:	ebc2 4299 	rsb	r2, r2, r9, lsr #18
 8004a96:	011b      	lsls	r3, r3, #4
 8004a98:	3332      	adds	r3, #50	; 0x32
 8004a9a:	0112      	lsls	r2, r2, #4
 8004a9c:	fba0 7303 	umull	r7, r3, r0, r3
 8004aa0:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8004aa4:	3232      	adds	r2, #50	; 0x32
 8004aa6:	fba0 0202 	umull	r0, r2, r0, r2
 8004aaa:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8004aae:	0b76      	lsrs	r6, r6, #13
 8004ab0:	fba1 0106 	umull	r0, r1, r1, r6
 8004ab4:	095b      	lsrs	r3, r3, #5
 8004ab6:	f3c2 1243 	ubfx	r2, r2, #5, #4
 8004aba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004abe:	4313      	orrs	r3, r2
 8004ac0:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 8004ac4:	60a3      	str	r3, [r4, #8]
    USART1->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 8004ac6:	68e3      	ldr	r3, [r4, #12]
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8004ac8:	462a      	mov	r2, r5
    USART1->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 8004aca:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8004ace:	f043 0320 	orr.w	r3, r3, #32
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8004ad2:	4629      	mov	r1, r5
    USART1->CR1 |= (USART_CR1_UE|USART_CR1_RXNEIE);
 8004ad4:	60e3      	str	r3, [r4, #12]
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8004ad6:	2025      	movs	r0, #37	; 0x25
 8004ad8:	f7fc f8cc 	bl	8000c74 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8004adc:	2025      	movs	r0, #37	; 0x25
 8004ade:	f7fc f901 	bl	8000ce4 <HAL_NVIC_EnableIRQ>
}
 8004ae2:	b007      	add	sp, #28
 8004ae4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004ae8:	40021000 	.word	0x40021000
 8004aec:	40010800 	.word	0x40010800
 8004af0:	40013800 	.word	0x40013800
 8004af4:	000ba69f 	.word	0x000ba69f
 8004af8:	91a2b3c5 	.word	0x91a2b3c5
 8004afc:	51eb851f 	.word	0x51eb851f

08004b00 <serialRxFree>:
    uint16_t tail = rxbuf.tail, head = rxbuf.head;
 8004b00:	4b05      	ldr	r3, [pc, #20]	; (8004b18 <serialRxFree+0x18>)
 8004b02:	6858      	ldr	r0, [r3, #4]
 8004b04:	681b      	ldr	r3, [r3, #0]
 8004b06:	b280      	uxth	r0, r0
 8004b08:	b29b      	uxth	r3, r3
    return RX_BUFFER_SIZE - BUFCOUNT(head, tail, RX_BUFFER_SIZE);
 8004b0a:	4298      	cmp	r0, r3
 8004b0c:	bf98      	it	ls
 8004b0e:	f500 6080 	addls.w	r0, r0, #1024	; 0x400
 8004b12:	1ac0      	subs	r0, r0, r3
 8004b14:	b280      	uxth	r0, r0
}
 8004b16:	4770      	bx	lr
 8004b18:	20000340 	.word	0x20000340

08004b1c <serialRxFlush>:
    rxbuf.head = rxbuf.tail = 0;
 8004b1c:	2200      	movs	r2, #0
 8004b1e:	4b02      	ldr	r3, [pc, #8]	; (8004b28 <serialRxFlush+0xc>)
 8004b20:	605a      	str	r2, [r3, #4]
 8004b22:	601a      	str	r2, [r3, #0]
}
 8004b24:	4770      	bx	lr
 8004b26:	bf00      	nop
 8004b28:	20000340 	.word	0x20000340

08004b2c <serialRxCancel>:
    rxbuf.data[rxbuf.head] = ASCII_CAN;
 8004b2c:	2118      	movs	r1, #24
 8004b2e:	4b06      	ldr	r3, [pc, #24]	; (8004b48 <serialRxCancel+0x1c>)
 8004b30:	681a      	ldr	r2, [r3, #0]
 8004b32:	441a      	add	r2, r3
 8004b34:	7291      	strb	r1, [r2, #10]
    rxbuf.tail = rxbuf.head;
 8004b36:	681a      	ldr	r2, [r3, #0]
 8004b38:	605a      	str	r2, [r3, #4]
    rxbuf.head = (rxbuf.tail + 1) & (RX_BUFFER_SIZE - 1);
 8004b3a:	685a      	ldr	r2, [r3, #4]
 8004b3c:	3201      	adds	r2, #1
 8004b3e:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8004b42:	601a      	str	r2, [r3, #0]
}
 8004b44:	4770      	bx	lr
 8004b46:	bf00      	nop
 8004b48:	20000340 	.word	0x20000340

08004b4c <serialWriteS>:
{
 8004b4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    while((c = *ptr++) != '\0')
 8004b50:	4607      	mov	r7, r0
 8004b52:	f817 6b01 	ldrb.w	r6, [r7], #1
 8004b56:	b1f6      	cbz	r6, 8004b96 <serialWriteS+0x4a>
 8004b58:	4d10      	ldr	r5, [pc, #64]	; (8004b9c <serialWriteS+0x50>)
            if(!hal.stream_blocking_callback())                         // check if blocking for space,
 8004b5a:	f8df 9044 	ldr.w	r9, [pc, #68]	; 8004ba0 <serialWriteS+0x54>
        USART1->CR1 |= USART_CR1_TXEIE;                                 // enable TX interrupts
 8004b5e:	f8df 8044 	ldr.w	r8, [pc, #68]	; 8004ba4 <serialWriteS+0x58>
        uint16_t next_head = (txbuf.head + 1) & (TX_BUFFER_SIZE - 1);   // .. if not, get pointer to next free slot in buffer
 8004b62:	682c      	ldr	r4, [r5, #0]
 8004b64:	3401      	adds	r4, #1
 8004b66:	f3c4 0408 	ubfx	r4, r4, #0, #9
        while(txbuf.tail == next_head) {                                // While TX buffer full
 8004b6a:	e003      	b.n	8004b74 <serialWriteS+0x28>
            if(!hal.stream_blocking_callback())                         // check if blocking for space,
 8004b6c:	f8d9 3130 	ldr.w	r3, [r9, #304]	; 0x130
 8004b70:	4798      	blx	r3
 8004b72:	b160      	cbz	r0, 8004b8e <serialWriteS+0x42>
        while(txbuf.tail == next_head) {                                // While TX buffer full
 8004b74:	686b      	ldr	r3, [r5, #4]
 8004b76:	42a3      	cmp	r3, r4
 8004b78:	d0f8      	beq.n	8004b6c <serialWriteS+0x20>
        txbuf.data[txbuf.head] = c;                                     // Add data to buffer,
 8004b7a:	682b      	ldr	r3, [r5, #0]
        txbuf.head = next_head;                                         // update head pointer and
 8004b7c:	602c      	str	r4, [r5, #0]
        txbuf.data[txbuf.head] = c;                                     // Add data to buffer,
 8004b7e:	442b      	add	r3, r5
 8004b80:	721e      	strb	r6, [r3, #8]
        USART1->CR1 |= USART_CR1_TXEIE;                                 // enable TX interrupts
 8004b82:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8004b86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004b8a:	f8c8 300c 	str.w	r3, [r8, #12]
    while((c = *ptr++) != '\0')
 8004b8e:	f817 6b01 	ldrb.w	r6, [r7], #1
 8004b92:	2e00      	cmp	r6, #0
 8004b94:	d1e5      	bne.n	8004b62 <serialWriteS+0x16>
}
 8004b96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004b9a:	bf00      	nop
 8004b9c:	2000074c 	.word	0x2000074c
 8004ba0:	200024bc 	.word	0x200024bc
 8004ba4:	40013800 	.word	0x40013800

08004ba8 <serialSuspendInput>:

bool serialSuspendInput (bool suspend)
{
 8004ba8:	b508      	push	{r3, lr}
    if(suspend)
 8004baa:	b148      	cbz	r0, 8004bc0 <serialSuspendInput+0x18>
        hal.stream.read = serialGetNull;
 8004bac:	4a0a      	ldr	r2, [pc, #40]	; (8004bd8 <serialSuspendInput+0x30>)
 8004bae:	490b      	ldr	r1, [pc, #44]	; (8004bdc <serialSuspendInput+0x34>)
 8004bb0:	4b0b      	ldr	r3, [pc, #44]	; (8004be0 <serialSuspendInput+0x38>)
 8004bb2:	66d1      	str	r1, [r2, #108]	; 0x6c
    else if(rxbuf.backup)
        memcpy(&rxbuf, &rxbackup, sizeof(stream_rx_buffer_t));

    return rxbuf.tail != rxbuf.head;
 8004bb4:	6858      	ldr	r0, [r3, #4]
 8004bb6:	681b      	ldr	r3, [r3, #0]
}
 8004bb8:	1ac0      	subs	r0, r0, r3
 8004bba:	bf18      	it	ne
 8004bbc:	2001      	movne	r0, #1
 8004bbe:	bd08      	pop	{r3, pc}
    else if(rxbuf.backup)
 8004bc0:	4b07      	ldr	r3, [pc, #28]	; (8004be0 <serialSuspendInput+0x38>)
 8004bc2:	7a5a      	ldrb	r2, [r3, #9]
 8004bc4:	2a00      	cmp	r2, #0
 8004bc6:	d0f5      	beq.n	8004bb4 <serialSuspendInput+0xc>
        memcpy(&rxbuf, &rxbackup, sizeof(stream_rx_buffer_t));
 8004bc8:	4618      	mov	r0, r3
 8004bca:	f240 420c 	movw	r2, #1036	; 0x40c
 8004bce:	4905      	ldr	r1, [pc, #20]	; (8004be4 <serialSuspendInput+0x3c>)
 8004bd0:	f00d f84a 	bl	8011c68 <memcpy>
 8004bd4:	4603      	mov	r3, r0
 8004bd6:	e7ed      	b.n	8004bb4 <serialSuspendInput+0xc>
 8004bd8:	200024bc 	.word	0x200024bc
 8004bdc:	080049d5 	.word	0x080049d5
 8004be0:	20000340 	.word	0x20000340
 8004be4:	20000138 	.word	0x20000138

08004be8 <USART1_IRQHandler>:

void USART1_IRQHandler (void)
{
    if(USART1->SR & USART_SR_RXNE) {
 8004be8:	4b26      	ldr	r3, [pc, #152]	; (8004c84 <USART1_IRQHandler+0x9c>)
{
 8004bea:	b570      	push	{r4, r5, r6, lr}
    if(USART1->SR & USART_SR_RXNE) {
 8004bec:	681a      	ldr	r2, [r3, #0]
 8004bee:	0690      	lsls	r0, r2, #26
 8004bf0:	d510      	bpl.n	8004c14 <USART1_IRQHandler+0x2c>

        uint16_t next_head = (rxbuf.head + 1) & (RX_BUFFER_SIZE - 1);   // Get and increment buffer pointer
 8004bf2:	4d25      	ldr	r5, [pc, #148]	; (8004c88 <USART1_IRQHandler+0xa0>)
 8004bf4:	682c      	ldr	r4, [r5, #0]

        if(rxbuf.tail == next_head) {                                   // If buffer full
 8004bf6:	686a      	ldr	r2, [r5, #4]
        uint16_t next_head = (rxbuf.head + 1) & (RX_BUFFER_SIZE - 1);   // Get and increment buffer pointer
 8004bf8:	3401      	adds	r4, #1
        if(rxbuf.tail == next_head) {                                   // If buffer full
 8004bfa:	f3c4 0409 	ubfx	r4, r4, #0, #10
 8004bfe:	42a2      	cmp	r2, r4
 8004c00:	d020      	beq.n	8004c44 <USART1_IRQHandler+0x5c>
            rxbuf.overflow = 1;                                         // flag overflow
            next_head =  USART1->DR;                                    // and do dummy read to clear interrupt
        } else {
            char data = USART1->DR;
 8004c02:	685e      	ldr	r6, [r3, #4]
 8004c04:	b2f6      	uxtb	r6, r6
            if(data == CMD_TOOL_ACK && !rxbuf.backup) {
 8004c06:	2ea3      	cmp	r6, #163	; 0xa3
 8004c08:	d02a      	beq.n	8004c60 <USART1_IRQHandler+0x78>
                memcpy(&rxbackup, &rxbuf, sizeof(stream_rx_buffer_t));
                rxbuf.backup = true;
                rxbuf.tail = rxbuf.head;
                hal.stream.read = serialGetC; // restore normal input

            } else if(!hal.stream.enqueue_realtime_command(data)) {     // Check and strip realtime commands,
 8004c0a:	4b20      	ldr	r3, [pc, #128]	; (8004c8c <USART1_IRQHandler+0xa4>)
 8004c0c:	4630      	mov	r0, r6
 8004c0e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004c10:	4798      	blx	r3
 8004c12:	b1d8      	cbz	r0, 8004c4c <USART1_IRQHandler+0x64>
                rxbuf.head = next_head;                                 // and update pointer
            }
        }
    }

    if((USART1->SR & USART_SR_TXE) && (USART1->CR1 & USART_CR1_TXEIE)) {
 8004c14:	4b1b      	ldr	r3, [pc, #108]	; (8004c84 <USART1_IRQHandler+0x9c>)
 8004c16:	681a      	ldr	r2, [r3, #0]
 8004c18:	0611      	lsls	r1, r2, #24
 8004c1a:	d512      	bpl.n	8004c42 <USART1_IRQHandler+0x5a>
 8004c1c:	68da      	ldr	r2, [r3, #12]
 8004c1e:	0612      	lsls	r2, r2, #24
 8004c20:	d50f      	bpl.n	8004c42 <USART1_IRQHandler+0x5a>

        uint16_t tail = txbuf.tail;             // Get buffer pointer
 8004c22:	481b      	ldr	r0, [pc, #108]	; (8004c90 <USART1_IRQHandler+0xa8>)
 8004c24:	6841      	ldr	r1, [r0, #4]

        USART1->DR = txbuf.data[tail++];        // Send next character and increment pointer
 8004c26:	1c4a      	adds	r2, r1, #1
 8004c28:	b292      	uxth	r2, r2

        if(tail == TX_BUFFER_SIZE)              // If at end
 8004c2a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8004c2e:	bf08      	it	eq
 8004c30:	2200      	moveq	r2, #0
        USART1->DR = txbuf.data[tail++];        // Send next character and increment pointer
 8004c32:	b289      	uxth	r1, r1
 8004c34:	4401      	add	r1, r0
 8004c36:	7a09      	ldrb	r1, [r1, #8]
 8004c38:	6059      	str	r1, [r3, #4]
            tail = 0;                           // wrap pointer around

        txbuf.tail = tail;                      // Update global pointer
 8004c3a:	6042      	str	r2, [r0, #4]

        if(tail == txbuf.head)                  // If buffer empty then
 8004c3c:	6801      	ldr	r1, [r0, #0]
 8004c3e:	4291      	cmp	r1, r2
 8004c40:	d009      	beq.n	8004c56 <USART1_IRQHandler+0x6e>
            USART1->CR1 &= ~USART_CR1_TXEIE;    // disable UART TX interrupt
   }
}
 8004c42:	bd70      	pop	{r4, r5, r6, pc}
            rxbuf.overflow = 1;                                         // flag overflow
 8004c44:	2201      	movs	r2, #1
            next_head =  USART1->DR;                                    // and do dummy read to clear interrupt
 8004c46:	685b      	ldr	r3, [r3, #4]
            rxbuf.overflow = 1;                                         // flag overflow
 8004c48:	722a      	strb	r2, [r5, #8]
            next_head =  USART1->DR;                                    // and do dummy read to clear interrupt
 8004c4a:	e7e3      	b.n	8004c14 <USART1_IRQHandler+0x2c>
                rxbuf.data[rxbuf.head] = data;                          // if not add data to buffer
 8004c4c:	682b      	ldr	r3, [r5, #0]
 8004c4e:	442b      	add	r3, r5
 8004c50:	729e      	strb	r6, [r3, #10]
                rxbuf.head = next_head;                                 // and update pointer
 8004c52:	602c      	str	r4, [r5, #0]
 8004c54:	e7de      	b.n	8004c14 <USART1_IRQHandler+0x2c>
            USART1->CR1 &= ~USART_CR1_TXEIE;    // disable UART TX interrupt
 8004c56:	68da      	ldr	r2, [r3, #12]
 8004c58:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8004c5c:	60da      	str	r2, [r3, #12]
}
 8004c5e:	bd70      	pop	{r4, r5, r6, pc}
            if(data == CMD_TOOL_ACK && !rxbuf.backup) {
 8004c60:	7a6b      	ldrb	r3, [r5, #9]
 8004c62:	2b00      	cmp	r3, #0
 8004c64:	d1d1      	bne.n	8004c0a <USART1_IRQHandler+0x22>
                memcpy(&rxbackup, &rxbuf, sizeof(stream_rx_buffer_t));
 8004c66:	f240 420c 	movw	r2, #1036	; 0x40c
 8004c6a:	4629      	mov	r1, r5
 8004c6c:	4809      	ldr	r0, [pc, #36]	; (8004c94 <USART1_IRQHandler+0xac>)
 8004c6e:	f00c fffb 	bl	8011c68 <memcpy>
                rxbuf.backup = true;
 8004c72:	2001      	movs	r0, #1
                rxbuf.tail = rxbuf.head;
 8004c74:	6829      	ldr	r1, [r5, #0]
                hal.stream.read = serialGetC; // restore normal input
 8004c76:	4b05      	ldr	r3, [pc, #20]	; (8004c8c <USART1_IRQHandler+0xa4>)
 8004c78:	4a07      	ldr	r2, [pc, #28]	; (8004c98 <USART1_IRQHandler+0xb0>)
                rxbuf.backup = true;
 8004c7a:	7268      	strb	r0, [r5, #9]
                rxbuf.tail = rxbuf.head;
 8004c7c:	6069      	str	r1, [r5, #4]
                hal.stream.read = serialGetC; // restore normal input
 8004c7e:	66da      	str	r2, [r3, #108]	; 0x6c
 8004c80:	e7c8      	b.n	8004c14 <USART1_IRQHandler+0x2c>
 8004c82:	bf00      	nop
 8004c84:	40013800 	.word	0x40013800
 8004c88:	20000340 	.word	0x20000340
 8004c8c:	200024bc 	.word	0x200024bc
 8004c90:	2000074c 	.word	0x2000074c
 8004c94:	20000138 	.word	0x20000138
 8004c98:	080049ad 	.word	0x080049ad

08004c9c <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8004c9c:	4b06      	ldr	r3, [pc, #24]	; (8004cb8 <HAL_MspInit+0x1c>)
{
 8004c9e:	b082      	sub	sp, #8
  __HAL_RCC_AFIO_CLK_ENABLE();
 8004ca0:	699a      	ldr	r2, [r3, #24]
 8004ca2:	f042 0201 	orr.w	r2, r2, #1
 8004ca6:	619a      	str	r2, [r3, #24]
 8004ca8:	699b      	ldr	r3, [r3, #24]
 8004caa:	f003 0301 	and.w	r3, r3, #1
 8004cae:	9301      	str	r3, [sp, #4]
 8004cb0:	9b01      	ldr	r3, [sp, #4]
//  __HAL_AFIO_REMAP_SWJ_DISABLE();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8004cb2:	b002      	add	sp, #8
 8004cb4:	4770      	bx	lr
 8004cb6:	bf00      	nop
 8004cb8:	40021000 	.word	0x40021000

08004cbc <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8004cbc:	4770      	bx	lr
 8004cbe:	bf00      	nop

08004cc0 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8004cc0:	e7fe      	b.n	8004cc0 <HardFault_Handler>
 8004cc2:	bf00      	nop

08004cc4 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8004cc4:	e7fe      	b.n	8004cc4 <MemManage_Handler>
 8004cc6:	bf00      	nop

08004cc8 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8004cc8:	e7fe      	b.n	8004cc8 <BusFault_Handler>
 8004cca:	bf00      	nop

08004ccc <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8004ccc:	e7fe      	b.n	8004ccc <UsageFault_Handler>
 8004cce:	bf00      	nop

08004cd0 <SVC_Handler>:
 8004cd0:	4770      	bx	lr
 8004cd2:	bf00      	nop

08004cd4 <DebugMon_Handler>:
 8004cd4:	4770      	bx	lr
 8004cd6:	bf00      	nop

08004cd8 <PendSV_Handler>:
 8004cd8:	4770      	bx	lr
 8004cda:	bf00      	nop

08004cdc <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8004cdc:	f7ff bd94 	b.w	8004808 <HAL_IncTick>

08004ce0 <USB_LP_CAN1_RX0_IRQHandler>:
void USB_LP_CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 8004ce0:	4801      	ldr	r0, [pc, #4]	; (8004ce8 <USB_LP_CAN1_RX0_IRQHandler+0x8>)
 8004ce2:	f7fd b895 	b.w	8001e10 <HAL_PCD_IRQHandler>
 8004ce6:	bf00      	nop
 8004ce8:	20001f74 	.word	0x20001f74

08004cec <I2C2_EV_IRQHandler>:
void I2C2_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
 8004cec:	4801      	ldr	r0, [pc, #4]	; (8004cf4 <I2C2_EV_IRQHandler+0x8>)
 8004cee:	f7fc bbdf 	b.w	80014b0 <HAL_I2C_EV_IRQHandler>
 8004cf2:	bf00      	nop
 8004cf4:	20001f20 	.word	0x20001f20

08004cf8 <I2C2_ER_IRQHandler>:
void I2C2_ER_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
 8004cf8:	4801      	ldr	r0, [pc, #4]	; (8004d00 <I2C2_ER_IRQHandler+0x8>)
 8004cfa:	f7fc bfaf 	b.w	8001c5c <HAL_I2C_ER_IRQHandler>
 8004cfe:	bf00      	nop
 8004d00:	20001f20 	.word	0x20001f20

08004d04 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8004d04:	2001      	movs	r0, #1
 8004d06:	4770      	bx	lr

08004d08 <_kill>:

int _kill(int pid, int sig)
{
 8004d08:	b508      	push	{r3, lr}
	errno = EINVAL;
 8004d0a:	f00c ff53 	bl	8011bb4 <__errno>
 8004d0e:	2216      	movs	r2, #22
 8004d10:	4603      	mov	r3, r0
	return -1;
}
 8004d12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	errno = EINVAL;
 8004d16:	601a      	str	r2, [r3, #0]
}
 8004d18:	bd08      	pop	{r3, pc}
 8004d1a:	bf00      	nop

08004d1c <_exit>:

void _exit (int status)
{
 8004d1c:	b508      	push	{r3, lr}
	errno = EINVAL;
 8004d1e:	f00c ff49 	bl	8011bb4 <__errno>
 8004d22:	2316      	movs	r3, #22
 8004d24:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
 8004d26:	e7fe      	b.n	8004d26 <_exit+0xa>

08004d28 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8004d28:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8004d2a:	1e16      	subs	r6, r2, #0
 8004d2c:	dd07      	ble.n	8004d3e <_read+0x16>
 8004d2e:	460c      	mov	r4, r1
 8004d30:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 8004d32:	f3af 8000 	nop.w
 8004d36:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8004d3a:	42a5      	cmp	r5, r4
 8004d3c:	d1f9      	bne.n	8004d32 <_read+0xa>
	}

return len;
}
 8004d3e:	4630      	mov	r0, r6
 8004d40:	bd70      	pop	{r4, r5, r6, pc}
 8004d42:	bf00      	nop

08004d44 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8004d44:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8004d46:	1e16      	subs	r6, r2, #0
 8004d48:	dd07      	ble.n	8004d5a <_write+0x16>
 8004d4a:	460c      	mov	r4, r1
 8004d4c:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 8004d4e:	f814 0b01 	ldrb.w	r0, [r4], #1
 8004d52:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8004d56:	42ac      	cmp	r4, r5
 8004d58:	d1f9      	bne.n	8004d4e <_write+0xa>
	}
	return len;
}
 8004d5a:	4630      	mov	r0, r6
 8004d5c:	bd70      	pop	{r4, r5, r6, pc}
 8004d5e:	bf00      	nop

08004d60 <_close>:

int _close(int file)
{
	return -1;
}
 8004d60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004d64:	4770      	bx	lr
 8004d66:	bf00      	nop

08004d68 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8004d68:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 8004d6c:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8004d6e:	604b      	str	r3, [r1, #4]
}
 8004d70:	4770      	bx	lr
 8004d72:	bf00      	nop

08004d74 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8004d74:	2001      	movs	r0, #1
 8004d76:	4770      	bx	lr

08004d78 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8004d78:	2000      	movs	r0, #0
 8004d7a:	4770      	bx	lr

08004d7c <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8004d7c:	4a0c      	ldr	r2, [pc, #48]	; (8004db0 <_sbrk+0x34>)
{
 8004d7e:	b508      	push	{r3, lr}
 8004d80:	4603      	mov	r3, r0
	if (heap_end == 0)
 8004d82:	6810      	ldr	r0, [r2, #0]
 8004d84:	b128      	cbz	r0, 8004d92 <_sbrk+0x16>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 8004d86:	4669      	mov	r1, sp
 8004d88:	4403      	add	r3, r0
 8004d8a:	428b      	cmp	r3, r1
 8004d8c:	d808      	bhi.n	8004da0 <_sbrk+0x24>
	{
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8004d8e:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 8004d90:	bd08      	pop	{r3, pc}
		heap_end = &end;
 8004d92:	4908      	ldr	r1, [pc, #32]	; (8004db4 <_sbrk+0x38>)
 8004d94:	4608      	mov	r0, r1
 8004d96:	6011      	str	r1, [r2, #0]
	if (heap_end + incr > stack_ptr)
 8004d98:	4669      	mov	r1, sp
 8004d9a:	4403      	add	r3, r0
 8004d9c:	428b      	cmp	r3, r1
 8004d9e:	d9f6      	bls.n	8004d8e <_sbrk+0x12>
		errno = ENOMEM;
 8004da0:	f00c ff08 	bl	8011bb4 <__errno>
 8004da4:	220c      	movs	r2, #12
 8004da6:	4603      	mov	r3, r0
		return (caddr_t) -1;
 8004da8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		errno = ENOMEM;
 8004dac:	601a      	str	r2, [r3, #0]
}
 8004dae:	bd08      	pop	{r3, pc}
 8004db0:	20000954 	.word	0x20000954
 8004db4:	20002740 	.word	0x20002740

08004db8 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8004db8:	b430      	push	{r4, r5}

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;
 8004dba:	f44f 051f 	mov.w	r5, #10420224	; 0x9f0000
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8004dbe:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR |= 0x00000001U;
 8004dc2:	4b0e      	ldr	r3, [pc, #56]	; (8004dfc <SystemInit+0x44>)
  RCC->CFGR &= 0xF8FF0000U;
 8004dc4:	4a0e      	ldr	r2, [pc, #56]	; (8004e00 <SystemInit+0x48>)
  RCC->CR |= 0x00000001U;
 8004dc6:	6819      	ldr	r1, [r3, #0]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8004dc8:	480e      	ldr	r0, [pc, #56]	; (8004e04 <SystemInit+0x4c>)
  RCC->CR |= 0x00000001U;
 8004dca:	f041 0101 	orr.w	r1, r1, #1
 8004dce:	6019      	str	r1, [r3, #0]
  RCC->CFGR &= 0xF8FF0000U;
 8004dd0:	6859      	ldr	r1, [r3, #4]
 8004dd2:	400a      	ands	r2, r1
 8004dd4:	605a      	str	r2, [r3, #4]
  RCC->CR &= 0xFEF6FFFFU;
 8004dd6:	681a      	ldr	r2, [r3, #0]
 8004dd8:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8004ddc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004de0:	601a      	str	r2, [r3, #0]
  RCC->CR &= 0xFFFBFFFFU;
 8004de2:	681a      	ldr	r2, [r3, #0]
 8004de4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004de8:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= 0xFF80FFFFU;
 8004dea:	685a      	ldr	r2, [r3, #4]
 8004dec:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8004df0:	605a      	str	r2, [r3, #4]
  RCC->CIR = 0x009F0000U;
 8004df2:	609d      	str	r5, [r3, #8]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8004df4:	6084      	str	r4, [r0, #8]
#endif 
}
 8004df6:	bc30      	pop	{r4, r5}
 8004df8:	4770      	bx	lr
 8004dfa:	bf00      	nop
 8004dfc:	40021000 	.word	0x40021000
 8004e00:	f8ff0000 	.word	0xf8ff0000
 8004e04:	e000ed00 	.word	0xe000ed00

08004e08 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8004e08:	f200 412c 	addw	r1, r0, #1068	; 0x42c
 8004e0c:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e10:	f7fe ba94 	b.w	800333c <USBD_LL_SetupStage>

08004e14 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8004e14:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8004e18:	f8d3 223c 	ldr.w	r2, [r3, #572]	; 0x23c
 8004e1c:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e20:	f7fe baba 	b.w	8003398 <USBD_LL_DataOutStage>

08004e24 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8004e24:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8004e28:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004e2a:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e2e:	f7fe bae7 	b.w	8003400 <USBD_LL_DataInStage>
 8004e32:	bf00      	nop

08004e34 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8004e34:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e38:	f7fe bb6e 	b.w	8003518 <USBD_LL_SOF>

08004e3c <HAL_PCD_ResetCallback>:
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{ 
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8004e3c:	6883      	ldr	r3, [r0, #8]
{ 
 8004e3e:	b510      	push	{r4, lr}
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8004e40:	2b02      	cmp	r3, #2
{ 
 8004e42:	4604      	mov	r4, r0
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 8004e44:	d001      	beq.n	8004e4a <HAL_PCD_ResetCallback+0xe>
  {
    Error_Handler();
 8004e46:	f7ff fdaf 	bl	80049a8 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8004e4a:	f8d4 045c 	ldr.w	r0, [r4, #1116]	; 0x45c
 8004e4e:	2101      	movs	r1, #1
 8004e50:	f7fe fb4c 	bl	80034ec <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8004e54:	f8d4 045c 	ldr.w	r0, [r4, #1116]	; 0x45c
}
 8004e58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8004e5c:	f7fe bb26 	b.w	80034ac <USBD_LL_Reset>

08004e60 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8004e60:	b510      	push	{r4, lr}
 8004e62:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8004e64:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e68:	f7fe fb44 	bl	80034f4 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8004e6c:	69a3      	ldr	r3, [r4, #24]
 8004e6e:	b123      	cbz	r3, 8004e7a <HAL_PCD_SuspendCallback+0x1a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8004e70:	4a02      	ldr	r2, [pc, #8]	; (8004e7c <HAL_PCD_SuspendCallback+0x1c>)
 8004e72:	6913      	ldr	r3, [r2, #16]
 8004e74:	f043 0306 	orr.w	r3, r3, #6
 8004e78:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8004e7a:	bd10      	pop	{r4, pc}
 8004e7c:	e000ed00 	.word	0xe000ed00

08004e80 <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8004e80:	f8d0 045c 	ldr.w	r0, [r0, #1116]	; 0x45c
 8004e84:	f7fe bb40 	b.w	8003508 <USBD_LL_Resume>

08004e88 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8004e88:	b510      	push	{r4, lr}
 8004e8a:	4614      	mov	r4, r2
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8004e8c:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
{
 8004e90:	461a      	mov	r2, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8004e92:	4623      	mov	r3, r4
 8004e94:	f7fd fab2 	bl	80023fc <HAL_PCD_EP_Open>
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
  USBD_StatusTypeDef usb_status = USBD_OK;

  switch (hal_status)
 8004e98:	2803      	cmp	r0, #3
 8004e9a:	bf96      	itet	ls
 8004e9c:	4b01      	ldrls	r3, [pc, #4]	; (8004ea4 <USBD_LL_OpenEP+0x1c>)
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8004e9e:	2002      	movhi	r0, #2
 8004ea0:	5c18      	ldrbls	r0, [r3, r0]
}
 8004ea2:	bd10      	pop	{r4, pc}
 8004ea4:	08014904 	.word	0x08014904

08004ea8 <USBD_LL_StallEP>:
{
 8004ea8:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8004eaa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8004eae:	f7fd faf9 	bl	80024a4 <HAL_PCD_EP_SetStall>
  switch (hal_status)
 8004eb2:	2803      	cmp	r0, #3
 8004eb4:	bf96      	itet	ls
 8004eb6:	4b02      	ldrls	r3, [pc, #8]	; (8004ec0 <USBD_LL_StallEP+0x18>)
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8004eb8:	2002      	movhi	r0, #2
 8004eba:	5c18      	ldrbls	r0, [r3, r0]
}
 8004ebc:	bd08      	pop	{r3, pc}
 8004ebe:	bf00      	nop
 8004ec0:	08014904 	.word	0x08014904

08004ec4 <USBD_LL_ClearStallEP>:
{
 8004ec4:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8004ec6:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8004eca:	f7fd fb17 	bl	80024fc <HAL_PCD_EP_ClrStall>
  switch (hal_status)
 8004ece:	2803      	cmp	r0, #3
 8004ed0:	bf96      	itet	ls
 8004ed2:	4b02      	ldrls	r3, [pc, #8]	; (8004edc <USBD_LL_ClearStallEP+0x18>)
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8004ed4:	2002      	movhi	r0, #2
 8004ed6:	5c18      	ldrbls	r0, [r3, r0]
}
 8004ed8:	bd08      	pop	{r3, pc}
 8004eda:	bf00      	nop
 8004edc:	08014904 	.word	0x08014904

08004ee0 <USBD_LL_IsStallEP>:
  if((ep_addr & 0x80) == 0x80)
 8004ee0:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8004ee2:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
  if((ep_addr & 0x80) == 0x80)
 8004ee6:	d404      	bmi.n	8004ef2 <USBD_LL_IsStallEP+0x12>
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8004ee8:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8004eec:	f891 022a 	ldrb.w	r0, [r1, #554]	; 0x22a
}
 8004ef0:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8004ef2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8004ef6:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8004efa:	f891 002a 	ldrb.w	r0, [r1, #42]	; 0x2a
 8004efe:	4770      	bx	lr

08004f00 <USBD_LL_SetUSBAddress>:
{
 8004f00:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8004f02:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8004f06:	f7fd fa65 	bl	80023d4 <HAL_PCD_SetAddress>
  switch (hal_status)
 8004f0a:	2803      	cmp	r0, #3
 8004f0c:	bf96      	itet	ls
 8004f0e:	4b02      	ldrls	r3, [pc, #8]	; (8004f18 <USBD_LL_SetUSBAddress+0x18>)
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8004f10:	2002      	movhi	r0, #2
 8004f12:	5c18      	ldrbls	r0, [r3, r0]
}
 8004f14:	bd08      	pop	{r3, pc}
 8004f16:	bf00      	nop
 8004f18:	08014904 	.word	0x08014904

08004f1c <USBD_LL_Transmit>:
{
 8004f1c:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8004f1e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8004f22:	f7fd faa9 	bl	8002478 <HAL_PCD_EP_Transmit>
  switch (hal_status)
 8004f26:	2803      	cmp	r0, #3
 8004f28:	bf96      	itet	ls
 8004f2a:	4b02      	ldrls	r3, [pc, #8]	; (8004f34 <USBD_LL_Transmit+0x18>)
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8004f2c:	2002      	movhi	r0, #2
 8004f2e:	5c18      	ldrbls	r0, [r3, r0]
}
 8004f30:	bd08      	pop	{r3, pc}
 8004f32:	bf00      	nop
 8004f34:	08014904 	.word	0x08014904

08004f38 <USBD_LL_PrepareReceive>:
{
 8004f38:	b508      	push	{r3, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8004f3a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8004f3e:	f7fd fa83 	bl	8002448 <HAL_PCD_EP_Receive>
  switch (hal_status)
 8004f42:	2803      	cmp	r0, #3
 8004f44:	bf96      	itet	ls
 8004f46:	4b02      	ldrls	r3, [pc, #8]	; (8004f50 <USBD_LL_PrepareReceive+0x18>)
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8004f48:	2002      	movhi	r0, #2
 8004f4a:	5c18      	ldrbls	r0, [r3, r0]
}
 8004f4c:	bd08      	pop	{r3, pc}
 8004f4e:	bf00      	nop
 8004f50:	08014904 	.word	0x08014904

08004f54 <Reset_Handler>:
 8004f54:	2100      	movs	r1, #0
 8004f56:	e003      	b.n	8004f60 <LoopCopyDataInit>

08004f58 <CopyDataInit>:
 8004f58:	4b0b      	ldr	r3, [pc, #44]	; (8004f88 <LoopFillZerobss+0x14>)
 8004f5a:	585b      	ldr	r3, [r3, r1]
 8004f5c:	5043      	str	r3, [r0, r1]
 8004f5e:	3104      	adds	r1, #4

08004f60 <LoopCopyDataInit>:
 8004f60:	480a      	ldr	r0, [pc, #40]	; (8004f8c <LoopFillZerobss+0x18>)
 8004f62:	4b0b      	ldr	r3, [pc, #44]	; (8004f90 <LoopFillZerobss+0x1c>)
 8004f64:	1842      	adds	r2, r0, r1
 8004f66:	429a      	cmp	r2, r3
 8004f68:	d3f6      	bcc.n	8004f58 <CopyDataInit>
 8004f6a:	4a0a      	ldr	r2, [pc, #40]	; (8004f94 <LoopFillZerobss+0x20>)
 8004f6c:	e002      	b.n	8004f74 <LoopFillZerobss>

08004f6e <FillZerobss>:
 8004f6e:	2300      	movs	r3, #0
 8004f70:	f842 3b04 	str.w	r3, [r2], #4

08004f74 <LoopFillZerobss>:
 8004f74:	4b08      	ldr	r3, [pc, #32]	; (8004f98 <LoopFillZerobss+0x24>)
 8004f76:	429a      	cmp	r2, r3
 8004f78:	d3f9      	bcc.n	8004f6e <FillZerobss>
 8004f7a:	f7ff ff1d 	bl	8004db8 <SystemInit>
 8004f7e:	f00c fe31 	bl	8011be4 <__libc_init_array>
 8004f82:	f7ff fce7 	bl	8004954 <main>
 8004f86:	4770      	bx	lr
 8004f88:	08015478 	.word	0x08015478
 8004f8c:	20000000 	.word	0x20000000
 8004f90:	20000084 	.word	0x20000084
 8004f94:	20000088 	.word	0x20000088
 8004f98:	2000273c 	.word	0x2000273c

08004f9c <ADC1_2_IRQHandler>:
 8004f9c:	e7fe      	b.n	8004f9c <ADC1_2_IRQHandler>
	...

08004fa0 <coolant_set_state>:
// Main program only. Immediately sets flood coolant running state and also mist coolant,
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state (coolant_state_t mode)
{
 8004fa0:	b510      	push	{r4, lr}
    if (!ABORTED) { // Block during abort.
 8004fa2:	4c06      	ldr	r4, [pc, #24]	; (8004fbc <coolant_set_state+0x1c>)
 8004fa4:	7923      	ldrb	r3, [r4, #4]
 8004fa6:	b943      	cbnz	r3, 8004fba <coolant_set_state+0x1a>
 8004fa8:	7963      	ldrb	r3, [r4, #5]
 8004faa:	b933      	cbnz	r3, 8004fba <coolant_set_state+0x1a>
        hal.coolant_set_state(mode);
 8004fac:	4b04      	ldr	r3, [pc, #16]	; (8004fc0 <coolant_set_state+0x20>)
 8004fae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004fb0:	4798      	blx	r3
        sys.report.coolant = On; // Set to report change immediately
 8004fb2:	7d23      	ldrb	r3, [r4, #20]
 8004fb4:	f043 0320 	orr.w	r3, r3, #32
 8004fb8:	7523      	strb	r3, [r4, #20]
    }
}
 8004fba:	bd10      	pop	{r4, pc}
 8004fbc:	20002494 	.word	0x20002494
 8004fc0:	200024bc 	.word	0x200024bc

08004fc4 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails
// if an abort or check-mode is active.
bool coolant_sync (coolant_state_t mode)
{
 8004fc4:	b570      	push	{r4, r5, r6, lr}
    bool ok = true;
    if (sys.state != STATE_CHECK_MODE) {
 8004fc6:	4e0e      	ldr	r6, [pc, #56]	; (8005000 <coolant_sync+0x3c>)
 8004fc8:	6833      	ldr	r3, [r6, #0]
 8004fca:	2b02      	cmp	r3, #2
 8004fcc:	d102      	bne.n	8004fd4 <coolant_sync+0x10>
    bool ok = true;
 8004fce:	2401      	movs	r4, #1
        if((ok = protocol_buffer_synchronize())) // Ensure coolant changes state when specified in program.
            coolant_set_state(mode);
    }

    return ok;
}
 8004fd0:	4620      	mov	r0, r4
 8004fd2:	bd70      	pop	{r4, r5, r6, pc}
        if((ok = protocol_buffer_synchronize())) // Ensure coolant changes state when specified in program.
 8004fd4:	4605      	mov	r5, r0
 8004fd6:	f006 fd6d 	bl	800bab4 <protocol_buffer_synchronize>
 8004fda:	4604      	mov	r4, r0
 8004fdc:	2800      	cmp	r0, #0
 8004fde:	d0f7      	beq.n	8004fd0 <coolant_sync+0xc>
    if (!ABORTED) { // Block during abort.
 8004fe0:	7933      	ldrb	r3, [r6, #4]
 8004fe2:	2b00      	cmp	r3, #0
 8004fe4:	d1f4      	bne.n	8004fd0 <coolant_sync+0xc>
 8004fe6:	7973      	ldrb	r3, [r6, #5]
 8004fe8:	2b00      	cmp	r3, #0
 8004fea:	d1f1      	bne.n	8004fd0 <coolant_sync+0xc>
        hal.coolant_set_state(mode);
 8004fec:	4b05      	ldr	r3, [pc, #20]	; (8005004 <coolant_sync+0x40>)
 8004fee:	4628      	mov	r0, r5
 8004ff0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004ff2:	4798      	blx	r3
        sys.report.coolant = On; // Set to report change immediately
 8004ff4:	7d33      	ldrb	r3, [r6, #20]
 8004ff6:	f043 0320 	orr.w	r3, r3, #32
 8004ffa:	7533      	strb	r3, [r6, #20]
 8004ffc:	e7e8      	b.n	8004fd0 <coolant_sync+0xc>
 8004ffe:	bf00      	nop
 8005000:	20002494 	.word	0x20002494
 8005004:	200024bc 	.word	0x200024bc

08005008 <ram_get_byte>:
    {0, 0, 0} // list termination - do not remove
};

inline static uint8_t ram_get_byte (uint32_t addr)
{
    return noepromdata[addr];
 8005008:	4b01      	ldr	r3, [pc, #4]	; (8005010 <ram_get_byte+0x8>)
 800500a:	681b      	ldr	r3, [r3, #0]
}
 800500c:	5c18      	ldrb	r0, [r3, r0]
 800500e:	4770      	bx	lr
 8005010:	2000095c 	.word	0x2000095c

08005014 <ram_put_byte>:

inline static void ram_put_byte (uint32_t addr, uint8_t new_value)
{
    dirty = dirty || noepromdata[addr] != new_value;
 8005014:	4a0a      	ldr	r2, [pc, #40]	; (8005040 <ram_put_byte+0x2c>)
{
 8005016:	b410      	push	{r4}
    dirty = dirty || noepromdata[addr] != new_value;
 8005018:	7813      	ldrb	r3, [r2, #0]
 800501a:	b133      	cbz	r3, 800502a <ram_put_byte+0x16>
 800501c:	4c09      	ldr	r4, [pc, #36]	; (8005044 <ram_put_byte+0x30>)
 800501e:	7013      	strb	r3, [r2, #0]
    noepromdata[addr] = new_value;
 8005020:	6824      	ldr	r4, [r4, #0]
 8005022:	4420      	add	r0, r4
 8005024:	7001      	strb	r1, [r0, #0]
}
 8005026:	bc10      	pop	{r4}
 8005028:	4770      	bx	lr
    dirty = dirty || noepromdata[addr] != new_value;
 800502a:	4b06      	ldr	r3, [pc, #24]	; (8005044 <ram_put_byte+0x30>)
 800502c:	681c      	ldr	r4, [r3, #0]
 800502e:	5c23      	ldrb	r3, [r4, r0]
 8005030:	4420      	add	r0, r4
 8005032:	1a5b      	subs	r3, r3, r1
 8005034:	bf18      	it	ne
 8005036:	2301      	movne	r3, #1
    noepromdata[addr] = new_value;
 8005038:	7001      	strb	r1, [r0, #0]
}
 800503a:	bc10      	pop	{r4}
    dirty = dirty || noepromdata[addr] != new_value;
 800503c:	7013      	strb	r3, [r2, #0]
}
 800503e:	4770      	bx	lr
 8005040:	20000958 	.word	0x20000958
 8005044:	2000095c 	.word	0x2000095c

08005048 <memcpy_from_ram_with_checksum>:
        }
    }
}

static bool memcpy_from_ram_with_checksum (uint8_t *destination, uint32_t source, uint32_t size)
{
 8005048:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800504c:	460e      	mov	r6, r1
    uint8_t checksum = calc_checksum(&noepromdata[source], size);
 800504e:	4f28      	ldr	r7, [pc, #160]	; (80050f0 <memcpy_from_ram_with_checksum+0xa8>)
 8005050:	4611      	mov	r1, r2
 8005052:	683b      	ldr	r3, [r7, #0]
{
 8005054:	4604      	mov	r4, r0
    uint8_t checksum = calc_checksum(&noepromdata[source], size);
 8005056:	1998      	adds	r0, r3, r6
{
 8005058:	4615      	mov	r5, r2
    uint8_t checksum = calc_checksum(&noepromdata[source], size);
 800505a:	f005 fa0d 	bl	800a478 <calc_checksum>
 800505e:	4684      	mov	ip, r0
    return noepromdata[addr];
 8005060:	6838      	ldr	r0, [r7, #0]

    for(; size > 0; size--)
 8005062:	b385      	cbz	r5, 80050c6 <memcpy_from_ram_with_checksum+0x7e>
 8005064:	1d32      	adds	r2, r6, #4
 8005066:	1983      	adds	r3, r0, r6
 8005068:	4402      	add	r2, r0
 800506a:	1d21      	adds	r1, r4, #4
 800506c:	428b      	cmp	r3, r1
 800506e:	bf38      	it	cc
 8005070:	4294      	cmpcc	r4, r2
 8005072:	d330      	bcc.n	80050d6 <memcpy_from_ram_with_checksum+0x8e>
 8005074:	1e6a      	subs	r2, r5, #1
 8005076:	2a07      	cmp	r2, #7
 8005078:	d92d      	bls.n	80050d6 <memcpy_from_ram_with_checksum+0x8e>
 800507a:	4622      	mov	r2, r4
 800507c:	f025 0703 	bic.w	r7, r5, #3
 8005080:	441f      	add	r7, r3
    return noepromdata[addr];
 8005082:	f853 1b04 	ldr.w	r1, [r3], #4
 8005086:	42bb      	cmp	r3, r7
        *(destination++) = ram_get_byte(source++);
 8005088:	f842 1b04 	str.w	r1, [r2], #4
    for(; size > 0; size--)
 800508c:	d1f9      	bne.n	8005082 <memcpy_from_ram_with_checksum+0x3a>
 800508e:	f025 0303 	bic.w	r3, r5, #3
 8005092:	429d      	cmp	r5, r3
 8005094:	eb04 0703 	add.w	r7, r4, r3
 8005098:	eb06 0203 	add.w	r2, r6, r3
 800509c:	eba5 0103 	sub.w	r1, r5, r3
 80050a0:	d010      	beq.n	80050c4 <memcpy_from_ram_with_checksum+0x7c>
    return noepromdata[addr];
 80050a2:	f810 e002 	ldrb.w	lr, [r0, r2]
    for(; size > 0; size--)
 80050a6:	2901      	cmp	r1, #1
        *(destination++) = ram_get_byte(source++);
 80050a8:	f102 0801 	add.w	r8, r2, #1
 80050ac:	f804 e003 	strb.w	lr, [r4, r3]
    for(; size > 0; size--)
 80050b0:	d008      	beq.n	80050c4 <memcpy_from_ram_with_checksum+0x7c>
    return noepromdata[addr];
 80050b2:	f810 3008 	ldrb.w	r3, [r0, r8]
    for(; size > 0; size--)
 80050b6:	2902      	cmp	r1, #2
        *(destination++) = ram_get_byte(source++);
 80050b8:	f102 0202 	add.w	r2, r2, #2
 80050bc:	707b      	strb	r3, [r7, #1]
    for(; size > 0; size--)
 80050be:	d001      	beq.n	80050c4 <memcpy_from_ram_with_checksum+0x7c>
    return noepromdata[addr];
 80050c0:	5c83      	ldrb	r3, [r0, r2]
        *(destination++) = ram_get_byte(source++);
 80050c2:	70bb      	strb	r3, [r7, #2]
    for(; size > 0; size--)
 80050c4:	442e      	add	r6, r5

    return checksum == ram_get_byte(source);
 80050c6:	5d80      	ldrb	r0, [r0, r6]
}
 80050c8:	eba0 000c 	sub.w	r0, r0, ip
 80050cc:	fab0 f080 	clz	r0, r0
 80050d0:	0940      	lsrs	r0, r0, #5
 80050d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80050d6:	1961      	adds	r1, r4, r5
 80050d8:	1e73      	subs	r3, r6, #1
 80050da:	4403      	add	r3, r0
 80050dc:	3901      	subs	r1, #1
 80050de:	3c01      	subs	r4, #1
    return noepromdata[addr];
 80050e0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
        *(destination++) = ram_get_byte(source++);
 80050e4:	f804 2f01 	strb.w	r2, [r4, #1]!
    for(; size > 0; size--)
 80050e8:	428c      	cmp	r4, r1
 80050ea:	d1f9      	bne.n	80050e0 <memcpy_from_ram_with_checksum+0x98>
 80050ec:	e7ea      	b.n	80050c4 <memcpy_from_ram_with_checksum+0x7c>
 80050ee:	bf00      	nop
 80050f0:	2000095c 	.word	0x2000095c

080050f4 <memcpy_to_ram_with_checksum>:
{
 80050f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80050f8:	460c      	mov	r4, r1
 80050fa:	4690      	mov	r8, r2
    dirty = false;
 80050fc:	2600      	movs	r6, #0
{
 80050fe:	4607      	mov	r7, r0
    uint8_t checksum = calc_checksum(source, size);
 8005100:	4611      	mov	r1, r2
 8005102:	4620      	mov	r0, r4
 8005104:	f005 f9b8 	bl	800a478 <calc_checksum>
    dirty = false;
 8005108:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 80051f0 <memcpy_to_ram_with_checksum+0xfc>
    dirty = dirty || noepromdata[addr] != new_value;
 800510c:	4b34      	ldr	r3, [pc, #208]	; (80051e0 <memcpy_to_ram_with_checksum+0xec>)
    dirty = false;
 800510e:	f88e 6000 	strb.w	r6, [lr]
    for(; size > 0; size--)
 8005112:	f1b8 0f00 	cmp.w	r8, #0
 8005116:	d050      	beq.n	80051ba <memcpy_to_ram_with_checksum+0xc6>
    dirty = dirty || noepromdata[addr] != new_value;
 8005118:	6819      	ldr	r1, [r3, #0]
 800511a:	eb04 0208 	add.w	r2, r4, r8
 800511e:	19cb      	adds	r3, r1, r7
        ram_put_byte(dest++, *(source++));
 8005120:	f814 5b01 	ldrb.w	r5, [r4], #1
    dirty = dirty || noepromdata[addr] != new_value;
 8005124:	b136      	cbz	r6, 8005134 <memcpy_to_ram_with_checksum+0x40>
    for(; size > 0; size--)
 8005126:	4294      	cmp	r4, r2
    noepromdata[addr] = new_value;
 8005128:	f803 5b01 	strb.w	r5, [r3], #1
    for(; size > 0; size--)
 800512c:	d1f8      	bne.n	8005120 <memcpy_to_ram_with_checksum+0x2c>
 800512e:	44b8      	add	r8, r7
    dirty = dirty || noepromdata[addr] != new_value;
 8005130:	4488      	add	r8, r1
 8005132:	e013      	b.n	800515c <memcpy_to_ram_with_checksum+0x68>
 8005134:	f893 c000 	ldrb.w	ip, [r3]
    noepromdata[addr] = new_value;
 8005138:	f803 5b01 	strb.w	r5, [r3], #1
    dirty = dirty || noepromdata[addr] != new_value;
 800513c:	ebb5 060c 	subs.w	r6, r5, ip
 8005140:	bf18      	it	ne
 8005142:	2601      	movne	r6, #1
    for(; size > 0; size--)
 8005144:	4294      	cmp	r4, r2
 8005146:	d1eb      	bne.n	8005120 <memcpy_to_ram_with_checksum+0x2c>
    dirty = dirty || noepromdata[addr] != new_value;
 8005148:	4565      	cmp	r5, ip
 800514a:	44b8      	add	r8, r7
 800514c:	f88e 6000 	strb.w	r6, [lr]
 8005150:	d1ee      	bne.n	8005130 <memcpy_to_ram_with_checksum+0x3c>
 8005152:	f811 3008 	ldrb.w	r3, [r1, r8]
 8005156:	4488      	add	r8, r1
 8005158:	4283      	cmp	r3, r0
 800515a:	d02a      	beq.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
 800515c:	2201      	movs	r2, #1
        if(hal.eeprom.driver_area.address && destination == hal.eeprom.driver_area.address)
 800515e:	4b21      	ldr	r3, [pc, #132]	; (80051e4 <memcpy_to_ram_with_checksum+0xf0>)
    noepromdata[addr] = new_value;
 8005160:	f888 0000 	strb.w	r0, [r8]
        settings_dirty.is_dirty = dirty;
 8005164:	4c20      	ldr	r4, [pc, #128]	; (80051e8 <memcpy_to_ram_with_checksum+0xf4>)
        if(hal.eeprom.driver_area.address && destination == hal.eeprom.driver_area.address)
 8005166:	f8b3 30f8 	ldrh.w	r3, [r3, #248]	; 0xf8
    dirty = dirty || noepromdata[addr] != new_value;
 800516a:	f88e 2000 	strb.w	r2, [lr]
        settings_dirty.is_dirty = dirty;
 800516e:	7022      	strb	r2, [r4, #0]
        if(hal.eeprom.driver_area.address && destination == hal.eeprom.driver_area.address)
 8005170:	b113      	cbz	r3, 8005178 <memcpy_to_ram_with_checksum+0x84>
 8005172:	42bb      	cmp	r3, r7
 8005174:	d01f      	beq.n	80051b6 <memcpy_to_ram_with_checksum+0xc2>
 8005176:	2300      	movs	r3, #0
 8005178:	481c      	ldr	r0, [pc, #112]	; (80051ec <memcpy_to_ram_with_checksum+0xf8>)
 800517a:	e003      	b.n	8005184 <memcpy_to_ram_with_checksum+0x90>
            } while(target[++idx].addr);
 800517c:	b2cb      	uxtb	r3, r1
 800517e:	f830 2023 	ldrh.w	r2, [r0, r3, lsl #2]
 8005182:	b1b2      	cbz	r2, 80051b2 <memcpy_to_ram_with_checksum+0xbe>
                if(target[idx].addr == destination)
 8005184:	42ba      	cmp	r2, r7
            } while(target[++idx].addr);
 8005186:	f103 0101 	add.w	r1, r3, #1
                if(target[idx].addr == destination)
 800518a:	d1f7      	bne.n	800517c <memcpy_to_ram_with_checksum+0x88>
            if(target[idx].addr) switch(target[idx].type) {
 800518c:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8005190:	7892      	ldrb	r2, [r2, #2]
 8005192:	009b      	lsls	r3, r3, #2
 8005194:	2a04      	cmp	r2, #4
 8005196:	d80c      	bhi.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
 8005198:	e8df f002 	tbb	[pc, r2]
 800519c:	03180b15 	.word	0x03180b15
 80051a0:	12          	.byte	0x12
 80051a1:	00          	.byte	0x00
                    settings_dirty.startup_lines |= (1 << target[idx].offset);
 80051a2:	2201      	movs	r2, #1
 80051a4:	4403      	add	r3, r0
 80051a6:	78db      	ldrb	r3, [r3, #3]
 80051a8:	7921      	ldrb	r1, [r4, #4]
 80051aa:	fa02 f303 	lsl.w	r3, r2, r3
 80051ae:	430b      	orrs	r3, r1
 80051b0:	7123      	strb	r3, [r4, #4]
}
 80051b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            settings_dirty.driver_settings = true;
 80051b6:	70e2      	strb	r2, [r4, #3]
 80051b8:	e7fb      	b.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
    for(; size > 0; size--)
 80051ba:	46b8      	mov	r8, r7
 80051bc:	6819      	ldr	r1, [r3, #0]
 80051be:	e7c8      	b.n	8005152 <memcpy_to_ram_with_checksum+0x5e>
                    settings_dirty.build_info = true;
 80051c0:	2301      	movs	r3, #1
 80051c2:	70a3      	strb	r3, [r4, #2]
}
 80051c4:	e7f5      	b.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
                    settings_dirty.global_settings = true;
 80051c6:	2301      	movs	r3, #1
 80051c8:	7063      	strb	r3, [r4, #1]
                    break;
 80051ca:	e7f2      	b.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
                    settings_dirty.coord_data |= (1 << target[idx].offset);
 80051cc:	2201      	movs	r2, #1
 80051ce:	4403      	add	r3, r0
 80051d0:	78db      	ldrb	r3, [r3, #3]
 80051d2:	88e1      	ldrh	r1, [r4, #6]
 80051d4:	fa02 f303 	lsl.w	r3, r2, r3
 80051d8:	430b      	orrs	r3, r1
 80051da:	80e3      	strh	r3, [r4, #6]
                    break;
 80051dc:	e7e9      	b.n	80051b2 <memcpy_to_ram_with_checksum+0xbe>
 80051de:	bf00      	nop
 80051e0:	2000095c 	.word	0x2000095c
 80051e4:	200024bc 	.word	0x200024bc
 80051e8:	200023d4 	.word	0x200023d4
 80051ec:	08014908 	.word	0x08014908
 80051f0:	20000958 	.word	0x20000958

080051f4 <eeprom_emu_init>:
//
// Try to allocate RAM for EEPROM emulation and switch over to RAM based copy
// Changes to RAM based copy will be written to EEPROM when Grbl is in IDLE state
// NOTE: enough free heap memory is required
bool eeprom_emu_init()
{
 80051f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(hal.eeprom.size == 0)
 80051f8:	4f31      	ldr	r7, [pc, #196]	; (80052c0 <eeprom_emu_init+0xcc>)
 80051fa:	f8b7 40f6 	ldrh.w	r4, [r7, #246]	; 0xf6
 80051fe:	b924      	cbnz	r4, 800520a <eeprom_emu_init+0x16>
        hal.eeprom.size = GRBL_EEPROM_SIZE;
 8005200:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005204:	461c      	mov	r4, r3
 8005206:	f8a7 30f6 	strh.w	r3, [r7, #246]	; 0xf6

    uint_fast16_t idx = hal.eeprom.size;

    memcpy(&physical_eeprom, &hal.eeprom, sizeof(eeprom_io_t)); // save pointers to physical EEPROM handler functions
 800520a:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 80052e4 <eeprom_emu_init+0xf0>
 800520e:	4e2d      	ldr	r6, [pc, #180]	; (80052c4 <eeprom_emu_init+0xd0>)
 8005210:	4645      	mov	r5, r8
 8005212:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005214:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8005216:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 800521a:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}

    if((noepromdata = malloc(hal.eeprom.size)) != 0) {
 800521e:	4620      	mov	r0, r4
 8005220:	f00c fd04 	bl	8011c2c <malloc>
 8005224:	4e28      	ldr	r6, [pc, #160]	; (80052c8 <eeprom_emu_init+0xd4>)
 8005226:	6030      	str	r0, [r6, #0]
 8005228:	b1b8      	cbz	r0, 800525a <eeprom_emu_init+0x66>

        if(physical_eeprom.type == EEPROM_Physical) {
 800522a:	f898 3000 	ldrb.w	r3, [r8]
 800522e:	2b01      	cmp	r3, #1
 8005230:	d01d      	beq.n	800526e <eeprom_emu_init+0x7a>
            // Copy physical EEPROM content to RAM
            do {
                idx--;
                ram_put_byte(idx, physical_eeprom.get_byte(idx));
            } while(idx);
        } else if(hal.eeprom.memcpy_from_flash)
 8005232:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8005236:	b112      	cbz	r2, 800523e <eeprom_emu_init+0x4a>
            hal.eeprom.memcpy_from_flash(noepromdata);
 8005238:	4790      	blx	r2
 800523a:	f898 3000 	ldrb.w	r3, [r8]

        // Switch hal to use RAM version of EEPROM data
        hal.eeprom.type = EEPROM_Emulated;
 800523e:	2102      	movs	r1, #2
        hal.eeprom.get_byte = &ram_get_byte;
 8005240:	4a22      	ldr	r2, [pc, #136]	; (80052cc <eeprom_emu_init+0xd8>)
        hal.eeprom.put_byte = &ram_put_byte;
 8005242:	4823      	ldr	r0, [pc, #140]	; (80052d0 <eeprom_emu_init+0xdc>)
        hal.eeprom.type = EEPROM_Emulated;
 8005244:	f887 10f4 	strb.w	r1, [r7, #244]	; 0xf4
        hal.eeprom.get_byte = &ram_get_byte;
 8005248:	f8c7 20fc 	str.w	r2, [r7, #252]	; 0xfc
        hal.eeprom.memcpy_to_with_checksum = &memcpy_to_ram_with_checksum;
 800524c:	4921      	ldr	r1, [pc, #132]	; (80052d4 <eeprom_emu_init+0xe0>)
        hal.eeprom.memcpy_from_with_checksum = &memcpy_from_ram_with_checksum;
 800524e:	4a22      	ldr	r2, [pc, #136]	; (80052d8 <eeprom_emu_init+0xe4>)
        hal.eeprom.memcpy_to_with_checksum = &memcpy_to_ram_with_checksum;
 8005250:	e9c7 0140 	strd	r0, r1, [r7, #256]	; 0x100
        hal.eeprom.memcpy_from_with_checksum = &memcpy_from_ram_with_checksum;
 8005254:	f8c7 2108 	str.w	r2, [r7, #264]	; 0x108

        // If no physical EEPROM available then import default settings to RAM
        if(physical_eeprom.type == EEPROM_None)
 8005258:	b353      	cbz	r3, 80052b0 <eeprom_emu_init+0xbc>
            settings_restore((settings_restore_t){0xFF});
    }

    // Clear settings dirty flags
    memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 800525a:	2200      	movs	r2, #0
 800525c:	4b1f      	ldr	r3, [pc, #124]	; (80052dc <eeprom_emu_init+0xe8>)

    return noepromdata != 0;
 800525e:	6830      	ldr	r0, [r6, #0]
    memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8005260:	601a      	str	r2, [r3, #0]
}
 8005262:	1a80      	subs	r0, r0, r2
    memset(&settings_dirty, 0, sizeof(settings_dirty_t));
 8005264:	605a      	str	r2, [r3, #4]
}
 8005266:	bf18      	it	ne
 8005268:	2001      	movne	r0, #1
 800526a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if(physical_eeprom.get_byte(0) != SETTINGS_VERSION)
 800526e:	2000      	movs	r0, #0
 8005270:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8005274:	4798      	blx	r3
 8005276:	280f      	cmp	r0, #15
 8005278:	d11f      	bne.n	80052ba <eeprom_emu_init+0xc6>
 800527a:	4d19      	ldr	r5, [pc, #100]	; (80052e0 <eeprom_emu_init+0xec>)
                idx--;
 800527c:	3c01      	subs	r4, #1
                ram_put_byte(idx, physical_eeprom.get_byte(idx));
 800527e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8005282:	4620      	mov	r0, r4
 8005284:	4798      	blx	r3
    dirty = dirty || noepromdata[addr] != new_value;
 8005286:	782b      	ldrb	r3, [r5, #0]
 8005288:	b133      	cbz	r3, 8005298 <eeprom_emu_init+0xa4>
    noepromdata[addr] = new_value;
 800528a:	6833      	ldr	r3, [r6, #0]
 800528c:	5518      	strb	r0, [r3, r4]
            } while(idx);
 800528e:	2c00      	cmp	r4, #0
 8005290:	d1f4      	bne.n	800527c <eeprom_emu_init+0x88>
 8005292:	f898 3000 	ldrb.w	r3, [r8]
 8005296:	e7d2      	b.n	800523e <eeprom_emu_init+0x4a>
    dirty = dirty || noepromdata[addr] != new_value;
 8005298:	6832      	ldr	r2, [r6, #0]
 800529a:	5d13      	ldrb	r3, [r2, r4]
    noepromdata[addr] = new_value;
 800529c:	5510      	strb	r0, [r2, r4]
    dirty = dirty || noepromdata[addr] != new_value;
 800529e:	1a18      	subs	r0, r3, r0
 80052a0:	bf18      	it	ne
 80052a2:	2001      	movne	r0, #1
 80052a4:	7028      	strb	r0, [r5, #0]
            } while(idx);
 80052a6:	2c00      	cmp	r4, #0
 80052a8:	d1e8      	bne.n	800527c <eeprom_emu_init+0x88>
 80052aa:	f898 3000 	ldrb.w	r3, [r8]
 80052ae:	e7c6      	b.n	800523e <eeprom_emu_init+0x4a>
            settings_restore((settings_restore_t){0xFF});
 80052b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80052b4:	f008 ff76 	bl	800e1a4 <settings_restore>
 80052b8:	e7cf      	b.n	800525a <eeprom_emu_init+0x66>
                settings_init();
 80052ba:	f009 fbb1 	bl	800ea20 <settings_init>
 80052be:	e7dc      	b.n	800527a <eeprom_emu_init+0x86>
 80052c0:	200024bc 	.word	0x200024bc
 80052c4:	200025b0 	.word	0x200025b0
 80052c8:	2000095c 	.word	0x2000095c
 80052cc:	08005009 	.word	0x08005009
 80052d0:	08005015 	.word	0x08005015
 80052d4:	080050f5 	.word	0x080050f5
 80052d8:	08005049 	.word	0x08005049
 80052dc:	200023d4 	.word	0x200023d4
 80052e0:	20000958 	.word	0x20000958
 80052e4:	20000960 	.word	0x20000960

080052e8 <eeprom_emu_sync_physical>:

// Write RAM changes to EEPROM
void eeprom_emu_sync_physical ()
{
 80052e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(!settings_dirty.is_dirty)
 80052ec:	4d40      	ldr	r5, [pc, #256]	; (80053f0 <eeprom_emu_sync_physical+0x108>)
 80052ee:	782b      	ldrb	r3, [r5, #0]
 80052f0:	b163      	cbz	r3, 800530c <eeprom_emu_sync_physical+0x24>
        return;

    if(physical_eeprom.type == EEPROM_Physical) {
 80052f2:	4e40      	ldr	r6, [pc, #256]	; (80053f4 <eeprom_emu_sync_physical+0x10c>)
 80052f4:	7833      	ldrb	r3, [r6, #0]
 80052f6:	2b01      	cmp	r3, #1
 80052f8:	d00a      	beq.n	8005310 <eeprom_emu_sync_physical+0x28>
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), sizeof(tool_data_t));
            }
        } while(idx);
#endif

    } else if(hal.eeprom.memcpy_to_flash)
 80052fa:	4b3f      	ldr	r3, [pc, #252]	; (80053f8 <eeprom_emu_sync_physical+0x110>)
 80052fc:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8005300:	b113      	cbz	r3, 8005308 <eeprom_emu_sync_physical+0x20>
        hal.eeprom.memcpy_to_flash(noepromdata);
 8005302:	4a3e      	ldr	r2, [pc, #248]	; (80053fc <eeprom_emu_sync_physical+0x114>)
 8005304:	6810      	ldr	r0, [r2, #0]
 8005306:	4798      	blx	r3

    settings_dirty.is_dirty = false;
 8005308:	2300      	movs	r3, #0
 800530a:	702b      	strb	r3, [r5, #0]
}
 800530c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(settings_dirty.build_info) {
 8005310:	78ab      	ldrb	r3, [r5, #2]
 8005312:	b153      	cbz	r3, 800532a <eeprom_emu_sync_physical+0x42>
            settings_dirty.build_info = false;
 8005314:	2200      	movs	r2, #0
            physical_eeprom.memcpy_to_with_checksum(EEPROM_ADDR_BUILD_INFO, (uint8_t *)(noepromdata + EEPROM_ADDR_BUILD_INFO), MAX_STORED_LINE_LENGTH);
 8005316:	4b39      	ldr	r3, [pc, #228]	; (80053fc <eeprom_emu_sync_physical+0x114>)
            settings_dirty.build_info = false;
 8005318:	70aa      	strb	r2, [r5, #2]
            physical_eeprom.memcpy_to_with_checksum(EEPROM_ADDR_BUILD_INFO, (uint8_t *)(noepromdata + EEPROM_ADDR_BUILD_INFO), MAX_STORED_LINE_LENGTH);
 800531a:	6819      	ldr	r1, [r3, #0]
 800531c:	2246      	movs	r2, #70	; 0x46
 800531e:	f240 30ae 	movw	r0, #942	; 0x3ae
 8005322:	6933      	ldr	r3, [r6, #16]
 8005324:	f201 31ae 	addw	r1, r1, #942	; 0x3ae
 8005328:	4798      	blx	r3
        if(settings_dirty.global_settings) {
 800532a:	786b      	ldrb	r3, [r5, #1]
 800532c:	b14b      	cbz	r3, 8005342 <eeprom_emu_sync_physical+0x5a>
            settings_dirty.global_settings = false;
 800532e:	2200      	movs	r2, #0
            physical_eeprom.memcpy_to_with_checksum(EEPROM_ADDR_GLOBAL, (uint8_t *)(noepromdata + EEPROM_ADDR_GLOBAL), sizeof(settings_t));
 8005330:	4b32      	ldr	r3, [pc, #200]	; (80053fc <eeprom_emu_sync_physical+0x114>)
            settings_dirty.global_settings = false;
 8005332:	706a      	strb	r2, [r5, #1]
            physical_eeprom.memcpy_to_with_checksum(EEPROM_ADDR_GLOBAL, (uint8_t *)(noepromdata + EEPROM_ADDR_GLOBAL), sizeof(settings_t));
 8005334:	6819      	ldr	r1, [r3, #0]
 8005336:	f44f 7286 	mov.w	r2, #268	; 0x10c
 800533a:	2001      	movs	r0, #1
 800533c:	6933      	ldr	r3, [r6, #16]
 800533e:	3101      	adds	r1, #1
 8005340:	4798      	blx	r3
        if(settings_dirty.startup_lines) do {
 8005342:	792a      	ldrb	r2, [r5, #4]
 8005344:	b302      	cbz	r2, 8005388 <eeprom_emu_sync_physical+0xa0>
 8005346:	2402      	movs	r4, #2
                bit_false(settings_dirty.startup_lines, bit(idx));
 8005348:	2701      	movs	r7, #1
        uint_fast8_t idx = N_STARTUP_LINE, offset;
 800534a:	4623      	mov	r3, r4
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), MAX_STORED_LINE_LENGTH);
 800534c:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 80053fc <eeprom_emu_sync_physical+0x114>
            idx--;
 8005350:	3b01      	subs	r3, #1
                offset = EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1);
 8005352:	eb03 00c3 	add.w	r0, r3, r3, lsl #3
                bit_false(settings_dirty.startup_lines, bit(idx));
 8005356:	fa07 f103 	lsl.w	r1, r7, r3
                offset = EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1);
 800535a:	ebc3 00c0 	rsb	r0, r3, r0, lsl #3
            if(bit_istrue(settings_dirty.startup_lines, bit(idx))) {
 800535e:	fa22 f303 	lsr.w	r3, r2, r3
                bit_false(settings_dirty.startup_lines, bit(idx));
 8005362:	ea22 0201 	bic.w	r2, r2, r1
            if(bit_istrue(settings_dirty.startup_lines, bit(idx))) {
 8005366:	07d9      	lsls	r1, r3, #31
                offset = EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1);
 8005368:	f200 301f 	addw	r0, r0, #799	; 0x31f
            if(bit_istrue(settings_dirty.startup_lines, bit(idx))) {
 800536c:	d506      	bpl.n	800537c <eeprom_emu_sync_physical+0x94>
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), MAX_STORED_LINE_LENGTH);
 800536e:	f8d8 1000 	ldr.w	r1, [r8]
                bit_false(settings_dirty.startup_lines, bit(idx));
 8005372:	712a      	strb	r2, [r5, #4]
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), MAX_STORED_LINE_LENGTH);
 8005374:	6933      	ldr	r3, [r6, #16]
 8005376:	2246      	movs	r2, #70	; 0x46
 8005378:	4401      	add	r1, r0
 800537a:	4798      	blx	r3
        } while(idx);
 800537c:	2c01      	cmp	r4, #1
 800537e:	d003      	beq.n	8005388 <eeprom_emu_sync_physical+0xa0>
 8005380:	2401      	movs	r4, #1
 8005382:	792a      	ldrb	r2, [r5, #4]
            idx--;
 8005384:	4623      	mov	r3, r4
 8005386:	e7e3      	b.n	8005350 <eeprom_emu_sync_physical+0x68>
        if(settings_dirty.coord_data) do {
 8005388:	88eb      	ldrh	r3, [r5, #6]
 800538a:	b1fb      	cbz	r3, 80053cc <eeprom_emu_sync_physical+0xe4>
        idx = SETTING_INDEX_NCOORD;
 800538c:	240b      	movs	r4, #11
                bit_false(settings_dirty.coord_data, bit(idx));
 800538e:	2701      	movs	r7, #1
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), sizeof(coord_data_t));
 8005390:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80053fc <eeprom_emu_sync_physical+0x114>
 8005394:	e000      	b.n	8005398 <eeprom_emu_sync_physical+0xb0>
 8005396:	88eb      	ldrh	r3, [r5, #6]
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
 8005398:	fa23 f204 	lsr.w	r2, r3, r4
 800539c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
                bit_false(settings_dirty.coord_data, bit(idx));
 80053a0:	fa07 f104 	lsl.w	r1, r7, r4
 80053a4:	eb04 0080 	add.w	r0, r4, r0, lsl #2
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
 80053a8:	f012 0f01 	tst.w	r2, #1
                bit_false(settings_dirty.coord_data, bit(idx));
 80053ac:	ea23 0301 	bic.w	r3, r3, r1
 80053b0:	f500 7000 	add.w	r0, r0, #512	; 0x200
            if(bit_istrue(settings_dirty.coord_data, bit(idx))) {
 80053b4:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 80053b8:	d006      	beq.n	80053c8 <eeprom_emu_sync_physical+0xe0>
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), sizeof(coord_data_t));
 80053ba:	f8d8 1000 	ldr.w	r1, [r8]
                bit_false(settings_dirty.coord_data, bit(idx));
 80053be:	80eb      	strh	r3, [r5, #6]
                physical_eeprom.memcpy_to_with_checksum(offset, (uint8_t *)(noepromdata + offset), sizeof(coord_data_t));
 80053c0:	220c      	movs	r2, #12
 80053c2:	6933      	ldr	r3, [r6, #16]
 80053c4:	4401      	add	r1, r0
 80053c6:	4798      	blx	r3
        } while(idx--);
 80053c8:	1c63      	adds	r3, r4, #1
 80053ca:	d1e4      	bne.n	8005396 <eeprom_emu_sync_physical+0xae>
        if(settings_dirty.driver_settings) {
 80053cc:	78eb      	ldrb	r3, [r5, #3]
 80053ce:	2b00      	cmp	r3, #0
 80053d0:	d09a      	beq.n	8005308 <eeprom_emu_sync_physical+0x20>
            settings_dirty.driver_settings = false;
 80053d2:	2200      	movs	r2, #0
            if(hal.eeprom.driver_area.size > 0)
 80053d4:	4b08      	ldr	r3, [pc, #32]	; (80053f8 <eeprom_emu_sync_physical+0x110>)
            settings_dirty.driver_settings = false;
 80053d6:	70ea      	strb	r2, [r5, #3]
            if(hal.eeprom.driver_area.size > 0)
 80053d8:	f8b3 20fa 	ldrh.w	r2, [r3, #250]	; 0xfa
 80053dc:	2a00      	cmp	r2, #0
 80053de:	d093      	beq.n	8005308 <eeprom_emu_sync_physical+0x20>
                physical_eeprom.memcpy_to_with_checksum(hal.eeprom.driver_area.address, (uint8_t *)(noepromdata + hal.eeprom.driver_area.address), hal.eeprom.driver_area.size);
 80053e0:	4906      	ldr	r1, [pc, #24]	; (80053fc <eeprom_emu_sync_physical+0x114>)
 80053e2:	f8b3 00f8 	ldrh.w	r0, [r3, #248]	; 0xf8
 80053e6:	6809      	ldr	r1, [r1, #0]
 80053e8:	6933      	ldr	r3, [r6, #16]
 80053ea:	4401      	add	r1, r0
 80053ec:	4798      	blx	r3
 80053ee:	e78b      	b.n	8005308 <eeprom_emu_sync_physical+0x20>
 80053f0:	200023d4 	.word	0x200023d4
 80053f4:	20000960 	.word	0x20000960
 80053f8:	200024bc 	.word	0x200024bc
 80053fc:	2000095c 	.word	0x2000095c

08005400 <init_sync_motion>:

    return add_cmd != NULL;
}

static status_code_t init_sync_motion (plan_line_data_t *pl_data, float pitch)
{
 8005400:	b570      	push	{r4, r5, r6, lr}
 8005402:	460c      	mov	r4, r1
    pl_data->overrides.sync = On;                   // set to sync overrides on execution of motion.

    // Disable feed rate and spindle overrides for the duration of the cycle.
    pl_data->overrides.spindle_rpm_disable = sys.override.control.spindle_rpm_disable = On;
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
    sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8005404:	2564      	movs	r5, #100	; 0x64
    pl_data->condition.inverse_time = Off;
 8005406:	f890 3020 	ldrb.w	r3, [r0, #32]
    pl_data->overrides = sys.override.control;      // Use current override flags and
 800540a:	4a1b      	ldr	r2, [pc, #108]	; (8005478 <init_sync_motion+0x78>)
    pl_data->condition.inverse_time = Off;
 800540c:	f36f 1345 	bfc	r3, #5, #1
 8005410:	f880 3020 	strb.w	r3, [r0, #32]
    pl_data->condition.is_rpm_pos_adjusted = Off;   // Switch off CSS.
 8005414:	f890 1020 	ldrb.w	r1, [r0, #32]
    pl_data->overrides = sys.override.control;      // Use current override flags and
 8005418:	7c93      	ldrb	r3, [r2, #18]
    pl_data->feed_rate = gc_state.distance_per_rev = pitch;
 800541a:	4e18      	ldr	r6, [pc, #96]	; (800547c <init_sync_motion+0x7c>)
    pl_data->condition.is_rpm_pos_adjusted = Off;   // Switch off CSS.
 800541c:	f36f 11c7 	bfc	r1, #7, #1
    pl_data->feed_rate = gc_state.distance_per_rev = pitch;
 8005420:	66b4      	str	r4, [r6, #104]	; 0x68
    pl_data->condition.is_rpm_pos_adjusted = Off;   // Switch off CSS.
 8005422:	f880 1020 	strb.w	r1, [r0, #32]
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
 8005426:	f063 017a 	orn	r1, r3, #122	; 0x7a
 800542a:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
 800542e:	f023 0305 	bic.w	r3, r3, #5
    // TODO: need for gc_state.distance_per_rev to be reset on modal change?
    float feed_rate = pl_data->feed_rate * hal.spindle_get_data(SpindleData_RPM).rpm;
 8005432:	4913      	ldr	r1, [pc, #76]	; (8005480 <init_sync_motion+0x80>)
{
 8005434:	b088      	sub	sp, #32
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
 8005436:	f043 0305 	orr.w	r3, r3, #5
    pl_data->feed_rate = gc_state.distance_per_rev = pitch;
 800543a:	6004      	str	r4, [r0, #0]
    pl_data->overrides.feed_rate_disable = sys.override.control.feed_rate_disable = On;
 800543c:	7493      	strb	r3, [r2, #18]
    float feed_rate = pl_data->feed_rate * hal.spindle_get_data(SpindleData_RPM).rpm;
 800543e:	4668      	mov	r0, sp
 8005440:	f8d1 30e8 	ldr.w	r3, [r1, #232]	; 0xe8
    sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8005444:	7415      	strb	r5, [r2, #16]
    float feed_rate = pl_data->feed_rate * hal.spindle_get_data(SpindleData_RPM).rpm;
 8005446:	2101      	movs	r1, #1
 8005448:	4798      	blx	r3
 800544a:	4620      	mov	r0, r4
 800544c:	9902      	ldr	r1, [sp, #8]
 800544e:	f7fb f9a1 	bl	8000794 <__aeabi_fmul>

    if(feed_rate == 0.0f)
 8005452:	2100      	movs	r1, #0
    float feed_rate = pl_data->feed_rate * hal.spindle_get_data(SpindleData_RPM).rpm;
 8005454:	4604      	mov	r4, r0
    if(feed_rate == 0.0f)
 8005456:	f7fb fb31 	bl	8000abc <__aeabi_fcmpeq>
 800545a:	b950      	cbnz	r0, 8005472 <init_sync_motion+0x72>
        FAIL(Status_GcodeSpindleNotRunning); // [Spindle not running]

    if(feed_rate > settings.max_rate[Z_AXIS])
 800545c:	4b09      	ldr	r3, [pc, #36]	; (8005484 <init_sync_motion+0x84>)
 800545e:	4621      	mov	r1, r4
 8005460:	6998      	ldr	r0, [r3, #24]
 8005462:	f7fb fb35 	bl	8000ad0 <__aeabi_fcmplt>
 8005466:	2800      	cmp	r0, #0
        FAIL(Status_GcodeMaxFeedRateExceeded); // [Feed rate too high]

    return Status_OK;
 8005468:	bf14      	ite	ne
 800546a:	202b      	movne	r0, #43	; 0x2b
 800546c:	2000      	moveq	r0, #0
}
 800546e:	b008      	add	sp, #32
 8005470:	bd70      	pop	{r4, r5, r6, pc}
        FAIL(Status_GcodeSpindleNotRunning); // [Spindle not running]
 8005472:	2029      	movs	r0, #41	; 0x29
}
 8005474:	b008      	add	sp, #32
 8005476:	bd70      	pop	{r4, r5, r6, pc}
 8005478:	20002494 	.word	0x20002494
 800547c:	200023dc 	.word	0x200023dc
 8005480:	200024bc 	.word	0x200024bc
 8005484:	20002620 	.word	0x20002620

08005488 <add_output_command.constprop.0>:
static bool add_output_command (output_command_t *command)
 8005488:	b538      	push	{r3, r4, r5, lr}
    if((add_cmd = malloc(sizeof(output_command_t)))) {
 800548a:	200c      	movs	r0, #12
 800548c:	f00c fbce 	bl	8011c2c <malloc>
 8005490:	4604      	mov	r4, r0
 8005492:	b158      	cbz	r0, 80054ac <add_output_command.constprop.0+0x24>
        if(output_commands == NULL)
 8005494:	4d0a      	ldr	r5, [pc, #40]	; (80054c0 <add_output_command.constprop.0+0x38>)
        memcpy(add_cmd, command, sizeof(output_command_t));
 8005496:	4a0b      	ldr	r2, [pc, #44]	; (80054c4 <add_output_command.constprop.0+0x3c>)
        if(output_commands == NULL)
 8005498:	682b      	ldr	r3, [r5, #0]
        memcpy(add_cmd, command, sizeof(output_command_t));
 800549a:	ca07      	ldmia	r2, {r0, r1, r2}
 800549c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        if(output_commands == NULL)
 80054a0:	b143      	cbz	r3, 80054b4 <add_output_command.constprop.0+0x2c>
            while(cmd->next)
 80054a2:	461a      	mov	r2, r3
 80054a4:	689b      	ldr	r3, [r3, #8]
 80054a6:	2b00      	cmp	r3, #0
 80054a8:	d1fb      	bne.n	80054a2 <add_output_command.constprop.0+0x1a>
            cmd->next = add_cmd;
 80054aa:	6094      	str	r4, [r2, #8]
}
 80054ac:	1e20      	subs	r0, r4, #0
 80054ae:	bf18      	it	ne
 80054b0:	2001      	movne	r0, #1
 80054b2:	bd38      	pop	{r3, r4, r5, pc}
 80054b4:	1e20      	subs	r0, r4, #0
 80054b6:	bf18      	it	ne
 80054b8:	2001      	movne	r0, #1
            output_commands = add_cmd;
 80054ba:	602c      	str	r4, [r5, #0]
}
 80054bc:	bd38      	pop	{r3, r4, r5, pc}
 80054be:	bf00      	nop
 80054c0:	20000a0c 	.word	0x20000a0c
 80054c4:	20000a00 	.word	0x20000a00

080054c8 <gc_get_scaling>:
}
 80054c8:	4800      	ldr	r0, [pc, #0]	; (80054cc <gc_get_scaling+0x4>)
 80054ca:	4770      	bx	lr
 80054cc:	20000a1c 	.word	0x20000a1c

080054d0 <gc_get_g51_state>:
{
 80054d0:	b538      	push	{r3, r4, r5, lr}
        if(scale_factor.ijk[--idx] != 1.0f)
 80054d2:	4d0f      	ldr	r5, [pc, #60]	; (8005510 <gc_get_g51_state+0x40>)
 80054d4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80054d8:	6968      	ldr	r0, [r5, #20]
 80054da:	f7fb faef 	bl	8000abc <__aeabi_fcmpeq>
 80054de:	fab0 f380 	clz	r3, r0
 80054e2:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80054e6:	095b      	lsrs	r3, r3, #5
 80054e8:	6928      	ldr	r0, [r5, #16]
        scaled.value <<= 1;
 80054ea:	005c      	lsls	r4, r3, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 80054ec:	f7fb fae6 	bl	8000abc <__aeabi_fcmpeq>
 80054f0:	b908      	cbnz	r0, 80054f6 <gc_get_g51_state+0x26>
            scaled.value |= 0x01;
 80054f2:	f044 0401 	orr.w	r4, r4, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 80054f6:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80054fa:	68e8      	ldr	r0, [r5, #12]
 80054fc:	f7fb fade 	bl	8000abc <__aeabi_fcmpeq>
        scaled.value <<= 1;
 8005500:	0064      	lsls	r4, r4, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8005502:	b910      	cbnz	r0, 800550a <gc_get_g51_state+0x3a>
            scaled.value |= 0x01;
 8005504:	f044 0301 	orr.w	r3, r4, #1
 8005508:	b2dc      	uxtb	r4, r3
}
 800550a:	4620      	mov	r0, r4
 800550c:	bd38      	pop	{r3, r4, r5, pc}
 800550e:	bf00      	nop
 8005510:	20000a10 	.word	0x20000a10

08005514 <gc_get_offset>:
{
 8005514:	b538      	push	{r3, r4, r5, lr}
 8005516:	4604      	mov	r4, r0
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8005518:	4d07      	ldr	r5, [pc, #28]	; (8005538 <gc_get_offset+0x24>)
 800551a:	1c82      	adds	r2, r0, #2
 800551c:	eb05 0380 	add.w	r3, r5, r0, lsl #2
 8005520:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
 8005524:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
 8005528:	3424      	adds	r4, #36	; 0x24
 800552a:	f7fb f82b 	bl	8000584 <__addsf3>
 800552e:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
 8005532:	f7fb f827 	bl	8000584 <__addsf3>
}
 8005536:	bd38      	pop	{r3, r4, r5, pc}
 8005538:	200023dc 	.word	0x200023dc

0800553c <gc_init>:
{
 800553c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(cold_start) {
 8005540:	2800      	cmp	r0, #0
 8005542:	d058      	beq.n	80055f6 <gc_init+0xba>
        memset(&gc_state, 0, sizeof(parser_state_t));
 8005544:	4e3a      	ldr	r6, [pc, #232]	; (8005630 <gc_init+0xf4>)
 8005546:	229c      	movs	r2, #156	; 0x9c
 8005548:	4630      	mov	r0, r6
 800554a:	2100      	movs	r1, #0
 800554c:	f00c fb9a 	bl	8011c84 <memset>
        memset(&tool_table, 0, sizeof(tool_table));
 8005550:	2200      	movs	r2, #0
 8005552:	4b38      	ldr	r3, [pc, #224]	; (8005634 <gc_init+0xf8>)
 8005554:	e9c3 2200 	strd	r2, r2, [r3]
 8005558:	e9c3 2202 	strd	r2, r2, [r3, #8]
        gc_state.tool = &tool_table;
 800555c:	f8c6 309c 	str.w	r3, [r6, #156]	; 0x9c
        memset(&tool_table, 0, sizeof(tool_table));
 8005560:	611a      	str	r2, [r3, #16]
    while(output_commands) {
 8005562:	4d35      	ldr	r5, [pc, #212]	; (8005638 <gc_init+0xfc>)
 8005564:	682c      	ldr	r4, [r5, #0]
 8005566:	b13c      	cbz	r4, 8005578 <gc_init+0x3c>
        output_command_t *next = output_commands->next;
 8005568:	4620      	mov	r0, r4
 800556a:	68a4      	ldr	r4, [r4, #8]
        free(output_commands);
 800556c:	f00c fb66 	bl	8011c3c <free>
        output_commands = next;
 8005570:	602c      	str	r4, [r5, #0]
    while(output_commands) {
 8005572:	2c00      	cmp	r4, #0
 8005574:	d1f8      	bne.n	8005568 <gc_init+0x2c>
 8005576:	7d34      	ldrb	r4, [r6, #20]
    gc_state.modal.override_ctrl = sys.override.control;
 8005578:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800564c <gc_init+0x110>
    gc_state.spindle.css.max_rpm = settings.spindle.rpm_max; // default max speed for CSS mode
 800557c:	4b2f      	ldr	r3, [pc, #188]	; (800563c <gc_init+0x100>)
    gc_state.modal.override_ctrl = sys.override.control;
 800557e:	f898 2012 	ldrb.w	r2, [r8, #18]
    gc_state.spindle.css.max_rpm = settings.spindle.rpm_max; // default max speed for CSS mode
 8005582:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        if(scale_factor.ijk[--idx] != 1.0f)
 8005584:	4f2e      	ldr	r7, [pc, #184]	; (8005640 <gc_init+0x104>)
 8005586:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    gc_state.spindle.css.max_rpm = settings.spindle.rpm_max; // default max speed for CSS mode
 800558a:	6573      	str	r3, [r6, #84]	; 0x54
        if(scale_factor.ijk[--idx] != 1.0f)
 800558c:	6978      	ldr	r0, [r7, #20]
    gc_state.modal.override_ctrl = sys.override.control;
 800558e:	76f2      	strb	r2, [r6, #27]
        if(scale_factor.ijk[--idx] != 1.0f)
 8005590:	f7fb fa94 	bl	8000abc <__aeabi_fcmpeq>
 8005594:	fab0 f380 	clz	r3, r0
 8005598:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800559c:	095b      	lsrs	r3, r3, #5
 800559e:	6938      	ldr	r0, [r7, #16]
        scaled.value <<= 1;
 80055a0:	005d      	lsls	r5, r3, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 80055a2:	f7fb fa8b 	bl	8000abc <__aeabi_fcmpeq>
 80055a6:	b908      	cbnz	r0, 80055ac <gc_init+0x70>
            scaled.value |= 0x01;
 80055a8:	f045 0501 	orr.w	r5, r5, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 80055ac:	f04f 597e 	mov.w	r9, #1065353216	; 0x3f800000
 80055b0:	68f8      	ldr	r0, [r7, #12]
 80055b2:	4649      	mov	r1, r9
 80055b4:	f7fb fa82 	bl	8000abc <__aeabi_fcmpeq>
        scaled.value <<= 1;
 80055b8:	006d      	lsls	r5, r5, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 80055ba:	bb50      	cbnz	r0, 8005612 <gc_init+0xd6>
        scale_factor.xyz[idx] = 0.0f;
 80055bc:	2300      	movs	r3, #0
        scale_factor.ijk[--idx] = factor;
 80055be:	f8c7 9014 	str.w	r9, [r7, #20]
 80055c2:	f8c7 9010 	str.w	r9, [r7, #16]
 80055c6:	f8c7 900c 	str.w	r9, [r7, #12]
    gc_state.modal.scaling_active = factor != 1.0f;
 80055ca:	77b0      	strb	r0, [r6, #30]
        scale_factor.xyz[idx] = 0.0f;
 80055cc:	60bb      	str	r3, [r7, #8]
 80055ce:	607b      	str	r3, [r7, #4]
 80055d0:	603b      	str	r3, [r7, #0]
        sys.report.scaling = On;
 80055d2:	f898 3014 	ldrb.w	r3, [r8, #20]
 80055d6:	f043 0302 	orr.w	r3, r3, #2
 80055da:	f888 3014 	strb.w	r3, [r8, #20]
    if (!settings_read_coord_data(gc_state.modal.coord_system.idx, &gc_state.modal.coord_system.xyz))
 80055de:	4620      	mov	r0, r4
 80055e0:	4918      	ldr	r1, [pc, #96]	; (8005644 <gc_init+0x108>)
 80055e2:	f008 fda5 	bl	800e130 <settings_read_coord_data>
 80055e6:	b990      	cbnz	r0, 800560e <gc_init+0xd2>
}
 80055e8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        hal.report.status_message(Status_SettingReadFail);
 80055ec:	4b16      	ldr	r3, [pc, #88]	; (8005648 <gc_init+0x10c>)
 80055ee:	2007      	movs	r0, #7
 80055f0:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 80055f4:	4718      	bx	r3
        memset(&gc_state, 0, offsetof(parser_state_t, g92_coord_offset));
 80055f6:	4e0e      	ldr	r6, [pc, #56]	; (8005630 <gc_init+0xf4>)
 80055f8:	4601      	mov	r1, r0
 80055fa:	2284      	movs	r2, #132	; 0x84
 80055fc:	4630      	mov	r0, r6
 80055fe:	f00c fb41 	bl	8011c84 <memset>
        gc_state.tool_pending = gc_state.tool->tool;
 8005602:	f8d6 309c 	ldr.w	r3, [r6, #156]	; 0x9c
 8005606:	7c1b      	ldrb	r3, [r3, #16]
 8005608:	f886 307c 	strb.w	r3, [r6, #124]	; 0x7c
 800560c:	e7a9      	b.n	8005562 <gc_init+0x26>
}
 800560e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        scale_factor.xyz[idx] = 0.0f;
 8005612:	2200      	movs	r2, #0
    gc_state.modal.scaling_active = factor != 1.0f;
 8005614:	2100      	movs	r1, #0
        scale_factor.ijk[--idx] = factor;
 8005616:	f8c7 9014 	str.w	r9, [r7, #20]
 800561a:	f8c7 9010 	str.w	r9, [r7, #16]
 800561e:	f8c7 900c 	str.w	r9, [r7, #12]
    gc_state.modal.scaling_active = factor != 1.0f;
 8005622:	77b1      	strb	r1, [r6, #30]
        scale_factor.xyz[idx] = 0.0f;
 8005624:	60ba      	str	r2, [r7, #8]
 8005626:	607a      	str	r2, [r7, #4]
 8005628:	603a      	str	r2, [r7, #0]
    if(state.value != gc_get_g51_state().value)
 800562a:	2d00      	cmp	r5, #0
 800562c:	d0d7      	beq.n	80055de <gc_init+0xa2>
 800562e:	e7d0      	b.n	80055d2 <gc_init+0x96>
 8005630:	200023dc 	.word	0x200023dc
 8005634:	2000247c 	.word	0x2000247c
 8005638:	20000a0c 	.word	0x20000a0c
 800563c:	20002620 	.word	0x20002620
 8005640:	20000a10 	.word	0x20000a10
 8005644:	200023e4 	.word	0x200023e4
 8005648:	200024bc 	.word	0x200024bc
 800564c:	20002494 	.word	0x20002494

08005650 <gc_execute_block>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
status_code_t gc_execute_block(char *block, char *message)
{
 8005650:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Old comment from protocol.c:
    // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
    // where, during a program, the system auto-cycle start will continue to execute
    // everything until the next '%' sign. This will help fix resuming issues with certain
    // functions that empty the planner buffer to execute its task on-time.
    if (block[0] == CMD_PROGRAM_DEMARCATION && block[1] == '\0') {
 8005654:	7803      	ldrb	r3, [r0, #0]
{
 8005656:	b0a9      	sub	sp, #164	; 0xa4
    if (block[0] == CMD_PROGRAM_DEMARCATION && block[1] == '\0') {
 8005658:	2b25      	cmp	r3, #37	; 0x25
{
 800565a:	4607      	mov	r7, r0
 800565c:	910a      	str	r1, [sp, #40]	; 0x28
    if (block[0] == CMD_PROGRAM_DEMARCATION && block[1] == '\0') {
 800565e:	d104      	bne.n	800566a <gc_execute_block+0x1a>
 8005660:	7843      	ldrb	r3, [r0, #1]
 8005662:	9304      	str	r3, [sp, #16]
 8005664:	2b00      	cmp	r3, #0
 8005666:	f000 843e 	beq.w	8005ee6 <gc_execute_block+0x896>
    uint8_t axis_words = 0; // XYZ tracking
    uint8_t ijk_words = 0; // IJK tracking

    // Initialize command and value words and parser flags variables.
    uint32_t command_words = 0; // Bitfield for tracking G and M command words. Also used for modal group violations.
    uint32_t value_words = 0;   // Bitfield for tracking value words.
 800566a:	2600      	movs	r6, #0
    memset(&gc_block, 0, sizeof(gc_block));                           // Initialize the parser block struct.
 800566c:	f8df 9140 	ldr.w	r9, [pc, #320]	; 80057b0 <gc_execute_block+0x160>
    memcpy(&gc_block.modal, &gc_state.modal, sizeof(gc_state.modal)); // Copy current modes
 8005670:	4d4e      	ldr	r5, [pc, #312]	; (80057ac <gc_execute_block+0x15c>)
    memset(&gc_block, 0, sizeof(gc_block));                           // Initialize the parser block struct.
 8005672:	228c      	movs	r2, #140	; 0x8c
 8005674:	2100      	movs	r1, #0
 8005676:	4648      	mov	r0, r9
    memcpy(&gc_block.modal, &gc_state.modal, sizeof(gc_state.modal)); // Copy current modes
 8005678:	f109 0408 	add.w	r4, r9, #8
    memset(&gc_block, 0, sizeof(gc_block));                           // Initialize the parser block struct.
 800567c:	f00c fb02 	bl	8011c84 <memset>
    memcpy(&gc_block.modal, &gc_state.modal, sizeof(gc_state.modal)); // Copy current modes
 8005680:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005682:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8005684:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005686:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8005688:	e895 0003 	ldmia.w	r5, {r0, r1}
 800568c:	e884 0003 	stmia.w	r4, {r0, r1}
    gc_parser_flags_t gc_parser_flags = {0};

    // Determine if the line is a jogging motion or a normal g-code block.
    if (block[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 8005690:	783b      	ldrb	r3, [r7, #0]
    uint32_t value_words = 0;   // Bitfield for tracking value words.
 8005692:	9615      	str	r6, [sp, #84]	; 0x54
    if (block[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 8005694:	2b24      	cmp	r3, #36	; 0x24
    gc_parser_flags_t gc_parser_flags = {0};
 8005696:	f8ad 601c 	strh.w	r6, [sp, #28]
    if (block[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
 800569a:	f000 8222 	beq.w	8005ae2 <gc_execute_block+0x492>
 800569e:	463a      	mov	r2, r7
 80056a0:	2301      	movs	r3, #1
    char letter;
    float value;
    uint_fast16_t int_value = 0;
    uint_fast16_t mantissa = 0;

    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 80056a2:	7815      	ldrb	r5, [r2, #0]
 80056a4:	9316      	str	r3, [sp, #88]	; 0x58
 80056a6:	2d00      	cmp	r5, #0
 80056a8:	f000 87ee 	beq.w	8006688 <gc_execute_block+0x1038>
    uint32_t command_words = 0; // Bitfield for tracking G and M command words. Also used for modal group violations.
 80056ac:	f04f 0800 	mov.w	r8, #0
    bool set_tool = false;
 80056b0:	e9cd 8805 	strd	r8, r8, [sp, #20]
        // accurate enough for value words that require integers to within 0.0001. This should be
        // a good enough comprimise and catch most all non-integer errors. To make it compliant,
        // we would simply need to change the mantissa to int16, but this add compiled flash space.
        // Maybe update this later.
        int_value = (uint_fast16_t)truncf(value);
        mantissa = (uint_fast16_t)roundf(100.0f * (value - int_value)); // Compute mantissa for Gxx.x commands.
 80056b4:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 80057b4 <gc_execute_block+0x164>
    uint8_t ijk_words = 0; // IJK tracking
 80056b8:	f8cd 8020 	str.w	r8, [sp, #32]
    uint8_t axis_words = 0; // XYZ tracking
 80056bc:	f8cd 8010 	str.w	r8, [sp, #16]
    uint_fast8_t port_command = 0;
 80056c0:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
        if((letter < 'A') || (letter > 'Z'))
 80056c4:	f1a5 0341 	sub.w	r3, r5, #65	; 0x41
 80056c8:	2b19      	cmp	r3, #25
 80056ca:	f200 844b 	bhi.w	8005f64 <gc_execute_block+0x914>
        if (!read_float(block, &char_counter, &value))
 80056ce:	4638      	mov	r0, r7
 80056d0:	aa17      	add	r2, sp, #92	; 0x5c
 80056d2:	a916      	add	r1, sp, #88	; 0x58
 80056d4:	f004 fd7c 	bl	800a1d0 <read_float>
 80056d8:	4606      	mov	r6, r0
 80056da:	2800      	cmp	r0, #0
 80056dc:	f000 8448 	beq.w	8005f70 <gc_execute_block+0x920>
        int_value = (uint_fast16_t)truncf(value);
 80056e0:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
 80056e4:	4658      	mov	r0, fp
 80056e6:	f7fb fa57 	bl	8000b98 <__aeabi_f2uiz>
 80056ea:	4604      	mov	r4, r0
        mantissa = (uint_fast16_t)roundf(100.0f * (value - int_value)); // Compute mantissa for Gxx.x commands.
 80056ec:	f7fa fffa 	bl	80006e4 <__aeabi_ui2f>
 80056f0:	4601      	mov	r1, r0
 80056f2:	4658      	mov	r0, fp
 80056f4:	f7fa ff44 	bl	8000580 <__aeabi_fsub>
 80056f8:	4651      	mov	r1, sl
 80056fa:	f7fb f84b 	bl	8000794 <__aeabi_fmul>
 80056fe:	f00d fb5f 	bl	8012dc0 <roundf>
 8005702:	f7fb fa49 	bl	8000b98 <__aeabi_f2uiz>
        // NOTE: Rounding must be used to catch small floating point errors.

        // Check if the g-code word is supported or errors due to modal group violations or has
        // been repeated in the g-code block. If ok, update the command or record its value.
        switch(letter) {
 8005706:	2d47      	cmp	r5, #71	; 0x47
 8005708:	f000 8150 	beq.w	80059ac <gc_execute_block+0x35c>
 800570c:	2d4d      	cmp	r5, #77	; 0x4d
 800570e:	f040 812a 	bne.w	8005966 <gc_execute_block+0x316>
                command_words |= bit(word_bit.group);
                break;

            case 'M': // Determine 'M' command and its modal group

                if (mantissa > 0)
 8005712:	2800      	cmp	r0, #0
 8005714:	f040 8432 	bne.w	8005f7c <gc_execute_block+0x92c>
                    FAIL(Status_GcodeCommandValueNotInteger); // [No Mxx.x commands]

                switch(int_value) {
 8005718:	2c44      	cmp	r4, #68	; 0x44
 800571a:	f200 8205 	bhi.w	8005b28 <gc_execute_block+0x4d8>
 800571e:	e8df f014 	tbh	[pc, r4, lsl #1]
 8005722:	0213      	.short	0x0213
 8005724:	02130213 	.word	0x02130213
 8005728:	02200220 	.word	0x02200220
 800572c:	004b0220 	.word	0x004b0220
 8005730:	01ea01ea 	.word	0x01ea01ea
 8005734:	020301ea 	.word	0x020301ea
 8005738:	02030203 	.word	0x02030203
 800573c:	02030203 	.word	0x02030203
 8005740:	02030203 	.word	0x02030203
 8005744:	02030203 	.word	0x02030203
 8005748:	02030203 	.word	0x02030203
 800574c:	02030203 	.word	0x02030203
 8005750:	02030203 	.word	0x02030203
 8005754:	02030203 	.word	0x02030203
 8005758:	02030203 	.word	0x02030203
 800575c:	02130203 	.word	0x02130203
 8005760:	02030203 	.word	0x02030203
 8005764:	02030203 	.word	0x02030203
 8005768:	02030203 	.word	0x02030203
 800576c:	02030203 	.word	0x02030203
 8005770:	02030203 	.word	0x02030203
 8005774:	02030203 	.word	0x02030203
 8005778:	02030203 	.word	0x02030203
 800577c:	02030203 	.word	0x02030203
 8005780:	02030203 	.word	0x02030203
 8005784:	01ca01ca 	.word	0x01ca01ca
 8005788:	020301ca 	.word	0x020301ca
 800578c:	020301ca 	.word	0x020301ca
 8005790:	01c50203 	.word	0x01c50203
 8005794:	02030203 	.word	0x02030203
 8005798:	02030203 	.word	0x02030203
 800579c:	02540051 	.word	0x02540051
 80057a0:	02540254 	.word	0x02540254
 80057a4:	023b0254 	.word	0x023b0254
 80057a8:	024a024a 	.word	0x024a024a
 80057ac:	200023dc 	.word	0x200023dc
 80057b0:	20000980 	.word	0x20000980
 80057b4:	42c80000 	.word	0x42c80000
                        gc_block.modal.spindle.ccw = int_value == 4;
                        sys.flags.delay_overrides = On;
                        break;

                    case 6:
                        if(hal.stream.suspend_read || hal.tool_change)
 80057b8:	4b79      	ldr	r3, [pc, #484]	; (80059a0 <gc_execute_block+0x350>)
 80057ba:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80057bc:	2a00      	cmp	r2, #0
 80057be:	f000 8401 	beq.w	8005fc4 <gc_execute_block+0x974>
 80057c2:	9e05      	ldr	r6, [sp, #20]
 80057c4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80057c8:	2210      	movs	r2, #16
                            FAIL(Status_GcodeUnsupportedCommand); // [Unsupported M command]
                } // end M-value switch

                // Check for more than one command per modal group violations in the current block
                // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
                if (bit_istrue(command_words, bit(word_bit.group)))
 80057ca:	fa28 f202 	lsr.w	r2, r8, r2
 80057ce:	07d0      	lsls	r0, r2, #31
 80057d0:	f100 83d7 	bmi.w	8005f82 <gc_execute_block+0x932>
                    FAIL(Status_GcodeModalGroupViolation);
                command_words |= bit(word_bit.group);
 80057d4:	ea48 0801 	orr.w	r8, r8, r1
                break;
 80057d8:	9605      	str	r6, [sp, #20]
    while ((letter = block[char_counter++]) != '\0') { // Loop until no more g-code words in block.
 80057da:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80057dc:	5cfd      	ldrb	r5, [r7, r3]
 80057de:	3301      	adds	r3, #1
 80057e0:	9316      	str	r3, [sp, #88]	; 0x58
 80057e2:	2d00      	cmp	r5, #0
 80057e4:	f47f af6e 	bne.w	80056c4 <gc_execute_block+0x74>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

    // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
    // command has been sent. If so, set axis command to current motion mode.
    if (axis_words && !axis_command)
 80057e8:	9b04      	ldr	r3, [sp, #16]
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	f000 8386 	beq.w	8005efc <gc_execute_block+0x8ac>
 80057f0:	9b06      	ldr	r3, [sp, #24]
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	f040 8382 	bne.w	8005efc <gc_execute_block+0x8ac>
        axis_command = AxisCommand_MotionMode; // Assign implicit motion-mode

    if(gc_state.tool_change && axis_command == AxisCommand_MotionMode && !gc_parser_flags.jog_motion)
 80057f8:	4b6a      	ldr	r3, [pc, #424]	; (80059a4 <gc_execute_block+0x354>)
 80057fa:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 80057fe:	2b00      	cmp	r3, #0
 8005800:	f040 8383 	bne.w	8005f0a <gc_execute_block+0x8ba>
 8005804:	9d15      	ldr	r5, [sp, #84]	; 0x54
        axis_command = AxisCommand_MotionMode; // Assign implicit motion-mode
 8005806:	2302      	movs	r3, #2
 8005808:	46aa      	mov	sl, r5
 800580a:	9306      	str	r3, [sp, #24]
 800580c:	f005 0380 	and.w	r3, r5, #128	; 0x80
        FAIL(Status_GcodeToolChangePending); // [Motions (except jogging) not allowed when changing tool]

    // Check for valid line number N value.
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (bit_istrue(value_words, bit(Word_N)) && gc_block.values.n > MAX_LINE_NUMBER)
 8005810:	b12b      	cbz	r3, 800581e <gc_execute_block+0x1ce>
 8005812:	4b65      	ldr	r3, [pc, #404]	; (80059a8 <gc_execute_block+0x358>)
 8005814:	f8d9 2078 	ldr.w	r2, [r9, #120]	; 0x78
 8005818:	429a      	cmp	r2, r3
 800581a:	f300 8416 	bgt.w	800604a <gc_execute_block+0x9fa>
    // [1. Comments ]: MSG's may be supported by driver layer. Comment handling performed by protocol.

    // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
    //   is not defined after switching between G93, G94 and G95.
    // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
    if (gc_parser_flags.jog_motion) {
 800581e:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8005822:	07db      	lsls	r3, r3, #31
 8005824:	f100 837d 	bmi.w	8005f22 <gc_execute_block+0x8d2>
            FAIL(Status_GcodeUndefinedFeedRate);

        if (gc_block.modal.units_imperial)
            gc_block.values.f *= MM_PER_INCH;

    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 8005828:	f899 3008 	ldrb.w	r3, [r9, #8]
 800582c:	2b21      	cmp	r3, #33	; 0x21
 800582e:	f000 8787 	beq.w	8006740 <gc_execute_block+0x10f0>
        } else {
            bit_false(value_words, bit(Word_K));
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
        }

    } else if (gc_block.modal.feed_mode == FeedMode_InverseTime) { // = G93
 8005832:	f899 2009 	ldrb.w	r2, [r9, #9]
 8005836:	2a01      	cmp	r2, #1
 8005838:	f001 8038 	beq.w	80068ac <gc_execute_block+0x125c>
        // NOTE: If in G93 mode or switched into it from G94, just keep F value as initialized zero or passed F word
        // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
        // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
        // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.

    } else if (gc_block.modal.feed_mode == FeedMode_UnitsPerMin || gc_block.modal.feed_mode == FeedMode_UnitsPerRev) {
 800583c:	f012 0ffd 	tst.w	r2, #253	; 0xfd
 8005840:	d10b      	bne.n	800585a <gc_execute_block+0x20a>
          // if F word passed, ensure value is in mm/min or mm/rev depending on mode, otherwise push last state value.
        if (bit_isfalse(value_words, bit(Word_F))) {
 8005842:	f01a 0f02 	tst.w	sl, #2
 8005846:	f040 836f 	bne.w	8005f28 <gc_execute_block+0x8d8>
            if(gc_block.modal.feed_mode == gc_state.modal.feed_mode)
 800584a:	4b56      	ldr	r3, [pc, #344]	; (80059a4 <gc_execute_block+0x354>)
 800584c:	785b      	ldrb	r3, [r3, #1]
 800584e:	4293      	cmp	r3, r2
 8005850:	d103      	bne.n	800585a <gc_execute_block+0x20a>
                gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
 8005852:	4b54      	ldr	r3, [pc, #336]	; (80059a4 <gc_execute_block+0x354>)
 8005854:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005856:	f8c9 3038 	str.w	r3, [r9, #56]	; 0x38
    } // else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.

    // bit_false(value_words,bit(Word_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

    // [4. Set spindle speed ]: S or D is negative (done.)
    if (bit_istrue(command_words, bit(ModalGroup_G14))) {
 800585a:	f418 5f00 	tst.w	r8, #8192	; 0x2000
 800585e:	f040 85d5 	bne.w	800640c <gc_execute_block+0xdbc>
 8005862:	4b50      	ldr	r3, [pc, #320]	; (80059a4 <gc_execute_block+0x354>)
 8005864:	f40a 6780 	and.w	r7, sl, #1024	; 0x400
 8005868:	7f1d      	ldrb	r5, [r3, #28]
        } else if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS)
            gc_state.spindle.rpm = sys.spindle_rpm; // Is it correct to restore latest spindle RPM here?
        gc_state.modal.spindle_rpm_mode = gc_block.modal.spindle_rpm_mode;
    }

    if (bit_isfalse(value_words, bit(Word_S)))
 800586a:	2f00      	cmp	r7, #0
 800586c:	f040 85e9 	bne.w	8006442 <gc_execute_block+0xdf2>
        gc_block.values.s = gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_RPM ? gc_state.spindle.rpm : gc_state.spindle.css.surface_speed;
 8005870:	4b4c      	ldr	r3, [pc, #304]	; (80059a4 <gc_execute_block+0x354>)
 8005872:	2d00      	cmp	r5, #0
 8005874:	f040 8672 	bne.w	800655c <gc_execute_block+0xf0c>
 8005878:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800587a:	f8c9 3058 	str.w	r3, [r9, #88]	; 0x58
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min

    // bit_false(value_words,bit(Word_S)); // NOTE: Single-meaning value word. Set at end of error-checking.

    // [5. Select tool ]: If not supported then only tracks value. T is negative (done.) Not an integer (done).
    if(set_tool) { // M61
 800587e:	9b05      	ldr	r3, [sp, #20]
 8005880:	2b00      	cmp	r3, #0
 8005882:	f000 85d3 	beq.w	800642c <gc_execute_block+0xddc>
        if(bit_isfalse(value_words, bit(Word_Q)))
 8005886:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
 800588a:	f000 866d 	beq.w	8006568 <gc_execute_block+0xf18>
            FAIL(Status_GcodeValueWordMissing);
        if (floorf(gc_block.values.q) - gc_block.values.q != 0.0f)
 800588e:	f8d9 4050 	ldr.w	r4, [r9, #80]	; 0x50
 8005892:	4620      	mov	r0, r4
 8005894:	f00d fa26 	bl	8012ce4 <floorf>
 8005898:	4621      	mov	r1, r4
 800589a:	f7fa fe71 	bl	8000580 <__aeabi_fsub>
 800589e:	2100      	movs	r1, #0
 80058a0:	f7fb f90c 	bl	8000abc <__aeabi_fcmpeq>
 80058a4:	2800      	cmp	r0, #0
 80058a6:	f000 8369 	beq.w	8005f7c <gc_execute_block+0x92c>
            FAIL(Status_GcodeCommandValueNotInteger);
        if ((int32_t)gc_block.values.q < 1 || (int32_t)gc_block.values.q > MAX_TOOL_NUMBER)
 80058aa:	4620      	mov	r0, r4
 80058ac:	f7fb f94e 	bl	8000b4c <__aeabi_f2iz>
 80058b0:	1e43      	subs	r3, r0, #1
 80058b2:	2bfe      	cmp	r3, #254	; 0xfe
 80058b4:	f201 802c 	bhi.w	8006910 <gc_execute_block+0x12c0>
            FAIL(Status_GcodeIllegalToolTableEntry);

        gc_block.values.t = (uint8_t)gc_block.values.q;
 80058b8:	4620      	mov	r0, r4
 80058ba:	f7fb f96d 	bl	8000b98 <__aeabi_f2uiz>

        bit_false(value_words, bit(Word_Q));
 80058be:	f42a 4a00 	bic.w	sl, sl, #32768	; 0x8000
        gc_block.values.t = (uint8_t)gc_block.values.q;
 80058c2:	f889 007d 	strb.w	r0, [r9, #125]	; 0x7d
        bit_false(value_words, bit(Word_Q));
 80058c6:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
    } else if (bit_isfalse(value_words, bit(Word_T)))
        gc_block.values.t = gc_state.tool_pending;

    if(bit_istrue(command_words, bit(ModalGroup_M10)) && port_command) {
 80058ca:	f418 1480 	ands.w	r4, r8, #1048576	; 0x100000
 80058ce:	f000 85e7 	beq.w	80064a0 <gc_execute_block+0xe50>
 80058d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80058d4:	2b00      	cmp	r3, #0
 80058d6:	f000 863c 	beq.w	8006552 <gc_execute_block+0xf02>

        switch(port_command) {
 80058da:	2b42      	cmp	r3, #66	; 0x42
 80058dc:	f001 83ad 	beq.w	800703a <gc_execute_block+0x19ea>
 80058e0:	f200 8611 	bhi.w	8006506 <gc_execute_block+0xeb6>
 80058e4:	3b3e      	subs	r3, #62	; 0x3e
 80058e6:	2b03      	cmp	r3, #3
 80058e8:	f200 8633 	bhi.w	8006552 <gc_execute_block+0xf02>

            case 62:
            case 63:
            case 64:
            case 65:
                if(bit_isfalse(value_words, bit(Word_P)))
 80058ec:	f41a 7f80 	tst.w	sl, #256	; 0x100
 80058f0:	f000 863a 	beq.w	8006568 <gc_execute_block+0xf18>
                    FAIL(Status_GcodeValueWordMissing);
                if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital)
 80058f4:	f8d9 504c 	ldr.w	r5, [r9, #76]	; 0x4c
 80058f8:	4f29      	ldr	r7, [pc, #164]	; (80059a0 <gc_execute_block+0x350>)
 80058fa:	4628      	mov	r0, r5
 80058fc:	f7fb f94c 	bl	8000b98 <__aeabi_f2uiz>
 8005900:	f897 2114 	ldrb.w	r2, [r7, #276]	; 0x114
 8005904:	1c43      	adds	r3, r0, #1
 8005906:	4293      	cmp	r3, r2
 8005908:	f201 85d8 	bhi.w	80074bc <gc_execute_block+0x1e6c>
                    FAIL(Status_GcodeValueOutOfRange);
                gc_block.output_command.is_digital = true;
 800590c:	2701      	movs	r7, #1
                gc_block.output_command.port = (uint8_t)gc_block.values.p;
 800590e:	4628      	mov	r0, r5
                gc_block.output_command.is_digital = true;
 8005910:	f889 7080 	strb.w	r7, [r9, #128]	; 0x80
                gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8005914:	f7fb f940 	bl	8000b98 <__aeabi_f2uiz>
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 8005918:	9b09      	ldr	r3, [sp, #36]	; 0x24
                gc_block.output_command.port = (uint8_t)gc_block.values.p;
 800591a:	f889 0081 	strb.w	r0, [r9, #129]	; 0x81
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 800591e:	2b3e      	cmp	r3, #62	; 0x3e
 8005920:	d004      	beq.n	800592c <gc_execute_block+0x2dc>
 8005922:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
 8005926:	fab7 f787 	clz	r7, r7
 800592a:	097f      	lsrs	r7, r7, #5
                bit_false(value_words, bit(Word_P));
 800592c:	f42a 7380 	bic.w	r3, sl, #256	; 0x100
 8005930:	9315      	str	r3, [sp, #84]	; 0x54
                gc_block.output_command.value = port_command == 62 || port_command == 64 ? 1.0f : 0.0f;
 8005932:	f8c9 7084 	str.w	r7, [r9, #132]	; 0x84
    // [6. Change tool ]: N/A
    // [7. Spindle control ]: N/A
    // [8. Coolant control ]: N/A

    // [9. Override control ]:
    if (bit_istrue(command_words, bit(ModalGroup_M9))) {
 8005936:	f418 2f00 	tst.w	r8, #524288	; 0x80000
 800593a:	f000 83ab 	beq.w	8006094 <gc_execute_block+0xa44>

        if(bit_isfalse(value_words, bit(Word_P)))
            gc_block.values.p = 1.0f;
 800593e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8005942:	f8c9 304c 	str.w	r3, [r9, #76]	; 0x4c
        else
            bit_false(value_words, bit(Word_P));

        switch(gc_block.override_command) {
 8005946:	f899 3001 	ldrb.w	r3, [r9, #1]
 800594a:	3b31      	subs	r3, #49	; 0x31
 800594c:	2b07      	cmp	r3, #7
 800594e:	f200 83a0 	bhi.w	8006092 <gc_execute_block+0xa42>
 8005952:	e8df f013 	tbh	[pc, r3, lsl #1]
 8005956:	052c      	.short	0x052c
 8005958:	054c051d 	.word	0x054c051d
 800595c:	053d039e 	.word	0x053d039e
 8005960:	039e039e 	.word	0x039e039e
 8005964:	038b      	.short	0x038b
                switch(letter) {
 8005966:	3d44      	subs	r5, #68	; 0x44
 8005968:	2d16      	cmp	r5, #22
 800596a:	f200 80b4 	bhi.w	8005ad6 <gc_execute_block+0x486>
 800596e:	e8df f015 	tbh	[pc, r5, lsl #1]
 8005972:	0174      	.short	0x0174
 8005974:	013601d1 	.word	0x013601d1
 8005978:	014900b2 	.word	0x014900b2
 800597c:	0183017a 	.word	0x0183017a
 8005980:	01640151 	.word	0x01640151
 8005984:	016c00b2 	.word	0x016c00b2
 8005988:	018c00b2 	.word	0x018c00b2
 800598c:	01980192 	.word	0x01980192
 8005990:	01a4019e 	.word	0x01a4019e
 8005994:	00b200b2 	.word	0x00b200b2
 8005998:	01b000b2 	.word	0x01b000b2
 800599c:	01c601bb 	.word	0x01c601bb
 80059a0:	200024bc 	.word	0x200024bc
 80059a4:	200023dc 	.word	0x200023dc
 80059a8:	00989680 	.word	0x00989680
                switch(int_value) {
 80059ac:	2c63      	cmp	r4, #99	; 0x63
 80059ae:	f200 8092 	bhi.w	8005ad6 <gc_execute_block+0x486>
 80059b2:	e8df f014 	tbh	[pc, r4, lsl #1]
 80059b6:	0290      	.short	0x0290
 80059b8:	02900290 	.word	0x02900290
 80059bc:	01cf0290 	.word	0x01cf0290
 80059c0:	00900290 	.word	0x00900290
 80059c4:	01da01da 	.word	0x01da01da
 80059c8:	01ef0090 	.word	0x01ef0090
 80059cc:	00900090 	.word	0x00900090
 80059d0:	00900090 	.word	0x00900090
 80059d4:	00900090 	.word	0x00900090
 80059d8:	020d020d 	.word	0x020d020d
 80059dc:	01b4020d 	.word	0x01b4020d
 80059e0:	009001b4 	.word	0x009001b4
 80059e4:	00900090 	.word	0x00900090
 80059e8:	00900090 	.word	0x00900090
 80059ec:	01ef0090 	.word	0x01ef0090
 80059f0:	01ef0090 	.word	0x01ef0090
 80059f4:	00900090 	.word	0x00900090
 80059f8:	009001bd 	.word	0x009001bd
 80059fc:	00900090 	.word	0x00900090
 8005a00:	00870090 	.word	0x00870090
 8005a04:	00790090 	.word	0x00790090
 8005a08:	00900090 	.word	0x00900090
 8005a0c:	00900212 	.word	0x00900212
 8005a10:	00900090 	.word	0x00900090
 8005a14:	00900090 	.word	0x00900090
 8005a18:	02250212 	.word	0x02250212
 8005a1c:	00900225 	.word	0x00900225
 8005a20:	023001cf 	.word	0x023001cf
 8005a24:	02300230 	.word	0x02300230
 8005a28:	02300230 	.word	0x02300230
 8005a2c:	00900230 	.word	0x00900230
 8005a30:	0090023a 	.word	0x0090023a
 8005a34:	00900090 	.word	0x00900090
 8005a38:	00900090 	.word	0x00900090
 8005a3c:	00900090 	.word	0x00900090
 8005a40:	00900090 	.word	0x00900090
 8005a44:	00900090 	.word	0x00900090
 8005a48:	00900241 	.word	0x00900241
 8005a4c:	01bd0090 	.word	0x01bd0090
 8005a50:	00900090 	.word	0x00900090
 8005a54:	00640090 	.word	0x00640090
 8005a58:	02410241 	.word	0x02410241
 8005a5c:	00900241 	.word	0x00900241
 8005a60:	02410241 	.word	0x02410241
 8005a64:	00900090 	.word	0x00900090
 8005a68:	02590241 	.word	0x02590241
 8005a6c:	01ef0259 	.word	0x01ef0259
 8005a70:	02660266 	.word	0x02660266
 8005a74:	0277026c 	.word	0x0277026c
 8005a78:	028b0277 	.word	0x028b0277
 8005a7c:	028b      	.short	0x028b
        switch(letter) {
 8005a7e:	2450      	movs	r4, #80	; 0x50
                        gc_block.modal.canned_cycle_active = false;
 8005a80:	2300      	movs	r3, #0
 8005a82:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
                        break;
 8005a86:	2301      	movs	r3, #1
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8005a88:	f889 4008 	strb.w	r4, [r9, #8]
                if (mantissa > 0)
 8005a8c:	2800      	cmp	r0, #0
 8005a8e:	f040 8275 	bne.w	8005f7c <gc_execute_block+0x92c>
 8005a92:	fa28 f203 	lsr.w	r2, r8, r3
                if (bit_istrue(command_words, bit(word_bit.group)))
 8005a96:	07d1      	lsls	r1, r2, #31
 8005a98:	f100 8273 	bmi.w	8005f82 <gc_execute_block+0x932>
                command_words |= bit(word_bit.group);
 8005a9c:	2201      	movs	r2, #1
 8005a9e:	fa02 f303 	lsl.w	r3, r2, r3
 8005aa2:	ea48 0803 	orr.w	r8, r8, r3
                break;
 8005aa6:	e698      	b.n	80057da <gc_execute_block+0x18a>
        switch(letter) {
 8005aa8:	2307      	movs	r3, #7
 8005aaa:	e7ef      	b.n	8005a8c <gc_execute_block+0x43c>
                        if(!settings.parking.flags.enable_override_control) // TODO: check if enabled?
 8005aac:	4bb6      	ldr	r3, [pc, #728]	; (8005d88 <gc_execute_block+0x738>)
 8005aae:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
 8005ab2:	075d      	lsls	r5, r3, #29
 8005ab4:	d50f      	bpl.n	8005ad6 <gc_execute_block+0x486>
                        break;
 8005ab6:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 8005aba:	2213      	movs	r2, #19
 8005abc:	9e05      	ldr	r6, [sp, #20]
                        gc_block.override_command = (override_mode_t)int_value;
 8005abe:	f889 4001 	strb.w	r4, [r9, #1]
                        break;
 8005ac2:	e682      	b.n	80057ca <gc_execute_block+0x17a>
                        if(!(hal.probe_get_state && ((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))))
 8005ac4:	4bb1      	ldr	r3, [pc, #708]	; (8005d8c <gc_execute_block+0x73c>)
 8005ac6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005aca:	b123      	cbz	r3, 8005ad6 <gc_execute_block+0x486>
 8005acc:	f1a0 0314 	sub.w	r3, r0, #20
 8005ad0:	2b1e      	cmp	r3, #30
 8005ad2:	f240 829b 	bls.w	800600c <gc_execute_block+0x9bc>

            switch(gc_block.values.l) {

                case 2:
                    if (bit_istrue(value_words, bit(Word_R)))
                        FAIL(Status_GcodeUnsupportedCommand); // [G10 L2 R not supported]
 8005ad6:	2314      	movs	r3, #20
 8005ad8:	9304      	str	r3, [sp, #16]
    }

    // TODO: % to denote start of program.

    return Status_OK;
}
 8005ada:	9804      	ldr	r0, [sp, #16]
 8005adc:	b029      	add	sp, #164	; 0xa4
 8005ade:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        gc_parser_flags.jog_motion = On;
 8005ae2:	2301      	movs	r3, #1
        gc_block.modal.spindle_rpm_mode = SpindleSpeedMode_RPM;
 8005ae4:	f889 6024 	strb.w	r6, [r9, #36]	; 0x24
        gc_block.modal.motion = MotionMode_Linear;
 8005ae8:	f8a9 3008 	strh.w	r3, [r9, #8]
        gc_parser_flags.jog_motion = On;
 8005aec:	f8ad 301c 	strh.w	r3, [sp, #28]
    uint_fast8_t char_counter = gc_parser_flags.jog_motion ? 3 /* Start parsing after `$J=` */ : 0;
 8005af0:	1cfa      	adds	r2, r7, #3
 8005af2:	2304      	movs	r3, #4
 8005af4:	e5d5      	b.n	80056a2 <gc_execute_block+0x52>
                        gc_parser_flags.set_coolant = On;
 8005af6:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                        sys.flags.delay_overrides = On;
 8005afa:	4aa5      	ldr	r2, [pc, #660]	; (8005d90 <gc_execute_block+0x740>)
                        gc_parser_flags.set_coolant = On;
 8005afc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005b00:	f8ad 301c 	strh.w	r3, [sp, #28]
                        sys.flags.delay_overrides = On;
 8005b04:	7a53      	ldrb	r3, [r2, #9]
 8005b06:	2c08      	cmp	r4, #8
 8005b08:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005b0c:	7253      	strb	r3, [r2, #9]
                        switch(int_value) {
 8005b0e:	f000 84bb 	beq.w	8006488 <gc_execute_block+0xe38>
 8005b12:	2c09      	cmp	r4, #9
 8005b14:	f040 84a6 	bne.w	8006464 <gc_execute_block+0xe14>
                                gc_block.modal.coolant.value = 0;
 8005b18:	2200      	movs	r2, #0
                                break;
 8005b1a:	f44f 2180 	mov.w	r1, #262144	; 0x40000
                                gc_block.modal.coolant.value = 0;
 8005b1e:	f889 2021 	strb.w	r2, [r9, #33]	; 0x21
                                break;
 8005b22:	9e05      	ldr	r6, [sp, #20]
 8005b24:	2212      	movs	r2, #18
 8005b26:	e650      	b.n	80057ca <gc_execute_block+0x17a>
                        if(hal.user_mcode_check && (gc_block.user_mcode = hal.user_mcode_check((user_mcode_t)int_value)))
 8005b28:	4b98      	ldr	r3, [pc, #608]	; (8005d8c <gc_execute_block+0x73c>)
 8005b2a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8005b2e:	2b00      	cmp	r3, #0
 8005b30:	d0d1      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005b32:	b2a0      	uxth	r0, r4
 8005b34:	4798      	blx	r3
 8005b36:	f8a9 0002 	strh.w	r0, [r9, #2]
 8005b3a:	2800      	cmp	r0, #0
 8005b3c:	d0cb      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005b3e:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8005b42:	2214      	movs	r2, #20
 8005b44:	9e05      	ldr	r6, [sp, #20]
 8005b46:	e640      	b.n	80057ca <gc_execute_block+0x17a>
                        switch(int_value) {
 8005b48:	2c00      	cmp	r4, #0
 8005b4a:	f000 8233 	beq.w	8005fb4 <gc_execute_block+0x964>
 8005b4e:	2c01      	cmp	r4, #1
 8005b50:	f000 821a 	beq.w	8005f88 <gc_execute_block+0x938>
                                gc_block.modal.program_flow = (program_flow_t)int_value;
 8005b54:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8005b58:	220f      	movs	r2, #15
 8005b5a:	9e05      	ldr	r6, [sp, #20]
 8005b5c:	f889 4020 	strb.w	r4, [r9, #32]
 8005b60:	e633      	b.n	80057ca <gc_execute_block+0x17a>
                        gc_block.modal.spindle.ccw = int_value == 4;
 8005b62:	f1a4 0304 	sub.w	r3, r4, #4
                        gc_block.modal.spindle.on = !(int_value == 5);
 8005b66:	1f61      	subs	r1, r4, #5
                        gc_block.modal.spindle.ccw = int_value == 4;
 8005b68:	fab3 f383 	clz	r3, r3
                        gc_block.modal.spindle.on = !(int_value == 5);
 8005b6c:	bf18      	it	ne
 8005b6e:	2101      	movne	r1, #1
                        sys.flags.delay_overrides = On;
 8005b70:	4a87      	ldr	r2, [pc, #540]	; (8005d90 <gc_execute_block+0x740>)
                        gc_block.modal.spindle.ccw = int_value == 4;
 8005b72:	095b      	lsrs	r3, r3, #5
                        gc_block.modal.spindle.on = !(int_value == 5);
 8005b74:	ea41 0143 	orr.w	r1, r1, r3, lsl #1
 8005b78:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
                        sys.flags.delay_overrides = On;
 8005b7c:	7a50      	ldrb	r0, [r2, #9]
                        gc_block.modal.spindle.on = !(int_value == 5);
 8005b7e:	f023 0303 	bic.w	r3, r3, #3
 8005b82:	4319      	orrs	r1, r3
                        sys.flags.delay_overrides = On;
 8005b84:	f040 0040 	orr.w	r0, r0, #64	; 0x40
                        gc_block.modal.spindle.on = !(int_value == 5);
 8005b88:	f889 1022 	strb.w	r1, [r9, #34]	; 0x22
                        sys.flags.delay_overrides = On;
 8005b8c:	7250      	strb	r0, [r2, #9]
                        break;
 8005b8e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8005b92:	2211      	movs	r2, #17
 8005b94:	9e05      	ldr	r6, [sp, #20]
 8005b96:	e618      	b.n	80057ca <gc_execute_block+0x17a>
                        if(hal.port.wait_on_input == NULL || (hal.port.num_digital == 0 && hal.port.num_analog == 0))
 8005b98:	4b7c      	ldr	r3, [pc, #496]	; (8005d8c <gc_execute_block+0x73c>)
 8005b9a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 8005b9e:	2a00      	cmp	r2, #0
 8005ba0:	d099      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005ba2:	f8b3 3114 	ldrh.w	r3, [r3, #276]	; 0x114
 8005ba6:	2b00      	cmp	r3, #0
 8005ba8:	d095      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005baa:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 8005bae:	2214      	movs	r2, #20
 8005bb0:	9e05      	ldr	r6, [sp, #20]
 8005bb2:	9409      	str	r4, [sp, #36]	; 0x24
 8005bb4:	e609      	b.n	80057ca <gc_execute_block+0x17a>
                        if(hal.port.analog_out == NULL || hal.port.num_analog == 0)
 8005bb6:	4b75      	ldr	r3, [pc, #468]	; (8005d8c <gc_execute_block+0x73c>)
 8005bb8:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
 8005bbc:	2a00      	cmp	r2, #0
 8005bbe:	d08a      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005bc0:	f893 3115 	ldrb.w	r3, [r3, #277]	; 0x115
 8005bc4:	2b00      	cmp	r3, #0
 8005bc6:	d1f0      	bne.n	8005baa <gc_execute_block+0x55a>
 8005bc8:	e785      	b.n	8005ad6 <gc_execute_block+0x486>
                        if(hal.port.digital_out == NULL || hal.port.num_digital == 0)
 8005bca:	4b70      	ldr	r3, [pc, #448]	; (8005d8c <gc_execute_block+0x73c>)
 8005bcc:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
 8005bd0:	2a00      	cmp	r2, #0
 8005bd2:	d080      	beq.n	8005ad6 <gc_execute_block+0x486>
 8005bd4:	f893 3114 	ldrb.w	r3, [r3, #276]	; 0x114
 8005bd8:	2b00      	cmp	r3, #0
 8005bda:	d1e6      	bne.n	8005baa <gc_execute_block+0x55a>
 8005bdc:	e77b      	b.n	8005ad6 <gc_execute_block+0x486>
                        break;
 8005bde:	2502      	movs	r5, #2
 8005be0:	2301      	movs	r3, #1
                        gc_block.values.f = value;
 8005be2:	f8c9 b038 	str.w	fp, [r9, #56]	; 0x38
                if (bit_istrue(value_words, bit(word_bit.parameter)))
 8005be6:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8005be8:	fa24 f303 	lsr.w	r3, r4, r3
 8005bec:	07de      	lsls	r6, r3, #31
 8005bee:	d41e      	bmi.n	8005c2e <gc_execute_block+0x5de>
                if ((bit(word_bit.parameter) & (bit(Word_D)|bit(Word_F)|bit(Word_H)|bit(Word_N)|bit(Word_P)|bit(Word_T)|bit(Word_S))) && value < 0.0f)
 8005bf0:	4658      	mov	r0, fp
 8005bf2:	2100      	movs	r1, #0
 8005bf4:	f7fa ff6c 	bl	8000ad0 <__aeabi_fcmplt>
 8005bf8:	2800      	cmp	r0, #0
 8005bfa:	f040 852e 	bne.w	800665a <gc_execute_block+0x100a>
                value_words |= bit(word_bit.parameter); // Flag to indicate parameter assigned.
 8005bfe:	432c      	orrs	r4, r5
 8005c00:	9415      	str	r4, [sp, #84]	; 0x54
 8005c02:	e5ea      	b.n	80057da <gc_execute_block+0x18a>
                        if (mantissa > 0)
 8005c04:	2800      	cmp	r0, #0
 8005c06:	f040 81b9 	bne.w	8005f7c <gc_execute_block+0x92c>
                        break;
 8005c0a:	2504      	movs	r5, #4
 8005c0c:	2302      	movs	r3, #2
                        gc_block.values.h = int_value;
 8005c0e:	f889 407c 	strb.w	r4, [r9, #124]	; 0x7c
                        break;
 8005c12:	e7e8      	b.n	8005be6 <gc_execute_block+0x596>
                        bit_true(ijk_words, bit(K_VALUE));
 8005c14:	9b08      	ldr	r3, [sp, #32]
                        break;
 8005c16:	2520      	movs	r5, #32
                        bit_true(ijk_words, bit(K_VALUE));
 8005c18:	f043 0304 	orr.w	r3, r3, #4
 8005c1c:	9308      	str	r3, [sp, #32]
                        break;
 8005c1e:	2305      	movs	r3, #5
                        gc_block.values.ijk[K_VALUE] = value;
 8005c20:	f8c9 b044 	str.w	fp, [r9, #68]	; 0x44
                if (bit_istrue(value_words, bit(word_bit.parameter)))
 8005c24:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8005c26:	fa24 f303 	lsr.w	r3, r4, r3
 8005c2a:	07d8      	lsls	r0, r3, #31
 8005c2c:	d5e7      	bpl.n	8005bfe <gc_execute_block+0x5ae>
                    FAIL(Status_GcodeWordRepeated); // [Word repeated]
 8005c2e:	2319      	movs	r3, #25
 8005c30:	9304      	str	r3, [sp, #16]
}
 8005c32:	9804      	ldr	r0, [sp, #16]
 8005c34:	b029      	add	sp, #164	; 0xa4
 8005c36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (mantissa > 0)
 8005c3a:	2800      	cmp	r0, #0
 8005c3c:	f040 819e 	bne.w	8005f7c <gc_execute_block+0x92c>
                        break;
 8005c40:	2540      	movs	r5, #64	; 0x40
 8005c42:	2306      	movs	r3, #6
                        gc_block.values.l = int_value;
 8005c44:	f889 407e 	strb.w	r4, [r9, #126]	; 0x7e
                        break;
 8005c48:	e7ec      	b.n	8005c24 <gc_execute_block+0x5d4>
                        gc_block.values.n = (int32_t)truncf(value);
 8005c4a:	4658      	mov	r0, fp
 8005c4c:	f7fa ff7e 	bl	8000b4c <__aeabi_f2iz>
                        break;
 8005c50:	2580      	movs	r5, #128	; 0x80
 8005c52:	2307      	movs	r3, #7
                        gc_block.values.n = (int32_t)truncf(value);
 8005c54:	f8c9 0078 	str.w	r0, [r9, #120]	; 0x78
                        break;
 8005c58:	e7c5      	b.n	8005be6 <gc_execute_block+0x596>
                        break;
 8005c5a:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 8005c5e:	2310      	movs	r3, #16
                        gc_block.values.d = value;
 8005c60:	f8c9 b030 	str.w	fp, [r9, #48]	; 0x30
                        break;
 8005c64:	e7bf      	b.n	8005be6 <gc_execute_block+0x596>
                        bit_true(ijk_words, bit(I_VALUE));
 8005c66:	9b08      	ldr	r3, [sp, #32]
                        break;
 8005c68:	2508      	movs	r5, #8
                        bit_true(ijk_words, bit(I_VALUE));
 8005c6a:	f043 0301 	orr.w	r3, r3, #1
 8005c6e:	9308      	str	r3, [sp, #32]
                        gc_block.values.ijk[I_VALUE] = value;
 8005c70:	f8c9 b03c 	str.w	fp, [r9, #60]	; 0x3c
                        break;
 8005c74:	2303      	movs	r3, #3
 8005c76:	e7d5      	b.n	8005c24 <gc_execute_block+0x5d4>
                        bit_true(ijk_words, bit(J_VALUE));
 8005c78:	9b08      	ldr	r3, [sp, #32]
                        break;
 8005c7a:	2510      	movs	r5, #16
                        bit_true(ijk_words, bit(J_VALUE));
 8005c7c:	f043 0302 	orr.w	r3, r3, #2
 8005c80:	9308      	str	r3, [sp, #32]
                        gc_block.values.ijk[J_VALUE] = value;
 8005c82:	f8c9 b040 	str.w	fp, [r9, #64]	; 0x40
                        break;
 8005c86:	2304      	movs	r3, #4
 8005c88:	e7cc      	b.n	8005c24 <gc_execute_block+0x5d4>
                        break;
 8005c8a:	f44f 7580 	mov.w	r5, #256	; 0x100
 8005c8e:	2308      	movs	r3, #8
                        gc_block.values.p = value;
 8005c90:	f8c9 b04c 	str.w	fp, [r9, #76]	; 0x4c
                        break;
 8005c94:	e7a7      	b.n	8005be6 <gc_execute_block+0x596>
                        break;
 8005c96:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 8005c9a:	230f      	movs	r3, #15
                        gc_block.values.q = value;
 8005c9c:	f8c9 b050 	str.w	fp, [r9, #80]	; 0x50
                        break;
 8005ca0:	e7c0      	b.n	8005c24 <gc_execute_block+0x5d4>
                        break;
 8005ca2:	f44f 7500 	mov.w	r5, #512	; 0x200
 8005ca6:	2309      	movs	r3, #9
                        gc_block.values.r = value;
 8005ca8:	f8c9 b054 	str.w	fp, [r9, #84]	; 0x54
                        break;
 8005cac:	e7ba      	b.n	8005c24 <gc_execute_block+0x5d4>
                        break;
 8005cae:	f44f 6580 	mov.w	r5, #1024	; 0x400
 8005cb2:	230a      	movs	r3, #10
                        gc_block.values.s = value;
 8005cb4:	f8c9 b058 	str.w	fp, [r9, #88]	; 0x58
                        break;
 8005cb8:	e795      	b.n	8005be6 <gc_execute_block+0x596>
                        if (mantissa > 0)
 8005cba:	2800      	cmp	r0, #0
 8005cbc:	f040 815e 	bne.w	8005f7c <gc_execute_block+0x92c>
                        if (int_value > MAX_TOOL_NUMBER)
 8005cc0:	2cff      	cmp	r4, #255	; 0xff
 8005cc2:	f200 8625 	bhi.w	8006910 <gc_execute_block+0x12c0>
                        break;
 8005cc6:	f44f 6500 	mov.w	r5, #2048	; 0x800
 8005cca:	230b      	movs	r3, #11
                        gc_block.values.t = int_value;
 8005ccc:	f889 407d 	strb.w	r4, [r9, #125]	; 0x7d
                        break;
 8005cd0:	e789      	b.n	8005be6 <gc_execute_block+0x596>
                        bit_true(axis_words, bit(X_AXIS));
 8005cd2:	9b04      	ldr	r3, [sp, #16]
                        break;
 8005cd4:	f44f 5580 	mov.w	r5, #4096	; 0x1000
                        bit_true(axis_words, bit(X_AXIS));
 8005cd8:	f043 0301 	orr.w	r3, r3, #1
 8005cdc:	b2db      	uxtb	r3, r3
 8005cde:	9304      	str	r3, [sp, #16]
                        gc_block.values.xyz[X_AXIS] = value;
 8005ce0:	f8c9 b05c 	str.w	fp, [r9, #92]	; 0x5c
                        break;
 8005ce4:	230c      	movs	r3, #12
 8005ce6:	e79d      	b.n	8005c24 <gc_execute_block+0x5d4>
                        bit_true(axis_words, bit(Y_AXIS));
 8005ce8:	9b04      	ldr	r3, [sp, #16]
                        break;
 8005cea:	f44f 5500 	mov.w	r5, #8192	; 0x2000
                        bit_true(axis_words, bit(Y_AXIS));
 8005cee:	f043 0302 	orr.w	r3, r3, #2
 8005cf2:	b2db      	uxtb	r3, r3
 8005cf4:	9304      	str	r3, [sp, #16]
                        gc_block.values.xyz[Y_AXIS] = value;
 8005cf6:	f8c9 b060 	str.w	fp, [r9, #96]	; 0x60
                        break;
 8005cfa:	230d      	movs	r3, #13
 8005cfc:	e792      	b.n	8005c24 <gc_execute_block+0x5d4>
                        bit_true(axis_words, bit(Z_AXIS));
 8005cfe:	9b04      	ldr	r3, [sp, #16]
                        break;
 8005d00:	f44f 4580 	mov.w	r5, #16384	; 0x4000
                        bit_true(axis_words, bit(Z_AXIS));
 8005d04:	f043 0304 	orr.w	r3, r3, #4
 8005d08:	b2db      	uxtb	r3, r3
 8005d0a:	9304      	str	r3, [sp, #16]
                        gc_block.values.xyz[Z_AXIS] = value;
 8005d0c:	f8c9 b064 	str.w	fp, [r9, #100]	; 0x64
                        break;
 8005d10:	230e      	movs	r3, #14
 8005d12:	e787      	b.n	8005c24 <gc_execute_block+0x5d4>
                        break;
 8005d14:	2501      	movs	r5, #1
 8005d16:	2300      	movs	r3, #0
                        gc_block.values.e = value;
 8005d18:	f8c9 b034 	str.w	fp, [r9, #52]	; 0x34
                        break;
 8005d1c:	e782      	b.n	8005c24 <gc_execute_block+0x5d4>
                        gc_block.modal.units_imperial = int_value == 20;
 8005d1e:	f1a4 0414 	sub.w	r4, r4, #20
 8005d22:	fab4 f484 	clz	r4, r4
 8005d26:	0964      	lsrs	r4, r4, #5
                        break;
 8005d28:	2306      	movs	r3, #6
                        gc_block.modal.units_imperial = int_value == 20;
 8005d2a:	f889 400a 	strb.w	r4, [r9, #10]
                        break;
 8005d2e:	e6ad      	b.n	8005a8c <gc_execute_block+0x43c>
                        if(!hal.spindle_get_data)
 8005d30:	4b16      	ldr	r3, [pc, #88]	; (8005d8c <gc_execute_block+0x73c>)
 8005d32:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8005d36:	2b00      	cmp	r3, #0
 8005d38:	f43f aecd 	beq.w	8005ad6 <gc_execute_block+0x486>
                        if (axis_command)
 8005d3c:	9b06      	ldr	r3, [sp, #24]
 8005d3e:	2b00      	cmp	r3, #0
 8005d40:	f040 85cd 	bne.w	80068de <gc_execute_block+0x128e>
                        axis_command = AxisCommand_MotionMode;
 8005d44:	2202      	movs	r2, #2
                        gc_block.modal.canned_cycle_active = false;
 8005d46:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8005d4a:	f889 4008 	strb.w	r4, [r9, #8]
                        break;
 8005d4e:	2301      	movs	r3, #1
                        axis_command = AxisCommand_MotionMode;
 8005d50:	9206      	str	r2, [sp, #24]
                        break;
 8005d52:	e69b      	b.n	8005a8c <gc_execute_block+0x43c>
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005d54:	b2e3      	uxtb	r3, r4
                        if ((int_value == 28) || (int_value == 30)) {
 8005d56:	2c1c      	cmp	r4, #28
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005d58:	f889 3000 	strb.w	r3, [r9]
                        if ((int_value == 28) || (int_value == 30)) {
 8005d5c:	f000 80f6 	beq.w	8005f4c <gc_execute_block+0x8fc>
 8005d60:	2c1e      	cmp	r4, #30
 8005d62:	f000 80f4 	beq.w	8005f4e <gc_execute_block+0x8fe>
 8005d66:	2300      	movs	r3, #0
 8005d68:	e690      	b.n	8005a8c <gc_execute_block+0x43c>
                        if(settings.flags.lathe_mode) {
 8005d6a:	4b07      	ldr	r3, [pc, #28]	; (8005d88 <gc_execute_block+0x738>)
 8005d6c:	f993 30bd 	ldrsb.w	r3, [r3, #189]	; 0xbd
 8005d70:	2b00      	cmp	r3, #0
 8005d72:	f6bf aeb0 	bge.w	8005ad6 <gc_execute_block+0x486>
                            gc_block.modal.diameter_mode = int_value == 7; // TODO: find specs for implementation, only affects X calculation? reporting? current position?
 8005d76:	f1a4 0407 	sub.w	r4, r4, #7
 8005d7a:	fab4 f484 	clz	r4, r4
 8005d7e:	0964      	lsrs	r4, r4, #5
                        break;
 8005d80:	230e      	movs	r3, #14
                            gc_block.modal.diameter_mode = int_value == 7; // TODO: find specs for implementation, only affects X calculation? reporting? current position?
 8005d82:	f889 400c 	strb.w	r4, [r9, #12]
                        break;
 8005d86:	e681      	b.n	8005a8c <gc_execute_block+0x43c>
 8005d88:	20002620 	.word	0x20002620
 8005d8c:	200024bc 	.word	0x200024bc
 8005d90:	20002494 	.word	0x20002494
                        if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
 8005d94:	2800      	cmp	r0, #0
 8005d96:	f000 8126 	beq.w	8005fe6 <gc_execute_block+0x996>
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005d9a:	b2e3      	uxtb	r3, r4
                        if ((int_value == 28) || (int_value == 30)) {
 8005d9c:	2c1c      	cmp	r4, #28
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005d9e:	f889 3000 	strb.w	r3, [r9]
                        if ((int_value == 28) || (int_value == 30)) {
 8005da2:	f000 80db 	beq.w	8005f5c <gc_execute_block+0x90c>
 8005da6:	2c1e      	cmp	r4, #30
 8005da8:	f000 80d9 	beq.w	8005f5e <gc_execute_block+0x90e>
                        } else if (int_value == 92) {
 8005dac:	2c5c      	cmp	r4, #92	; 0x5c
 8005dae:	f040 80e5 	bne.w	8005f7c <gc_execute_block+0x92c>
                            if (!((mantissa == 0) || (mantissa == 10) || (mantissa == 20) || (mantissa == 30)))
 8005db2:	281e      	cmp	r0, #30
 8005db4:	f63f ae8f 	bhi.w	8005ad6 <gc_execute_block+0x486>
 8005db8:	4ba5      	ldr	r3, [pc, #660]	; (8006050 <gc_execute_block+0xa00>)
 8005dba:	40c3      	lsrs	r3, r0
 8005dbc:	43db      	mvns	r3, r3
 8005dbe:	f013 0301 	ands.w	r3, r3, #1
 8005dc2:	f47f ae88 	bne.w	8005ad6 <gc_execute_block+0x486>
                            gc_block.non_modal_command += mantissa;
 8005dc6:	305c      	adds	r0, #92	; 0x5c
 8005dc8:	4642      	mov	r2, r8
 8005dca:	f889 0000 	strb.w	r0, [r9]
                if (mantissa > 0)
 8005dce:	e662      	b.n	8005a96 <gc_execute_block+0x446>
                        gc_block.modal.plane_select = (plane_select_t)(int_value - 17);
 8005dd0:	3c11      	subs	r4, #17
                        break;
 8005dd2:	2302      	movs	r3, #2
                        gc_block.modal.plane_select = (plane_select_t)(int_value - 17);
 8005dd4:	f889 400d 	strb.w	r4, [r9, #13]
                        break;
 8005dd8:	e658      	b.n	8005a8c <gc_execute_block+0x43c>
                        if (axis_command)
 8005dda:	9b06      	ldr	r3, [sp, #24]
 8005ddc:	2b00      	cmp	r3, #0
 8005dde:	f040 857e 	bne.w	80068de <gc_execute_block+0x128e>
                        if (int_value == 49) // G49
 8005de2:	2c31      	cmp	r4, #49	; 0x31
 8005de4:	f000 8375 	beq.w	80064d2 <gc_execute_block+0xe82>
                        else if (mantissa == 10) // G43.1
 8005de8:	280a      	cmp	r0, #10
 8005dea:	f47f ae74 	bne.w	8005ad6 <gc_execute_block+0x486>
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_EnableDynamic;
 8005dee:	2302      	movs	r3, #2
                        axis_command = AxisCommand_ToolLengthOffset;
 8005df0:	2103      	movs	r1, #3
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_EnableDynamic;
 8005df2:	f889 300e 	strb.w	r3, [r9, #14]
 8005df6:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8005dfa:	2308      	movs	r3, #8
                        axis_command = AxisCommand_ToolLengthOffset;
 8005dfc:	9106      	str	r1, [sp, #24]
 8005dfe:	e64a      	b.n	8005a96 <gc_execute_block+0x446>
                        gc_block.modal.scaling_active = int_value == 51;
 8005e00:	f1a4 0433 	sub.w	r4, r4, #51	; 0x33
 8005e04:	fab4 f484 	clz	r4, r4
                        axis_command = AxisCommand_Scaling;
 8005e08:	2204      	movs	r2, #4
                        gc_block.modal.scaling_active = int_value == 51;
 8005e0a:	0964      	lsrs	r4, r4, #5
                        break;
 8005e0c:	230a      	movs	r3, #10
                        gc_block.modal.scaling_active = int_value == 51;
 8005e0e:	f889 4026 	strb.w	r4, [r9, #38]	; 0x26
                        axis_command = AxisCommand_Scaling;
 8005e12:	9206      	str	r2, [sp, #24]
                        break;
 8005e14:	e63a      	b.n	8005a8c <gc_execute_block+0x43c>
                        gc_block.modal.coord_system.idx = int_value - 54; // Shift to array indexing.
 8005e16:	f1a4 0336 	sub.w	r3, r4, #54	; 0x36
                        if(int_value == 59) {
 8005e1a:	2c3b      	cmp	r4, #59	; 0x3b
                        gc_block.modal.coord_system.idx = int_value - 54; // Shift to array indexing.
 8005e1c:	b2db      	uxtb	r3, r3
                        if(int_value == 59) {
 8005e1e:	f000 834c 	beq.w	80064ba <gc_execute_block+0xe6a>
                        gc_block.modal.coord_system.idx = int_value - 54; // Shift to array indexing.
 8005e22:	f889 301c 	strb.w	r3, [r9, #28]
 8005e26:	230b      	movs	r3, #11
 8005e28:	e630      	b.n	8005a8c <gc_execute_block+0x43c>
                        if (mantissa != 0) // [G61.1 not supported]
 8005e2a:	2800      	cmp	r0, #0
 8005e2c:	f47f ae53 	bne.w	8005ad6 <gc_execute_block+0x486>
 8005e30:	230c      	movs	r3, #12
 8005e32:	ea4f 3218 	mov.w	r2, r8, lsr #12
 8005e36:	e62e      	b.n	8005a96 <gc_execute_block+0x446>
                        if (axis_command)
 8005e38:	9b06      	ldr	r3, [sp, #24]
 8005e3a:	2b00      	cmp	r3, #0
 8005e3c:	f040 854f 	bne.w	80068de <gc_execute_block+0x128e>
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 8005e40:	4b84      	ldr	r3, [pc, #528]	; (8006054 <gc_execute_block+0xa04>)
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8005e42:	b2e4      	uxtb	r4, r4
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 8005e44:	781a      	ldrb	r2, [r3, #0]
 8005e46:	f8bd 101c 	ldrh.w	r1, [sp, #28]
 8005e4a:	1b12      	subs	r2, r2, r4
 8005e4c:	bf18      	it	ne
 8005e4e:	2201      	movne	r2, #1
                        gc_block.modal.canned_cycle_active = true;
 8005e50:	2301      	movs	r3, #1
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 8005e52:	f362 0141 	bfi	r1, r2, #1, #1
                        axis_command = AxisCommand_MotionMode;
 8005e56:	2202      	movs	r2, #2
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8005e58:	f889 4008 	strb.w	r4, [r9, #8]
                        gc_parser_flags.canned_cycle_change = gc_block.modal.motion != gc_state.modal.motion;
 8005e5c:	f8ad 101c 	strh.w	r1, [sp, #28]
                        gc_block.modal.canned_cycle_active = true;
 8005e60:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
                        axis_command = AxisCommand_MotionMode;
 8005e64:	9206      	str	r2, [sp, #24]
                        break;
 8005e66:	e611      	b.n	8005a8c <gc_execute_block+0x43c>
                        if (mantissa == 0) {
 8005e68:	2800      	cmp	r0, #0
 8005e6a:	f000 80b1 	beq.w	8005fd0 <gc_execute_block+0x980>
                            if ((mantissa != 10) || (int_value == 90))
 8005e6e:	280a      	cmp	r0, #10
 8005e70:	f47f ae31 	bne.w	8005ad6 <gc_execute_block+0x486>
 8005e74:	2c5a      	cmp	r4, #90	; 0x5a
 8005e76:	f43f ae2e 	beq.w	8005ad6 <gc_execute_block+0x486>
 8005e7a:	2304      	movs	r3, #4
 8005e7c:	ea4f 1218 	mov.w	r2, r8, lsr #4
 8005e80:	e609      	b.n	8005a96 <gc_execute_block+0x446>
                        gc_block.modal.feed_mode = (feed_mode_t)(94 - int_value);
 8005e82:	f1c4 045e 	rsb	r4, r4, #94	; 0x5e
                        break;
 8005e86:	2305      	movs	r3, #5
                        gc_block.modal.feed_mode = (feed_mode_t)(94 - int_value);
 8005e88:	f889 4009 	strb.w	r4, [r9, #9]
                        break;
 8005e8c:	e5fe      	b.n	8005a8c <gc_execute_block+0x43c>
                        if(hal.spindle_get_data) {
 8005e8e:	4b72      	ldr	r3, [pc, #456]	; (8006058 <gc_execute_block+0xa08>)
 8005e90:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8005e94:	2b00      	cmp	r3, #0
 8005e96:	f43f ae1e 	beq.w	8005ad6 <gc_execute_block+0x486>
                            gc_block.modal.feed_mode = FeedMode_UnitsPerRev;
 8005e9a:	2302      	movs	r3, #2
 8005e9c:	f889 3009 	strb.w	r3, [r9, #9]
                        break;
 8005ea0:	2305      	movs	r3, #5
 8005ea2:	e5f3      	b.n	8005a8c <gc_execute_block+0x43c>
                        if(settings.flags.lathe_mode && hal.driver_cap.variable_spindle) {
 8005ea4:	4b6d      	ldr	r3, [pc, #436]	; (800605c <gc_execute_block+0xa0c>)
 8005ea6:	f993 30bd 	ldrsb.w	r3, [r3, #189]	; 0xbd
 8005eaa:	2b00      	cmp	r3, #0
 8005eac:	f6bf ae13 	bge.w	8005ad6 <gc_execute_block+0x486>
 8005eb0:	4b69      	ldr	r3, [pc, #420]	; (8006058 <gc_execute_block+0xa08>)
 8005eb2:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 8005eb6:	079d      	lsls	r5, r3, #30
 8005eb8:	f57f ae0d 	bpl.w	8005ad6 <gc_execute_block+0x486>
                            gc_block.modal.spindle_rpm_mode = (spindle_rpm_mode_t)((int_value - 96) ^ 1);
 8005ebc:	f1a4 0360 	sub.w	r3, r4, #96	; 0x60
 8005ec0:	f083 0301 	eor.w	r3, r3, #1
 8005ec4:	f889 3024 	strb.w	r3, [r9, #36]	; 0x24
                        break;
 8005ec8:	230d      	movs	r3, #13
 8005eca:	e5df      	b.n	8005a8c <gc_execute_block+0x43c>
                        gc_block.modal.retract_mode = (cc_retract_mode_t)(int_value - 98);
 8005ecc:	3c62      	subs	r4, #98	; 0x62
                        break;
 8005ece:	2309      	movs	r3, #9
                        gc_block.modal.retract_mode = (cc_retract_mode_t)(int_value - 98);
 8005ed0:	f889 4025 	strb.w	r4, [r9, #37]	; 0x25
                        break;
 8005ed4:	e5da      	b.n	8005a8c <gc_execute_block+0x43c>
                        if (axis_command)
 8005ed6:	9b06      	ldr	r3, [sp, #24]
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	f040 8500 	bne.w	80068de <gc_execute_block+0x128e>
                        axis_command = AxisCommand_MotionMode;
 8005ede:	2302      	movs	r3, #2
 8005ee0:	b2e4      	uxtb	r4, r4
 8005ee2:	9306      	str	r3, [sp, #24]
 8005ee4:	e5cc      	b.n	8005a80 <gc_execute_block+0x430>
        gc_state.file_run = !gc_state.file_run;
 8005ee6:	4a5b      	ldr	r2, [pc, #364]	; (8006054 <gc_execute_block+0xa04>)
}
 8005ee8:	9804      	ldr	r0, [sp, #16]
        gc_state.file_run = !gc_state.file_run;
 8005eea:	f892 307d 	ldrb.w	r3, [r2, #125]	; 0x7d
 8005eee:	f083 0301 	eor.w	r3, r3, #1
 8005ef2:	f882 307d 	strb.w	r3, [r2, #125]	; 0x7d
}
 8005ef6:	b029      	add	sp, #164	; 0xa4
 8005ef8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(gc_state.tool_change && axis_command == AxisCommand_MotionMode && !gc_parser_flags.jog_motion)
 8005efc:	4b55      	ldr	r3, [pc, #340]	; (8006054 <gc_execute_block+0xa04>)
 8005efe:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8005f02:	b1f3      	cbz	r3, 8005f42 <gc_execute_block+0x8f2>
 8005f04:	9b06      	ldr	r3, [sp, #24]
 8005f06:	2b02      	cmp	r3, #2
 8005f08:	d11b      	bne.n	8005f42 <gc_execute_block+0x8f2>
 8005f0a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8005f0e:	07da      	lsls	r2, r3, #31
 8005f10:	f141 810c 	bpl.w	800712c <gc_execute_block+0x1adc>
    if (bit_istrue(value_words, bit(Word_N)) && gc_block.values.n > MAX_LINE_NUMBER)
 8005f14:	2302      	movs	r3, #2
 8005f16:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8005f18:	9306      	str	r3, [sp, #24]
 8005f1a:	062a      	lsls	r2, r5, #24
 8005f1c:	46aa      	mov	sl, r5
 8005f1e:	f53f ac78 	bmi.w	8005812 <gc_execute_block+0x1c2>
        if(bit_isfalse(value_words, bit(Word_F)))
 8005f22:	07af      	lsls	r7, r5, #30
 8005f24:	f140 84d0 	bpl.w	80068c8 <gc_execute_block+0x1278>
        } else if (gc_block.modal.units_imperial)
 8005f28:	f899 300a 	ldrb.w	r3, [r9, #10]
 8005f2c:	2b00      	cmp	r3, #0
 8005f2e:	f43f ac94 	beq.w	800585a <gc_execute_block+0x20a>
            gc_block.values.f *= MM_PER_INCH;
 8005f32:	f8d9 0038 	ldr.w	r0, [r9, #56]	; 0x38
 8005f36:	494a      	ldr	r1, [pc, #296]	; (8006060 <gc_execute_block+0xa10>)
 8005f38:	f7fa fc2c 	bl	8000794 <__aeabi_fmul>
 8005f3c:	f8c9 0038 	str.w	r0, [r9, #56]	; 0x38
 8005f40:	e48b      	b.n	800585a <gc_execute_block+0x20a>
 8005f42:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8005f44:	46aa      	mov	sl, r5
 8005f46:	f005 0380 	and.w	r3, r5, #128	; 0x80
 8005f4a:	e461      	b.n	8005810 <gc_execute_block+0x1c0>
 8005f4c:	4623      	mov	r3, r4
                            if (!((mantissa == 0) || (mantissa == 10)))
 8005f4e:	b930      	cbnz	r0, 8005f5e <gc_execute_block+0x90e>
                            gc_block.non_modal_command += mantissa;
 8005f50:	4418      	add	r0, r3
 8005f52:	4642      	mov	r2, r8
 8005f54:	2300      	movs	r3, #0
 8005f56:	f889 0000 	strb.w	r0, [r9]
                if (mantissa > 0)
 8005f5a:	e59c      	b.n	8005a96 <gc_execute_block+0x446>
                        if ((int_value == 28) || (int_value == 30)) {
 8005f5c:	4623      	mov	r3, r4
                            if (!((mantissa == 0) || (mantissa == 10)))
 8005f5e:	280a      	cmp	r0, #10
 8005f60:	d0f6      	beq.n	8005f50 <gc_execute_block+0x900>
 8005f62:	e5b8      	b.n	8005ad6 <gc_execute_block+0x486>
            FAIL(Status_ExpectedCommandLetter); // [Expected word letter]
 8005f64:	2301      	movs	r3, #1
 8005f66:	9304      	str	r3, [sp, #16]
}
 8005f68:	9804      	ldr	r0, [sp, #16]
 8005f6a:	b029      	add	sp, #164	; 0xa4
 8005f6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            FAIL(Status_BadNumberFormat); // [Expected word value]
 8005f70:	2302      	movs	r3, #2
 8005f72:	9304      	str	r3, [sp, #16]
}
 8005f74:	9804      	ldr	r0, [sp, #16]
 8005f76:	b029      	add	sp, #164	; 0xa4
 8005f78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                            FAIL(Status_GcodeCommandValueNotInteger);
 8005f7c:	2317      	movs	r3, #23
 8005f7e:	9304      	str	r3, [sp, #16]
 8005f80:	e5ab      	b.n	8005ada <gc_execute_block+0x48a>
                    FAIL(Status_GcodeModalGroupViolation);
 8005f82:	2315      	movs	r3, #21
 8005f84:	9304      	str	r3, [sp, #16]
 8005f86:	e5a8      	b.n	8005ada <gc_execute_block+0x48a>
                                if(hal.driver_cap.program_stop ? !hal.system_control_get_state().stop_disable : !sys.flags.optional_stop_disable)
 8005f88:	4b33      	ldr	r3, [pc, #204]	; (8006058 <gc_execute_block+0xa08>)
 8005f8a:	f893 2145 	ldrb.w	r2, [r3, #325]	; 0x145
 8005f8e:	0712      	lsls	r2, r2, #28
 8005f90:	d555      	bpl.n	800603e <gc_execute_block+0x9ee>
 8005f92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005f94:	4798      	blx	r3
 8005f96:	f080 0320 	eor.w	r3, r0, #32
 8005f9a:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8005f9e:	2b00      	cmp	r3, #0
 8005fa0:	f000 82a0 	beq.w	80064e4 <gc_execute_block+0xe94>
                                    gc_block.modal.program_flow = ProgramFlow_OptionalStop;
 8005fa4:	2201      	movs	r2, #1
 8005fa6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8005faa:	f889 2020 	strb.w	r2, [r9, #32]
 8005fae:	9e05      	ldr	r6, [sp, #20]
 8005fb0:	220f      	movs	r2, #15
 8005fb2:	e40a      	b.n	80057ca <gc_execute_block+0x17a>
                                gc_block.modal.program_flow = ProgramFlow_Paused;
 8005fb4:	2203      	movs	r2, #3
                                break;
 8005fb6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
                                gc_block.modal.program_flow = ProgramFlow_Paused;
 8005fba:	f889 2020 	strb.w	r2, [r9, #32]
                                break;
 8005fbe:	9e05      	ldr	r6, [sp, #20]
 8005fc0:	220f      	movs	r2, #15
 8005fc2:	e402      	b.n	80057ca <gc_execute_block+0x17a>
                        if(hal.stream.suspend_read || hal.tool_change)
 8005fc4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
 8005fc8:	2b00      	cmp	r3, #0
 8005fca:	f47f abfa 	bne.w	80057c2 <gc_execute_block+0x172>
 8005fce:	e582      	b.n	8005ad6 <gc_execute_block+0x486>
                            gc_block.modal.distance_incremental = int_value == 91;
 8005fd0:	f1a4 045b 	sub.w	r4, r4, #91	; 0x5b
 8005fd4:	fab4 f484 	clz	r4, r4
 8005fd8:	0964      	lsrs	r4, r4, #5
 8005fda:	2303      	movs	r3, #3
 8005fdc:	ea4f 02d8 	mov.w	r2, r8, lsr #3
 8005fe0:	f889 400b 	strb.w	r4, [r9, #11]
                if (mantissa > 0)
 8005fe4:	e557      	b.n	8005a96 <gc_execute_block+0x446>
                            if (axis_command)
 8005fe6:	9b06      	ldr	r3, [sp, #24]
 8005fe8:	2b00      	cmp	r3, #0
 8005fea:	f040 8478 	bne.w	80068de <gc_execute_block+0x128e>
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005fee:	b2e3      	uxtb	r3, r4
                        if ((int_value == 28) || (int_value == 30)) {
 8005ff0:	2c1c      	cmp	r4, #28
                        gc_block.non_modal_command = (non_modal_t)int_value;
 8005ff2:	f889 3000 	strb.w	r3, [r9]
                        if ((int_value == 28) || (int_value == 30)) {
 8005ff6:	f000 8375 	beq.w	80066e4 <gc_execute_block+0x1094>
 8005ffa:	2c1e      	cmp	r4, #30
 8005ffc:	f000 8473 	beq.w	80068e6 <gc_execute_block+0x1296>
                        } else if (int_value == 92) {
 8006000:	2c5c      	cmp	r4, #92	; 0x5c
 8006002:	f040 87a5 	bne.w	8006f50 <gc_execute_block+0x1900>
                            axis_command = AxisCommand_NonModal;
 8006006:	2301      	movs	r3, #1
 8006008:	9306      	str	r3, [sp, #24]
 800600a:	e6d5      	b.n	8005db8 <gc_execute_block+0x768>
                        if(!(hal.probe_get_state && ((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))))
 800600c:	4a10      	ldr	r2, [pc, #64]	; (8006050 <gc_execute_block+0xa00>)
 800600e:	fa22 f303 	lsr.w	r3, r2, r3
 8006012:	07de      	lsls	r6, r3, #31
 8006014:	f57f ad5f 	bpl.w	8005ad6 <gc_execute_block+0x486>
                        int_value += (mantissa / 10) + 100;
 8006018:	4b12      	ldr	r3, [pc, #72]	; (8006064 <gc_execute_block+0xa14>)
 800601a:	fba3 2300 	umull	r2, r3, r3, r0
                        if (axis_command)
 800601e:	9a06      	ldr	r2, [sp, #24]
                        int_value += (mantissa / 10) + 100;
 8006020:	08db      	lsrs	r3, r3, #3
 8006022:	338a      	adds	r3, #138	; 0x8a
                        if (axis_command)
 8006024:	2a00      	cmp	r2, #0
 8006026:	f040 845a 	bne.w	80068de <gc_execute_block+0x128e>
                        axis_command = AxisCommand_MotionMode;
 800602a:	2102      	movs	r1, #2
                        gc_block.modal.canned_cycle_active = false;
 800602c:	f889 2027 	strb.w	r2, [r9, #39]	; 0x27
                        gc_block.modal.motion = (motion_mode_t)int_value;
 8006030:	f889 3008 	strb.w	r3, [r9, #8]
                if (mantissa > 0)
 8006034:	ea4f 0258 	mov.w	r2, r8, lsr #1
                        gc_block.modal.canned_cycle_active = false;
 8006038:	2301      	movs	r3, #1
                        axis_command = AxisCommand_MotionMode;
 800603a:	9106      	str	r1, [sp, #24]
 800603c:	e52b      	b.n	8005a96 <gc_execute_block+0x446>
                                if(hal.driver_cap.program_stop ? !hal.system_control_get_state().stop_disable : !sys.flags.optional_stop_disable)
 800603e:	4a0a      	ldr	r2, [pc, #40]	; (8006068 <gc_execute_block+0xa18>)
 8006040:	7a53      	ldrb	r3, [r2, #9]
 8006042:	43db      	mvns	r3, r3
 8006044:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8006048:	e7a9      	b.n	8005f9e <gc_execute_block+0x94e>
        FAIL(Status_GcodeInvalidLineNumber); // [Exceeds max line number]
 800604a:	231b      	movs	r3, #27
 800604c:	9304      	str	r3, [sp, #16]
 800604e:	e544      	b.n	8005ada <gc_execute_block+0x48a>
 8006050:	40100401 	.word	0x40100401
 8006054:	200023dc 	.word	0x200023dc
 8006058:	200024bc 	.word	0x200024bc
 800605c:	20002620 	.word	0x20002620
 8006060:	41cb3333 	.word	0x41cb3333
 8006064:	cccccccd 	.word	0xcccccccd
 8006068:	20002494 	.word	0x20002494
                if(settings.parking.flags.enable_override_control)
 800606c:	4bbe      	ldr	r3, [pc, #760]	; (8006368 <gc_execute_block+0xd18>)
 800606e:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
 8006072:	075d      	lsls	r5, r3, #29
 8006074:	d50d      	bpl.n	8006092 <gc_execute_block+0xa42>
                    gc_block.modal.override_ctrl.parking_disable = gc_block.values.p == 0.0f;
 8006076:	2100      	movs	r1, #0
 8006078:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 800607c:	f7fa fd1e 	bl	8000abc <__aeabi_fcmpeq>
 8006080:	1e03      	subs	r3, r0, #0
 8006082:	bf18      	it	ne
 8006084:	2301      	movne	r3, #1
 8006086:	f899 2023 	ldrb.w	r2, [r9, #35]	; 0x23
 800608a:	f363 02c3 	bfi	r2, r3, #3, #1
 800608e:	f889 2023 	strb.w	r2, [r9, #35]	; 0x23
    if (bit_istrue(command_words, bit(ModalGroup_M10)) && gc_block.user_mcode) {
 8006092:	b16c      	cbz	r4, 80060b0 <gc_execute_block+0xa60>
 8006094:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8006098:	b153      	cbz	r3, 80060b0 <gc_execute_block+0xa60>
        if((int_value = (uint_fast16_t)hal.user_mcode_validate(&gc_block, &value_words)))
 800609a:	4fb4      	ldr	r7, [pc, #720]	; (800636c <gc_execute_block+0xd1c>)
 800609c:	48b4      	ldr	r0, [pc, #720]	; (8006370 <gc_execute_block+0xd20>)
 800609e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80060a2:	a915      	add	r1, sp, #84	; 0x54
 80060a4:	4798      	blx	r3
 80060a6:	9004      	str	r0, [sp, #16]
 80060a8:	2800      	cmp	r0, #0
 80060aa:	f47f ad16 	bne.w	8005ada <gc_execute_block+0x48a>
        axis_words = ijk_words = 0;
 80060ae:	9008      	str	r0, [sp, #32]
    if (gc_block.non_modal_command == NonModal_Dwell) {
 80060b0:	f899 7000 	ldrb.w	r7, [r9]
 80060b4:	2f04      	cmp	r7, #4
 80060b6:	f000 825b 	beq.w	8006570 <gc_execute_block+0xf20>
    switch (gc_block.modal.plane_select) {
 80060ba:	f899 300d 	ldrb.w	r3, [r9, #13]
 80060be:	930b      	str	r3, [sp, #44]	; 0x2c
 80060c0:	2b00      	cmp	r3, #0
 80060c2:	f000 82ce 	beq.w	8006662 <gc_execute_block+0x1012>
 80060c6:	2b01      	cmp	r3, #1
 80060c8:	f040 8215 	bne.w	80064f6 <gc_execute_block+0xea6>
 80060cc:	2200      	movs	r2, #0
 80060ce:	e9cd 320c 	strd	r3, r2, [sp, #48]	; 0x30
 80060d2:	2302      	movs	r3, #2
 80060d4:	920e      	str	r2, [sp, #56]	; 0x38
 80060d6:	930b      	str	r3, [sp, #44]	; 0x2c
    if (gc_block.modal.units_imperial) do { // Axes indices are consistent, so loop may be used.
 80060d8:	f899 300a 	ldrb.w	r3, [r9, #10]
 80060dc:	b1eb      	cbz	r3, 800611a <gc_execute_block+0xaca>
        if (bit_istrue(axis_words, bit(--idx)))
 80060de:	9b04      	ldr	r3, [sp, #16]
 80060e0:	0758      	lsls	r0, r3, #29
 80060e2:	d506      	bpl.n	80060f2 <gc_execute_block+0xaa2>
            gc_block.values.xyz[idx] *= MM_PER_INCH;
 80060e4:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 80060e8:	49a2      	ldr	r1, [pc, #648]	; (8006374 <gc_execute_block+0xd24>)
 80060ea:	f7fa fb53 	bl	8000794 <__aeabi_fmul>
 80060ee:	f8c9 0064 	str.w	r0, [r9, #100]	; 0x64
        if (bit_istrue(axis_words, bit(--idx)))
 80060f2:	9b04      	ldr	r3, [sp, #16]
 80060f4:	0799      	lsls	r1, r3, #30
 80060f6:	d506      	bpl.n	8006106 <gc_execute_block+0xab6>
            gc_block.values.xyz[idx] *= MM_PER_INCH;
 80060f8:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 80060fc:	499d      	ldr	r1, [pc, #628]	; (8006374 <gc_execute_block+0xd24>)
 80060fe:	f7fa fb49 	bl	8000794 <__aeabi_fmul>
 8006102:	f8c9 0060 	str.w	r0, [r9, #96]	; 0x60
        if (bit_istrue(axis_words, bit(--idx)))
 8006106:	9b04      	ldr	r3, [sp, #16]
 8006108:	07da      	lsls	r2, r3, #31
 800610a:	d506      	bpl.n	800611a <gc_execute_block+0xaca>
            gc_block.values.xyz[idx] *= MM_PER_INCH;
 800610c:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 8006110:	4998      	ldr	r1, [pc, #608]	; (8006374 <gc_execute_block+0xd24>)
 8006112:	f7fa fb3f 	bl	8000794 <__aeabi_fmul>
 8006116:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
    if (bit_istrue(command_words, bit(ModalGroup_G15))) {
 800611a:	f418 4f80 	tst.w	r8, #16384	; 0x4000
 800611e:	f000 81e7 	beq.w	80064f0 <gc_execute_block+0xea0>
        sys.report.xmode |= gc_state.modal.diameter_mode != gc_block.modal.diameter_mode;
 8006122:	4c95      	ldr	r4, [pc, #596]	; (8006378 <gc_execute_block+0xd28>)
 8006124:	4d95      	ldr	r5, [pc, #596]	; (800637c <gc_execute_block+0xd2c>)
 8006126:	7d21      	ldrb	r1, [r4, #20]
 8006128:	f899 300c 	ldrb.w	r3, [r9, #12]
 800612c:	4608      	mov	r0, r1
 800612e:	792a      	ldrb	r2, [r5, #4]
 8006130:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 8006134:	405a      	eors	r2, r3
 8006136:	430a      	orrs	r2, r1
 8006138:	f362 00c3 	bfi	r0, r2, #3, #1
 800613c:	7520      	strb	r0, [r4, #20]
        gc_state.modal.diameter_mode = gc_block.modal.diameter_mode;
 800613e:	712b      	strb	r3, [r5, #4]
    if(gc_state.modal.diameter_mode && bit_istrue(axis_words, bit(X_AXIS)))
 8006140:	b153      	cbz	r3, 8006158 <gc_execute_block+0xb08>
 8006142:	9b04      	ldr	r3, [sp, #16]
 8006144:	07db      	lsls	r3, r3, #31
 8006146:	d507      	bpl.n	8006158 <gc_execute_block+0xb08>
        gc_block.values.xyz[X_AXIS] /= 2.0f;
 8006148:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 800614c:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8006150:	f7fa fb20 	bl	8000794 <__aeabi_fmul>
 8006154:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
    if(axis_command == AxisCommand_Scaling) {
 8006158:	9b06      	ldr	r3, [sp, #24]
 800615a:	2b04      	cmp	r3, #4
 800615c:	f000 820f 	beq.w	800657e <gc_execute_block+0xf2e>
    if(gc_state.modal.scaling_active) {
 8006160:	4b86      	ldr	r3, [pc, #536]	; (800637c <gc_execute_block+0xd2c>)
 8006162:	7f9b      	ldrb	r3, [r3, #30]
 8006164:	2b00      	cmp	r3, #0
 8006166:	d03a      	beq.n	80061de <gc_execute_block+0xb8e>
 8006168:	f899 300b 	ldrb.w	r3, [r9, #11]
 800616c:	2b00      	cmp	r3, #0
 800616e:	f040 837a 	bne.w	8006866 <gc_execute_block+0x1216>
            if(bit_istrue(axis_words, bit(--idx))) {
 8006172:	9b04      	ldr	r3, [sp, #16]
 8006174:	0759      	lsls	r1, r3, #29
 8006176:	d50e      	bpl.n	8006196 <gc_execute_block+0xb46>
                     gc_block.values.xyz[idx] = (gc_block.values.xyz[idx] - scale_factor.xyz[idx]) * scale_factor.ijk[idx] + scale_factor.xyz[idx];
 8006178:	4d81      	ldr	r5, [pc, #516]	; (8006380 <gc_execute_block+0xd30>)
 800617a:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 800617e:	68ac      	ldr	r4, [r5, #8]
 8006180:	4621      	mov	r1, r4
 8006182:	f7fa f9fd 	bl	8000580 <__aeabi_fsub>
 8006186:	6969      	ldr	r1, [r5, #20]
 8006188:	f7fa fb04 	bl	8000794 <__aeabi_fmul>
 800618c:	4621      	mov	r1, r4
 800618e:	f7fa f9f9 	bl	8000584 <__addsf3>
 8006192:	f8c9 0064 	str.w	r0, [r9, #100]	; 0x64
            if(bit_istrue(axis_words, bit(--idx))) {
 8006196:	9b04      	ldr	r3, [sp, #16]
 8006198:	079a      	lsls	r2, r3, #30
 800619a:	d50e      	bpl.n	80061ba <gc_execute_block+0xb6a>
                     gc_block.values.xyz[idx] = (gc_block.values.xyz[idx] - scale_factor.xyz[idx]) * scale_factor.ijk[idx] + scale_factor.xyz[idx];
 800619c:	4d78      	ldr	r5, [pc, #480]	; (8006380 <gc_execute_block+0xd30>)
 800619e:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 80061a2:	686c      	ldr	r4, [r5, #4]
 80061a4:	4621      	mov	r1, r4
 80061a6:	f7fa f9eb 	bl	8000580 <__aeabi_fsub>
 80061aa:	6929      	ldr	r1, [r5, #16]
 80061ac:	f7fa faf2 	bl	8000794 <__aeabi_fmul>
 80061b0:	4621      	mov	r1, r4
 80061b2:	f7fa f9e7 	bl	8000584 <__addsf3>
 80061b6:	f8c9 0060 	str.w	r0, [r9, #96]	; 0x60
            if(bit_istrue(axis_words, bit(--idx))) {
 80061ba:	9b04      	ldr	r3, [sp, #16]
 80061bc:	07db      	lsls	r3, r3, #31
 80061be:	d50e      	bpl.n	80061de <gc_execute_block+0xb8e>
                     gc_block.values.xyz[idx] = (gc_block.values.xyz[idx] - scale_factor.xyz[idx]) * scale_factor.ijk[idx] + scale_factor.xyz[idx];
 80061c0:	4d6f      	ldr	r5, [pc, #444]	; (8006380 <gc_execute_block+0xd30>)
 80061c2:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 80061c6:	682c      	ldr	r4, [r5, #0]
 80061c8:	4621      	mov	r1, r4
 80061ca:	f7fa f9d9 	bl	8000580 <__aeabi_fsub>
 80061ce:	68e9      	ldr	r1, [r5, #12]
 80061d0:	f7fa fae0 	bl	8000794 <__aeabi_fmul>
 80061d4:	4621      	mov	r1, r4
 80061d6:	f7fa f9d5 	bl	8000584 <__addsf3>
 80061da:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
    if (axis_command == AxisCommand_ToolLengthOffset) { // Indicates called in block.
 80061de:	9b06      	ldr	r3, [sp, #24]
 80061e0:	2b03      	cmp	r3, #3
 80061e2:	f000 8244 	beq.w	800666e <gc_execute_block+0x101e>
    if (bit_istrue(command_words, bit(ModalGroup_G12))) { // Check if called in block
 80061e6:	f418 6f00 	tst.w	r8, #2048	; 0x800
 80061ea:	d010      	beq.n	800620e <gc_execute_block+0xbbe>
        if (gc_block.modal.coord_system.idx > N_COORDINATE_SYSTEM)
 80061ec:	f899 001c 	ldrb.w	r0, [r9, #28]
 80061f0:	2809      	cmp	r0, #9
 80061f2:	f200 86b2 	bhi.w	8006f5a <gc_execute_block+0x190a>
        if (gc_state.modal.coord_system.idx != gc_block.modal.coord_system.idx && !settings_read_coord_data(gc_block.modal.coord_system.idx, &gc_block.modal.coord_system.xyz))
 80061f6:	4b61      	ldr	r3, [pc, #388]	; (800637c <gc_execute_block+0xd2c>)
 80061f8:	7d1b      	ldrb	r3, [r3, #20]
 80061fa:	4283      	cmp	r3, r0
 80061fc:	d007      	beq.n	800620e <gc_execute_block+0xbbe>
 80061fe:	4961      	ldr	r1, [pc, #388]	; (8006384 <gc_execute_block+0xd34>)
 8006200:	f007 ff96 	bl	800e130 <settings_read_coord_data>
 8006204:	2800      	cmp	r0, #0
 8006206:	f000 8799 	beq.w	800713c <gc_execute_block+0x1aec>
 800620a:	f899 7000 	ldrb.w	r7, [r9]
    switch (gc_block.non_modal_command) {
 800620e:	2f0a      	cmp	r7, #10
 8006210:	f000 82e2 	beq.w	80067d8 <gc_execute_block+0x1188>
 8006214:	2f5c      	cmp	r7, #92	; 0x5c
 8006216:	f000 82ab 	beq.w	8006770 <gc_execute_block+0x1120>
            if (axis_words && axis_command != AxisCommand_ToolLengthOffset) { // TLO block any axis command.
 800621a:	9b04      	ldr	r3, [sp, #16]
 800621c:	2b00      	cmp	r3, #0
 800621e:	d03f      	beq.n	80062a0 <gc_execute_block+0xc50>
 8006220:	9b06      	ldr	r3, [sp, #24]
 8006222:	2b03      	cmp	r3, #3
 8006224:	d03c      	beq.n	80062a0 <gc_execute_block+0xc50>
 8006226:	f899 300b 	ldrb.w	r3, [r9, #11]
 800622a:	2b00      	cmp	r3, #0
 800622c:	f041 814a 	bne.w	80074c4 <gc_execute_block+0x1e74>
                    if (bit_isfalse(axis_words, bit(--idx)))
 8006230:	9a04      	ldr	r2, [sp, #16]
 8006232:	4613      	mov	r3, r2
 8006234:	075b      	lsls	r3, r3, #29
 8006236:	f141 83e5 	bpl.w	8007a04 <gc_execute_block+0x23b4>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 800623a:	2f35      	cmp	r7, #53	; 0x35
 800623c:	f001 8402 	beq.w	8007a44 <gc_execute_block+0x23f4>
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8006240:	4b4e      	ldr	r3, [pc, #312]	; (800637c <gc_execute_block+0xd2c>)
 8006242:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8006246:	461c      	mov	r4, r3
 8006248:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
 800624c:	f7fa f99a 	bl	8000584 <__addsf3>
 8006250:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 8006254:	f7fa f996 	bl	8000584 <__addsf3>
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8006258:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 800625c:	f7fa f992 	bl	8000584 <__addsf3>
                    if (bit_isfalse(axis_words, bit(--idx)))
 8006260:	9b04      	ldr	r3, [sp, #16]
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8006262:	f8c9 0064 	str.w	r0, [r9, #100]	; 0x64
                    if (bit_isfalse(axis_words, bit(--idx)))
 8006266:	079d      	lsls	r5, r3, #30
 8006268:	f101 83d5 	bmi.w	8007a16 <gc_execute_block+0x23c6>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 800626c:	4b43      	ldr	r3, [pc, #268]	; (800637c <gc_execute_block+0xd2c>)
 800626e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006270:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 8006274:	9b04      	ldr	r3, [sp, #16]
 8006276:	07dc      	lsls	r4, r3, #31
 8006278:	f141 823c 	bpl.w	80076f4 <gc_execute_block+0x20a4>
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 800627c:	4b3f      	ldr	r3, [pc, #252]	; (800637c <gc_execute_block+0xd2c>)
 800627e:	f8d9 1010 	ldr.w	r1, [r9, #16]
 8006282:	461c      	mov	r4, r3
 8006284:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
 8006288:	f7fa f97c 	bl	8000584 <__addsf3>
 800628c:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8006290:	f7fa f978 	bl	8000584 <__addsf3>
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8006294:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
 8006298:	f7fa f974 	bl	8000584 <__addsf3>
 800629c:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
            switch (gc_block.non_modal_command) {
 80062a0:	2f1e      	cmp	r7, #30
 80062a2:	f001 8133 	beq.w	800750c <gc_execute_block+0x1ebc>
 80062a6:	2f35      	cmp	r7, #53	; 0x35
 80062a8:	f000 8754 	beq.w	8007154 <gc_execute_block+0x1b04>
 80062ac:	2f1c      	cmp	r7, #28
 80062ae:	f001 81a6 	beq.w	80075fe <gc_execute_block+0x1fae>
 80062b2:	f899 4008 	ldrb.w	r4, [r9, #8]
    if (gc_block.modal.motion == MotionMode_None) {
 80062b6:	2c50      	cmp	r4, #80	; 0x50
 80062b8:	f040 8218 	bne.w	80066ec <gc_execute_block+0x109c>
        if (axis_words) // [No axis words allowed]
 80062bc:	9b04      	ldr	r3, [sp, #16]
 80062be:	2b00      	cmp	r3, #0
 80062c0:	f040 8286 	bne.w	80067d0 <gc_execute_block+0x1180>
        gc_block.modal.retract_mode = CCRetractMode_Previous;
 80062c4:	2300      	movs	r3, #0
 80062c6:	2450      	movs	r4, #80	; 0x50
 80062c8:	f889 3025 	strb.w	r3, [r9, #37]	; 0x25
    if (gc_parser_flags.jog_motion) // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
 80062cc:	f8bd 301c 	ldrh.w	r3, [sp, #28]
        bit_false(value_words, bit(Word_N)|bit(Word_F));
 80062d0:	9915      	ldr	r1, [sp, #84]	; 0x54
    if (gc_parser_flags.jog_motion) // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
 80062d2:	f013 0501 	ands.w	r5, r3, #1
    if (axis_command)
 80062d6:	9b06      	ldr	r3, [sp, #24]
        bit_false(value_words, bit(Word_N)|bit(Word_F)|bit(Word_S)|bit(Word_T)); // Remove single-meaning value words.
 80062d8:	bf0a      	itet	eq
 80062da:	f421 6148 	biceq.w	r1, r1, #3200	; 0xc80
        bit_false(value_words, bit(Word_N)|bit(Word_F));
 80062de:	f021 0182 	bicne.w	r1, r1, #130	; 0x82
        bit_false(value_words, bit(Word_N)|bit(Word_F)|bit(Word_S)|bit(Word_T)); // Remove single-meaning value words.
 80062e2:	f021 0102 	biceq.w	r1, r1, #2
    if (axis_command)
 80062e6:	b10b      	cbz	r3, 80062ec <gc_execute_block+0xc9c>
        bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 80062e8:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
 80062ec:	9115      	str	r1, [sp, #84]	; 0x54
    if (value_words)
 80062ee:	2900      	cmp	r1, #0
 80062f0:	f040 830a 	bne.w	8006908 <gc_execute_block+0x12b8>
    memset(&plan_data, 0, sizeof(plan_line_data_t)); // Zero plan_data struct
 80062f4:	2234      	movs	r2, #52	; 0x34
 80062f6:	a81b      	add	r0, sp, #108	; 0x6c
 80062f8:	f00b fcc4 	bl	8011c84 <memset>
    if (gc_parser_flags.jog_motion) {
 80062fc:	2d00      	cmp	r5, #0
 80062fe:	f000 8325 	beq.w	800694c <gc_execute_block+0x12fc>
        if (command_words & ~(bit(ModalGroup_G3)|bit(ModalGroup_G6)|bit(ModalGroup_G0)))
 8006302:	f038 0349 	bics.w	r3, r8, #73	; 0x49
 8006306:	f040 8750 	bne.w	80071aa <gc_execute_block+0x1b5a>
        if (!(gc_block.non_modal_command == NonModal_AbsoluteOverride || gc_block.non_modal_command == NonModal_NoAction))
 800630a:	f899 3000 	ldrb.w	r3, [r9]
 800630e:	2b35      	cmp	r3, #53	; 0x35
 8006310:	d002      	beq.n	8006318 <gc_execute_block+0xcc8>
 8006312:	2b00      	cmp	r3, #0
 8006314:	f040 8749 	bne.w	80071aa <gc_execute_block+0x1b5a>
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 8006318:	4c1b      	ldr	r4, [pc, #108]	; (8006388 <gc_execute_block+0xd38>)
 800631a:	ad1c      	add	r5, sp, #112	; 0x70
 800631c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800631e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8006320:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8006324:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8006328:	f894 1027 	ldrb.w	r1, [r4, #39]	; 0x27
 800632c:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
        plan_data.condition.spindle = gc_state.modal.spindle;
 8006330:	f814 5c3e 	ldrb.w	r5, [r4, #-62]
        plan_data.condition.coolant = gc_state.modal.coolant;
 8006334:	f814 2c3f 	ldrb.w	r2, [r4, #-63]
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8006338:	f361 1386 	bfi	r3, r1, #6, #1
        if ((status_code_t)(int_value = (uint_fast16_t)mc_jog_execute(&plan_data, &gc_block)) == Status_OK)
 800633c:	a81b      	add	r0, sp, #108	; 0x6c
 800633e:	490c      	ldr	r1, [pc, #48]	; (8006370 <gc_execute_block+0xd20>)
        plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8006340:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
        plan_data.condition.spindle = gc_state.modal.spindle;
 8006344:	f88d 508e 	strb.w	r5, [sp, #142]	; 0x8e
        plan_data.condition.coolant = gc_state.modal.coolant;
 8006348:	f88d 208f 	strb.w	r2, [sp, #143]	; 0x8f
        if ((status_code_t)(int_value = (uint_fast16_t)mc_jog_execute(&plan_data, &gc_block)) == Status_OK)
 800634c:	f003 fc4e 	bl	8009bec <mc_jog_execute>
 8006350:	9004      	str	r0, [sp, #16]
 8006352:	2800      	cmp	r0, #0
 8006354:	f47f abc1 	bne.w	8005ada <gc_execute_block+0x48a>
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position));
 8006358:	4b0c      	ldr	r3, [pc, #48]	; (800638c <gc_execute_block+0xd3c>)
 800635a:	3414      	adds	r4, #20
 800635c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8006360:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8006364:	f7ff bbb9 	b.w	8005ada <gc_execute_block+0x48a>
 8006368:	20002620 	.word	0x20002620
 800636c:	200024bc 	.word	0x200024bc
 8006370:	20000980 	.word	0x20000980
 8006374:	41cb3333 	.word	0x41cb3333
 8006378:	20002494 	.word	0x20002494
 800637c:	200023dc 	.word	0x200023dc
 8006380:	20000a10 	.word	0x20000a10
 8006384:	20000990 	.word	0x20000990
 8006388:	20002424 	.word	0x20002424
 800638c:	200009dc 	.word	0x200009dc
                gc_block.modal.override_ctrl.feed_rate_disable = gc_block.values.p == 0.0f;
 8006390:	2100      	movs	r1, #0
 8006392:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 8006396:	f7fa fb91 	bl	8000abc <__aeabi_fcmpeq>
 800639a:	1e03      	subs	r3, r0, #0
 800639c:	bf18      	it	ne
 800639e:	2301      	movne	r3, #1
 80063a0:	f899 2023 	ldrb.w	r2, [r9, #35]	; 0x23
 80063a4:	f363 0200 	bfi	r2, r3, #0, #1
 80063a8:	f889 2023 	strb.w	r2, [r9, #35]	; 0x23
                break;
 80063ac:	e671      	b.n	8006092 <gc_execute_block+0xa42>
                gc_block.modal.override_ctrl.feed_rate_disable = gc_block.values.p == 0.0f;
 80063ae:	2100      	movs	r1, #0
 80063b0:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80063b4:	f7fa fb82 	bl	8000abc <__aeabi_fcmpeq>
 80063b8:	1e02      	subs	r2, r0, #0
 80063ba:	bf18      	it	ne
 80063bc:	2201      	movne	r2, #1
 80063be:	f899 3023 	ldrb.w	r3, [r9, #35]	; 0x23
 80063c2:	f362 0300 	bfi	r3, r2, #0, #1
                gc_block.modal.override_ctrl.spindle_rpm_disable = gc_block.values.p == 0.0f;
 80063c6:	f362 0382 	bfi	r3, r2, #2, #1
 80063ca:	f889 3023 	strb.w	r3, [r9, #35]	; 0x23
                break;
 80063ce:	e660      	b.n	8006092 <gc_execute_block+0xa42>
                gc_block.modal.override_ctrl.feed_hold_disable = gc_block.values.p == 0.0f;
 80063d0:	2100      	movs	r1, #0
 80063d2:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80063d6:	f7fa fb71 	bl	8000abc <__aeabi_fcmpeq>
 80063da:	1e03      	subs	r3, r0, #0
 80063dc:	bf18      	it	ne
 80063de:	2301      	movne	r3, #1
 80063e0:	f899 2023 	ldrb.w	r2, [r9, #35]	; 0x23
 80063e4:	f363 0241 	bfi	r2, r3, #1, #1
 80063e8:	f889 2023 	strb.w	r2, [r9, #35]	; 0x23
                break;
 80063ec:	e651      	b.n	8006092 <gc_execute_block+0xa42>
                gc_block.modal.override_ctrl.spindle_rpm_disable = gc_block.values.p == 0.0f;
 80063ee:	2100      	movs	r1, #0
 80063f0:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80063f4:	f7fa fb62 	bl	8000abc <__aeabi_fcmpeq>
 80063f8:	1e03      	subs	r3, r0, #0
 80063fa:	bf18      	it	ne
 80063fc:	2301      	movne	r3, #1
 80063fe:	f899 2023 	ldrb.w	r2, [r9, #35]	; 0x23
 8006402:	f363 0282 	bfi	r2, r3, #2, #1
 8006406:	f889 2023 	strb.w	r2, [r9, #35]	; 0x23
                break;
 800640a:	e642      	b.n	8006092 <gc_execute_block+0xa42>
        if(gc_block.modal.spindle_rpm_mode == SpindleSpeedMode_CSS) {
 800640c:	f899 5024 	ldrb.w	r5, [r9, #36]	; 0x24
 8006410:	2d01      	cmp	r5, #1
 8006412:	f000 814e 	beq.w	80066b2 <gc_execute_block+0x1062>
        } else if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS)
 8006416:	4bc3      	ldr	r3, [pc, #780]	; (8006724 <gc_execute_block+0x10d4>)
 8006418:	7f1b      	ldrb	r3, [r3, #28]
 800641a:	2b01      	cmp	r3, #1
 800641c:	f000 8258 	beq.w	80068d0 <gc_execute_block+0x1280>
 8006420:	f40a 6780 	and.w	r7, sl, #1024	; 0x400
        gc_state.modal.spindle_rpm_mode = gc_block.modal.spindle_rpm_mode;
 8006424:	4bbf      	ldr	r3, [pc, #764]	; (8006724 <gc_execute_block+0x10d4>)
 8006426:	771d      	strb	r5, [r3, #28]
 8006428:	f7ff ba1f 	b.w	800586a <gc_execute_block+0x21a>
    } else if (bit_isfalse(value_words, bit(Word_T)))
 800642c:	f41a 6f00 	tst.w	sl, #2048	; 0x800
 8006430:	f47f aa4b 	bne.w	80058ca <gc_execute_block+0x27a>
        gc_block.values.t = gc_state.tool_pending;
 8006434:	4bbb      	ldr	r3, [pc, #748]	; (8006724 <gc_execute_block+0x10d4>)
 8006436:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
 800643a:	f889 307d 	strb.w	r3, [r9, #125]	; 0x7d
 800643e:	f7ff ba44 	b.w	80058ca <gc_execute_block+0x27a>
    else if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS)
 8006442:	2d01      	cmp	r5, #1
 8006444:	f47f aa1b 	bne.w	800587e <gc_execute_block+0x22e>
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
 8006448:	f899 300a 	ldrb.w	r3, [r9, #10]
 800644c:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8006450:	2b00      	cmp	r3, #0
 8006452:	f040 826d 	bne.w	8006930 <gc_execute_block+0x12e0>
 8006456:	49b4      	ldr	r1, [pc, #720]	; (8006728 <gc_execute_block+0x10d8>)
 8006458:	f7fa f99c 	bl	8000794 <__aeabi_fmul>
 800645c:	f8c9 0058 	str.w	r0, [r9, #88]	; 0x58
 8006460:	f7ff ba0d 	b.w	800587e <gc_execute_block+0x22e>
                                if(!hal.driver_cap.mist_control)
 8006464:	4bb1      	ldr	r3, [pc, #708]	; (800672c <gc_execute_block+0x10dc>)
 8006466:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 800646a:	07de      	lsls	r6, r3, #31
 800646c:	f57f ab33 	bpl.w	8005ad6 <gc_execute_block+0x486>
                                gc_block.modal.coolant.mist = On;
 8006470:	f899 2021 	ldrb.w	r2, [r9, #33]	; 0x21
                                break;
 8006474:	f44f 2180 	mov.w	r1, #262144	; 0x40000
                                gc_block.modal.coolant.mist = On;
 8006478:	f042 0202 	orr.w	r2, r2, #2
 800647c:	f889 2021 	strb.w	r2, [r9, #33]	; 0x21
                                break;
 8006480:	9e05      	ldr	r6, [sp, #20]
 8006482:	2212      	movs	r2, #18
 8006484:	f7ff b9a1 	b.w	80057ca <gc_execute_block+0x17a>
                                gc_block.modal.coolant.flood = On;
 8006488:	f899 2021 	ldrb.w	r2, [r9, #33]	; 0x21
                                break;
 800648c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
                                gc_block.modal.coolant.flood = On;
 8006490:	f042 0201 	orr.w	r2, r2, #1
 8006494:	f889 2021 	strb.w	r2, [r9, #33]	; 0x21
                                break;
 8006498:	9e05      	ldr	r6, [sp, #20]
 800649a:	2212      	movs	r2, #18
 800649c:	f7ff b995 	b.w	80057ca <gc_execute_block+0x17a>
    if (bit_istrue(command_words, bit(ModalGroup_M9))) {
 80064a0:	f418 2f00 	tst.w	r8, #524288	; 0x80000
 80064a4:	f43f ae04 	beq.w	80060b0 <gc_execute_block+0xa60>
        if(bit_isfalse(value_words, bit(Word_P)))
 80064a8:	f41a 7f80 	tst.w	sl, #256	; 0x100
 80064ac:	f43f aa47 	beq.w	800593e <gc_execute_block+0x2ee>
            bit_false(value_words, bit(Word_P));
 80064b0:	f42a 7380 	bic.w	r3, sl, #256	; 0x100
 80064b4:	9315      	str	r3, [sp, #84]	; 0x54
 80064b6:	f7ff ba46 	b.w	8005946 <gc_execute_block+0x2f6>
                            gc_block.modal.coord_system.idx += mantissa / 10;
 80064ba:	499d      	ldr	r1, [pc, #628]	; (8006730 <gc_execute_block+0x10e0>)
 80064bc:	ea4f 22d8 	mov.w	r2, r8, lsr #11
 80064c0:	fba1 1000 	umull	r1, r0, r1, r0
 80064c4:	eb03 03d0 	add.w	r3, r3, r0, lsr #3
 80064c8:	f889 301c 	strb.w	r3, [r9, #28]
 80064cc:	230b      	movs	r3, #11
 80064ce:	f7ff bae2 	b.w	8005a96 <gc_execute_block+0x446>
                        axis_command = AxisCommand_ToolLengthOffset;
 80064d2:	2103      	movs	r1, #3
                            gc_block.modal.tool_offset_mode = ToolLengthOffset_Cancel;
 80064d4:	f889 300e 	strb.w	r3, [r9, #14]
 80064d8:	ea4f 2218 	mov.w	r2, r8, lsr #8
 80064dc:	2308      	movs	r3, #8
                        axis_command = AxisCommand_ToolLengthOffset;
 80064de:	9106      	str	r1, [sp, #24]
 80064e0:	f7ff bad9 	b.w	8005a96 <gc_execute_block+0x446>
 80064e4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80064e8:	220f      	movs	r2, #15
 80064ea:	9e05      	ldr	r6, [sp, #20]
 80064ec:	f7ff b96d 	b.w	80057ca <gc_execute_block+0x17a>
 80064f0:	4b8c      	ldr	r3, [pc, #560]	; (8006724 <gc_execute_block+0x10d4>)
 80064f2:	791b      	ldrb	r3, [r3, #4]
 80064f4:	e624      	b.n	8006140 <gc_execute_block+0xaf0>
    switch (gc_block.modal.plane_select) {
 80064f6:	2302      	movs	r3, #2
            plane.axis_linear = X_AXIS;
 80064f8:	2200      	movs	r2, #0
    switch (gc_block.modal.plane_select) {
 80064fa:	930e      	str	r3, [sp, #56]	; 0x38
            plane.axis_1 = Z_AXIS;
 80064fc:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
            plane.axis_0 = Y_AXIS;
 8006500:	2301      	movs	r3, #1
 8006502:	930b      	str	r3, [sp, #44]	; 0x2c
 8006504:	e5e8      	b.n	80060d8 <gc_execute_block+0xa88>
                if(bit_isfalse(value_words, bit(Word_E)|bit(Word_Q)))
 8006506:	f248 0301 	movw	r3, #32769	; 0x8001
 800650a:	ea1a 0f03 	tst.w	sl, r3
 800650e:	d02b      	beq.n	8006568 <gc_execute_block+0xf18>
                if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog)
 8006510:	f8d9 5034 	ldr.w	r5, [r9, #52]	; 0x34
 8006514:	4f85      	ldr	r7, [pc, #532]	; (800672c <gc_execute_block+0x10dc>)
 8006516:	4628      	mov	r0, r5
 8006518:	f7fa fb3e 	bl	8000b98 <__aeabi_f2uiz>
 800651c:	f897 2115 	ldrb.w	r2, [r7, #277]	; 0x115
 8006520:	1c43      	adds	r3, r0, #1
 8006522:	4293      	cmp	r3, r2
 8006524:	f201 853e 	bhi.w	8007fa4 <gc_execute_block+0x2954>
                gc_block.output_command.is_digital = false;
 8006528:	2300      	movs	r3, #0
                gc_block.output_command.port = (uint8_t)gc_block.values.e;
 800652a:	4628      	mov	r0, r5
                gc_block.output_command.is_digital = false;
 800652c:	f889 3080 	strb.w	r3, [r9, #128]	; 0x80
                gc_block.output_command.port = (uint8_t)gc_block.values.e;
 8006530:	f7fa fb32 	bl	8000b98 <__aeabi_f2uiz>
 8006534:	4603      	mov	r3, r0
                gc_block.output_command.value = gc_block.values.q;
 8006536:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
                gc_block.output_command.port = (uint8_t)gc_block.values.e;
 800653a:	f889 3081 	strb.w	r3, [r9, #129]	; 0x81
                gc_block.output_command.value = gc_block.values.q;
 800653e:	f7fa fb05 	bl	8000b4c <__aeabi_f2iz>
                bit_false(value_words, bit(Word_E)|bit(Word_Q));
 8006542:	f42a 4a00 	bic.w	sl, sl, #32768	; 0x8000
 8006546:	f02a 0a01 	bic.w	sl, sl, #1
 800654a:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
                gc_block.output_command.value = gc_block.values.q;
 800654e:	f8c9 0084 	str.w	r0, [r9, #132]	; 0x84
    if (bit_istrue(command_words, bit(ModalGroup_M9))) {
 8006552:	f418 2f00 	tst.w	r8, #524288	; 0x80000
 8006556:	f43f ad9d 	beq.w	8006094 <gc_execute_block+0xa44>
 800655a:	e7a5      	b.n	80064a8 <gc_execute_block+0xe58>
        gc_block.values.s = gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_RPM ? gc_state.spindle.rpm : gc_state.spindle.css.surface_speed;
 800655c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800655e:	f7ff b98c 	b.w	800587a <gc_execute_block+0x22a>
                        } else if(gc_parser_flags.canned_cycle_change)
 8006562:	2f00      	cmp	r7, #0
 8006564:	f001 871b 	beq.w	800839e <gc_execute_block+0x2d4e>
                    FAIL(Status_GcodeValueWordMissing);
 8006568:	231c      	movs	r3, #28
 800656a:	9304      	str	r3, [sp, #16]
 800656c:	f7ff bab5 	b.w	8005ada <gc_execute_block+0x48a>
        if (bit_isfalse(value_words, bit(Word_P)))
 8006570:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8006572:	05dc      	lsls	r4, r3, #23
 8006574:	d5f8      	bpl.n	8006568 <gc_execute_block+0xf18>
        bit_false(value_words, bit(Word_P));
 8006576:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800657a:	9315      	str	r3, [sp, #84]	; 0x54
 800657c:	e59d      	b.n	80060ba <gc_execute_block+0xa6a>
        if(gc_block.modal.scaling_active) {
 800657e:	f899 a026 	ldrb.w	sl, [r9, #38]	; 0x26
 8006582:	f1ba 0f00 	cmp.w	sl, #0
 8006586:	f000 8503 	beq.w	8006f90 <gc_execute_block+0x1940>
            gc_block.modal.scaling_active = false;
 800658a:	2300      	movs	r3, #0
 800658c:	f889 3026 	strb.w	r3, [r9, #38]	; 0x26
            if (!axis_words)
 8006590:	9b04      	ldr	r3, [sp, #16]
 8006592:	2b00      	cmp	r3, #0
 8006594:	f000 81c8 	beq.w	8006928 <gc_execute_block+0x12d8>
                if(bit_istrue(axis_words, bit(--idx))) {
 8006598:	075e      	lsls	r6, r3, #29
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 800659a:	4c66      	ldr	r4, [pc, #408]	; (8006734 <gc_execute_block+0x10e4>)
                if(bit_istrue(axis_words, bit(--idx))) {
 800659c:	f100 85ac 	bmi.w	80070f8 <gc_execute_block+0x1aa8>
 80065a0:	461a      	mov	r2, r3
 80065a2:	4d65      	ldr	r5, [pc, #404]	; (8006738 <gc_execute_block+0x10e8>)
 80065a4:	0790      	lsls	r0, r2, #30
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 80065a6:	68ab      	ldr	r3, [r5, #8]
                if(bit_istrue(axis_words, bit(--idx))) {
 80065a8:	d50f      	bpl.n	80065ca <gc_execute_block+0xf7a>
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 80065aa:	7d22      	ldrb	r2, [r4, #20]
 80065ac:	0791      	lsls	r1, r2, #30
 80065ae:	f141 80a7 	bpl.w	8007700 <gc_execute_block+0x20b0>
 80065b2:	4652      	mov	r2, sl
 80065b4:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 80065b8:	7d20      	ldrb	r0, [r4, #20]
                    scale_factor.ijk[idx] = gc_block.values.xyz[idx];
 80065ba:	6129      	str	r1, [r5, #16]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 80065bc:	f362 0041 	bfi	r0, r2, #1, #1
                    bit_false(axis_words, bit(idx));
 80065c0:	9a04      	ldr	r2, [sp, #16]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 80065c2:	7520      	strb	r0, [r4, #20]
                    bit_false(axis_words, bit(idx));
 80065c4:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 80065c8:	9204      	str	r2, [sp, #16]
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 80065ca:	4618      	mov	r0, r3
 80065cc:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80065d0:	f7fa fa74 	bl	8000abc <__aeabi_fcmpeq>
 80065d4:	2800      	cmp	r0, #0
 80065d6:	f000 85a3 	beq.w	8007120 <gc_execute_block+0x1ad0>
 80065da:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80065de:	6868      	ldr	r0, [r5, #4]
 80065e0:	f7fa fa6c 	bl	8000abc <__aeabi_fcmpeq>
 80065e4:	fab0 f380 	clz	r3, r0
                if(bit_istrue(axis_words, bit(--idx))) {
 80065e8:	9a04      	ldr	r2, [sp, #16]
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 80065ea:	095b      	lsrs	r3, r3, #5
                if(bit_istrue(axis_words, bit(--idx))) {
 80065ec:	07d2      	lsls	r2, r2, #31
 80065ee:	d50f      	bpl.n	8006610 <gc_execute_block+0xfc0>
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 80065f0:	7d22      	ldrb	r2, [r4, #20]
 80065f2:	0796      	lsls	r6, r2, #30
 80065f4:	f141 804d 	bpl.w	8007692 <gc_execute_block+0x2042>
 80065f8:	4652      	mov	r2, sl
 80065fa:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
 80065fe:	7d20      	ldrb	r0, [r4, #20]
                    scale_factor.ijk[idx] = gc_block.values.xyz[idx];
 8006600:	60e9      	str	r1, [r5, #12]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8006602:	f362 0041 	bfi	r0, r2, #1, #1
                    bit_false(axis_words, bit(idx));
 8006606:	9a04      	ldr	r2, [sp, #16]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8006608:	7520      	strb	r0, [r4, #20]
                    bit_false(axis_words, bit(idx));
 800660a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 800660e:	9204      	str	r2, [sp, #16]
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 8006610:	2b00      	cmp	r3, #0
 8006612:	f040 8563 	bne.w	80070dc <gc_execute_block+0x1a8c>
 8006616:	6828      	ldr	r0, [r5, #0]
 8006618:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800661c:	f7fa fa4e 	bl	8000abc <__aeabi_fcmpeq>
 8006620:	fab0 f380 	clz	r3, r0
            bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 8006624:	9d15      	ldr	r5, [sp, #84]	; 0x54
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 8006626:	7d22      	ldrb	r2, [r4, #20]
                gc_block.modal.scaling_active = gc_block.modal.scaling_active || (scale_factor.xyz[idx] != 1.0f);
 8006628:	095b      	lsrs	r3, r3, #5
            bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 800662a:	f425 45e0 	bic.w	r5, r5, #28672	; 0x7000
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 800662e:	0790      	lsls	r0, r2, #30
 8006630:	f889 3026 	strb.w	r3, [r9, #38]	; 0x26
            bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 8006634:	9515      	str	r5, [sp, #84]	; 0x54
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 8006636:	d406      	bmi.n	8006646 <gc_execute_block+0xff6>
 8006638:	4a3a      	ldr	r2, [pc, #232]	; (8006724 <gc_execute_block+0x10d4>)
 800663a:	f892 a01e 	ldrb.w	sl, [r2, #30]
 800663e:	ea83 0a0a 	eor.w	sl, r3, sl
 8006642:	fa5f fa8a 	uxtb.w	sl, sl
 8006646:	7d22      	ldrb	r2, [r4, #20]
            gc_state.modal.scaling_active = gc_block.modal.scaling_active;
 8006648:	4936      	ldr	r1, [pc, #216]	; (8006724 <gc_execute_block+0x10d4>)
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 800664a:	f36a 0241 	bfi	r2, sl, #1, #1
            gc_state.modal.scaling_active = gc_block.modal.scaling_active;
 800664e:	778b      	strb	r3, [r1, #30]
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 8006650:	7522      	strb	r2, [r4, #20]
    if(gc_state.modal.scaling_active) {
 8006652:	2b00      	cmp	r3, #0
 8006654:	f43f adc7 	beq.w	80061e6 <gc_execute_block+0xb96>
 8006658:	e586      	b.n	8006168 <gc_execute_block+0xb18>
                    FAIL(Status_NegativeValue); // [Word value cannot be negative]
 800665a:	2304      	movs	r3, #4
 800665c:	9304      	str	r3, [sp, #16]
 800665e:	f7ff ba3c 	b.w	8005ada <gc_execute_block+0x48a>
    switch (gc_block.modal.plane_select) {
 8006662:	2301      	movs	r3, #1
            plane.axis_linear = Z_AXIS;
 8006664:	2202      	movs	r2, #2
    switch (gc_block.modal.plane_select) {
 8006666:	930e      	str	r3, [sp, #56]	; 0x38
            plane.axis_1 = Y_AXIS;
 8006668:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 800666c:	e534      	b.n	80060d8 <gc_execute_block+0xa88>
        switch(gc_block.modal.tool_offset_mode) {
 800666e:	f899 300e 	ldrb.w	r3, [r9, #14]
 8006672:	2b02      	cmp	r3, #2
 8006674:	f47f adb7 	bne.w	80061e6 <gc_execute_block+0xb96>
                if (!axis_words)
 8006678:	9b04      	ldr	r3, [sp, #16]
 800667a:	2b00      	cmp	r3, #0
 800667c:	f47f adb3 	bne.w	80061e6 <gc_execute_block+0xb96>
                    FAIL(Status_GcodeG43DynamicAxisError);
 8006680:	2325      	movs	r3, #37	; 0x25
 8006682:	9304      	str	r3, [sp, #16]
 8006684:	f7ff ba29 	b.w	8005ada <gc_execute_block+0x48a>
    if (gc_parser_flags.jog_motion) {
 8006688:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800668c:	f013 0301 	ands.w	r3, r3, #1
 8006690:	9304      	str	r3, [sp, #16]
 8006692:	f040 8119 	bne.w	80068c8 <gc_execute_block+0x1278>
    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 8006696:	f899 3008 	ldrb.w	r3, [r9, #8]
 800669a:	2b21      	cmp	r3, #33	; 0x21
 800669c:	f000 8127 	beq.w	80068ee <gc_execute_block+0x129e>
    uint8_t ijk_words = 0; // IJK tracking
 80066a0:	9a04      	ldr	r2, [sp, #16]
    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 80066a2:	4692      	mov	sl, r2
    uint32_t command_words = 0; // Bitfield for tracking G and M command words. Also used for modal group violations.
 80066a4:	4690      	mov	r8, r2
    bool set_tool = false;
 80066a6:	e9cd 2205 	strd	r2, r2, [sp, #20]
    uint8_t ijk_words = 0; // IJK tracking
 80066aa:	9208      	str	r2, [sp, #32]
    uint_fast8_t port_command = 0;
 80066ac:	9209      	str	r2, [sp, #36]	; 0x24
 80066ae:	f7ff b8c0 	b.w	8005832 <gc_execute_block+0x1e2>
            if (bit_isfalse(value_words, bit(Word_S))) // TODO: add check for S0?
 80066b2:	f41a 6780 	ands.w	r7, sl, #1024	; 0x400
 80066b6:	f43f af57 	beq.w	8006568 <gc_execute_block+0xf18>
            if (bit_istrue(value_words, bit(Word_D))) {
 80066ba:	f41a 3f80 	tst.w	sl, #65536	; 0x10000
                gc_state.spindle.css.max_rpm = min(gc_block.values.d, settings.spindle.rpm_max);
 80066be:	4b1f      	ldr	r3, [pc, #124]	; (800673c <gc_execute_block+0x10ec>)
            if (bit_istrue(value_words, bit(Word_D))) {
 80066c0:	f000 8441 	beq.w	8006f46 <gc_execute_block+0x18f6>
                gc_state.spindle.css.max_rpm = min(gc_block.values.d, settings.spindle.rpm_max);
 80066c4:	f8d9 6030 	ldr.w	r6, [r9, #48]	; 0x30
 80066c8:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 80066ca:	4631      	mov	r1, r6
 80066cc:	4620      	mov	r0, r4
 80066ce:	f7fa fa09 	bl	8000ae4 <__aeabi_fcmple>
 80066d2:	b900      	cbnz	r0, 80066d6 <gc_execute_block+0x1086>
 80066d4:	4634      	mov	r4, r6
 80066d6:	4b13      	ldr	r3, [pc, #76]	; (8006724 <gc_execute_block+0x10d4>)
                bit_false(value_words, bit(Word_D));
 80066d8:	f42a 3a80 	bic.w	sl, sl, #65536	; 0x10000
 80066dc:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
                gc_state.spindle.css.max_rpm = min(gc_block.values.d, settings.spindle.rpm_max);
 80066e0:	655c      	str	r4, [r3, #84]	; 0x54
                bit_false(value_words, bit(Word_D));
 80066e2:	e69f      	b.n	8006424 <gc_execute_block+0xdd4>
                            axis_command = AxisCommand_NonModal;
 80066e4:	2201      	movs	r2, #1
                        if ((int_value == 28) || (int_value == 30)) {
 80066e6:	4623      	mov	r3, r4
                            axis_command = AxisCommand_NonModal;
 80066e8:	9206      	str	r2, [sp, #24]
 80066ea:	e431      	b.n	8005f50 <gc_execute_block+0x900>
    } else if (axis_command == AxisCommand_MotionMode) {
 80066ec:	9b06      	ldr	r3, [sp, #24]
 80066ee:	2b02      	cmp	r3, #2
 80066f0:	f47f adec 	bne.w	80062cc <gc_execute_block+0xc7c>
        gc_parser_flags.motion_mode_changed = gc_block.modal.motion != gc_state.modal.motion;
 80066f4:	4b0b      	ldr	r3, [pc, #44]	; (8006724 <gc_execute_block+0x10d4>)
 80066f6:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80066fa:	f893 a000 	ldrb.w	sl, [r3]
 80066fe:	ebba 0304 	subs.w	r3, sl, r4
 8006702:	bf18      	it	ne
 8006704:	2301      	movne	r3, #1
 8006706:	f363 2249 	bfi	r2, r3, #9, #1
 800670a:	f8ad 201c 	strh.w	r2, [sp, #28]
        if (gc_block.modal.motion == MotionMode_Seek) {
 800670e:	2c00      	cmp	r4, #0
 8006710:	f040 8559 	bne.w	80071c6 <gc_execute_block+0x1b76>
            if (!axis_words)
 8006714:	9b04      	ldr	r3, [sp, #16]
 8006716:	9a06      	ldr	r2, [sp, #24]
 8006718:	2b00      	cmp	r3, #0
 800671a:	bf04      	itt	eq
 800671c:	461a      	moveq	r2, r3
 800671e:	461c      	moveq	r4, r3
 8006720:	9206      	str	r2, [sp, #24]
 8006722:	e5d3      	b.n	80062cc <gc_execute_block+0xc7c>
 8006724:	200023dc 	.word	0x200023dc
 8006728:	447a0000 	.word	0x447a0000
 800672c:	200024bc 	.word	0x200024bc
 8006730:	cccccccd 	.word	0xcccccccd
 8006734:	20002494 	.word	0x20002494
 8006738:	20000a10 	.word	0x20000a10
 800673c:	20002620 	.word	0x20002620
        if (bit_isfalse(value_words, bit(Word_K))) {
 8006740:	06ae      	lsls	r6, r5, #26
 8006742:	f140 80db 	bpl.w	80068fc <gc_execute_block+0x12ac>
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
 8006746:	f899 300a 	ldrb.w	r3, [r9, #10]
            bit_false(value_words, bit(Word_K));
 800674a:	f025 0a20 	bic.w	sl, r5, #32
 800674e:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
 8006752:	2b00      	cmp	r3, #0
 8006754:	f000 84ee 	beq.w	8007134 <gc_execute_block+0x1ae4>
 8006758:	f8d9 0044 	ldr.w	r0, [r9, #68]	; 0x44
 800675c:	4975      	ldr	r1, [pc, #468]	; (8006934 <gc_execute_block+0x12e4>)
 800675e:	f7fa f819 	bl	8000794 <__aeabi_fmul>
 8006762:	4603      	mov	r3, r0
 8006764:	f8c9 0044 	str.w	r0, [r9, #68]	; 0x44
 8006768:	f8c9 3048 	str.w	r3, [r9, #72]	; 0x48
 800676c:	f7ff b875 	b.w	800585a <gc_execute_block+0x20a>
            if (!axis_words)
 8006770:	9b04      	ldr	r3, [sp, #16]
 8006772:	2b00      	cmp	r3, #0
 8006774:	f000 80d8 	beq.w	8006928 <gc_execute_block+0x12d8>
                if (bit_istrue(axis_words, bit(--idx))) {
 8006778:	0758      	lsls	r0, r3, #29
 800677a:	f100 844b 	bmi.w	8007014 <gc_execute_block+0x19c4>
                    gc_block.values.xyz[idx] = gc_state.g92_coord_offset[idx];
 800677e:	4b6e      	ldr	r3, [pc, #440]	; (8006938 <gc_execute_block+0x12e8>)
 8006780:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8006784:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
                if (bit_istrue(axis_words, bit(--idx))) {
 8006788:	9b04      	ldr	r3, [sp, #16]
 800678a:	0799      	lsls	r1, r3, #30
 800678c:	f100 842f 	bmi.w	8006fee <gc_execute_block+0x199e>
                    gc_block.values.xyz[idx] = gc_state.g92_coord_offset[idx];
 8006790:	4b69      	ldr	r3, [pc, #420]	; (8006938 <gc_execute_block+0x12e8>)
 8006792:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8006796:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
                if (bit_istrue(axis_words, bit(--idx))) {
 800679a:	9b04      	ldr	r3, [sp, #16]
 800679c:	07da      	lsls	r2, r3, #31
 800679e:	f140 83e0 	bpl.w	8006f62 <gc_execute_block+0x1912>
                    gc_block.values.xyz[idx] = gc_state.position[idx] - gc_block.modal.coord_system.xyz[idx] - gc_block.values.xyz[idx] - gc_state.tool_length_offset[idx];
 80067a2:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
 80067a6:	f8d9 0010 	ldr.w	r0, [r9, #16]
 80067aa:	f7f9 feeb 	bl	8000584 <__addsf3>
 80067ae:	4b62      	ldr	r3, [pc, #392]	; (8006938 <gc_execute_block+0x12e8>)
 80067b0:	4601      	mov	r1, r0
 80067b2:	461c      	mov	r4, r3
 80067b4:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 80067b6:	f7f9 fee3 	bl	8000580 <__aeabi_fsub>
 80067ba:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80067be:	f7f9 fedf 	bl	8000580 <__aeabi_fsub>
 80067c2:	4603      	mov	r3, r0
 80067c4:	f8c9 305c 	str.w	r3, [r9, #92]	; 0x5c
    if (gc_block.modal.motion == MotionMode_None) {
 80067c8:	f899 4008 	ldrb.w	r4, [r9, #8]
 80067cc:	2c50      	cmp	r4, #80	; 0x50
 80067ce:	d18d      	bne.n	80066ec <gc_execute_block+0x109c>
            FAIL(Status_GcodeAxisWordsExist);
 80067d0:	231f      	movs	r3, #31
 80067d2:	9304      	str	r3, [sp, #16]
 80067d4:	f7ff b981 	b.w	8005ada <gc_execute_block+0x48a>
            if (!(axis_words || (gc_block.values.l != 20 && bit_istrue(value_words, bit(Word_R)))))
 80067d8:	9b04      	ldr	r3, [sp, #16]
 80067da:	2b00      	cmp	r3, #0
 80067dc:	f000 809c 	beq.w	8006918 <gc_execute_block+0x12c8>
 80067e0:	9b15      	ldr	r3, [sp, #84]	; 0x54
            if (bit_isfalse(value_words, bit(Word_P)|bit(Word_L)))
 80067e2:	f413 7fa0 	tst.w	r3, #320	; 0x140
 80067e6:	f43f aebf 	beq.w	8006568 <gc_execute_block+0xf18>
            switch(gc_block.values.l) {
 80067ea:	f899 207e 	ldrb.w	r2, [r9, #126]	; 0x7e
 80067ee:	2a02      	cmp	r2, #2
 80067f0:	f000 84d6 	beq.w	80071a0 <gc_execute_block+0x1b50>
 80067f4:	2a14      	cmp	r2, #20
 80067f6:	f47f a96e 	bne.w	8005ad6 <gc_execute_block+0x486>
            p_value = (uint8_t)truncf(gc_block.values.p); // Convert p value to int.
 80067fa:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80067fe:	f7fa f9cb 	bl	8000b98 <__aeabi_f2uiz>
 8006802:	b2c3      	uxtb	r3, r0
                    if (p_value > N_COORDINATE_SYSTEM)
 8006804:	2b09      	cmp	r3, #9
 8006806:	f200 83a8 	bhi.w	8006f5a <gc_execute_block+0x190a>
                    gc_block.values.coord_data.idx = p_value == 0
 800680a:	2b00      	cmp	r3, #0
 800680c:	f040 879d 	bne.w	800774a <gc_execute_block+0x20fa>
 8006810:	f899 001c 	ldrb.w	r0, [r9, #28]
                    if (!settings_read_coord_data(gc_block.values.coord_data.idx, &gc_block.values.coord_data.xyz))
 8006814:	4949      	ldr	r1, [pc, #292]	; (800693c <gc_execute_block+0x12ec>)
                    gc_block.values.coord_data.idx = p_value == 0
 8006816:	f889 0074 	strb.w	r0, [r9, #116]	; 0x74
                    if (!settings_read_coord_data(gc_block.values.coord_data.idx, &gc_block.values.coord_data.xyz))
 800681a:	f007 fc89 	bl	800e130 <settings_read_coord_data>
 800681e:	2800      	cmp	r0, #0
 8006820:	f000 848c 	beq.w	800713c <gc_execute_block+0x1aec>
 8006824:	f899 307e 	ldrb.w	r3, [r9, #126]	; 0x7e
 8006828:	2b14      	cmp	r3, #20
                        if (bit_istrue(axis_words, bit(--idx))) {
 800682a:	9b04      	ldr	r3, [sp, #16]
 800682c:	f000 87a1 	beq.w	8007772 <gc_execute_block+0x2122>
 8006830:	075a      	lsls	r2, r3, #29
                                gc_block.values.coord_data.xyz[idx] = gc_block.values.xyz[idx];
 8006832:	bf44      	itt	mi
 8006834:	f8d9 3064 	ldrmi.w	r3, [r9, #100]	; 0x64
 8006838:	f8c9 3070 	strmi.w	r3, [r9, #112]	; 0x70
                        if (bit_istrue(axis_words, bit(--idx))) {
 800683c:	9b04      	ldr	r3, [sp, #16]
 800683e:	079b      	lsls	r3, r3, #30
                                gc_block.values.coord_data.xyz[idx] = gc_block.values.xyz[idx];
 8006840:	bf44      	itt	mi
 8006842:	f8d9 3060 	ldrmi.w	r3, [r9, #96]	; 0x60
 8006846:	f8c9 306c 	strmi.w	r3, [r9, #108]	; 0x6c
                        if (bit_istrue(axis_words, bit(--idx))) {
 800684a:	9b04      	ldr	r3, [sp, #16]
 800684c:	07df      	lsls	r7, r3, #31
 800684e:	d503      	bpl.n	8006858 <gc_execute_block+0x1208>
                                gc_block.values.coord_data.xyz[idx] = gc_block.values.xyz[idx];
 8006850:	f8d9 305c 	ldr.w	r3, [r9, #92]	; 0x5c
 8006854:	f8c9 3068 	str.w	r3, [r9, #104]	; 0x68
            bit_false(value_words, bit(Word_L)|bit(Word_P));
 8006858:	9d15      	ldr	r5, [sp, #84]	; 0x54
 800685a:	f899 4008 	ldrb.w	r4, [r9, #8]
 800685e:	f425 75a0 	bic.w	r5, r5, #320	; 0x140
 8006862:	9515      	str	r5, [sp, #84]	; 0x54
            break;
 8006864:	e527      	b.n	80062b6 <gc_execute_block+0xc66>
            if(bit_istrue(axis_words, bit(--idx))) {
 8006866:	9b04      	ldr	r3, [sp, #16]
 8006868:	075e      	lsls	r6, r3, #29
 800686a:	d507      	bpl.n	800687c <gc_execute_block+0x122c>
                     gc_block.values.xyz[idx] *= scale_factor.ijk[idx];
 800686c:	4d34      	ldr	r5, [pc, #208]	; (8006940 <gc_execute_block+0x12f0>)
 800686e:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 8006872:	6968      	ldr	r0, [r5, #20]
 8006874:	f7f9 ff8e 	bl	8000794 <__aeabi_fmul>
 8006878:	f8c9 0064 	str.w	r0, [r9, #100]	; 0x64
            if(bit_istrue(axis_words, bit(--idx))) {
 800687c:	9b04      	ldr	r3, [sp, #16]
 800687e:	079d      	lsls	r5, r3, #30
 8006880:	d507      	bpl.n	8006892 <gc_execute_block+0x1242>
                     gc_block.values.xyz[idx] *= scale_factor.ijk[idx];
 8006882:	4d2f      	ldr	r5, [pc, #188]	; (8006940 <gc_execute_block+0x12f0>)
 8006884:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 8006888:	6928      	ldr	r0, [r5, #16]
 800688a:	f7f9 ff83 	bl	8000794 <__aeabi_fmul>
 800688e:	f8c9 0060 	str.w	r0, [r9, #96]	; 0x60
            if(bit_istrue(axis_words, bit(--idx))) {
 8006892:	9b04      	ldr	r3, [sp, #16]
 8006894:	07dc      	lsls	r4, r3, #31
 8006896:	f57f aca2 	bpl.w	80061de <gc_execute_block+0xb8e>
                     gc_block.values.xyz[idx] *= scale_factor.ijk[idx];
 800689a:	4d29      	ldr	r5, [pc, #164]	; (8006940 <gc_execute_block+0x12f0>)
 800689c:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 80068a0:	68e9      	ldr	r1, [r5, #12]
 80068a2:	f7f9 ff77 	bl	8000794 <__aeabi_fmul>
 80068a6:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
        } while(idx);
 80068aa:	e498      	b.n	80061de <gc_execute_block+0xb8e>
        if (axis_command == AxisCommand_MotionMode) {
 80068ac:	9a06      	ldr	r2, [sp, #24]
 80068ae:	2a02      	cmp	r2, #2
 80068b0:	f47e afd3 	bne.w	800585a <gc_execute_block+0x20a>
            if (!(gc_block.modal.motion == MotionMode_None || gc_block.modal.motion == MotionMode_Seek)) {
 80068b4:	2b50      	cmp	r3, #80	; 0x50
 80068b6:	f43e afd0 	beq.w	800585a <gc_execute_block+0x20a>
 80068ba:	2b00      	cmp	r3, #0
 80068bc:	f43e afcd 	beq.w	800585a <gc_execute_block+0x20a>
                if (bit_isfalse(value_words, bit(Word_F)))
 80068c0:	f01a 0f02 	tst.w	sl, #2
 80068c4:	f47e afc9 	bne.w	800585a <gc_execute_block+0x20a>
                FAIL(Status_GcodeUndefinedFeedRate); // [Feed rate undefined]
 80068c8:	2316      	movs	r3, #22
 80068ca:	9304      	str	r3, [sp, #16]
 80068cc:	f7ff b905 	b.w	8005ada <gc_execute_block+0x48a>
            gc_state.spindle.rpm = sys.spindle_rpm; // Is it correct to restore latest spindle RPM here?
 80068d0:	4c1c      	ldr	r4, [pc, #112]	; (8006944 <gc_execute_block+0x12f4>)
 80068d2:	4a19      	ldr	r2, [pc, #100]	; (8006938 <gc_execute_block+0x12e8>)
 80068d4:	69a3      	ldr	r3, [r4, #24]
 80068d6:	f40a 6780 	and.w	r7, sl, #1024	; 0x400
 80068da:	6493      	str	r3, [r2, #72]	; 0x48
 80068dc:	e5a2      	b.n	8006424 <gc_execute_block+0xdd4>
                        FAIL(Status_GcodeAxisCommandConflict); // [An axis other than X or Y is specified]
 80068de:	2318      	movs	r3, #24
 80068e0:	9304      	str	r3, [sp, #16]
 80068e2:	f7ff b8fa 	b.w	8005ada <gc_execute_block+0x48a>
                            axis_command = AxisCommand_NonModal;
 80068e6:	2201      	movs	r2, #1
 80068e8:	9206      	str	r2, [sp, #24]
 80068ea:	f7ff bb31 	b.w	8005f50 <gc_execute_block+0x900>
    uint8_t ijk_words = 0; // IJK tracking
 80068ee:	9b04      	ldr	r3, [sp, #16]
    } else if(gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 80068f0:	469a      	mov	sl, r3
    uint32_t command_words = 0; // Bitfield for tracking G and M command words. Also used for modal group violations.
 80068f2:	4698      	mov	r8, r3
    bool set_tool = false;
 80068f4:	e9cd 3305 	strd	r3, r3, [sp, #20]
    uint8_t ijk_words = 0; // IJK tracking
 80068f8:	9308      	str	r3, [sp, #32]
    uint_fast8_t port_command = 0;
 80068fa:	9309      	str	r3, [sp, #36]	; 0x24
            gc_block.values.k = gc_state.distance_per_rev;
 80068fc:	4b0e      	ldr	r3, [pc, #56]	; (8006938 <gc_execute_block+0x12e8>)
 80068fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8006900:	f8c9 3048 	str.w	r3, [r9, #72]	; 0x48
 8006904:	f7fe bfa9 	b.w	800585a <gc_execute_block+0x20a>
        FAIL(Status_GcodeUnusedWords); // [Unused words]
 8006908:	2324      	movs	r3, #36	; 0x24
 800690a:	9304      	str	r3, [sp, #16]
 800690c:	f7ff b8e5 	b.w	8005ada <gc_execute_block+0x48a>
                            FAIL(Status_GcodeIllegalToolTableEntry);
 8006910:	2326      	movs	r3, #38	; 0x26
 8006912:	9304      	str	r3, [sp, #16]
 8006914:	f7ff b8e1 	b.w	8005ada <gc_execute_block+0x48a>
            if (!(axis_words || (gc_block.values.l != 20 && bit_istrue(value_words, bit(Word_R)))))
 8006918:	f899 307e 	ldrb.w	r3, [r9, #126]	; 0x7e
 800691c:	2b14      	cmp	r3, #20
 800691e:	d003      	beq.n	8006928 <gc_execute_block+0x12d8>
 8006920:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8006922:	0598      	lsls	r0, r3, #22
 8006924:	f53f af5d 	bmi.w	80067e2 <gc_execute_block+0x1192>
                        FAIL(Status_GcodeNoAxisWords); // [No axis words]
 8006928:	231a      	movs	r3, #26
 800692a:	9304      	str	r3, [sp, #16]
 800692c:	f7ff b8d5 	b.w	8005ada <gc_execute_block+0x48a>
        gc_block.values.s *= (gc_block.modal.units_imperial ? MM_PER_INCH * 12.0f : 1000.0f); // convert surface speed to mm/min
 8006930:	4905      	ldr	r1, [pc, #20]	; (8006948 <gc_execute_block+0x12f8>)
 8006932:	e591      	b.n	8006458 <gc_execute_block+0xe08>
 8006934:	41cb3333 	.word	0x41cb3333
 8006938:	200023dc 	.word	0x200023dc
 800693c:	200009e8 	.word	0x200009e8
 8006940:	20000a10 	.word	0x20000a10
 8006944:	20002494 	.word	0x20002494
 8006948:	43986666 	.word	0x43986666
    if (settings.flags.laser_mode) {
 800694c:	f8df a328 	ldr.w	sl, [pc, #808]	; 8006c78 <gc_execute_block+0x1628>
 8006950:	f89a 30bc 	ldrb.w	r3, [sl, #188]	; 0xbc
 8006954:	0798      	lsls	r0, r3, #30
 8006956:	d527      	bpl.n	80069a8 <gc_execute_block+0x1358>
        if (!((gc_block.modal.motion == MotionMode_Linear) || (gc_block.modal.motion == MotionMode_CwArc) || (gc_block.modal.motion == MotionMode_CcwArc)))
 8006958:	1e63      	subs	r3, r4, #1
 800695a:	2b02      	cmp	r3, #2
 800695c:	d905      	bls.n	800696a <gc_execute_block+0x131a>
          gc_parser_flags.laser_disable = On;
 800695e:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8006962:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006966:	f8ad 301c 	strh.w	r3, [sp, #28]
        if (axis_words && (axis_command == AxisCommand_MotionMode))
 800696a:	9b04      	ldr	r3, [sp, #16]
 800696c:	b11b      	cbz	r3, 8006976 <gc_execute_block+0x1326>
 800696e:	9b06      	ldr	r3, [sp, #24]
 8006970:	2b02      	cmp	r3, #2
 8006972:	f001 831b 	beq.w	8007fac <gc_execute_block+0x295c>
        else if (gc_state.modal.spindle.on && !gc_state.modal.spindle.ccw) {
 8006976:	4bb9      	ldr	r3, [pc, #740]	; (8006c5c <gc_execute_block+0x160c>)
 8006978:	7e9b      	ldrb	r3, [r3, #26]
 800697a:	f003 0203 	and.w	r2, r3, #3
 800697e:	2a01      	cmp	r2, #1
 8006980:	f000 83fd 	beq.w	800717e <gc_execute_block+0x1b2e>
        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.ccw && !gc_parser_flags.laser_disable && hal.driver_cap.variable_spindle;
 8006984:	079e      	lsls	r6, r3, #30
 8006986:	f140 8409 	bpl.w	800719c <gc_execute_block+0x1b4c>
 800698a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800698e:	065d      	lsls	r5, r3, #25
 8006990:	f100 8404 	bmi.w	800719c <gc_execute_block+0x1b4c>
 8006994:	4fb2      	ldr	r7, [pc, #712]	; (8006c60 <gc_execute_block+0x1610>)
 8006996:	f897 3144 	ldrb.w	r3, [r7, #324]	; 0x144
 800699a:	0798      	lsls	r0, r3, #30
 800699c:	f140 83fe 	bpl.w	800719c <gc_execute_block+0x1b4c>
 80069a0:	2301      	movs	r3, #1
 80069a2:	4aae      	ldr	r2, [pc, #696]	; (8006c5c <gc_execute_block+0x160c>)
 80069a4:	f882 307f 	strb.w	r3, [r2, #127]	; 0x7f
    gc_state.line_number = gc_block.values.n;
 80069a8:	f8d9 3078 	ldr.w	r3, [r9, #120]	; 0x78
 80069ac:	4aab      	ldr	r2, [pc, #684]	; (8006c5c <gc_execute_block+0x160c>)
    if(message && (plan_data.message = malloc(strlen(message) + 1)))
 80069ae:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    gc_state.line_number = gc_block.values.n;
 80069b0:	6793      	str	r3, [r2, #120]	; 0x78
    plan_data.line_number = gc_state.line_number; // Record data for planner use.
 80069b2:	9325      	str	r3, [sp, #148]	; 0x94
    if(message && (plan_data.message = malloc(strlen(message) + 1)))
 80069b4:	b166      	cbz	r6, 80069d0 <gc_execute_block+0x1380>
 80069b6:	4630      	mov	r0, r6
 80069b8:	f7f9 fbca 	bl	8000150 <strlen>
 80069bc:	1c45      	adds	r5, r0, #1
 80069be:	4628      	mov	r0, r5
 80069c0:	f00b f934 	bl	8011c2c <malloc>
 80069c4:	9026      	str	r0, [sp, #152]	; 0x98
 80069c6:	b118      	cbz	r0, 80069d0 <gc_execute_block+0x1380>
        strcpy(plan_data.message, message);
 80069c8:	462a      	mov	r2, r5
 80069ca:	4631      	mov	r1, r6
 80069cc:	f00b f94c 	bl	8011c68 <memcpy>
    gc_state.modal.feed_mode = gc_block.modal.feed_mode;
 80069d0:	f899 3009 	ldrb.w	r3, [r9, #9]
 80069d4:	4aa1      	ldr	r2, [pc, #644]	; (8006c5c <gc_execute_block+0x160c>)
    if (gc_state.modal.feed_mode == FeedMode_InverseTime)
 80069d6:	2b01      	cmp	r3, #1
    gc_state.modal.feed_mode = gc_block.modal.feed_mode;
 80069d8:	7053      	strb	r3, [r2, #1]
    if (gc_state.modal.feed_mode == FeedMode_InverseTime)
 80069da:	d105      	bne.n	80069e8 <gc_execute_block+0x1398>
        plan_data.condition.inverse_time = On; // Set condition flag for planner use.
 80069dc:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
 80069e0:	f043 0320 	orr.w	r3, r3, #32
 80069e4:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
    if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS) {
 80069e8:	499c      	ldr	r1, [pc, #624]	; (8006c5c <gc_execute_block+0x160c>)
    gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 80069ea:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
    if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS) {
 80069ee:	7f0a      	ldrb	r2, [r1, #28]
    gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
 80069f0:	664b      	str	r3, [r1, #100]	; 0x64
    if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS) {
 80069f2:	2a01      	cmp	r2, #1
    plan_data.feed_rate = gc_state.feed_rate; // Record data for planner use.
 80069f4:	931b      	str	r3, [sp, #108]	; 0x6c
    if(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_CSS) {
 80069f6:	f000 85a7 	beq.w	8007548 <gc_execute_block+0x1ef8>
 80069fa:	f8d9 4058 	ldr.w	r4, [r9, #88]	; 0x58
    if ((gc_state.spindle.rpm != gc_block.values.s) || gc_parser_flags.spindle_force_sync) {
 80069fe:	4b97      	ldr	r3, [pc, #604]	; (8006c5c <gc_execute_block+0x160c>)
 8006a00:	4621      	mov	r1, r4
 8006a02:	6c98      	ldr	r0, [r3, #72]	; 0x48
 8006a04:	f7fa f85a 	bl	8000abc <__aeabi_fcmpeq>
 8006a08:	2800      	cmp	r0, #0
 8006a0a:	f040 83af 	bne.w	800716c <gc_execute_block+0x1b1c>
 8006a0e:	f89d 301c 	ldrb.w	r3, [sp, #28]
        if (gc_state.modal.spindle.on && !gc_parser_flags.laser_is_motion)
 8006a12:	4a92      	ldr	r2, [pc, #584]	; (8006c5c <gc_execute_block+0x160c>)
 8006a14:	7e92      	ldrb	r2, [r2, #26]
 8006a16:	07d2      	lsls	r2, r2, #31
 8006a18:	f140 83a5 	bpl.w	8007166 <gc_execute_block+0x1b16>
 8006a1c:	061f      	lsls	r7, r3, #24
 8006a1e:	f100 83a2 	bmi.w	8007166 <gc_execute_block+0x1b16>
            spindle_sync(gc_state.modal.spindle, gc_parser_flags.laser_disable ? 0.0f : gc_block.values.s);
 8006a22:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8006a26:	bf18      	it	ne
 8006a28:	2400      	movne	r4, #0
 8006a2a:	4b8c      	ldr	r3, [pc, #560]	; (8006c5c <gc_execute_block+0x160c>)
 8006a2c:	4621      	mov	r1, r4
 8006a2e:	7e98      	ldrb	r0, [r3, #26]
 8006a30:	f008 f924 	bl	800ec7c <spindle_sync>
 8006a34:	f8d9 4058 	ldr.w	r4, [r9, #88]	; 0x58
        gc_state.spindle.rpm = gc_block.values.s; // Update spindle speed state.
 8006a38:	4b88      	ldr	r3, [pc, #544]	; (8006c5c <gc_execute_block+0x160c>)
 8006a3a:	649c      	str	r4, [r3, #72]	; 0x48
    if (!gc_parser_flags.laser_disable)
 8006a3c:	b93d      	cbnz	r5, 8006a4e <gc_execute_block+0x13fe>
        memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t)); // Record data for planner use.
 8006a3e:	4d89      	ldr	r5, [pc, #548]	; (8006c64 <gc_execute_block+0x1614>)
 8006a40:	ac1c      	add	r4, sp, #112	; 0x70
 8006a42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006a44:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8006a46:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8006a4a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    if(gc_state.tool_pending != gc_block.values.t) {
 8006a4e:	4983      	ldr	r1, [pc, #524]	; (8006c5c <gc_execute_block+0x160c>)
 8006a50:	f899 307d 	ldrb.w	r3, [r9, #125]	; 0x7d
 8006a54:	f891 207c 	ldrb.w	r2, [r1, #124]	; 0x7c
 8006a58:	429a      	cmp	r2, r3
 8006a5a:	d017      	beq.n	8006a8c <gc_execute_block+0x143c>
        if(set_tool || !(hal.stream.suspend_read || hal.tool_change)) {
 8006a5c:	9a05      	ldr	r2, [sp, #20]
 8006a5e:	4f80      	ldr	r7, [pc, #512]	; (8006c60 <gc_execute_block+0x1610>)
        gc_state.tool_pending = gc_block.values.t;
 8006a60:	f881 307c 	strb.w	r3, [r1, #124]	; 0x7c
        if(set_tool || !(hal.stream.suspend_read || hal.tool_change)) {
 8006a64:	2a00      	cmp	r2, #0
 8006a66:	f040 85bf 	bne.w	80075e8 <gc_execute_block+0x1f98>
 8006a6a:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8006a6c:	2a00      	cmp	r2, #0
 8006a6e:	f000 85b6 	beq.w	80075de <gc_execute_block+0x1f8e>
        if(hal.tool_select) {
 8006a72:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8006a76:	2b00      	cmp	r3, #0
 8006a78:	f001 8044 	beq.w	8007b04 <gc_execute_block+0x24b4>
            hal.tool_select(gc_state.tool, !set_tool);
 8006a7c:	9a05      	ldr	r2, [sp, #20]
 8006a7e:	f082 0101 	eor.w	r1, r2, #1
 8006a82:	4a76      	ldr	r2, [pc, #472]	; (8006c5c <gc_execute_block+0x160c>)
 8006a84:	b2c9      	uxtb	r1, r1
 8006a86:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
 8006a8a:	4798      	blx	r3
    if(port_command) {
 8006a8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006a8e:	2b00      	cmp	r3, #0
 8006a90:	f040 81b5 	bne.w	8006dfe <gc_execute_block+0x17ae>
    if (bit_istrue(command_words, bit(ModalGroup_M6)) && !set_tool) {
 8006a94:	f418 3f80 	tst.w	r8, #65536	; 0x10000
 8006a98:	d003      	beq.n	8006aa2 <gc_execute_block+0x1452>
 8006a9a:	9b05      	ldr	r3, [sp, #20]
 8006a9c:	2b00      	cmp	r3, #0
 8006a9e:	f001 8038 	beq.w	8007b12 <gc_execute_block+0x24c2>
 8006aa2:	4c71      	ldr	r4, [pc, #452]	; (8006c68 <gc_execute_block+0x1618>)
    if (gc_state.modal.spindle.value != gc_block.modal.spindle.value) {
 8006aa4:	4d6d      	ldr	r5, [pc, #436]	; (8006c5c <gc_execute_block+0x160c>)
 8006aa6:	f899 0022 	ldrb.w	r0, [r9, #34]	; 0x22
 8006aaa:	7eab      	ldrb	r3, [r5, #26]
 8006aac:	4283      	cmp	r3, r0
 8006aae:	d006      	beq.n	8006abe <gc_execute_block+0x146e>
        if(spindle_sync(gc_block.modal.spindle, plan_data.spindle.rpm))
 8006ab0:	991c      	ldr	r1, [sp, #112]	; 0x70
 8006ab2:	f008 f8e3 	bl	800ec7c <spindle_sync>
 8006ab6:	b110      	cbz	r0, 8006abe <gc_execute_block+0x146e>
            gc_state.modal.spindle = gc_block.modal.spindle;
 8006ab8:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
 8006abc:	76ab      	strb	r3, [r5, #26]
    plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8006abe:	4867      	ldr	r0, [pc, #412]	; (8006c5c <gc_execute_block+0x160c>)
 8006ac0:	f89d 208c 	ldrb.w	r2, [sp, #140]	; 0x8c
 8006ac4:	f890 307f 	ldrb.w	r3, [r0, #127]	; 0x7f
    plan_data.condition.spindle = gc_state.modal.spindle; // Set condition flag for planner use.
 8006ac8:	7e81      	ldrb	r1, [r0, #26]
    plan_data.condition.is_rpm_rate_adjusted = gc_state.is_rpm_rate_adjusted;
 8006aca:	f363 1286 	bfi	r2, r3, #6, #1
 8006ace:	f88d 208c 	strb.w	r2, [sp, #140]	; 0x8c
    plan_data.condition.spindle = gc_state.modal.spindle; // Set condition flag for planner use.
 8006ad2:	f88d 108e 	strb.w	r1, [sp, #142]	; 0x8e
    plan_data.condition.is_laser_ppi_mode = gc_state.is_rpm_rate_adjusted && gc_state.is_laser_ppi_mode;
 8006ad6:	b10b      	cbz	r3, 8006adc <gc_execute_block+0x148c>
 8006ad8:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
 8006adc:	f89d 208d 	ldrb.w	r2, [sp, #141]	; 0x8d
 8006ae0:	f363 0200 	bfi	r2, r3, #0, #1
    if (gc_parser_flags.set_coolant && gc_state.modal.coolant.value != gc_block.modal.coolant.value) {
 8006ae4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
    plan_data.condition.is_laser_ppi_mode = gc_state.is_rpm_rate_adjusted && gc_state.is_laser_ppi_mode;
 8006ae8:	f88d 208d 	strb.w	r2, [sp, #141]	; 0x8d
    if (gc_parser_flags.set_coolant && gc_state.modal.coolant.value != gc_block.modal.coolant.value) {
 8006aec:	05de      	lsls	r6, r3, #23
 8006aee:	d50b      	bpl.n	8006b08 <gc_execute_block+0x14b8>
 8006af0:	4d5a      	ldr	r5, [pc, #360]	; (8006c5c <gc_execute_block+0x160c>)
 8006af2:	f899 0021 	ldrb.w	r0, [r9, #33]	; 0x21
 8006af6:	7e6b      	ldrb	r3, [r5, #25]
 8006af8:	4283      	cmp	r3, r0
 8006afa:	d005      	beq.n	8006b08 <gc_execute_block+0x14b8>
        if(coolant_sync(gc_block.modal.coolant))
 8006afc:	f7fe fa62 	bl	8004fc4 <coolant_sync>
 8006b00:	b110      	cbz	r0, 8006b08 <gc_execute_block+0x14b8>
            gc_state.modal.coolant = gc_block.modal.coolant;
 8006b02:	f899 3021 	ldrb.w	r3, [r9, #33]	; 0x21
 8006b06:	766b      	strb	r3, [r5, #25]
    sys.flags.delay_overrides = Off;
 8006b08:	7a62      	ldrb	r2, [r4, #9]
    plan_data.condition.coolant = gc_state.modal.coolant; // Set condition flag for planner use.
 8006b0a:	4854      	ldr	r0, [pc, #336]	; (8006c5c <gc_execute_block+0x160c>)
    sys.flags.delay_overrides = Off;
 8006b0c:	f36f 1286 	bfc	r2, #6, #1
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 8006b10:	f899 3023 	ldrb.w	r3, [r9, #35]	; 0x23
    sys.flags.delay_overrides = Off;
 8006b14:	7262      	strb	r2, [r4, #9]
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 8006b16:	7ec2      	ldrb	r2, [r0, #27]
    plan_data.condition.coolant = gc_state.modal.coolant; // Set condition flag for planner use.
 8006b18:	7e41      	ldrb	r1, [r0, #25]
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 8006b1a:	429a      	cmp	r2, r3
    plan_data.condition.coolant = gc_state.modal.coolant; // Set condition flag for planner use.
 8006b1c:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
    if (gc_state.modal.override_ctrl.value != gc_block.modal.override_ctrl.value) {
 8006b20:	d00c      	beq.n	8006b3c <gc_execute_block+0x14ec>
        if(gc_state.modal.override_ctrl.feed_rate_disable)
 8006b22:	07dd      	lsls	r5, r3, #31
        gc_state.modal.override_ctrl = gc_block.modal.override_ctrl;
 8006b24:	76c3      	strb	r3, [r0, #27]
        if(gc_state.modal.override_ctrl.feed_rate_disable)
 8006b26:	f100 87e7 	bmi.w	8007af8 <gc_execute_block+0x24a8>
        if(gc_state.modal.override_ctrl.spindle_rpm_disable)
 8006b2a:	4b4c      	ldr	r3, [pc, #304]	; (8006c5c <gc_execute_block+0x160c>)
 8006b2c:	7edb      	ldrb	r3, [r3, #27]
 8006b2e:	0758      	lsls	r0, r3, #29
 8006b30:	f100 87dd 	bmi.w	8007aee <gc_execute_block+0x249e>
        mc_override_ctrl_update(gc_state.modal.override_ctrl); // NOTE: must be called last!
 8006b34:	4b49      	ldr	r3, [pc, #292]	; (8006c5c <gc_execute_block+0x160c>)
 8006b36:	7ed8      	ldrb	r0, [r3, #27]
 8006b38:	f003 f954 	bl	8009de4 <mc_override_ctrl_update>
    if(gc_block.user_mcode && sys.state != STATE_CHECK_MODE) {
 8006b3c:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 8006b40:	b163      	cbz	r3, 8006b5c <gc_execute_block+0x150c>
 8006b42:	6820      	ldr	r0, [r4, #0]
 8006b44:	2802      	cmp	r0, #2
 8006b46:	d009      	beq.n	8006b5c <gc_execute_block+0x150c>
        if(gc_block.user_mcode_sync)
 8006b48:	f899 3004 	ldrb.w	r3, [r9, #4]
 8006b4c:	2b00      	cmp	r3, #0
 8006b4e:	f041 8008 	bne.w	8007b62 <gc_execute_block+0x2512>
        hal.user_mcode_execute(sys.state, &gc_block);
 8006b52:	4f43      	ldr	r7, [pc, #268]	; (8006c60 <gc_execute_block+0x1610>)
 8006b54:	4945      	ldr	r1, [pc, #276]	; (8006c6c <gc_execute_block+0x161c>)
 8006b56:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8006b5a:	4798      	blx	r3
    if (gc_block.non_modal_command == NonModal_Dwell)
 8006b5c:	f899 3000 	ldrb.w	r3, [r9]
 8006b60:	2b04      	cmp	r3, #4
 8006b62:	f000 8644 	beq.w	80077ee <gc_execute_block+0x219e>
    gc_state.modal.units_imperial = gc_block.modal.units_imperial;
 8006b66:	f899 300a 	ldrb.w	r3, [r9, #10]
    gc_state.modal.plane_select = gc_block.modal.plane_select;
 8006b6a:	493c      	ldr	r1, [pc, #240]	; (8006c5c <gc_execute_block+0x160c>)
 8006b6c:	f899 200d 	ldrb.w	r2, [r9, #13]
    gc_state.modal.units_imperial = gc_block.modal.units_imperial;
 8006b70:	708b      	strb	r3, [r1, #2]
    if (axis_command == AxisCommand_ToolLengthOffset) { // Indicates a change.
 8006b72:	9b06      	ldr	r3, [sp, #24]
    gc_state.modal.plane_select = gc_block.modal.plane_select;
 8006b74:	714a      	strb	r2, [r1, #5]
    if (axis_command == AxisCommand_ToolLengthOffset) { // Indicates a change.
 8006b76:	2b03      	cmp	r3, #3
 8006b78:	f000 8543 	beq.w	8007602 <gc_execute_block+0x1fb2>
    if (gc_state.modal.coord_system.idx != gc_block.modal.coord_system.idx) {
 8006b7c:	4b37      	ldr	r3, [pc, #220]	; (8006c5c <gc_execute_block+0x160c>)
 8006b7e:	7d1a      	ldrb	r2, [r3, #20]
 8006b80:	f899 301c 	ldrb.w	r3, [r9, #28]
 8006b84:	429a      	cmp	r2, r3
 8006b86:	d00a      	beq.n	8006b9e <gc_execute_block+0x154e>
        sys.report.gwco = On;
 8006b88:	7d62      	ldrb	r2, [r4, #21]
        memcpy(&gc_state.modal.coord_system, &gc_block.modal.coord_system, sizeof(gc_state.modal.coord_system));
 8006b8a:	4b39      	ldr	r3, [pc, #228]	; (8006c70 <gc_execute_block+0x1620>)
        sys.report.gwco = On;
 8006b8c:	f042 0202 	orr.w	r2, r2, #2
        memcpy(&gc_state.modal.coord_system, &gc_block.modal.coord_system, sizeof(gc_state.modal.coord_system));
 8006b90:	4d38      	ldr	r5, [pc, #224]	; (8006c74 <gc_execute_block+0x1624>)
        sys.report.gwco = On;
 8006b92:	7562      	strb	r2, [r4, #21]
        memcpy(&gc_state.modal.coord_system, &gc_block.modal.coord_system, sizeof(gc_state.modal.coord_system));
 8006b94:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8006b96:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        system_flag_wco_change();
 8006b9a:	f00a fdad 	bl	80116f8 <system_flag_wco_change>
    gc_state.modal.distance_incremental = gc_block.modal.distance_incremental;
 8006b9e:	f899 300b 	ldrb.w	r3, [r9, #11]
 8006ba2:	492e      	ldr	r1, [pc, #184]	; (8006c5c <gc_execute_block+0x160c>)
    gc_state.modal.retract_mode = gc_block.modal.retract_mode;
 8006ba4:	f899 2025 	ldrb.w	r2, [r9, #37]	; 0x25
    gc_state.modal.distance_incremental = gc_block.modal.distance_incremental;
 8006ba8:	70cb      	strb	r3, [r1, #3]
    switch(gc_block.non_modal_command) {
 8006baa:	f899 3000 	ldrb.w	r3, [r9]
    gc_state.modal.retract_mode = gc_block.modal.retract_mode;
 8006bae:	774a      	strb	r2, [r1, #29]
    switch(gc_block.non_modal_command) {
 8006bb0:	2b28      	cmp	r3, #40	; 0x28
 8006bb2:	f200 815c 	bhi.w	8006e6e <gc_execute_block+0x181e>
 8006bb6:	2b09      	cmp	r3, #9
 8006bb8:	d87e      	bhi.n	8006cb8 <gc_execute_block+0x1668>
    gc_state.modal.motion = gc_block.modal.motion;
 8006bba:	f899 0008 	ldrb.w	r0, [r9, #8]
 8006bbe:	4a27      	ldr	r2, [pc, #156]	; (8006c5c <gc_execute_block+0x160c>)
    gc_state.modal.canned_cycle_active = gc_block.modal.canned_cycle_active;
 8006bc0:	f899 3027 	ldrb.w	r3, [r9, #39]	; 0x27
    if (gc_state.modal.motion != MotionMode_None && axis_command == AxisCommand_MotionMode) {
 8006bc4:	2850      	cmp	r0, #80	; 0x50
    gc_state.modal.motion = gc_block.modal.motion;
 8006bc6:	7010      	strb	r0, [r2, #0]
    gc_state.modal.canned_cycle_active = gc_block.modal.canned_cycle_active;
 8006bc8:	77d3      	strb	r3, [r2, #31]
    if (gc_state.modal.motion != MotionMode_None && axis_command == AxisCommand_MotionMode) {
 8006bca:	d003      	beq.n	8006bd4 <gc_execute_block+0x1584>
 8006bcc:	9b06      	ldr	r3, [sp, #24]
 8006bce:	2b02      	cmp	r3, #2
 8006bd0:	f000 861c 	beq.w	800780c <gc_execute_block+0x21bc>
    if(plan_data.message)
 8006bd4:	9826      	ldr	r0, [sp, #152]	; 0x98
 8006bd6:	b108      	cbz	r0, 8006bdc <gc_execute_block+0x158c>
        protocol_message(plan_data.message);
 8006bd8:	f004 fab2 	bl	800b140 <protocol_message>
    gc_state.modal.program_flow = gc_block.modal.program_flow;
 8006bdc:	f899 3020 	ldrb.w	r3, [r9, #32]
 8006be0:	4a1e      	ldr	r2, [pc, #120]	; (8006c5c <gc_execute_block+0x160c>)
 8006be2:	9304      	str	r3, [sp, #16]
 8006be4:	7613      	strb	r3, [r2, #24]
    if (gc_state.modal.program_flow) {
 8006be6:	2b00      	cmp	r3, #0
 8006be8:	f43e af77 	beq.w	8005ada <gc_execute_block+0x48a>
        protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
 8006bec:	f004 ff62 	bl	800bab4 <protocol_buffer_synchronize>
        if (gc_state.modal.program_flow == ProgramFlow_Paused || gc_block.modal.program_flow == ProgramFlow_OptionalStop) {
 8006bf0:	4b1a      	ldr	r3, [pc, #104]	; (8006c5c <gc_execute_block+0x160c>)
 8006bf2:	7e1b      	ldrb	r3, [r3, #24]
 8006bf4:	2b03      	cmp	r3, #3
 8006bf6:	f000 86e5 	beq.w	80079c4 <gc_execute_block+0x2374>
 8006bfa:	f899 3020 	ldrb.w	r3, [r9, #32]
 8006bfe:	2b01      	cmp	r3, #1
 8006c00:	f000 86e0 	beq.w	80079c4 <gc_execute_block+0x2374>
            gc_state.file_run = false;
 8006c04:	2300      	movs	r3, #0
            gc_state.modal.motion = MotionMode_Linear;
 8006c06:	2101      	movs	r1, #1
            gc_state.modal.spindle = (spindle_state_t){0};
 8006c08:	4814      	ldr	r0, [pc, #80]	; (8006c5c <gc_execute_block+0x160c>)
            gc_block.modal.canned_cycle_active = false;
 8006c0a:	f889 3027 	strb.w	r3, [r9, #39]	; 0x27
            gc_state.modal.spindle = (spindle_state_t){0};
 8006c0e:	8b42      	ldrh	r2, [r0, #26]
            gc_state.file_run = false;
 8006c10:	f880 307d 	strb.w	r3, [r0, #125]	; 0x7d
            gc_state.modal.spindle = (spindle_state_t){0};
 8006c14:	f422 62bf 	bic.w	r2, r2, #1528	; 0x5f8
 8006c18:	f022 0207 	bic.w	r2, r2, #7
 8006c1c:	8342      	strh	r2, [r0, #26]
            if(settings.parking.flags.enabled)
 8006c1e:	f89a 20d8 	ldrb.w	r2, [sl, #216]	; 0xd8
            gc_state.modal.plane_select = PlaneSelect_XY;
 8006c22:	7143      	strb	r3, [r0, #5]
            gc_state.modal.distance_incremental = false;
 8006c24:	70c3      	strb	r3, [r0, #3]
            gc_state.modal.coord_system.idx = 0; // G54
 8006c26:	7503      	strb	r3, [r0, #20]
            gc_state.modal.coolant = (coolant_state_t){0};
 8006c28:	7643      	strb	r3, [r0, #25]
            gc_state.modal.spindle_rpm_mode = SpindleSpeedMode_RPM; // NOTE: not compliant with linuxcnc (?)
 8006c2a:	7703      	strb	r3, [r0, #28]
            if(settings.parking.flags.enabled)
 8006c2c:	07d3      	lsls	r3, r2, #31
            gc_state.modal.motion = MotionMode_Linear;
 8006c2e:	8001      	strh	r1, [r0, #0]
            if(settings.parking.flags.enabled)
 8006c30:	d50b      	bpl.n	8006c4a <gc_execute_block+0x15fa>
                gc_state.modal.override_ctrl.parking_disable = settings.parking.flags.enable_override_control &&
 8006c32:	f002 0306 	and.w	r3, r2, #6
 8006c36:	f1a3 0c06 	sub.w	ip, r3, #6
 8006c3a:	7ec2      	ldrb	r2, [r0, #27]
 8006c3c:	f1dc 0300 	rsbs	r3, ip, #0
 8006c40:	eb43 030c 	adc.w	r3, r3, ip
 8006c44:	f363 02c3 	bfi	r2, r3, #3, #1
 8006c48:	76c2      	strb	r2, [r0, #27]
            sys.override.control = gc_state.modal.override_ctrl;
 8006c4a:	4a04      	ldr	r2, [pc, #16]	; (8006c5c <gc_execute_block+0x160c>)
            if(settings.flags.restore_overrides) {
 8006c4c:	f89a 30bc 	ldrb.w	r3, [sl, #188]	; 0xbc
            sys.override.control = gc_state.modal.override_ctrl;
 8006c50:	7ed2      	ldrb	r2, [r2, #27]
            if(settings.flags.restore_overrides) {
 8006c52:	06df      	lsls	r7, r3, #27
            sys.override.control = gc_state.modal.override_ctrl;
 8006c54:	74a2      	strb	r2, [r4, #18]
            if(settings.flags.restore_overrides) {
 8006c56:	d516      	bpl.n	8006c86 <gc_execute_block+0x1636>
 8006c58:	e010      	b.n	8006c7c <gc_execute_block+0x162c>
 8006c5a:	bf00      	nop
 8006c5c:	200023dc 	.word	0x200023dc
 8006c60:	200024bc 	.word	0x200024bc
 8006c64:	20002424 	.word	0x20002424
 8006c68:	20002494 	.word	0x20002494
 8006c6c:	20000980 	.word	0x20000980
 8006c70:	20000990 	.word	0x20000990
 8006c74:	200023e4 	.word	0x200023e4
 8006c78:	20002620 	.word	0x20002620
                sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;
 8006c7c:	f246 4264 	movw	r2, #25700	; 0x6464
                sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8006c80:	2364      	movs	r3, #100	; 0x64
                sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;
 8006c82:	81e2      	strh	r2, [r4, #14]
                sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE;
 8006c84:	7423      	strb	r3, [r4, #16]
            if (sys.state != STATE_CHECK_MODE) {
 8006c86:	6823      	ldr	r3, [r4, #0]
 8006c88:	2b02      	cmp	r3, #2
 8006c8a:	f041 81b5 	bne.w	8007ff8 <gc_execute_block+0x29a8>
 8006c8e:	4fb7      	ldr	r7, [pc, #732]	; (8006f6c <gc_execute_block+0x191c>)
            while(output_commands) {
 8006c90:	4db7      	ldr	r5, [pc, #732]	; (8006f70 <gc_execute_block+0x1920>)
 8006c92:	682c      	ldr	r4, [r5, #0]
 8006c94:	b134      	cbz	r4, 8006ca4 <gc_execute_block+0x1654>
                output_command_t *next = output_commands->next;
 8006c96:	4620      	mov	r0, r4
 8006c98:	68a4      	ldr	r4, [r4, #8]
                free(output_commands);
 8006c9a:	f00a ffcf 	bl	8011c3c <free>
                output_commands = next;
 8006c9e:	602c      	str	r4, [r5, #0]
            while(output_commands) {
 8006ca0:	2c00      	cmp	r4, #0
 8006ca2:	d1f8      	bne.n	8006c96 <gc_execute_block+0x1646>
            hal.report.feedback_message(Message_ProgramEnd);
 8006ca4:	2008      	movs	r0, #8
 8006ca6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8006caa:	4798      	blx	r3
        gc_state.modal.program_flow = ProgramFlow_Running; // Reset program flow.
 8006cac:	2300      	movs	r3, #0
 8006cae:	4ab1      	ldr	r2, [pc, #708]	; (8006f74 <gc_execute_block+0x1924>)
    return Status_OK;
 8006cb0:	9304      	str	r3, [sp, #16]
        gc_state.modal.program_flow = ProgramFlow_Running; // Reset program flow.
 8006cb2:	7613      	strb	r3, [r2, #24]
 8006cb4:	f7fe bf11 	b.w	8005ada <gc_execute_block+0x48a>
 8006cb8:	3b0a      	subs	r3, #10
 8006cba:	2b1e      	cmp	r3, #30
 8006cbc:	f63f af7d 	bhi.w	8006bba <gc_execute_block+0x156a>
 8006cc0:	a201      	add	r2, pc, #4	; (adr r2, 8006cc8 <gc_execute_block+0x1678>)
 8006cc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006cc6:	bf00      	nop
 8006cc8:	08006dd5 	.word	0x08006dd5
 8006ccc:	08006bbb 	.word	0x08006bbb
 8006cd0:	08006bbb 	.word	0x08006bbb
 8006cd4:	08006bbb 	.word	0x08006bbb
 8006cd8:	08006bbb 	.word	0x08006bbb
 8006cdc:	08006bbb 	.word	0x08006bbb
 8006ce0:	08006bbb 	.word	0x08006bbb
 8006ce4:	08006bbb 	.word	0x08006bbb
 8006ce8:	08006bbb 	.word	0x08006bbb
 8006cec:	08006bbb 	.word	0x08006bbb
 8006cf0:	08006bbb 	.word	0x08006bbb
 8006cf4:	08006bbb 	.word	0x08006bbb
 8006cf8:	08006bbb 	.word	0x08006bbb
 8006cfc:	08006bbb 	.word	0x08006bbb
 8006d00:	08006bbb 	.word	0x08006bbb
 8006d04:	08006bbb 	.word	0x08006bbb
 8006d08:	08006bbb 	.word	0x08006bbb
 8006d0c:	08006bbb 	.word	0x08006bbb
 8006d10:	08006d59 	.word	0x08006d59
 8006d14:	08006bbb 	.word	0x08006bbb
 8006d18:	08006d59 	.word	0x08006d59
 8006d1c:	08006bbb 	.word	0x08006bbb
 8006d20:	08006bbb 	.word	0x08006bbb
 8006d24:	08006bbb 	.word	0x08006bbb
 8006d28:	08006bbb 	.word	0x08006bbb
 8006d2c:	08006bbb 	.word	0x08006bbb
 8006d30:	08006bbb 	.word	0x08006bbb
 8006d34:	08006bbb 	.word	0x08006bbb
 8006d38:	08006d4f 	.word	0x08006d4f
 8006d3c:	08006bbb 	.word	0x08006bbb
 8006d40:	08006d45 	.word	0x08006d45
            settings_write_coord_data(SETTING_INDEX_G30, &gc_state.position);
 8006d44:	200a      	movs	r0, #10
 8006d46:	498c      	ldr	r1, [pc, #560]	; (8006f78 <gc_execute_block+0x1928>)
 8006d48:	f007 f9dc 	bl	800e104 <settings_write_coord_data>
            break;
 8006d4c:	e735      	b.n	8006bba <gc_execute_block+0x156a>
            settings_write_coord_data(SETTING_INDEX_G28, &gc_state.position);
 8006d4e:	2009      	movs	r0, #9
 8006d50:	4989      	ldr	r1, [pc, #548]	; (8006f78 <gc_execute_block+0x1928>)
 8006d52:	f007 f9d7 	bl	800e104 <settings_write_coord_data>
            break;
 8006d56:	e730      	b.n	8006bba <gc_execute_block+0x156a>
            plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 8006d58:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
 8006d5c:	f043 0301 	orr.w	r3, r3, #1
 8006d60:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
            if (axis_command)
 8006d64:	9b06      	ldr	r3, [sp, #24]
 8006d66:	2b00      	cmp	r3, #0
 8006d68:	f041 82c3 	bne.w	80082f2 <gc_execute_block+0x2ca2>
            mc_line(gc_block.values.coord_data.xyz, &plan_data);
 8006d6c:	4f83      	ldr	r7, [pc, #524]	; (8006f7c <gc_execute_block+0x192c>)
            memcpy(gc_state.position, gc_block.values.coord_data.xyz, sizeof(gc_state.position));
 8006d6e:	4e82      	ldr	r6, [pc, #520]	; (8006f78 <gc_execute_block+0x1928>)
        if(scale_factor.ijk[--idx] != 1.0f)
 8006d70:	4d83      	ldr	r5, [pc, #524]	; (8006f80 <gc_execute_block+0x1930>)
            mc_line(gc_block.values.coord_data.xyz, &plan_data);
 8006d72:	a91b      	add	r1, sp, #108	; 0x6c
 8006d74:	4638      	mov	r0, r7
 8006d76:	f001 ff67 	bl	8008c48 <mc_line>
            memcpy(gc_state.position, gc_block.values.coord_data.xyz, sizeof(gc_state.position));
 8006d7a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8006d7e:	e886 0007 	stmia.w	r6, {r0, r1, r2}
        if(scale_factor.ijk[--idx] != 1.0f)
 8006d82:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8006d86:	6968      	ldr	r0, [r5, #20]
 8006d88:	f7f9 fe98 	bl	8000abc <__aeabi_fcmpeq>
 8006d8c:	fab0 f380 	clz	r3, r0
 8006d90:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8006d94:	095b      	lsrs	r3, r3, #5
 8006d96:	6928      	ldr	r0, [r5, #16]
        scaled.value <<= 1;
 8006d98:	005e      	lsls	r6, r3, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8006d9a:	f7f9 fe8f 	bl	8000abc <__aeabi_fcmpeq>
 8006d9e:	b908      	cbnz	r0, 8006da4 <gc_execute_block+0x1754>
            scaled.value |= 0x01;
 8006da0:	f046 0601 	orr.w	r6, r6, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8006da4:	f04f 577e 	mov.w	r7, #1065353216	; 0x3f800000
 8006da8:	68e8      	ldr	r0, [r5, #12]
 8006daa:	4639      	mov	r1, r7
 8006dac:	f7f9 fe86 	bl	8000abc <__aeabi_fcmpeq>
        scaled.value <<= 1;
 8006db0:	0076      	lsls	r6, r6, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8006db2:	2800      	cmp	r0, #0
 8006db4:	f041 810d 	bne.w	8007fd2 <gc_execute_block+0x2982>
        scale_factor.xyz[idx] = 0.0f;
 8006db8:	2300      	movs	r3, #0
    gc_state.modal.scaling_active = factor != 1.0f;
 8006dba:	496e      	ldr	r1, [pc, #440]	; (8006f74 <gc_execute_block+0x1924>)
        scale_factor.ijk[--idx] = factor;
 8006dbc:	616f      	str	r7, [r5, #20]
 8006dbe:	612f      	str	r7, [r5, #16]
 8006dc0:	60ef      	str	r7, [r5, #12]
    gc_state.modal.scaling_active = factor != 1.0f;
 8006dc2:	7788      	strb	r0, [r1, #30]
        scale_factor.xyz[idx] = 0.0f;
 8006dc4:	60ab      	str	r3, [r5, #8]
 8006dc6:	606b      	str	r3, [r5, #4]
 8006dc8:	602b      	str	r3, [r5, #0]
        sys.report.scaling = On;
 8006dca:	7d23      	ldrb	r3, [r4, #20]
 8006dcc:	f043 0302 	orr.w	r3, r3, #2
 8006dd0:	7523      	strb	r3, [r4, #20]
 8006dd2:	e6f2      	b.n	8006bba <gc_execute_block+0x156a>
            settings_write_coord_data(gc_block.values.coord_data.idx, &gc_block.values.coord_data.xyz);
 8006dd4:	4d69      	ldr	r5, [pc, #420]	; (8006f7c <gc_execute_block+0x192c>)
 8006dd6:	f899 0074 	ldrb.w	r0, [r9, #116]	; 0x74
 8006dda:	4629      	mov	r1, r5
 8006ddc:	f007 f992 	bl	800e104 <settings_write_coord_data>
            if (gc_state.modal.coord_system.idx == gc_block.values.coord_data.idx) {
 8006de0:	4b64      	ldr	r3, [pc, #400]	; (8006f74 <gc_execute_block+0x1924>)
 8006de2:	7d1a      	ldrb	r2, [r3, #20]
 8006de4:	f899 3074 	ldrb.w	r3, [r9, #116]	; 0x74
 8006de8:	429a      	cmp	r2, r3
 8006dea:	f47f aee6 	bne.w	8006bba <gc_execute_block+0x156a>
                memcpy(gc_state.modal.coord_system.xyz, gc_block.values.coord_data.xyz, sizeof(gc_state.modal.coord_system.xyz));
 8006dee:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8006df2:	4b64      	ldr	r3, [pc, #400]	; (8006f84 <gc_execute_block+0x1934>)
 8006df4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                system_flag_wco_change();
 8006df8:	f00a fc7e 	bl	80116f8 <system_flag_wco_change>
 8006dfc:	e6dd      	b.n	8006bba <gc_execute_block+0x156a>
        switch(port_command) {
 8006dfe:	f1a3 063e 	sub.w	r6, r3, #62	; 0x3e
 8006e02:	2e06      	cmp	r6, #6
 8006e04:	f63f ae46 	bhi.w	8006a94 <gc_execute_block+0x1444>
 8006e08:	e8df f006 	tbb	[pc, r6]
 8006e0c:	20200404 	.word	0x20200404
 8006e10:	0413      	.short	0x0413
 8006e12:	07          	.byte	0x07
 8006e13:	00          	.byte	0x00
                add_output_command(&gc_block.output_command);
 8006e14:	f7fe fb38 	bl	8005488 <add_output_command.constprop.0>
                break;
 8006e18:	e63c      	b.n	8006a94 <gc_execute_block+0x1444>
                hal.port.analog_out(gc_block.output_command.port, gc_block.output_command.value);
 8006e1a:	f8d9 0084 	ldr.w	r0, [r9, #132]	; 0x84
 8006e1e:	f7f9 fc65 	bl	80006ec <__aeabi_i2f>
 8006e22:	4f52      	ldr	r7, [pc, #328]	; (8006f6c <gc_execute_block+0x191c>)
 8006e24:	4601      	mov	r1, r0
 8006e26:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8006e2a:	f899 0081 	ldrb.w	r0, [r9, #129]	; 0x81
 8006e2e:	4798      	blx	r3
                break;
 8006e30:	e630      	b.n	8006a94 <gc_execute_block+0x1444>
                hal.port.wait_on_input(gc_block.output_command.is_digital, gc_block.output_command.port, (wait_mode_t)gc_block.values.l, gc_block.values.q);
 8006e32:	4f4e      	ldr	r7, [pc, #312]	; (8006f6c <gc_execute_block+0x191c>)
 8006e34:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
 8006e38:	f8d7 4120 	ldr.w	r4, [r7, #288]	; 0x120
 8006e3c:	f899 207e 	ldrb.w	r2, [r9, #126]	; 0x7e
 8006e40:	f899 1081 	ldrb.w	r1, [r9, #129]	; 0x81
 8006e44:	f899 0080 	ldrb.w	r0, [r9, #128]	; 0x80
 8006e48:	47a0      	blx	r4
                break;
 8006e4a:	e623      	b.n	8006a94 <gc_execute_block+0x1444>
                hal.port.digital_out(gc_block.output_command.port, gc_block.output_command.value != 0.0f);
 8006e4c:	f8d9 0084 	ldr.w	r0, [r9, #132]	; 0x84
 8006e50:	f7f9 fc4c 	bl	80006ec <__aeabi_i2f>
 8006e54:	2100      	movs	r1, #0
 8006e56:	f7f9 fe31 	bl	8000abc <__aeabi_fcmpeq>
 8006e5a:	fab0 f180 	clz	r1, r0
 8006e5e:	4f43      	ldr	r7, [pc, #268]	; (8006f6c <gc_execute_block+0x191c>)
 8006e60:	f899 0081 	ldrb.w	r0, [r9, #129]	; 0x81
 8006e64:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8006e68:	0949      	lsrs	r1, r1, #5
 8006e6a:	4798      	blx	r3
                break;
 8006e6c:	e612      	b.n	8006a94 <gc_execute_block+0x1444>
    switch(gc_block.non_modal_command) {
 8006e6e:	3b5c      	subs	r3, #92	; 0x5c
 8006e70:	b2da      	uxtb	r2, r3
 8006e72:	2a1e      	cmp	r2, #30
 8006e74:	f63f aea1 	bhi.w	8006bba <gc_execute_block+0x156a>
 8006e78:	2b1e      	cmp	r3, #30
 8006e7a:	f63f ae9e 	bhi.w	8006bba <gc_execute_block+0x156a>
 8006e7e:	a201      	add	r2, pc, #4	; (adr r2, 8006e84 <gc_execute_block+0x1834>)
 8006e80:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006e84:	08006f35 	.word	0x08006f35
 8006e88:	08006bbb 	.word	0x08006bbb
 8006e8c:	08006bbb 	.word	0x08006bbb
 8006e90:	08006bbb 	.word	0x08006bbb
 8006e94:	08006bbb 	.word	0x08006bbb
 8006e98:	08006bbb 	.word	0x08006bbb
 8006e9c:	08006bbb 	.word	0x08006bbb
 8006ea0:	08006bbb 	.word	0x08006bbb
 8006ea4:	08006bbb 	.word	0x08006bbb
 8006ea8:	08006bbb 	.word	0x08006bbb
 8006eac:	08006f1f 	.word	0x08006f1f
 8006eb0:	08006bbb 	.word	0x08006bbb
 8006eb4:	08006bbb 	.word	0x08006bbb
 8006eb8:	08006bbb 	.word	0x08006bbb
 8006ebc:	08006bbb 	.word	0x08006bbb
 8006ec0:	08006bbb 	.word	0x08006bbb
 8006ec4:	08006bbb 	.word	0x08006bbb
 8006ec8:	08006bbb 	.word	0x08006bbb
 8006ecc:	08006bbb 	.word	0x08006bbb
 8006ed0:	08006bbb 	.word	0x08006bbb
 8006ed4:	08006f0f 	.word	0x08006f0f
 8006ed8:	08006bbb 	.word	0x08006bbb
 8006edc:	08006bbb 	.word	0x08006bbb
 8006ee0:	08006bbb 	.word	0x08006bbb
 8006ee4:	08006bbb 	.word	0x08006bbb
 8006ee8:	08006bbb 	.word	0x08006bbb
 8006eec:	08006bbb 	.word	0x08006bbb
 8006ef0:	08006bbb 	.word	0x08006bbb
 8006ef4:	08006bbb 	.word	0x08006bbb
 8006ef8:	08006bbb 	.word	0x08006bbb
 8006efc:	08006f01 	.word	0x08006f01
            settings_read_coord_data(SETTING_INDEX_G92, &gc_state.g92_coord_offset); // Restore G92 offsets from EEPROM
 8006f00:	4921      	ldr	r1, [pc, #132]	; (8006f88 <gc_execute_block+0x1938>)
 8006f02:	200b      	movs	r0, #11
 8006f04:	f007 f914 	bl	800e130 <settings_read_coord_data>
            system_flag_wco_change();
 8006f08:	f00a fbf6 	bl	80116f8 <system_flag_wco_change>
            break;
 8006f0c:	e655      	b.n	8006bba <gc_execute_block+0x156a>
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 8006f0e:	2200      	movs	r2, #0
 8006f10:	4b1d      	ldr	r3, [pc, #116]	; (8006f88 <gc_execute_block+0x1938>)
 8006f12:	e9c3 2200 	strd	r2, r2, [r3]
 8006f16:	609a      	str	r2, [r3, #8]
            system_flag_wco_change();
 8006f18:	f00a fbee 	bl	80116f8 <system_flag_wco_change>
            break;
 8006f1c:	e64d      	b.n	8006bba <gc_execute_block+0x156a>
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 8006f1e:	2300      	movs	r3, #0
 8006f20:	4919      	ldr	r1, [pc, #100]	; (8006f88 <gc_execute_block+0x1938>)
            settings_write_coord_data(SETTING_INDEX_G92, &gc_state.g92_coord_offset); // Save G92 offsets to EEPROM
 8006f22:	200b      	movs	r0, #11
            clear_vector(gc_state.g92_coord_offset); // Disable G92 offsets by zeroing offset vector.
 8006f24:	e9c1 3300 	strd	r3, r3, [r1]
 8006f28:	608b      	str	r3, [r1, #8]
            settings_write_coord_data(SETTING_INDEX_G92, &gc_state.g92_coord_offset); // Save G92 offsets to EEPROM
 8006f2a:	f007 f8eb 	bl	800e104 <settings_write_coord_data>
            system_flag_wco_change();
 8006f2e:	f00a fbe3 	bl	80116f8 <system_flag_wco_change>
            break;
 8006f32:	e642      	b.n	8006bba <gc_execute_block+0x156a>
            memcpy(gc_state.g92_coord_offset, gc_block.values.xyz, sizeof(gc_state.g92_coord_offset));
 8006f34:	4d15      	ldr	r5, [pc, #84]	; (8006f8c <gc_execute_block+0x193c>)
 8006f36:	4b14      	ldr	r3, [pc, #80]	; (8006f88 <gc_execute_block+0x1938>)
 8006f38:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8006f3c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
            system_flag_wco_change();
 8006f40:	f00a fbda 	bl	80116f8 <system_flag_wco_change>
            break;
 8006f44:	e639      	b.n	8006bba <gc_execute_block+0x156a>
                gc_state.spindle.css.max_rpm = settings.spindle.rpm_max;
 8006f46:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006f48:	4a0a      	ldr	r2, [pc, #40]	; (8006f74 <gc_execute_block+0x1924>)
 8006f4a:	6553      	str	r3, [r2, #84]	; 0x54
 8006f4c:	f7ff ba6a 	b.w	8006424 <gc_execute_block+0xdd4>
                            axis_command = AxisCommand_NonModal;
 8006f50:	2201      	movs	r2, #1
                        } else if (int_value == 92) {
 8006f52:	9b06      	ldr	r3, [sp, #24]
                            axis_command = AxisCommand_NonModal;
 8006f54:	9206      	str	r2, [sp, #24]
 8006f56:	f7fe bd9c 	b.w	8005a92 <gc_execute_block+0x442>
            FAIL(Status_GcodeUnsupportedCoordSys); // [Greater than N sys]
 8006f5a:	231d      	movs	r3, #29
 8006f5c:	9304      	str	r3, [sp, #16]
 8006f5e:	f7fe bdbc 	b.w	8005ada <gc_execute_block+0x48a>
                    gc_block.values.xyz[idx] = gc_state.g92_coord_offset[idx];
 8006f62:	4b04      	ldr	r3, [pc, #16]	; (8006f74 <gc_execute_block+0x1924>)
 8006f64:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006f68:	e42c      	b.n	80067c4 <gc_execute_block+0x1174>
 8006f6a:	bf00      	nop
 8006f6c:	200024bc 	.word	0x200024bc
 8006f70:	20000a0c 	.word	0x20000a0c
 8006f74:	200023dc 	.word	0x200023dc
 8006f78:	20002448 	.word	0x20002448
 8006f7c:	200009e8 	.word	0x200009e8
 8006f80:	20000a10 	.word	0x20000a10
 8006f84:	200023e4 	.word	0x200023e4
 8006f88:	20002460 	.word	0x20002460
 8006f8c:	200009dc 	.word	0x200009dc
        if(scale_factor.ijk[--idx] != 1.0f)
 8006f90:	4da5      	ldr	r5, [pc, #660]	; (8007228 <gc_execute_block+0x1bd8>)
 8006f92:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8006f96:	6968      	ldr	r0, [r5, #20]
 8006f98:	f7f9 fd90 	bl	8000abc <__aeabi_fcmpeq>
 8006f9c:	fab0 f480 	clz	r4, r0
 8006fa0:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8006fa4:	0964      	lsrs	r4, r4, #5
 8006fa6:	6928      	ldr	r0, [r5, #16]
        scaled.value <<= 1;
 8006fa8:	0064      	lsls	r4, r4, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8006faa:	f7f9 fd87 	bl	8000abc <__aeabi_fcmpeq>
 8006fae:	b908      	cbnz	r0, 8006fb4 <gc_execute_block+0x1964>
            scaled.value |= 0x01;
 8006fb0:	f044 0401 	orr.w	r4, r4, #1
        if(scale_factor.ijk[--idx] != 1.0f)
 8006fb4:	f04f 5a7e 	mov.w	sl, #1065353216	; 0x3f800000
 8006fb8:	68e8      	ldr	r0, [r5, #12]
 8006fba:	4651      	mov	r1, sl
 8006fbc:	f7f9 fd7e 	bl	8000abc <__aeabi_fcmpeq>
        scaled.value <<= 1;
 8006fc0:	0064      	lsls	r4, r4, #1
        scale_factor.xyz[idx] = 0.0f;
 8006fc2:	2200      	movs	r2, #0
        scale_factor.ijk[--idx] = factor;
 8006fc4:	f8c5 a014 	str.w	sl, [r5, #20]
 8006fc8:	f8c5 a010 	str.w	sl, [r5, #16]
 8006fcc:	f8c5 a00c 	str.w	sl, [r5, #12]
        if(scale_factor.ijk[--idx] != 1.0f)
 8006fd0:	2800      	cmp	r0, #0
 8006fd2:	f040 80ee 	bne.w	80071b2 <gc_execute_block+0x1b62>
    gc_state.modal.scaling_active = factor != 1.0f;
 8006fd6:	4995      	ldr	r1, [pc, #596]	; (800722c <gc_execute_block+0x1bdc>)
        scale_factor.xyz[idx] = 0.0f;
 8006fd8:	60aa      	str	r2, [r5, #8]
    gc_state.modal.scaling_active = factor != 1.0f;
 8006fda:	7788      	strb	r0, [r1, #30]
        scale_factor.xyz[idx] = 0.0f;
 8006fdc:	606a      	str	r2, [r5, #4]
 8006fde:	602a      	str	r2, [r5, #0]
        sys.report.scaling = On;
 8006fe0:	4c93      	ldr	r4, [pc, #588]	; (8007230 <gc_execute_block+0x1be0>)
 8006fe2:	7d23      	ldrb	r3, [r4, #20]
 8006fe4:	f043 0302 	orr.w	r3, r3, #2
 8006fe8:	7523      	strb	r3, [r4, #20]
 8006fea:	f7ff b8fc 	b.w	80061e6 <gc_execute_block+0xb96>
                    gc_block.values.xyz[idx] = gc_state.position[idx] - gc_block.modal.coord_system.xyz[idx] - gc_block.values.xyz[idx] - gc_state.tool_length_offset[idx];
 8006fee:	f8d9 1014 	ldr.w	r1, [r9, #20]
 8006ff2:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 8006ff6:	f7f9 fac5 	bl	8000584 <__addsf3>
 8006ffa:	4b8c      	ldr	r3, [pc, #560]	; (800722c <gc_execute_block+0x1bdc>)
 8006ffc:	4601      	mov	r1, r0
 8006ffe:	461c      	mov	r4, r3
 8007000:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8007002:	f7f9 fabd 	bl	8000580 <__aeabi_fsub>
 8007006:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 800700a:	f7f9 fab9 	bl	8000580 <__aeabi_fsub>
 800700e:	4603      	mov	r3, r0
 8007010:	f7ff bbc1 	b.w	8006796 <gc_execute_block+0x1146>
 8007014:	f8d9 1018 	ldr.w	r1, [r9, #24]
 8007018:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 800701c:	f7f9 fab2 	bl	8000584 <__addsf3>
 8007020:	4b82      	ldr	r3, [pc, #520]	; (800722c <gc_execute_block+0x1bdc>)
 8007022:	4601      	mov	r1, r0
 8007024:	461c      	mov	r4, r3
 8007026:	6f58      	ldr	r0, [r3, #116]	; 0x74
 8007028:	f7f9 faaa 	bl	8000580 <__aeabi_fsub>
 800702c:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 8007030:	f7f9 faa6 	bl	8000580 <__aeabi_fsub>
 8007034:	4603      	mov	r3, r0
 8007036:	f7ff bba5 	b.w	8006784 <gc_execute_block+0x1134>
                if(bit_isfalse(value_words, bit(Word_L)|bit(Word_Q)))
 800703a:	f248 0340 	movw	r3, #32832	; 0x8040
 800703e:	ea1a 0f03 	tst.w	sl, r3
 8007042:	f43f aa91 	beq.w	8006568 <gc_execute_block+0xf18>
                if(bit_istrue(value_words, bit(Word_P)) && bit_istrue(value_words, bit(Word_E)))
 8007046:	f240 1301 	movw	r3, #257	; 0x101
 800704a:	ea33 030a 	bics.w	r3, r3, sl
 800704e:	f001 8078 	beq.w	8008142 <gc_execute_block+0x2af2>
                if(gc_block.values.l >= (uint8_t)WaitMode_Max)
 8007052:	f899 507e 	ldrb.w	r5, [r9, #126]	; 0x7e
 8007056:	2d04      	cmp	r5, #4
 8007058:	f200 8230 	bhi.w	80074bc <gc_execute_block+0x1e6c>
                if((wait_mode_t)gc_block.values.l != WaitMode_Immediate && gc_block.values.q == 0.0f)
 800705c:	b13d      	cbz	r5, 800706e <gc_execute_block+0x1a1e>
 800705e:	2100      	movs	r1, #0
 8007060:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
 8007064:	f7f9 fd2a 	bl	8000abc <__aeabi_fcmpeq>
 8007068:	2800      	cmp	r0, #0
 800706a:	f040 8227 	bne.w	80074bc <gc_execute_block+0x1e6c>
                if(bit_istrue(value_words, bit(Word_P))) {
 800706e:	f41a 7f80 	tst.w	sl, #256	; 0x100
 8007072:	d013      	beq.n	800709c <gc_execute_block+0x1a4c>
                    if((uint32_t)gc_block.values.p + 1 > hal.port.num_digital)
 8007074:	f8d9 604c 	ldr.w	r6, [r9, #76]	; 0x4c
 8007078:	4f6e      	ldr	r7, [pc, #440]	; (8007234 <gc_execute_block+0x1be4>)
 800707a:	4630      	mov	r0, r6
 800707c:	f7f9 fd8c 	bl	8000b98 <__aeabi_f2uiz>
 8007080:	f897 2114 	ldrb.w	r2, [r7, #276]	; 0x114
 8007084:	1c43      	adds	r3, r0, #1
 8007086:	4293      	cmp	r3, r2
 8007088:	f200 8218 	bhi.w	80074bc <gc_execute_block+0x1e6c>
                    gc_block.output_command.is_digital = true;
 800708c:	2301      	movs	r3, #1
                    gc_block.output_command.port = (uint8_t)gc_block.values.p;
 800708e:	4630      	mov	r0, r6
                    gc_block.output_command.is_digital = true;
 8007090:	f889 3080 	strb.w	r3, [r9, #128]	; 0x80
                    gc_block.output_command.port = (uint8_t)gc_block.values.p;
 8007094:	f7f9 fd80 	bl	8000b98 <__aeabi_f2uiz>
 8007098:	f889 0081 	strb.w	r0, [r9, #129]	; 0x81
                if(bit_istrue(value_words, bit(Word_E))) {
 800709c:	f01a 0f01 	tst.w	sl, #1
 80070a0:	d015      	beq.n	80070ce <gc_execute_block+0x1a7e>
                    if((uint32_t)gc_block.values.e + 1 > hal.port.num_analog)
 80070a2:	f8d9 6034 	ldr.w	r6, [r9, #52]	; 0x34
 80070a6:	4f63      	ldr	r7, [pc, #396]	; (8007234 <gc_execute_block+0x1be4>)
 80070a8:	4630      	mov	r0, r6
 80070aa:	f7f9 fd75 	bl	8000b98 <__aeabi_f2uiz>
 80070ae:	f897 2115 	ldrb.w	r2, [r7, #277]	; 0x115
 80070b2:	1c43      	adds	r3, r0, #1
 80070b4:	4293      	cmp	r3, r2
 80070b6:	f200 8201 	bhi.w	80074bc <gc_execute_block+0x1e6c>
                    if((wait_mode_t)gc_block.values.l != WaitMode_Immediate)
 80070ba:	2d00      	cmp	r5, #0
 80070bc:	f040 81fe 	bne.w	80074bc <gc_execute_block+0x1e6c>
                    gc_block.output_command.port = (uint8_t)gc_block.values.e;
 80070c0:	4630      	mov	r0, r6
                    gc_block.output_command.is_digital = false;
 80070c2:	f889 5080 	strb.w	r5, [r9, #128]	; 0x80
                    gc_block.output_command.port = (uint8_t)gc_block.values.e;
 80070c6:	f7f9 fd67 	bl	8000b98 <__aeabi_f2uiz>
 80070ca:	f889 0081 	strb.w	r0, [r9, #129]	; 0x81
                bit_false(value_words, bit(Word_E)|bit(Word_L)|bit(Word_P)|bit(Word_Q));
 80070ce:	f42a 4301 	bic.w	r3, sl, #33024	; 0x8100
 80070d2:	f023 0341 	bic.w	r3, r3, #65	; 0x41
 80070d6:	9315      	str	r3, [sp, #84]	; 0x54
                break;
 80070d8:	f7fe bc2d 	b.w	8005936 <gc_execute_block+0x2e6>
            } while(idx);
 80070dc:	2201      	movs	r2, #1
            bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 80070de:	9d15      	ldr	r5, [sp, #84]	; 0x54
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 80070e0:	7d23      	ldrb	r3, [r4, #20]
            bit_false(value_words, AXIS_WORDS_MASK); // Remove axis words.
 80070e2:	f425 45e0 	bic.w	r5, r5, #28672	; 0x7000
 80070e6:	9515      	str	r5, [sp, #84]	; 0x54
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 80070e8:	079d      	lsls	r5, r3, #30
 80070ea:	f889 2026 	strb.w	r2, [r9, #38]	; 0x26
 80070ee:	f100 82c9 	bmi.w	8007684 <gc_execute_block+0x2034>
 80070f2:	4653      	mov	r3, sl
 80070f4:	f7ff baa0 	b.w	8006638 <gc_execute_block+0xfe8>
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 80070f8:	7d23      	ldrb	r3, [r4, #20]
 80070fa:	079d      	lsls	r5, r3, #30
 80070fc:	f140 82d7 	bpl.w	80076ae <gc_execute_block+0x205e>
 8007100:	4653      	mov	r3, sl
 8007102:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 8007106:	4d48      	ldr	r5, [pc, #288]	; (8007228 <gc_execute_block+0x1bd8>)
 8007108:	7d22      	ldrb	r2, [r4, #20]
                    scale_factor.ijk[idx] = gc_block.values.xyz[idx];
 800710a:	6169      	str	r1, [r5, #20]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 800710c:	f363 0241 	bfi	r2, r3, #1, #1
                    bit_false(axis_words, bit(idx));
 8007110:	9b04      	ldr	r3, [sp, #16]
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8007112:	7522      	strb	r2, [r4, #20]
                    bit_false(axis_words, bit(idx));
 8007114:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
 8007118:	461a      	mov	r2, r3
 800711a:	9304      	str	r3, [sp, #16]
 800711c:	f7ff ba42 	b.w	80065a4 <gc_execute_block+0xf54>
                if(bit_istrue(axis_words, bit(--idx))) {
 8007120:	9b04      	ldr	r3, [sp, #16]
 8007122:	07db      	lsls	r3, r3, #31
 8007124:	d5da      	bpl.n	80070dc <gc_execute_block+0x1a8c>
 8007126:	4653      	mov	r3, sl
 8007128:	f7ff ba62 	b.w	80065f0 <gc_execute_block+0xfa0>
        FAIL(Status_GcodeToolChangePending); // [Motions (except jogging) not allowed when changing tool]
 800712c:	2328      	movs	r3, #40	; 0x28
 800712e:	9304      	str	r3, [sp, #16]
 8007130:	f7fe bcd3 	b.w	8005ada <gc_execute_block+0x48a>
            gc_block.values.k = gc_block.modal.units_imperial ? gc_block.values.ijk[K_VALUE] *= MM_PER_INCH : gc_block.values.ijk[K_VALUE];
 8007134:	f8d9 3044 	ldr.w	r3, [r9, #68]	; 0x44
 8007138:	f7ff bb16 	b.w	8006768 <gc_execute_block+0x1118>
                    FAIL(Status_SettingReadFail);
 800713c:	2307      	movs	r3, #7
 800713e:	9304      	str	r3, [sp, #16]
 8007140:	f7fe bccb 	b.w	8005ada <gc_execute_block+0x48a>
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007144:	9b04      	ldr	r3, [sp, #16]
 8007146:	079a      	lsls	r2, r3, #30
 8007148:	f140 84fe 	bpl.w	8007b48 <gc_execute_block+0x24f8>
 800714c:	9b04      	ldr	r3, [sp, #16]
 800714e:	07de      	lsls	r6, r3, #31
 8007150:	f140 82d0 	bpl.w	80076f4 <gc_execute_block+0x20a4>
                    if (!(gc_block.modal.motion == MotionMode_Seek || gc_block.modal.motion == MotionMode_Linear))
 8007154:	f899 4008 	ldrb.w	r4, [r9, #8]
 8007158:	2c01      	cmp	r4, #1
 800715a:	f67f aac7 	bls.w	80066ec <gc_execute_block+0x109c>
                        FAIL(Status_GcodeG53InvalidMotionMode); // [G53 G0/1 not active]
 800715e:	231e      	movs	r3, #30
 8007160:	9304      	str	r3, [sp, #16]
 8007162:	f7fe bcba 	b.w	8005ada <gc_execute_block+0x48a>
 8007166:	f003 0540 	and.w	r5, r3, #64	; 0x40
 800716a:	e465      	b.n	8006a38 <gc_execute_block+0x13e8>
    if ((gc_state.spindle.rpm != gc_block.values.s) || gc_parser_flags.spindle_force_sync) {
 800716c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 8007170:	0691      	lsls	r1, r2, #26
 8007172:	b2d3      	uxtb	r3, r2
 8007174:	f53f ac4d 	bmi.w	8006a12 <gc_execute_block+0x13c2>
 8007178:	f003 0540 	and.w	r5, r3, #64	; 0x40
 800717c:	e45e      	b.n	8006a3c <gc_execute_block+0x13ec>
            if ((gc_state.modal.motion == MotionMode_Linear) || (gc_state.modal.motion == MotionMode_CwArc) || (gc_state.modal.motion == MotionMode_CcwArc)) {
 800717e:	4a2b      	ldr	r2, [pc, #172]	; (800722c <gc_execute_block+0x1bdc>)
                if (gc_parser_flags.laser_disable)
 8007180:	f8bd 101c 	ldrh.w	r1, [sp, #28]
            if ((gc_state.modal.motion == MotionMode_Linear) || (gc_state.modal.motion == MotionMode_CwArc) || (gc_state.modal.motion == MotionMode_CcwArc)) {
 8007184:	7812      	ldrb	r2, [r2, #0]
 8007186:	3a01      	subs	r2, #1
 8007188:	2a02      	cmp	r2, #2
                if (gc_parser_flags.laser_disable)
 800718a:	460a      	mov	r2, r1
            if ((gc_state.modal.motion == MotionMode_Linear) || (gc_state.modal.motion == MotionMode_CwArc) || (gc_state.modal.motion == MotionMode_CcwArc)) {
 800718c:	f200 8718 	bhi.w	8007fc0 <gc_execute_block+0x2970>
                if (gc_parser_flags.laser_disable)
 8007190:	0651      	lsls	r1, r2, #25
 8007192:	f100 8718 	bmi.w	8007fc6 <gc_execute_block+0x2976>
        gc_state.is_rpm_rate_adjusted = gc_state.modal.spindle.ccw && !gc_parser_flags.laser_disable && hal.driver_cap.variable_spindle;
 8007196:	0799      	lsls	r1, r3, #30
 8007198:	f53f abfc 	bmi.w	8006994 <gc_execute_block+0x1344>
                axis_command = AxisCommand_None;
 800719c:	2300      	movs	r3, #0
 800719e:	e400      	b.n	80069a2 <gc_execute_block+0x1352>
                    if (bit_istrue(value_words, bit(Word_R)))
 80071a0:	0599      	lsls	r1, r3, #22
 80071a2:	f53e ac98 	bmi.w	8005ad6 <gc_execute_block+0x486>
 80071a6:	f7ff bb28 	b.w	80067fa <gc_execute_block+0x11aa>
            FAIL(Status_InvalidJogCommand);
 80071aa:	2310      	movs	r3, #16
 80071ac:	9304      	str	r3, [sp, #16]
 80071ae:	f7fe bc94 	b.w	8005ada <gc_execute_block+0x48a>
        scale_factor.xyz[idx] = 0.0f;
 80071b2:	2300      	movs	r3, #0
    gc_state.modal.scaling_active = factor != 1.0f;
 80071b4:	491d      	ldr	r1, [pc, #116]	; (800722c <gc_execute_block+0x1bdc>)
        scale_factor.xyz[idx] = 0.0f;
 80071b6:	60ab      	str	r3, [r5, #8]
    gc_state.modal.scaling_active = factor != 1.0f;
 80071b8:	778a      	strb	r2, [r1, #30]
        scale_factor.xyz[idx] = 0.0f;
 80071ba:	606b      	str	r3, [r5, #4]
 80071bc:	602b      	str	r3, [r5, #0]
    if(state.value != gc_get_g51_state().value)
 80071be:	2c00      	cmp	r4, #0
 80071c0:	f43f a811 	beq.w	80061e6 <gc_execute_block+0xb96>
 80071c4:	e70c      	b.n	8006fe0 <gc_execute_block+0x1990>
            if(!gc_block.modal.canned_cycle_active)
 80071c6:	f899 3027 	ldrb.w	r3, [r9, #39]	; 0x27
 80071ca:	930f      	str	r3, [sp, #60]	; 0x3c
 80071cc:	b90b      	cbnz	r3, 80071d2 <gc_execute_block+0x1b82>
                gc_block.modal.retract_mode = CCRetractMode_Previous;
 80071ce:	f889 3025 	strb.w	r3, [r9, #37]	; 0x25
            if(gc_block.modal.spindle_rpm_mode == SpindleSpeedMode_CSS && (!gc_block.modal.spindle.on || gc_block.values.s == 0.0f))
 80071d2:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
 80071d6:	2b01      	cmp	r3, #1
 80071d8:	f000 82bb 	beq.w	8007752 <gc_execute_block+0x2102>
            if (gc_block.modal.motion == MotionMode_SpindleSynchronized) {
 80071dc:	2c21      	cmp	r4, #33	; 0x21
 80071de:	f000 8165 	beq.w	80074ac <gc_execute_block+0x1e5c>
            } else if (gc_block.modal.motion == MotionMode_Threading) {
 80071e2:	2c4c      	cmp	r4, #76	; 0x4c
 80071e4:	f000 84ce 	beq.w	8007b84 <gc_execute_block+0x2534>
            } else if (gc_block.values.f == 0.0f)
 80071e8:	2100      	movs	r1, #0
 80071ea:	f8d9 0038 	ldr.w	r0, [r9, #56]	; 0x38
 80071ee:	f7f9 fc65 	bl	8000abc <__aeabi_fcmpeq>
 80071f2:	2800      	cmp	r0, #0
 80071f4:	f47f ab68 	bne.w	80068c8 <gc_execute_block+0x1278>
            if (gc_block.modal.canned_cycle_active) {
 80071f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80071fa:	2b00      	cmp	r3, #0
 80071fc:	f040 861c 	bne.w	8007e38 <gc_execute_block+0x27e8>
            } else switch (gc_block.modal.motion) {
 8007200:	2c05      	cmp	r4, #5
 8007202:	f200 8735 	bhi.w	8008070 <gc_execute_block+0x2a20>
 8007206:	1e63      	subs	r3, r4, #1
 8007208:	2b04      	cmp	r3, #4
 800720a:	f63f a85f 	bhi.w	80062cc <gc_execute_block+0xc7c>
 800720e:	a201      	add	r2, pc, #4	; (adr r2, 8007214 <gc_execute_block+0x1bc4>)
 8007210:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007214:	0800749d 	.word	0x0800749d
 8007218:	0800731b 	.word	0x0800731b
 800721c:	08007327 	.word	0x08007327
 8007220:	080062cd 	.word	0x080062cd
 8007224:	08007239 	.word	0x08007239
 8007228:	20000a10 	.word	0x20000a10
 800722c:	200023dc 	.word	0x200023dc
 8007230:	20002494 	.word	0x20002494
 8007234:	200024bc 	.word	0x200024bc
                    if(gc_block.modal.plane_select != PlaneSelect_XY)
 8007238:	f899 300d 	ldrb.w	r3, [r9, #13]
 800723c:	2b00      	cmp	r3, #0
 800723e:	f041 8062 	bne.w	8008306 <gc_execute_block+0x2cb6>
                    if (axis_words & ~(bit(X_AXIS)|bit(Y_AXIS)))
 8007242:	9b04      	ldr	r3, [sp, #16]
 8007244:	f033 0303 	bics.w	r3, r3, #3
 8007248:	f47f ab49 	bne.w	80068de <gc_execute_block+0x128e>
                    if((value_words & (bit(Word_P)|bit(Word_Q))) != (bit(Word_P)|bit(Word_Q)))
 800724c:	9f15      	ldr	r7, [sp, #84]	; 0x54
 800724e:	f407 4301 	and.w	r3, r7, #33024	; 0x8100
 8007252:	f5b3 4f01 	cmp.w	r3, #33024	; 0x8100
 8007256:	f47f a987 	bne.w	8006568 <gc_execute_block+0xf18>
                    if(gc_parser_flags.motion_mode_changed && (value_words & (bit(Word_I)|bit(Word_J))) != (bit(Word_I)|bit(Word_J)))
 800725a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800725e:	059d      	lsls	r5, r3, #22
 8007260:	f141 806c 	bpl.w	800833c <gc_execute_block+0x2cec>
 8007264:	f007 0318 	and.w	r3, r7, #24
 8007268:	2b18      	cmp	r3, #24
 800726a:	f47f a97d 	bne.w	8006568 <gc_execute_block+0xf18>
                        if (gc_block.modal.units_imperial) {
 800726e:	f899 300a 	ldrb.w	r3, [r9, #10]
 8007272:	2b00      	cmp	r3, #0
 8007274:	f001 804b 	beq.w	800830e <gc_execute_block+0x2cbe>
                            gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 8007278:	49ae      	ldr	r1, [pc, #696]	; (8007534 <gc_execute_block+0x1ee4>)
 800727a:	f8d9 003c 	ldr.w	r0, [r9, #60]	; 0x3c
 800727e:	f7f9 fa89 	bl	8000794 <__aeabi_fmul>
 8007282:	4682      	mov	sl, r0
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8007284:	49ab      	ldr	r1, [pc, #684]	; (8007534 <gc_execute_block+0x1ee4>)
 8007286:	f8d9 0040 	ldr.w	r0, [r9, #64]	; 0x40
                            gc_block.values.ijk[I_VALUE] *= MM_PER_INCH;
 800728a:	f8c9 a03c 	str.w	sl, [r9, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 800728e:	f7f9 fa81 	bl	8000794 <__aeabi_fmul>
                        if(gc_state.modal.scaling_active) {
 8007292:	4ba9      	ldr	r3, [pc, #676]	; (8007538 <gc_execute_block+0x1ee8>)
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8007294:	4606      	mov	r6, r0
                        if(gc_state.modal.scaling_active) {
 8007296:	7f9b      	ldrb	r3, [r3, #30]
                            gc_block.values.ijk[J_VALUE] *= MM_PER_INCH;
 8007298:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
                        if(gc_state.modal.scaling_active) {
 800729c:	b16b      	cbz	r3, 80072ba <gc_execute_block+0x1c6a>
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 800729e:	4da7      	ldr	r5, [pc, #668]	; (800753c <gc_execute_block+0x1eec>)
 80072a0:	4651      	mov	r1, sl
 80072a2:	68e8      	ldr	r0, [r5, #12]
 80072a4:	f7f9 fa76 	bl	8000794 <__aeabi_fmul>
 80072a8:	4603      	mov	r3, r0
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 80072aa:	4631      	mov	r1, r6
 80072ac:	6928      	ldr	r0, [r5, #16]
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 80072ae:	f8c9 303c 	str.w	r3, [r9, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 80072b2:	f7f9 fa6f 	bl	8000794 <__aeabi_fmul>
 80072b6:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
                        gc_block.values.p *= MM_PER_INCH;
 80072ba:	499e      	ldr	r1, [pc, #632]	; (8007534 <gc_execute_block+0x1ee4>)
 80072bc:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80072c0:	f7f9 fa68 	bl	8000794 <__aeabi_fmul>
 80072c4:	4603      	mov	r3, r0
                        gc_block.values.q *= MM_PER_INCH;
 80072c6:	499b      	ldr	r1, [pc, #620]	; (8007534 <gc_execute_block+0x1ee4>)
 80072c8:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
                        gc_block.values.p *= MM_PER_INCH;
 80072cc:	f8c9 304c 	str.w	r3, [r9, #76]	; 0x4c
                        gc_block.values.q *= MM_PER_INCH;
 80072d0:	f7f9 fa60 	bl	8000794 <__aeabi_fmul>
 80072d4:	f8c9 0050 	str.w	r0, [r9, #80]	; 0x50
                    if(gc_state.modal.scaling_active) {
 80072d8:	4b97      	ldr	r3, [pc, #604]	; (8007538 <gc_execute_block+0x1ee8>)
 80072da:	7f9b      	ldrb	r3, [r3, #30]
 80072dc:	b17b      	cbz	r3, 80072fe <gc_execute_block+0x1cae>
 80072de:	4d97      	ldr	r5, [pc, #604]	; (800753c <gc_execute_block+0x1eec>)
                        gc_block.values.p *= scale_factor.ijk[X_AXIS];
 80072e0:	68e9      	ldr	r1, [r5, #12]
 80072e2:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80072e6:	f7f9 fa55 	bl	8000794 <__aeabi_fmul>
 80072ea:	4603      	mov	r3, r0
                        gc_block.values.q *= scale_factor.ijk[Y_AXIS];
 80072ec:	6929      	ldr	r1, [r5, #16]
 80072ee:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
                        gc_block.values.p *= scale_factor.ijk[X_AXIS];
 80072f2:	f8c9 304c 	str.w	r3, [r9, #76]	; 0x4c
                        gc_block.values.q *= scale_factor.ijk[Y_AXIS];
 80072f6:	f7f9 fa4d 	bl	8000794 <__aeabi_fmul>
 80072fa:	f8c9 0050 	str.w	r0, [r9, #80]	; 0x50
                    gc_state.modal.spline_pq[X_AXIS] = gc_block.values.p;
 80072fe:	498e      	ldr	r1, [pc, #568]	; (8007538 <gc_execute_block+0x1ee8>)
 8007300:	f8d9 204c 	ldr.w	r2, [r9, #76]	; 0x4c
                    gc_state.modal.spline_pq[Y_AXIS] = gc_block.values.q;
 8007304:	f8d9 3050 	ldr.w	r3, [r9, #80]	; 0x50
                    bit_false(value_words, bit(Word_P)|bit(Word_Q)|bit(Word_I)|bit(Word_J));
 8007308:	f427 4701 	bic.w	r7, r7, #33024	; 0x8100
 800730c:	f027 0718 	bic.w	r7, r7, #24
 8007310:	9715      	str	r7, [sp, #84]	; 0x54
                    gc_state.modal.spline_pq[X_AXIS] = gc_block.values.p;
 8007312:	620a      	str	r2, [r1, #32]
                    gc_state.modal.spline_pq[Y_AXIS] = gc_block.values.q;
 8007314:	624b      	str	r3, [r1, #36]	; 0x24
                    break;
 8007316:	f7fe bfd9 	b.w	80062cc <gc_execute_block+0xc7c>
                    gc_parser_flags.arc_is_clockwise = On;
 800731a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800731e:	f043 0304 	orr.w	r3, r3, #4
 8007322:	f8ad 301c 	strh.w	r3, [sp, #28]
                    if (!axis_words)
 8007326:	9804      	ldr	r0, [sp, #16]
 8007328:	2800      	cmp	r0, #0
 800732a:	f43f aafd 	beq.w	8006928 <gc_execute_block+0x12d8>
                    if (!(axis_words & (bit(plane.axis_0)|bit(plane.axis_1))))
 800732e:	2301      	movs	r3, #1
 8007330:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8007332:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8007334:	fa03 f502 	lsl.w	r5, r3, r2
 8007338:	40b3      	lsls	r3, r6
 800733a:	431d      	orrs	r5, r3
 800733c:	4228      	tst	r0, r5
 800733e:	f000 87de 	beq.w	80082fe <gc_execute_block+0x2cae>
                    x = gc_block.values.xyz[plane.axis_0] - gc_state.position[plane.axis_0]; // Delta x between current position and target
 8007342:	4613      	mov	r3, r2
 8007344:	4f7c      	ldr	r7, [pc, #496]	; (8007538 <gc_execute_block+0x1ee8>)
 8007346:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800734a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800734e:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007350:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8007352:	f7f9 f915 	bl	8000580 <__aeabi_fsub>
 8007356:	4602      	mov	r2, r0
                    y = gc_block.values.xyz[plane.axis_1] - gc_state.position[plane.axis_1]; // Delta y between current position and target
 8007358:	eb07 0386 	add.w	r3, r7, r6, lsl #2
 800735c:	eb09 0186 	add.w	r1, r9, r6, lsl #2
 8007360:	6dc8      	ldr	r0, [r1, #92]	; 0x5c
 8007362:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
                    x = gc_block.values.xyz[plane.axis_0] - gc_state.position[plane.axis_0]; // Delta x between current position and target
 8007364:	4693      	mov	fp, r2
                    y = gc_block.values.xyz[plane.axis_1] - gc_state.position[plane.axis_1]; // Delta y between current position and target
 8007366:	f7f9 f90b 	bl	8000580 <__aeabi_fsub>
                    if (value_words & bit(Word_R)) { // Arc Radius Mode
 800736a:	9b15      	ldr	r3, [sp, #84]	; 0x54
                    y = gc_block.values.xyz[plane.axis_1] - gc_state.position[plane.axis_1]; // Delta y between current position and target
 800736c:	4682      	mov	sl, r0
                    if (value_words & bit(Word_R)) { // Arc Radius Mode
 800736e:	059a      	lsls	r2, r3, #22
 8007370:	f140 86fa 	bpl.w	8008168 <gc_execute_block+0x2b18>
                        bit_false(value_words, bit(Word_R));
 8007374:	f423 7300 	bic.w	r3, r3, #512	; 0x200
                        if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8007378:	220c      	movs	r2, #12
 800737a:	4971      	ldr	r1, [pc, #452]	; (8007540 <gc_execute_block+0x1ef0>)
 800737c:	f107 006c 	add.w	r0, r7, #108	; 0x6c
                        bit_false(value_words, bit(Word_R));
 8007380:	9315      	str	r3, [sp, #84]	; 0x54
                        if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 8007382:	f00a fc63 	bl	8011c4c <memcmp>
 8007386:	2800      	cmp	r0, #0
 8007388:	f000 869e 	beq.w	80080c8 <gc_execute_block+0x2a78>
                        if (gc_block.modal.units_imperial)
 800738c:	f899 300a 	ldrb.w	r3, [r9, #10]
 8007390:	b133      	cbz	r3, 80073a0 <gc_execute_block+0x1d50>
                            gc_block.values.r *= MM_PER_INCH;
 8007392:	f8d9 0054 	ldr.w	r0, [r9, #84]	; 0x54
 8007396:	4967      	ldr	r1, [pc, #412]	; (8007534 <gc_execute_block+0x1ee4>)
 8007398:	f7f9 f9fc 	bl	8000794 <__aeabi_fmul>
 800739c:	f8c9 0054 	str.w	r0, [r9, #84]	; 0x54
                        if(gc_state.modal.scaling_active)
 80073a0:	4b65      	ldr	r3, [pc, #404]	; (8007538 <gc_execute_block+0x1ee8>)
 80073a2:	7f9b      	ldrb	r3, [r3, #30]
 80073a4:	b1ab      	cbz	r3, 80073d2 <gc_execute_block+0x1d82>
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 80073a6:	4b65      	ldr	r3, [pc, #404]	; (800753c <gc_execute_block+0x1eec>)
 80073a8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80073aa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80073ac:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80073b0:	eb03 0381 	add.w	r3, r3, r1, lsl #2
                                                   : scale_factor.ijk[plane.axis_1]);
 80073b4:	68d5      	ldr	r5, [r2, #12]
 80073b6:	68df      	ldr	r7, [r3, #12]
 80073b8:	4628      	mov	r0, r5
 80073ba:	4639      	mov	r1, r7
 80073bc:	f7f9 fb9c 	bl	8000af8 <__aeabi_fcmpge>
 80073c0:	b900      	cbnz	r0, 80073c4 <gc_execute_block+0x1d74>
 80073c2:	463d      	mov	r5, r7
                            gc_block.values.r *= (scale_factor.ijk[plane.axis_0] > scale_factor.ijk[plane.axis_1]
 80073c4:	f8d9 1054 	ldr.w	r1, [r9, #84]	; 0x54
 80073c8:	4628      	mov	r0, r5
 80073ca:	f7f9 f9e3 	bl	8000794 <__aeabi_fmul>
 80073ce:	f8c9 0054 	str.w	r0, [r9, #84]	; 0x54
                        float h_x2_div_d = 4.0f * gc_block.values.r * gc_block.values.r - x * x - y * y;
 80073d2:	4651      	mov	r1, sl
 80073d4:	4650      	mov	r0, sl
 80073d6:	f7f9 f9dd 	bl	8000794 <__aeabi_fmul>
 80073da:	4659      	mov	r1, fp
 80073dc:	4605      	mov	r5, r0
 80073de:	4658      	mov	r0, fp
 80073e0:	f7f9 f9d8 	bl	8000794 <__aeabi_fmul>
 80073e4:	4601      	mov	r1, r0
 80073e6:	4628      	mov	r0, r5
 80073e8:	f7f9 f8cc 	bl	8000584 <__addsf3>
 80073ec:	4605      	mov	r5, r0
 80073ee:	f8d9 7054 	ldr.w	r7, [r9, #84]	; 0x54
 80073f2:	4639      	mov	r1, r7
 80073f4:	4638      	mov	r0, r7
 80073f6:	f7f9 f9cd 	bl	8000794 <__aeabi_fmul>
 80073fa:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 80073fe:	f7f9 f9c9 	bl	8000794 <__aeabi_fmul>
 8007402:	4629      	mov	r1, r5
 8007404:	f7f9 f8bc 	bl	8000580 <__aeabi_fsub>
                        if (h_x2_div_d < 0.0f)
 8007408:	2100      	movs	r1, #0
                        float h_x2_div_d = 4.0f * gc_block.values.r * gc_block.values.r - x * x - y * y;
 800740a:	4606      	mov	r6, r0
                        if (h_x2_div_d < 0.0f)
 800740c:	f7f9 fb60 	bl	8000ad0 <__aeabi_fcmplt>
 8007410:	2800      	cmp	r0, #0
 8007412:	f040 8765 	bne.w	80082e0 <gc_execute_block+0x2c90>
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 8007416:	4630      	mov	r0, r6
 8007418:	f00b fde8 	bl	8012fec <sqrtf>
 800741c:	4602      	mov	r2, r0
    return sqrtf(x*x + y*y);
 800741e:	4628      	mov	r0, r5
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 8007420:	4615      	mov	r5, r2
    return sqrtf(x*x + y*y);
 8007422:	f00b fde3 	bl	8012fec <sqrtf>
 8007426:	4601      	mov	r1, r0
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 8007428:	f105 4000 	add.w	r0, r5, #2147483648	; 0x80000000
 800742c:	f7f9 fa66 	bl	80008fc <__aeabi_fdiv>
                        if (gc_block.modal.motion == MotionMode_CcwArc)
 8007430:	2c03      	cmp	r4, #3
                        h_x2_div_d = -sqrtf(h_x2_div_d) / hypot_f(x, y); // == -(h * 2 / d)
 8007432:	4605      	mov	r5, r0
                        if (gc_block.values.r < 0.0f) {
 8007434:	f04f 0100 	mov.w	r1, #0
                            h_x2_div_d = -h_x2_div_d;
 8007438:	bf08      	it	eq
 800743a:	f100 4500 	addeq.w	r5, r0, #2147483648	; 0x80000000
                        if (gc_block.values.r < 0.0f) {
 800743e:	4638      	mov	r0, r7
 8007440:	f7f9 fb46 	bl	8000ad0 <__aeabi_fcmplt>
 8007444:	b128      	cbz	r0, 8007452 <gc_execute_block+0x1e02>
                            gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 8007446:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
                            h_x2_div_d = -h_x2_div_d;
 800744a:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
                            gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
 800744e:	f8c9 3054 	str.w	r3, [r9, #84]	; 0x54
                        gc_block.values.ijk[plane.axis_0] = 0.5f * (x - (y * h_x2_div_d));
 8007452:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007454:	4651      	mov	r1, sl
 8007456:	4628      	mov	r0, r5
 8007458:	f103 070e 	add.w	r7, r3, #14
 800745c:	f7f9 f99a 	bl	8000794 <__aeabi_fmul>
 8007460:	4601      	mov	r1, r0
 8007462:	4658      	mov	r0, fp
 8007464:	f7f9 f88c 	bl	8000580 <__aeabi_fsub>
 8007468:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800746c:	f7f9 f992 	bl	8000794 <__aeabi_fmul>
 8007470:	eb09 0787 	add.w	r7, r9, r7, lsl #2
                        gc_block.values.ijk[plane.axis_1] = 0.5f * (y + (x * h_x2_div_d));
 8007474:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007476:	4659      	mov	r1, fp
                        gc_block.values.ijk[plane.axis_0] = 0.5f * (x - (y * h_x2_div_d));
 8007478:	6078      	str	r0, [r7, #4]
                        gc_block.values.ijk[plane.axis_1] = 0.5f * (y + (x * h_x2_div_d));
 800747a:	4628      	mov	r0, r5
 800747c:	f103 050e 	add.w	r5, r3, #14
 8007480:	f7f9 f988 	bl	8000794 <__aeabi_fmul>
 8007484:	4651      	mov	r1, sl
 8007486:	f7f9 f87d 	bl	8000584 <__addsf3>
 800748a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800748e:	f7f9 f981 	bl	8000794 <__aeabi_fmul>
 8007492:	eb09 0585 	add.w	r5, r9, r5, lsl #2
 8007496:	6068      	str	r0, [r5, #4]
 8007498:	f7fe bf18 	b.w	80062cc <gc_execute_block+0xc7c>
                        axis_command = AxisCommand_None;
 800749c:	9b04      	ldr	r3, [sp, #16]
 800749e:	2b00      	cmp	r3, #0
 80074a0:	9b06      	ldr	r3, [sp, #24]
 80074a2:	bf08      	it	eq
 80074a4:	2300      	moveq	r3, #0
 80074a6:	9306      	str	r3, [sp, #24]
 80074a8:	f7fe bf10 	b.w	80062cc <gc_execute_block+0xc7c>
                if(gc_block.values.k == 0.0f)
 80074ac:	2100      	movs	r1, #0
 80074ae:	f8d9 0048 	ldr.w	r0, [r9, #72]	; 0x48
 80074b2:	f7f9 fb03 	bl	8000abc <__aeabi_fcmpeq>
 80074b6:	2800      	cmp	r0, #0
 80074b8:	f000 84b4 	beq.w	8007e24 <gc_execute_block+0x27d4>
                    FAIL(Status_GcodeValueOutOfRange);
 80074bc:	2327      	movs	r3, #39	; 0x27
 80074be:	9304      	str	r3, [sp, #16]
 80074c0:	f7fe bb0b 	b.w	8005ada <gc_execute_block+0x48a>
                    if (bit_isfalse(axis_words, bit(--idx)))
 80074c4:	9c04      	ldr	r4, [sp, #16]
 80074c6:	0761      	lsls	r1, r4, #29
 80074c8:	f140 80fd 	bpl.w	80076c6 <gc_execute_block+0x2076>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 80074cc:	2f35      	cmp	r7, #53	; 0x35
 80074ce:	f43f ae39 	beq.w	8007144 <gc_execute_block+0x1af4>
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 80074d2:	4b19      	ldr	r3, [pc, #100]	; (8007538 <gc_execute_block+0x1ee8>)
 80074d4:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 80074d8:	6f58      	ldr	r0, [r3, #116]	; 0x74
 80074da:	f7f9 f853 	bl	8000584 <__addsf3>
                    if (bit_isfalse(axis_words, bit(--idx)))
 80074de:	07a2      	lsls	r2, r4, #30
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 80074e0:	f8c9 0064 	str.w	r0, [r9, #100]	; 0x64
                    if (bit_isfalse(axis_words, bit(--idx)))
 80074e4:	f100 80fa 	bmi.w	80076dc <gc_execute_block+0x208c>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 80074e8:	4b13      	ldr	r3, [pc, #76]	; (8007538 <gc_execute_block+0x1ee8>)
 80074ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80074ec:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 80074f0:	9b04      	ldr	r3, [sp, #16]
 80074f2:	07d9      	lsls	r1, r3, #31
 80074f4:	f140 80fe 	bpl.w	80076f4 <gc_execute_block+0x20a4>
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 80074f8:	4b0f      	ldr	r3, [pc, #60]	; (8007538 <gc_execute_block+0x1ee8>)
 80074fa:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 80074fe:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8007500:	f7f9 f840 	bl	8000584 <__addsf3>
 8007504:	f8c9 005c 	str.w	r0, [r9, #92]	; 0x5c
                } while(idx);
 8007508:	f7fe beca 	b.w	80062a0 <gc_execute_block+0xc50>
                    if (!settings_read_coord_data(gc_block.non_modal_command == NonModal_GoHome_0 ? SETTING_INDEX_G28 : SETTING_INDEX_G30, &gc_block.values.coord_data.xyz))
 800750c:	200a      	movs	r0, #10
 800750e:	490d      	ldr	r1, [pc, #52]	; (8007544 <gc_execute_block+0x1ef4>)
 8007510:	f006 fe0e 	bl	800e130 <settings_read_coord_data>
 8007514:	2800      	cmp	r0, #0
 8007516:	f43f ae11 	beq.w	800713c <gc_execute_block+0x1aec>
                    if (axis_words) {
 800751a:	9b04      	ldr	r3, [sp, #16]
 800751c:	2b00      	cmp	r3, #0
 800751e:	f040 80fd 	bne.w	800771c <gc_execute_block+0x20cc>
    if (gc_block.modal.motion == MotionMode_None) {
 8007522:	f899 4008 	ldrb.w	r4, [r9, #8]
 8007526:	2c50      	cmp	r4, #80	; 0x50
 8007528:	d1bd      	bne.n	80074a6 <gc_execute_block+0x1e56>
                        axis_command = AxisCommand_None; // Set to none if no intermediate motion.
 800752a:	9b04      	ldr	r3, [sp, #16]
 800752c:	9306      	str	r3, [sp, #24]
 800752e:	f7fe bec9 	b.w	80062c4 <gc_execute_block+0xc74>
 8007532:	bf00      	nop
 8007534:	41cb3333 	.word	0x41cb3333
 8007538:	200023dc 	.word	0x200023dc
 800753c:	20000a10 	.word	0x20000a10
 8007540:	200009dc 	.word	0x200009dc
 8007544:	200009e8 	.word	0x200009e8
        gc_state.spindle.css.surface_speed = gc_block.values.s;
 8007548:	f8d9 5058 	ldr.w	r5, [r9, #88]	; 0x58
 800754c:	4bab      	ldr	r3, [pc, #684]	; (80077fc <gc_execute_block+0x21ac>)
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 800754e:	2c50      	cmp	r4, #80	; 0x50
        gc_state.spindle.css.surface_speed = gc_block.values.s;
 8007550:	64dd      	str	r5, [r3, #76]	; 0x4c
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 8007552:	f000 8245 	beq.w	80079e0 <gc_execute_block+0x2390>
 8007556:	2c00      	cmp	r4, #0
 8007558:	f000 8242 	beq.w	80079e0 <gc_execute_block+0x2390>
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 800755c:	4ca7      	ldr	r4, [pc, #668]	; (80077fc <gc_execute_block+0x21ac>)
 800755e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 8007560:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
            gc_state.spindle.css.active = true;
 8007564:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8007568:	1cb1      	adds	r1, r6, #2
 800756a:	eb04 0286 	add.w	r2, r4, r6, lsl #2
 800756e:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 8007572:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8007576:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
            gc_state.spindle.css.axis = plane.axis_1;
 800757a:	65e6      	str	r6, [r4, #92]	; 0x5c
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 800757c:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
    return gc_state.modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8007580:	f7f9 f800 	bl	8000584 <__addsf3>
 8007584:	4633      	mov	r3, r6
 8007586:	3324      	adds	r3, #36	; 0x24
 8007588:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 800758c:	f7f8 fffa 	bl	8000584 <__addsf3>
 8007590:	4601      	mov	r1, r0
            float pos = gc_state.position[gc_state.spindle.css.axis] - gc_state.spindle.css.tool_offset;
 8007592:	eb04 0386 	add.w	r3, r4, r6, lsl #2
            gc_state.spindle.css.tool_offset = gc_get_offset(gc_state.spindle.css.axis);
 8007596:	65a1      	str	r1, [r4, #88]	; 0x58
            float pos = gc_state.position[gc_state.spindle.css.axis] - gc_state.spindle.css.tool_offset;
 8007598:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 800759a:	f7f8 fff1 	bl	8000580 <__aeabi_fsub>
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css.max_rpm : min(gc_state.spindle.css.max_rpm, gc_state.spindle.css.surface_speed / (pos * (float)(2.0f * M_PI)));
 800759e:	2100      	movs	r1, #0
            float pos = gc_state.position[gc_state.spindle.css.axis] - gc_state.spindle.css.tool_offset;
 80075a0:	4604      	mov	r4, r0
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css.max_rpm : min(gc_state.spindle.css.max_rpm, gc_state.spindle.css.surface_speed / (pos * (float)(2.0f * M_PI)));
 80075a2:	f7f9 fa9f 	bl	8000ae4 <__aeabi_fcmple>
 80075a6:	2800      	cmp	r0, #0
 80075a8:	f040 8522 	bne.w	8007ff0 <gc_execute_block+0x29a0>
 80075ac:	4628      	mov	r0, r5
 80075ae:	4994      	ldr	r1, [pc, #592]	; (8007800 <gc_execute_block+0x21b0>)
 80075b0:	f7f9 f8f0 	bl	8000794 <__aeabi_fmul>
 80075b4:	4621      	mov	r1, r4
 80075b6:	f7f9 f9a1 	bl	80008fc <__aeabi_fdiv>
 80075ba:	4b90      	ldr	r3, [pc, #576]	; (80077fc <gc_execute_block+0x21ac>)
 80075bc:	4604      	mov	r4, r0
 80075be:	6d5d      	ldr	r5, [r3, #84]	; 0x54
 80075c0:	4629      	mov	r1, r5
 80075c2:	f7f9 fa8f 	bl	8000ae4 <__aeabi_fcmple>
 80075c6:	b900      	cbnz	r0, 80075ca <gc_execute_block+0x1f7a>
 80075c8:	462c      	mov	r4, r5
            gc_parser_flags.spindle_force_sync = On;
 80075ca:	f8bd 301c 	ldrh.w	r3, [sp, #28]
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css.max_rpm : min(gc_state.spindle.css.max_rpm, gc_state.spindle.css.surface_speed / (pos * (float)(2.0f * M_PI)));
 80075ce:	f8c9 4058 	str.w	r4, [r9, #88]	; 0x58
            gc_parser_flags.spindle_force_sync = On;
 80075d2:	f043 0320 	orr.w	r3, r3, #32
 80075d6:	f8ad 301c 	strh.w	r3, [sp, #28]
 80075da:	f7ff ba10 	b.w	80069fe <gc_execute_block+0x13ae>
        if(set_tool || !(hal.stream.suspend_read || hal.tool_change)) {
 80075de:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 80075e2:	2a00      	cmp	r2, #0
 80075e4:	f47f aa45 	bne.w	8006a72 <gc_execute_block+0x1422>
            gc_state.tool->tool = gc_state.tool_pending;
 80075e8:	4a84      	ldr	r2, [pc, #528]	; (80077fc <gc_execute_block+0x21ac>)
            sys.report.tool = On;
 80075ea:	4c86      	ldr	r4, [pc, #536]	; (8007804 <gc_execute_block+0x21b4>)
            gc_state.tool->tool = gc_state.tool_pending;
 80075ec:	f8d2 209c 	ldr.w	r2, [r2, #156]	; 0x9c
 80075f0:	7413      	strb	r3, [r2, #16]
            sys.report.tool = On;
 80075f2:	7d23      	ldrb	r3, [r4, #20]
 80075f4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80075f8:	7523      	strb	r3, [r4, #20]
 80075fa:	f7ff ba3a 	b.w	8006a72 <gc_execute_block+0x1422>
                    if (!settings_read_coord_data(gc_block.non_modal_command == NonModal_GoHome_0 ? SETTING_INDEX_G28 : SETTING_INDEX_G30, &gc_block.values.coord_data.xyz))
 80075fe:	2009      	movs	r0, #9
 8007600:	e785      	b.n	800750e <gc_execute_block+0x1ebe>
        gc_state.modal.tool_offset_mode = gc_block.modal.tool_offset_mode;
 8007602:	f899 300e 	ldrb.w	r3, [r9, #14]
 8007606:	460a      	mov	r2, r1
 8007608:	718b      	strb	r3, [r1, #6]
            switch(gc_state.modal.tool_offset_mode) {
 800760a:	2b00      	cmp	r3, #0
 800760c:	f000 8560 	beq.w	80080d0 <gc_execute_block+0x2a80>
 8007610:	2b02      	cmp	r3, #2
 8007612:	f47f aab3 	bne.w	8006b7c <gc_execute_block+0x152c>
                    if (bit_istrue(axis_words, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 8007616:	9b04      	ldr	r3, [sp, #16]
 8007618:	0759      	lsls	r1, r3, #29
 800761a:	f3c3 0580 	ubfx	r5, r3, #2, #1
 800761e:	d50d      	bpl.n	800763c <gc_execute_block+0x1fec>
 8007620:	f8d9 5064 	ldr.w	r5, [r9, #100]	; 0x64
 8007624:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
 8007628:	4629      	mov	r1, r5
 800762a:	4616      	mov	r6, r2
 800762c:	f7f9 fa46 	bl	8000abc <__aeabi_fcmpeq>
 8007630:	2800      	cmp	r0, #0
 8007632:	f040 8626 	bne.w	8008282 <gc_execute_block+0x2c32>
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
 8007636:	f8c6 5098 	str.w	r5, [r6, #152]	; 0x98
                        tlo_changed = true;
 800763a:	2501      	movs	r5, #1
                    if (bit_istrue(axis_words, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 800763c:	9b04      	ldr	r3, [sp, #16]
 800763e:	079f      	lsls	r7, r3, #30
 8007640:	f140 856c 	bpl.w	800811c <gc_execute_block+0x2acc>
 8007644:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
 8007648:	4f6c      	ldr	r7, [pc, #432]	; (80077fc <gc_execute_block+0x21ac>)
 800764a:	4631      	mov	r1, r6
 800764c:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 8007650:	f7f9 fa34 	bl	8000abc <__aeabi_fcmpeq>
 8007654:	2800      	cmp	r0, #0
 8007656:	f040 8561 	bne.w	800811c <gc_execute_block+0x2acc>
 800765a:	9b04      	ldr	r3, [sp, #16]
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
 800765c:	f8c7 6094 	str.w	r6, [r7, #148]	; 0x94
                    if (bit_istrue(axis_words, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 8007660:	07da      	lsls	r2, r3, #31
 8007662:	d50b      	bpl.n	800767c <gc_execute_block+0x202c>
 8007664:	f8d9 605c 	ldr.w	r6, [r9, #92]	; 0x5c
 8007668:	4b64      	ldr	r3, [pc, #400]	; (80077fc <gc_execute_block+0x21ac>)
 800766a:	4631      	mov	r1, r6
 800766c:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 8007670:	f7f9 fa24 	bl	8000abc <__aeabi_fcmpeq>
 8007674:	b910      	cbnz	r0, 800767c <gc_execute_block+0x202c>
                        gc_state.tool_length_offset[idx] = gc_block.values.xyz[idx];
 8007676:	4b61      	ldr	r3, [pc, #388]	; (80077fc <gc_execute_block+0x21ac>)
 8007678:	f8c3 6090 	str.w	r6, [r3, #144]	; 0x90
            system_flag_wco_change();
 800767c:	f00a f83c 	bl	80116f8 <system_flag_wco_change>
 8007680:	f7ff ba7c 	b.w	8006b7c <gc_execute_block+0x152c>
            sys.report.scaling = sys.report.scaling || gc_state.modal.scaling_active != gc_block.modal.scaling_active;
 8007684:	f043 0302 	orr.w	r3, r3, #2
 8007688:	7523      	strb	r3, [r4, #20]
            gc_state.modal.scaling_active = gc_block.modal.scaling_active;
 800768a:	4b5c      	ldr	r3, [pc, #368]	; (80077fc <gc_execute_block+0x21ac>)
 800768c:	779a      	strb	r2, [r3, #30]
    if(gc_state.modal.scaling_active) {
 800768e:	f7fe bd6b 	b.w	8006168 <gc_execute_block+0xb18>
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8007692:	f8d9 105c 	ldr.w	r1, [r9, #92]	; 0x5c
 8007696:	68e8      	ldr	r0, [r5, #12]
 8007698:	9310      	str	r3, [sp, #64]	; 0x40
 800769a:	910f      	str	r1, [sp, #60]	; 0x3c
 800769c:	f7f9 fa0e 	bl	8000abc <__aeabi_fcmpeq>
 80076a0:	e9dd 130f 	ldrd	r1, r3, [sp, #60]	; 0x3c
 80076a4:	fab0 f280 	clz	r2, r0
 80076a8:	0952      	lsrs	r2, r2, #5
 80076aa:	f7fe bfa8 	b.w	80065fe <gc_execute_block+0xfae>
 80076ae:	4d56      	ldr	r5, [pc, #344]	; (8007808 <gc_execute_block+0x21b8>)
 80076b0:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 80076b4:	6968      	ldr	r0, [r5, #20]
 80076b6:	910f      	str	r1, [sp, #60]	; 0x3c
 80076b8:	f7f9 fa00 	bl	8000abc <__aeabi_fcmpeq>
 80076bc:	fab0 f380 	clz	r3, r0
 80076c0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80076c2:	095b      	lsrs	r3, r3, #5
 80076c4:	e520      	b.n	8007108 <gc_execute_block+0x1ab8>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 80076c6:	4b4d      	ldr	r3, [pc, #308]	; (80077fc <gc_execute_block+0x21ac>)
 80076c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80076ca:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
                    if (bit_isfalse(axis_words, bit(--idx)))
 80076ce:	9b04      	ldr	r3, [sp, #16]
 80076d0:	079b      	lsls	r3, r3, #30
 80076d2:	f140 8239 	bpl.w	8007b48 <gc_execute_block+0x24f8>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 80076d6:	2f35      	cmp	r7, #53	; 0x35
 80076d8:	f43f ad38 	beq.w	800714c <gc_execute_block+0x1afc>
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 80076dc:	4b47      	ldr	r3, [pc, #284]	; (80077fc <gc_execute_block+0x21ac>)
 80076de:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 80076e2:	6f18      	ldr	r0, [r3, #112]	; 0x70
 80076e4:	f7f8 ff4e 	bl	8000584 <__addsf3>
                    if (bit_isfalse(axis_words, bit(--idx)))
 80076e8:	9b04      	ldr	r3, [sp, #16]
                            gc_block.values.xyz[idx] += gc_state.position[idx];
 80076ea:	f8c9 0060 	str.w	r0, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 80076ee:	07de      	lsls	r6, r3, #31
 80076f0:	f53f af02 	bmi.w	80074f8 <gc_execute_block+0x1ea8>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 80076f4:	4b41      	ldr	r3, [pc, #260]	; (80077fc <gc_execute_block+0x21ac>)
 80076f6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80076f8:	f8c9 305c 	str.w	r3, [r9, #92]	; 0x5c
 80076fc:	f7fe bdd0 	b.w	80062a0 <gc_execute_block+0xc50>
                    sys.report.scaling = sys.report.scaling || scale_factor.ijk[idx] != gc_block.values.xyz[idx];
 8007700:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 8007704:	6928      	ldr	r0, [r5, #16]
 8007706:	9310      	str	r3, [sp, #64]	; 0x40
 8007708:	910f      	str	r1, [sp, #60]	; 0x3c
 800770a:	f7f9 f9d7 	bl	8000abc <__aeabi_fcmpeq>
 800770e:	e9dd 130f 	ldrd	r1, r3, [sp, #60]	; 0x3c
 8007712:	fab0 f280 	clz	r2, r0
 8007716:	0952      	lsrs	r2, r2, #5
 8007718:	f7fe bf4e 	b.w	80065b8 <gc_execute_block+0xf68>
                            if (bit_isfalse(axis_words, bit(--idx)))
 800771c:	075c      	lsls	r4, r3, #29
 800771e:	d403      	bmi.n	8007728 <gc_execute_block+0x20d8>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx];
 8007720:	4b36      	ldr	r3, [pc, #216]	; (80077fc <gc_execute_block+0x21ac>)
 8007722:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007724:	f8c9 3070 	str.w	r3, [r9, #112]	; 0x70
                            if (bit_isfalse(axis_words, bit(--idx)))
 8007728:	9b04      	ldr	r3, [sp, #16]
 800772a:	0798      	lsls	r0, r3, #30
 800772c:	d403      	bmi.n	8007736 <gc_execute_block+0x20e6>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx];
 800772e:	4b33      	ldr	r3, [pc, #204]	; (80077fc <gc_execute_block+0x21ac>)
 8007730:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007732:	f8c9 306c 	str.w	r3, [r9, #108]	; 0x6c
                            if (bit_isfalse(axis_words, bit(--idx)))
 8007736:	9b04      	ldr	r3, [sp, #16]
 8007738:	07d9      	lsls	r1, r3, #31
 800773a:	f53f a845 	bmi.w	80067c8 <gc_execute_block+0x1178>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx];
 800773e:	4b2f      	ldr	r3, [pc, #188]	; (80077fc <gc_execute_block+0x21ac>)
 8007740:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8007742:	f8c9 3068 	str.w	r3, [r9, #104]	; 0x68
                        } while(idx);
 8007746:	f7ff b83f 	b.w	80067c8 <gc_execute_block+0x1178>
                    gc_block.values.coord_data.idx = p_value == 0
 800774a:	3b01      	subs	r3, #1
 800774c:	b2d8      	uxtb	r0, r3
 800774e:	f7ff b861 	b.w	8006814 <gc_execute_block+0x11c4>
            if(gc_block.modal.spindle_rpm_mode == SpindleSpeedMode_CSS && (!gc_block.modal.spindle.on || gc_block.values.s == 0.0f))
 8007752:	f899 3022 	ldrb.w	r3, [r9, #34]	; 0x22
 8007756:	07da      	lsls	r2, r3, #31
 8007758:	d507      	bpl.n	800776a <gc_execute_block+0x211a>
 800775a:	2100      	movs	r1, #0
 800775c:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8007760:	f7f9 f9ac 	bl	8000abc <__aeabi_fcmpeq>
 8007764:	2800      	cmp	r0, #0
 8007766:	f43f ad39 	beq.w	80071dc <gc_execute_block+0x1b8c>
                 FAIL(Status_GcodeSpindleNotRunning);
 800776a:	2329      	movs	r3, #41	; 0x29
 800776c:	9304      	str	r3, [sp, #16]
 800776e:	f7fe b9b4 	b.w	8005ada <gc_execute_block+0x48a>
                        if (bit_istrue(axis_words, bit(--idx))) {
 8007772:	075e      	lsls	r6, r3, #29
 8007774:	d510      	bpl.n	8007798 <gc_execute_block+0x2148>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx] - gc_block.values.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_state.tool_length_offset[idx];
 8007776:	4c21      	ldr	r4, [pc, #132]	; (80077fc <gc_execute_block+0x21ac>)
 8007778:	f8d9 1064 	ldr.w	r1, [r9, #100]	; 0x64
 800777c:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8007780:	f7f8 ff00 	bl	8000584 <__addsf3>
 8007784:	4601      	mov	r1, r0
 8007786:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8007788:	f7f8 fefa 	bl	8000580 <__aeabi_fsub>
 800778c:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 8007790:	f7f8 fef6 	bl	8000580 <__aeabi_fsub>
 8007794:	f8c9 0070 	str.w	r0, [r9, #112]	; 0x70
                        if (bit_istrue(axis_words, bit(--idx))) {
 8007798:	9b04      	ldr	r3, [sp, #16]
 800779a:	079d      	lsls	r5, r3, #30
 800779c:	d510      	bpl.n	80077c0 <gc_execute_block+0x2170>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx] - gc_block.values.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_state.tool_length_offset[idx];
 800779e:	4c17      	ldr	r4, [pc, #92]	; (80077fc <gc_execute_block+0x21ac>)
 80077a0:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 80077a4:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 80077a8:	f7f8 feec 	bl	8000584 <__addsf3>
 80077ac:	4601      	mov	r1, r0
 80077ae:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80077b0:	f7f8 fee6 	bl	8000580 <__aeabi_fsub>
 80077b4:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 80077b8:	f7f8 fee2 	bl	8000580 <__aeabi_fsub>
 80077bc:	f8c9 006c 	str.w	r0, [r9, #108]	; 0x6c
                        if (bit_istrue(axis_words, bit(--idx))) {
 80077c0:	9b04      	ldr	r3, [sp, #16]
 80077c2:	07dc      	lsls	r4, r3, #31
 80077c4:	f57f a848 	bpl.w	8006858 <gc_execute_block+0x1208>
                                gc_block.values.coord_data.xyz[idx] = gc_state.position[idx] - gc_block.values.xyz[idx] - gc_state.g92_coord_offset[idx] - gc_state.tool_length_offset[idx];
 80077c8:	4c0c      	ldr	r4, [pc, #48]	; (80077fc <gc_execute_block+0x21ac>)
 80077ca:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 80077ce:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 80077d2:	f7f8 fed7 	bl	8000584 <__addsf3>
 80077d6:	4601      	mov	r1, r0
 80077d8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80077da:	f7f8 fed1 	bl	8000580 <__aeabi_fsub>
 80077de:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 80077e2:	f7f8 fecd 	bl	8000580 <__aeabi_fsub>
 80077e6:	f8c9 0068 	str.w	r0, [r9, #104]	; 0x68
                    } while(idx);
 80077ea:	f7ff b835 	b.w	8006858 <gc_execute_block+0x1208>
        mc_dwell(gc_block.values.p);
 80077ee:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 80077f2:	f002 fa3b 	bl	8009c6c <mc_dwell>
 80077f6:	f7ff b9b6 	b.w	8006b66 <gc_execute_block+0x1516>
 80077fa:	bf00      	nop
 80077fc:	200023dc 	.word	0x200023dc
 8007800:	3e22f983 	.word	0x3e22f983
 8007804:	20002494 	.word	0x20002494
 8007808:	20000a10 	.word	0x20000a10
        output_commands = NULL;
 800780c:	2200      	movs	r2, #0
        plan_data.output_commands = output_commands;
 800780e:	4b96      	ldr	r3, [pc, #600]	; (8007a68 <gc_execute_block+0x2418>)
        switch(gc_state.modal.motion) {
 8007810:	2821      	cmp	r0, #33	; 0x21
        plan_data.output_commands = output_commands;
 8007812:	681f      	ldr	r7, [r3, #0]
        output_commands = NULL;
 8007814:	601a      	str	r2, [r3, #0]
        plan_data.output_commands = output_commands;
 8007816:	9727      	str	r7, [sp, #156]	; 0x9c
        switch(gc_state.modal.motion) {
 8007818:	f200 80a3 	bhi.w	8007962 <gc_execute_block+0x2312>
 800781c:	2821      	cmp	r0, #33	; 0x21
 800781e:	f200 808e 	bhi.w	800793e <gc_execute_block+0x22ee>
 8007822:	e8df f000 	tbb	[pc, r0]
 8007826:	7690      	.short	0x7690
 8007828:	388c5050 	.word	0x388c5050
 800782c:	8c8c8c8c 	.word	0x8c8c8c8c
 8007830:	8c8c8c8c 	.word	0x8c8c8c8c
 8007834:	8c8c8c8c 	.word	0x8c8c8c8c
 8007838:	8c8c8c8c 	.word	0x8c8c8c8c
 800783c:	8c8c8c8c 	.word	0x8c8c8c8c
 8007840:	8c8c8c8c 	.word	0x8c8c8c8c
 8007844:	118c8c8c 	.word	0x118c8c8c
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 8007848:	f004 f934 	bl	800bab4 <protocol_buffer_synchronize>
                    status_code_t status = init_sync_motion(&plan_data, gc_block.values.k);
 800784c:	f8d9 1048 	ldr.w	r1, [r9, #72]	; 0x48
 8007850:	a81b      	add	r0, sp, #108	; 0x6c
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 8007852:	7ca6      	ldrb	r6, [r4, #18]
                    status_code_t status = init_sync_motion(&plan_data, gc_block.values.k);
 8007854:	f7fd fdd4 	bl	8005400 <init_sync_motion>
                    if(status != Status_OK)
 8007858:	9004      	str	r0, [sp, #16]
 800785a:	2800      	cmp	r0, #0
 800785c:	f47e a93d 	bne.w	8005ada <gc_execute_block+0x48a>
                    plan_data.condition.spindle.synchronized = On;
 8007860:	f89d 308e 	ldrb.w	r3, [sp, #142]	; 0x8e
                    mc_line(gc_block.values.xyz, &plan_data);
 8007864:	4d81      	ldr	r5, [pc, #516]	; (8007a6c <gc_execute_block+0x241c>)
                    plan_data.condition.spindle.synchronized = On;
 8007866:	f043 0380 	orr.w	r3, r3, #128	; 0x80
                    mc_dwell(0.01f); // Needed for now since initial spindle sync is done just before st_wake_up
 800786a:	4881      	ldr	r0, [pc, #516]	; (8007a70 <gc_execute_block+0x2420>)
                    plan_data.condition.spindle.synchronized = On;
 800786c:	f88d 308e 	strb.w	r3, [sp, #142]	; 0x8e
                    mc_dwell(0.01f); // Needed for now since initial spindle sync is done just before st_wake_up
 8007870:	f002 f9fc 	bl	8009c6c <mc_dwell>
                    mc_line(gc_block.values.xyz, &plan_data);
 8007874:	a91b      	add	r1, sp, #108	; 0x6c
 8007876:	4628      	mov	r0, r5
 8007878:	f001 f9e6 	bl	8008c48 <mc_line>
                    protocol_buffer_synchronize();    // Wait until thread is finished,
 800787c:	f004 f91a 	bl	800bab4 <protocol_buffer_synchronize>
        if(sys.cancel)
 8007880:	7963      	ldrb	r3, [r4, #5]
                    sys.override.control = overrides; // then restore previous override disable status.
 8007882:	74a6      	strb	r6, [r4, #18]
        if(sys.cancel)
 8007884:	2b00      	cmp	r3, #0
 8007886:	d155      	bne.n	8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 8007888:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 800788a:	2f00      	cmp	r7, #0
 800788c:	d03f      	beq.n	800790e <gc_execute_block+0x22be>
            free(plan_data.output_commands);
 800788e:	4638      	mov	r0, r7
 8007890:	f00a f9d4 	bl	8011c3c <free>
        while(plan_data.output_commands) {
 8007894:	e7fb      	b.n	800788e <gc_execute_block+0x223e>
                mc_cubic_b_spline(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_state.modal.spline_pq);
 8007896:	4b77      	ldr	r3, [pc, #476]	; (8007a74 <gc_execute_block+0x2424>)
 8007898:	4e77      	ldr	r6, [pc, #476]	; (8007a78 <gc_execute_block+0x2428>)
 800789a:	f103 0020 	add.w	r0, r3, #32
 800789e:	a91b      	add	r1, sp, #108	; 0x6c
 80078a0:	9600      	str	r6, [sp, #0]
 80078a2:	f106 024c 	add.w	r2, r6, #76	; 0x4c
 80078a6:	f001 fbad 	bl	8009004 <mc_cubic_b_spline>
        if(sys.cancel)
 80078aa:	7963      	ldrb	r3, [r4, #5]
 80078ac:	2b00      	cmp	r3, #0
 80078ae:	d141      	bne.n	8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 80078b0:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 80078b2:	2f00      	cmp	r7, #0
 80078b4:	d1eb      	bne.n	800788e <gc_execute_block+0x223e>
 80078b6:	4d6d      	ldr	r5, [pc, #436]	; (8007a6c <gc_execute_block+0x241c>)
 80078b8:	364c      	adds	r6, #76	; 0x4c
            memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_state.position)); // gc_state.position[] = gc_block.values.xyz[]
 80078ba:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80078be:	e886 0007 	stmia.w	r6, {r0, r1, r2}
 80078c2:	f7ff b987 	b.w	8006bd4 <gc_execute_block+0x1584>
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 80078c6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                        plane, gc_parser_flags.arc_is_clockwise);
 80078c8:	f8bd 101c 	ldrh.w	r1, [sp, #28]
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 80078cc:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 80078d0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80078d2:	f8d9 0054 	ldr.w	r0, [r9, #84]	; 0x54
 80078d6:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
 80078da:	9b0c      	ldr	r3, [sp, #48]	; 0x30
                        plane, gc_parser_flags.arc_is_clockwise);
 80078dc:	f3c1 0180 	ubfx	r1, r1, #2, #1
                mc_arc(gc_block.values.xyz, &plan_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
 80078e0:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
 80078e4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80078e6:	4b63      	ldr	r3, [pc, #396]	; (8007a74 <gc_execute_block+0x2424>)
 80078e8:	0c15      	lsrs	r5, r2, #16
 80078ea:	9102      	str	r1, [sp, #8]
 80078ec:	f8ad 2004 	strh.w	r2, [sp, #4]
 80078f0:	9000      	str	r0, [sp, #0]
 80078f2:	4a62      	ldr	r2, [pc, #392]	; (8007a7c <gc_execute_block+0x242c>)
 80078f4:	f103 0020 	add.w	r0, r3, #32
 80078f8:	a91b      	add	r1, sp, #108	; 0x6c
 80078fa:	f88d 5006 	strb.w	r5, [sp, #6]
 80078fe:	f001 f9eb 	bl	8008cd8 <mc_arc>
        if(sys.cancel)
 8007902:	7963      	ldrb	r3, [r4, #5]
 8007904:	b9b3      	cbnz	r3, 8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 8007906:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 8007908:	2f00      	cmp	r7, #0
 800790a:	d1c0      	bne.n	800788e <gc_execute_block+0x223e>
 800790c:	4d57      	ldr	r5, [pc, #348]	; (8007a6c <gc_execute_block+0x241c>)
 800790e:	4e5b      	ldr	r6, [pc, #364]	; (8007a7c <gc_execute_block+0x242c>)
 8007910:	e7d3      	b.n	80078ba <gc_execute_block+0x226a>
                if(gc_state.modal.feed_mode == FeedMode_UnitsPerRev) {
 8007912:	4b5b      	ldr	r3, [pc, #364]	; (8007a80 <gc_execute_block+0x2430>)
 8007914:	785b      	ldrb	r3, [r3, #1]
 8007916:	2b02      	cmp	r3, #2
 8007918:	d105      	bne.n	8007926 <gc_execute_block+0x22d6>
                    plan_data.condition.spindle.synchronized = On;
 800791a:	f89d 308e 	ldrb.w	r3, [sp, #142]	; 0x8e
 800791e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007922:	f88d 308e 	strb.w	r3, [sp, #142]	; 0x8e
                mc_line(gc_block.values.xyz, &plan_data);
 8007926:	4851      	ldr	r0, [pc, #324]	; (8007a6c <gc_execute_block+0x241c>)
 8007928:	a91b      	add	r1, sp, #108	; 0x6c
 800792a:	f001 f98d 	bl	8008c48 <mc_line>
        if(sys.cancel)
 800792e:	7963      	ldrb	r3, [r4, #5]
 8007930:	2b00      	cmp	r3, #0
 8007932:	d0e8      	beq.n	8007906 <gc_execute_block+0x22b6>
        while(plan_data.output_commands) {
 8007934:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 8007936:	2f00      	cmp	r7, #0
 8007938:	d1a9      	bne.n	800788e <gc_execute_block+0x223e>
 800793a:	f7ff b94b 	b.w	8006bd4 <gc_execute_block+0x1584>
        if(sys.cancel)
 800793e:	7963      	ldrb	r3, [r4, #5]
 8007940:	2b00      	cmp	r3, #0
 8007942:	d0e1      	beq.n	8007908 <gc_execute_block+0x22b8>
 8007944:	e7f6      	b.n	8007934 <gc_execute_block+0x22e4>
                plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 8007946:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
                mc_line(gc_block.values.xyz, &plan_data);
 800794a:	4848      	ldr	r0, [pc, #288]	; (8007a6c <gc_execute_block+0x241c>)
                plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 800794c:	f043 0301 	orr.w	r3, r3, #1
                mc_line(gc_block.values.xyz, &plan_data);
 8007950:	a91b      	add	r1, sp, #108	; 0x6c
                plan_data.condition.rapid_motion = On; // Set rapid motion condition flag.
 8007952:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
                mc_line(gc_block.values.xyz, &plan_data);
 8007956:	f001 f977 	bl	8008c48 <mc_line>
        if(sys.cancel)
 800795a:	7963      	ldrb	r3, [r4, #5]
 800795c:	2b00      	cmp	r3, #0
 800795e:	d1e9      	bne.n	8007934 <gc_execute_block+0x22e4>
 8007960:	e7d1      	b.n	8007906 <gc_execute_block+0x22b6>
        switch(gc_state.modal.motion) {
 8007962:	2853      	cmp	r0, #83	; 0x53
 8007964:	f200 8096 	bhi.w	8007a94 <gc_execute_block+0x2444>
 8007968:	2850      	cmp	r0, #80	; 0x50
 800796a:	f200 848d 	bhi.w	8008288 <gc_execute_block+0x2c38>
 800796e:	2849      	cmp	r0, #73	; 0x49
 8007970:	f000 848a 	beq.w	8008288 <gc_execute_block+0x2c38>
 8007974:	284c      	cmp	r0, #76	; 0x4c
 8007976:	d1e2      	bne.n	800793e <gc_execute_block+0x22ee>
                    status_code_t status = init_sync_motion(&plan_data, thread.pitch);
 8007978:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8007a90 <gc_execute_block+0x2440>
                    protocol_buffer_synchronize(); // Wait until any previous moves are finished.
 800797c:	f004 f89a 	bl	800bab4 <protocol_buffer_synchronize>
                    status_code_t status = init_sync_motion(&plan_data, thread.pitch);
 8007980:	f8d8 1000 	ldr.w	r1, [r8]
 8007984:	a81b      	add	r0, sp, #108	; 0x6c
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 8007986:	7ca5      	ldrb	r5, [r4, #18]
                    status_code_t status = init_sync_motion(&plan_data, thread.pitch);
 8007988:	f7fd fd3a 	bl	8005400 <init_sync_motion>
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 800798c:	462f      	mov	r7, r5
                    if(status != Status_OK)
 800798e:	9004      	str	r0, [sp, #16]
                    gc_override_flags_t overrides = sys.override.control; // Save current override disable status.
 8007990:	f3c5 0540 	ubfx	r5, r5, #1, #1
                    if(status != Status_OK)
 8007994:	2800      	cmp	r0, #0
 8007996:	f47e a8a0 	bne.w	8005ada <gc_execute_block+0x48a>
                    mc_thread(&plan_data, gc_state.position, &thread, overrides.feed_hold_disable);
 800799a:	4e38      	ldr	r6, [pc, #224]	; (8007a7c <gc_execute_block+0x242c>)
 800799c:	462b      	mov	r3, r5
 800799e:	4642      	mov	r2, r8
 80079a0:	4631      	mov	r1, r6
 80079a2:	a81b      	add	r0, sp, #108	; 0x6c
 80079a4:	f001 ff54 	bl	8009850 <mc_thread>
                    protocol_buffer_synchronize();    // Wait until thread is finished,
 80079a8:	f004 f884 	bl	800bab4 <protocol_buffer_synchronize>
        if(sys.cancel)
 80079ac:	7963      	ldrb	r3, [r4, #5]
                    sys.override.control = overrides; // then restore previous override disable status.
 80079ae:	f365 0741 	bfi	r7, r5, #1, #1
 80079b2:	74a7      	strb	r7, [r4, #18]
        if(sys.cancel)
 80079b4:	2b00      	cmp	r3, #0
 80079b6:	d1bd      	bne.n	8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 80079b8:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 80079ba:	2f00      	cmp	r7, #0
 80079bc:	f47f af67 	bne.w	800788e <gc_execute_block+0x223e>
 80079c0:	4d2a      	ldr	r5, [pc, #168]	; (8007a6c <gc_execute_block+0x241c>)
 80079c2:	e77a      	b.n	80078ba <gc_execute_block+0x226a>
            if (sys.state != STATE_CHECK_MODE) {
 80079c4:	6823      	ldr	r3, [r4, #0]
 80079c6:	2b02      	cmp	r3, #2
 80079c8:	f43f a970 	beq.w	8006cac <gc_execute_block+0x165c>
                system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
 80079cc:	4b2d      	ldr	r3, [pc, #180]	; (8007a84 <gc_execute_block+0x2434>)
 80079ce:	2108      	movs	r1, #8
 80079d0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80079d4:	482c      	ldr	r0, [pc, #176]	; (8007a88 <gc_execute_block+0x2438>)
 80079d6:	4798      	blx	r3
                protocol_execute_realtime(); // Execute suspend.
 80079d8:	f003 fda2 	bl	800b520 <protocol_execute_realtime>
 80079dc:	f7ff b966 	b.w	8006cac <gc_execute_block+0x165c>
            if(gc_state.spindle.css.active) {
 80079e0:	4a27      	ldr	r2, [pc, #156]	; (8007a80 <gc_execute_block+0x2430>)
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 80079e2:	f89d 308c 	ldrb.w	r3, [sp, #140]	; 0x8c
            if(gc_state.spindle.css.active) {
 80079e6:	f892 2060 	ldrb.w	r2, [r2, #96]	; 0x60
        if((plan_data.condition.is_rpm_pos_adjusted = gc_block.modal.motion != MotionMode_None && gc_block.modal.motion != MotionMode_Seek)) {
 80079ea:	f36f 13c7 	bfc	r3, #7, #1
 80079ee:	f88d 308c 	strb.w	r3, [sp, #140]	; 0x8c
            if(gc_state.spindle.css.active) {
 80079f2:	2a00      	cmp	r2, #0
 80079f4:	f040 8327 	bne.w	8008046 <gc_execute_block+0x29f6>
            gc_block.values.s = sys.spindle_rpm; // Keep current RPM
 80079f8:	4c24      	ldr	r4, [pc, #144]	; (8007a8c <gc_execute_block+0x243c>)
 80079fa:	69a4      	ldr	r4, [r4, #24]
 80079fc:	f8c9 4058 	str.w	r4, [r9, #88]	; 0x58
 8007a00:	f7fe bffd 	b.w	80069fe <gc_execute_block+0x13ae>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8007a04:	4b1e      	ldr	r3, [pc, #120]	; (8007a80 <gc_execute_block+0x2430>)
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007a06:	0796      	lsls	r6, r2, #30
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8007a08:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007a0a:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007a0e:	d51d      	bpl.n	8007a4c <gc_execute_block+0x23fc>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 8007a10:	2f35      	cmp	r7, #53	; 0x35
 8007a12:	f43f ab9b 	beq.w	800714c <gc_execute_block+0x1afc>
    return gc_block->modal.coord_system.xyz[idx] + gc_state.g92_coord_offset[idx] + gc_state.tool_length_offset[idx];
 8007a16:	4b1a      	ldr	r3, [pc, #104]	; (8007a80 <gc_execute_block+0x2430>)
 8007a18:	f8d9 1014 	ldr.w	r1, [r9, #20]
 8007a1c:	461c      	mov	r4, r3
 8007a1e:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
 8007a22:	f7f8 fdaf 	bl	8000584 <__addsf3>
 8007a26:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
 8007a2a:	f7f8 fdab 	bl	8000584 <__addsf3>
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8007a2e:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
 8007a32:	f7f8 fda7 	bl	8000584 <__addsf3>
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007a36:	9b04      	ldr	r3, [sp, #16]
                            gc_block.values.xyz[idx] += gc_get_block_offset(&gc_block, idx);
 8007a38:	f8c9 0060 	str.w	r0, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007a3c:	07d8      	lsls	r0, r3, #31
 8007a3e:	f53e ac1d 	bmi.w	800627c <gc_execute_block+0xc2c>
 8007a42:	e657      	b.n	80076f4 <gc_execute_block+0x20a4>
 8007a44:	9b04      	ldr	r3, [sp, #16]
 8007a46:	0798      	lsls	r0, r3, #30
 8007a48:	f53f ab80 	bmi.w	800714c <gc_execute_block+0x1afc>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8007a4c:	4b0c      	ldr	r3, [pc, #48]	; (8007a80 <gc_execute_block+0x2430>)
 8007a4e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007a50:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007a54:	9b04      	ldr	r3, [sp, #16]
 8007a56:	07dc      	lsls	r4, r3, #31
 8007a58:	f57f ae4c 	bpl.w	80076f4 <gc_execute_block+0x20a4>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 8007a5c:	2f35      	cmp	r7, #53	; 0x35
 8007a5e:	f47e ac0d 	bne.w	800627c <gc_execute_block+0xc2c>
 8007a62:	f7ff bb77 	b.w	8007154 <gc_execute_block+0x1b04>
 8007a66:	bf00      	nop
 8007a68:	20000a0c 	.word	0x20000a0c
 8007a6c:	200009dc 	.word	0x200009dc
 8007a70:	3c23d70a 	.word	0x3c23d70a
 8007a74:	200009bc 	.word	0x200009bc
 8007a78:	200023fc 	.word	0x200023fc
 8007a7c:	20002448 	.word	0x20002448
 8007a80:	200023dc 	.word	0x200023dc
 8007a84:	200024bc 	.word	0x200024bc
 8007a88:	200024b4 	.word	0x200024b4
 8007a8c:	20002494 	.word	0x20002494
 8007a90:	20000a28 	.word	0x20000a28
        switch(gc_state.modal.motion) {
 8007a94:	f100 0374 	add.w	r3, r0, #116	; 0x74
 8007a98:	b2db      	uxtb	r3, r3
 8007a9a:	2b03      	cmp	r3, #3
 8007a9c:	f63f af4f 	bhi.w	800793e <gc_execute_block+0x22ee>
                plan_data.condition.no_feed_override = !settings.flags.allow_probing_feed_override;
 8007aa0:	f89a 30bd 	ldrb.w	r3, [sl, #189]	; 0xbd
 8007aa4:	f89d 608c 	ldrb.w	r6, [sp, #140]	; 0x8c
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 8007aa8:	4d30      	ldr	r5, [pc, #192]	; (8007b6c <gc_execute_block+0x251c>)
                plan_data.condition.no_feed_override = !settings.flags.allow_probing_feed_override;
 8007aaa:	f083 0304 	eor.w	r3, r3, #4
 8007aae:	f3c3 0380 	ubfx	r3, r3, #2, #1
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 8007ab2:	f8bd 201c 	ldrh.w	r2, [sp, #28]
                plan_data.condition.no_feed_override = !settings.flags.allow_probing_feed_override;
 8007ab6:	f363 1604 	bfi	r6, r3, #4, #1
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 8007aba:	4628      	mov	r0, r5
 8007abc:	a91b      	add	r1, sp, #108	; 0x6c
                plan_data.condition.no_feed_override = !settings.flags.allow_probing_feed_override;
 8007abe:	f88d 608c 	strb.w	r6, [sp, #140]	; 0x8c
                gc_update_pos = (pos_update_t)mc_probe_cycle(gc_block.values.xyz, &plan_data, gc_parser_flags);
 8007ac2:	f002 f8e5 	bl	8009c90 <mc_probe_cycle>
        if(sys.cancel)
 8007ac6:	7962      	ldrb	r2, [r4, #5]
 8007ac8:	2a00      	cmp	r2, #0
 8007aca:	f47f af33 	bne.w	8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 8007ace:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 8007ad0:	2f00      	cmp	r7, #0
 8007ad2:	f47f aedc 	bne.w	800788e <gc_execute_block+0x223e>
        if (gc_update_pos == GCUpdatePos_Target)
 8007ad6:	2800      	cmp	r0, #0
 8007ad8:	f43f af19 	beq.w	800790e <gc_execute_block+0x22be>
        else if (gc_update_pos == GCUpdatePos_System)
 8007adc:	2801      	cmp	r0, #1
 8007ade:	f47f a879 	bne.w	8006bd4 <gc_execute_block+0x1584>
            gc_sync_position(); // gc_state.position[] = sys_position
 8007ae2:	4923      	ldr	r1, [pc, #140]	; (8007b70 <gc_execute_block+0x2520>)
 8007ae4:	4823      	ldr	r0, [pc, #140]	; (8007b74 <gc_execute_block+0x2524>)
 8007ae6:	f009 fe1f 	bl	8011728 <system_convert_array_steps_to_mpos>
 8007aea:	f7ff b873 	b.w	8006bd4 <gc_execute_block+0x1584>
            spindle_set_override(DEFAULT_SPINDLE_RPM_OVERRIDE);
 8007aee:	2064      	movs	r0, #100	; 0x64
 8007af0:	f007 f89e 	bl	800ec30 <spindle_set_override>
 8007af4:	f7ff b81e 	b.w	8006b34 <gc_execute_block+0x14e4>
            plan_feed_override(0, 0);
 8007af8:	2100      	movs	r1, #0
 8007afa:	4608      	mov	r0, r1
 8007afc:	f003 fab2 	bl	800b064 <plan_feed_override>
 8007b00:	f7ff b813 	b.w	8006b2a <gc_execute_block+0x14da>
            sys.report.tool = On;
 8007b04:	4c1c      	ldr	r4, [pc, #112]	; (8007b78 <gc_execute_block+0x2528>)
 8007b06:	7d23      	ldrb	r3, [r4, #20]
 8007b08:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007b0c:	7523      	strb	r3, [r4, #20]
 8007b0e:	f7fe bfbd 	b.w	8006a8c <gc_execute_block+0x143c>
        protocol_buffer_synchronize();
 8007b12:	f003 ffcf 	bl	800bab4 <protocol_buffer_synchronize>
        gc_state.tool->tool = gc_state.tool_pending;
 8007b16:	4a19      	ldr	r2, [pc, #100]	; (8007b7c <gc_execute_block+0x252c>)
        if(hal.tool_change) { // ATC
 8007b18:	4f19      	ldr	r7, [pc, #100]	; (8007b80 <gc_execute_block+0x2530>)
        gc_state.tool->tool = gc_state.tool_pending;
 8007b1a:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8007b1e:	f892 207c 	ldrb.w	r2, [r2, #124]	; 0x7c
 8007b22:	741a      	strb	r2, [r3, #16]
        if(hal.tool_change) { // ATC
 8007b24:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8007b28:	2b00      	cmp	r3, #0
 8007b2a:	f000 8293 	beq.w	8008054 <gc_execute_block+0x2a04>
            if((int_value = (uint_fast16_t)hal.tool_change(&gc_state)) != Status_OK)
 8007b2e:	4813      	ldr	r0, [pc, #76]	; (8007b7c <gc_execute_block+0x252c>)
 8007b30:	4798      	blx	r3
 8007b32:	4603      	mov	r3, r0
 8007b34:	2800      	cmp	r0, #0
 8007b36:	f47e ae4c 	bne.w	80067d2 <gc_execute_block+0x1182>
            sys.report.tool = On;
 8007b3a:	4c0f      	ldr	r4, [pc, #60]	; (8007b78 <gc_execute_block+0x2528>)
 8007b3c:	7d23      	ldrb	r3, [r4, #20]
 8007b3e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007b42:	7523      	strb	r3, [r4, #20]
 8007b44:	f7fe bfae 	b.w	8006aa4 <gc_execute_block+0x1454>
                        gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
 8007b48:	4b0c      	ldr	r3, [pc, #48]	; (8007b7c <gc_execute_block+0x252c>)
 8007b4a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007b4c:	f8c9 3060 	str.w	r3, [r9, #96]	; 0x60
                    if (bit_isfalse(axis_words, bit(--idx)))
 8007b50:	9b04      	ldr	r3, [sp, #16]
 8007b52:	07dd      	lsls	r5, r3, #31
 8007b54:	f57f adce 	bpl.w	80076f4 <gc_execute_block+0x20a4>
                    else if (gc_block.non_modal_command != NonModal_AbsoluteOverride) {
 8007b58:	2f35      	cmp	r7, #53	; 0x35
 8007b5a:	f47f accd 	bne.w	80074f8 <gc_execute_block+0x1ea8>
 8007b5e:	f7ff baf9 	b.w	8007154 <gc_execute_block+0x1b04>
            protocol_buffer_synchronize(); // Ensure user defined mcode is executed when specified in program.
 8007b62:	f003 ffa7 	bl	800bab4 <protocol_buffer_synchronize>
 8007b66:	6820      	ldr	r0, [r4, #0]
 8007b68:	f7fe bff3 	b.w	8006b52 <gc_execute_block+0x1502>
 8007b6c:	200009dc 	.word	0x200009dc
 8007b70:	20002610 	.word	0x20002610
 8007b74:	20002448 	.word	0x20002448
 8007b78:	20002494 	.word	0x20002494
 8007b7c:	200023dc 	.word	0x200023dc
 8007b80:	200024bc 	.word	0x200024bc
                if(gc_block.modal.plane_select != PlaneSelect_ZX)
 8007b84:	f899 300d 	ldrb.w	r3, [r9, #13]
 8007b88:	2b01      	cmp	r3, #1
 8007b8a:	f040 83bc 	bne.w	8008306 <gc_execute_block+0x2cb6>
                if(axis_words & ~(bit(X_AXIS)|bit(Z_AXIS)))
 8007b8e:	9b04      	ldr	r3, [sp, #16]
 8007b90:	f033 0305 	bics.w	r3, r3, #5
 8007b94:	f47e aeb8 	bne.w	8006908 <gc_execute_block+0x12b8>
                if(bit_istrue(value_words, bit(Word_R)) && gc_block.values.r < 1.0f)
 8007b98:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8007b9a:	9308      	str	r3, [sp, #32]
 8007b9c:	f413 7300 	ands.w	r3, r3, #512	; 0x200
 8007ba0:	9312      	str	r3, [sp, #72]	; 0x48
 8007ba2:	d008      	beq.n	8007bb6 <gc_execute_block+0x2566>
 8007ba4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8007ba8:	f8d9 0054 	ldr.w	r0, [r9, #84]	; 0x54
 8007bac:	f7f8 ff90 	bl	8000ad0 <__aeabi_fcmplt>
 8007bb0:	2800      	cmp	r0, #0
 8007bb2:	f47f ac83 	bne.w	80074bc <gc_execute_block+0x1e6c>
                if(bit_isfalse(axis_words, bit(Z_AXIS)) || bit_isfalse(value_words, bit(Word_I)|bit(Word_J)|bit(Word_K)|bit(Word_P)))
 8007bb6:	9b04      	ldr	r3, [sp, #16]
 8007bb8:	075b      	lsls	r3, r3, #29
 8007bba:	f57e acd5 	bpl.w	8006568 <gc_execute_block+0xf18>
 8007bbe:	9e08      	ldr	r6, [sp, #32]
 8007bc0:	f416 7f9c 	tst.w	r6, #312	; 0x138
 8007bc4:	f43e acd0 	beq.w	8006568 <gc_execute_block+0xf18>
                if(gc_block.values.p < 0.0f || gc_block.values.ijk[J_VALUE] < 0.0f || gc_block.values.ijk[K_VALUE] < 0.0f || gc_block.values.h < 0.0f)
 8007bc8:	f8d9 304c 	ldr.w	r3, [r9, #76]	; 0x4c
 8007bcc:	2100      	movs	r1, #0
 8007bce:	4618      	mov	r0, r3
 8007bd0:	9310      	str	r3, [sp, #64]	; 0x40
 8007bd2:	f7f8 ff7d 	bl	8000ad0 <__aeabi_fcmplt>
 8007bd6:	2800      	cmp	r0, #0
 8007bd8:	f47e ad3f 	bne.w	800665a <gc_execute_block+0x100a>
 8007bdc:	f8d9 5040 	ldr.w	r5, [r9, #64]	; 0x40
 8007be0:	2100      	movs	r1, #0
 8007be2:	4628      	mov	r0, r5
 8007be4:	f7f8 ff74 	bl	8000ad0 <__aeabi_fcmplt>
 8007be8:	2800      	cmp	r0, #0
 8007bea:	f47e ad36 	bne.w	800665a <gc_execute_block+0x100a>
 8007bee:	f8d9 7044 	ldr.w	r7, [r9, #68]	; 0x44
 8007bf2:	2100      	movs	r1, #0
 8007bf4:	4638      	mov	r0, r7
 8007bf6:	f7f8 ff6b 	bl	8000ad0 <__aeabi_fcmplt>
 8007bfa:	2800      	cmp	r0, #0
 8007bfc:	f47e ad2d 	bne.w	800665a <gc_execute_block+0x100a>
                if(gc_block.values.ijk[I_VALUE] == 0.0f ||
 8007c00:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 8007c04:	2100      	movs	r1, #0
 8007c06:	4618      	mov	r0, r3
 8007c08:	9311      	str	r3, [sp, #68]	; 0x44
 8007c0a:	f7f8 ff57 	bl	8000abc <__aeabi_fcmpeq>
 8007c0e:	2800      	cmp	r0, #0
 8007c10:	f47f ac54 	bne.w	80074bc <gc_execute_block+0x1e6c>
 8007c14:	2100      	movs	r1, #0
 8007c16:	4628      	mov	r0, r5
 8007c18:	f7f8 ff50 	bl	8000abc <__aeabi_fcmpeq>
 8007c1c:	2800      	cmp	r0, #0
 8007c1e:	f47f ac4d 	bne.w	80074bc <gc_execute_block+0x1e6c>
                    gc_block.values.ijk[J_VALUE] == 0.0f ||
 8007c22:	4639      	mov	r1, r7
 8007c24:	4628      	mov	r0, r5
 8007c26:	f7f8 ff67 	bl	8000af8 <__aeabi_fcmpge>
 8007c2a:	2800      	cmp	r0, #0
 8007c2c:	f47f ac46 	bne.w	80074bc <gc_execute_block+0x1e6c>
                     gc_block.values.ijk[K_VALUE] <= gc_block.values.ijk[J_VALUE] ||
 8007c30:	f016 0340 	ands.w	r3, r6, #64	; 0x40
 8007c34:	9313      	str	r3, [sp, #76]	; 0x4c
 8007c36:	d004      	beq.n	8007c42 <gc_execute_block+0x25f2>
                      (bit_istrue(value_words, bit(Word_L)) && (gc_taper_type)gc_block.values.l > Taper_Both))
 8007c38:	f899 307e 	ldrb.w	r3, [r9, #126]	; 0x7e
 8007c3c:	2b03      	cmp	r3, #3
 8007c3e:	f63f ac3d 	bhi.w	80074bc <gc_execute_block+0x1e6c>
                if(gc_state.spindle.rpm < settings.spindle.rpm_min || gc_state.spindle.rpm > settings.spindle.rpm_max)
 8007c42:	4bac      	ldr	r3, [pc, #688]	; (8007ef4 <gc_execute_block+0x28a4>)
 8007c44:	4eac      	ldr	r6, [pc, #688]	; (8007ef8 <gc_execute_block+0x28a8>)
 8007c46:	f8d3 b048 	ldr.w	fp, [r3, #72]	; 0x48
 8007c4a:	6cb1      	ldr	r1, [r6, #72]	; 0x48
 8007c4c:	4658      	mov	r0, fp
 8007c4e:	f7f8 ff3f 	bl	8000ad0 <__aeabi_fcmplt>
 8007c52:	2800      	cmp	r0, #0
 8007c54:	f040 81a6 	bne.w	8007fa4 <gc_execute_block+0x2954>
 8007c58:	4658      	mov	r0, fp
 8007c5a:	6c71      	ldr	r1, [r6, #68]	; 0x44
 8007c5c:	f7f8 ff56 	bl	8000b0c <__aeabi_fcmpgt>
 8007c60:	2800      	cmp	r0, #0
 8007c62:	f040 819f 	bne.w	8007fa4 <gc_execute_block+0x2954>
                if(gc_block.modal.motion != gc_state.modal.motion) {
 8007c66:	f1ba 0f4c 	cmp.w	sl, #76	; 0x4c
                    memset(&thread, 0, sizeof(gc_thread_data));
 8007c6a:	f8df a294 	ldr.w	sl, [pc, #660]	; 8007f00 <gc_execute_block+0x28b0>
                if(gc_block.modal.motion != gc_state.modal.motion) {
 8007c6e:	d00b      	beq.n	8007c88 <gc_execute_block+0x2638>
                    thread.depth_degression = 1.0f;
 8007c70:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
                    memset(&thread, 0, sizeof(gc_thread_data));
 8007c74:	e9ca 0007 	strd	r0, r0, [sl, #28]
 8007c78:	e9ca 0009 	strd	r0, r0, [sl, #36]	; 0x24
 8007c7c:	f8ca 0018 	str.w	r0, [sl, #24]
                    thread.depth_degression = 1.0f;
 8007c80:	f8ca 1014 	str.w	r1, [sl, #20]
                    memset(&thread, 0, sizeof(gc_thread_data));
 8007c84:	f8ca 002c 	str.w	r0, [sl, #44]	; 0x2c
                thread.z_final = gc_block.values.xyz[Z_AXIS];
 8007c88:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
                thread.pitch = gc_block.values.p;
 8007c8c:	9a10      	ldr	r2, [sp, #64]	; 0x40
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 8007c8e:	2100      	movs	r1, #0
 8007c90:	9811      	ldr	r0, [sp, #68]	; 0x44
                thread.pitch = gc_block.values.p;
 8007c92:	f8ca 2000 	str.w	r2, [sl]
                thread.z_final = gc_block.values.xyz[Z_AXIS];
 8007c96:	f8ca 3004 	str.w	r3, [sl, #4]
 8007c9a:	461e      	mov	r6, r3
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 8007c9c:	f7f8 ff18 	bl	8000ad0 <__aeabi_fcmplt>
 8007ca0:	2800      	cmp	r0, #0
 8007ca2:	f040 83b7 	bne.w	8008414 <gc_execute_block+0x2dc4>
 8007ca6:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
                thread.peak = fabsf(gc_block.values.ijk[I_VALUE]);
 8007caa:	9911      	ldr	r1, [sp, #68]	; 0x44
                if(gc_block.modal.units_imperial) {
 8007cac:	f899 200a 	ldrb.w	r2, [r9, #10]
                thread.peak = fabsf(gc_block.values.ijk[I_VALUE]);
 8007cb0:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
 8007cb4:	f8ca 0008 	str.w	r0, [sl, #8]
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 8007cb8:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
                thread.initial_depth = gc_block.values.ijk[J_VALUE];
 8007cbc:	f8ca 500c 	str.w	r5, [sl, #12]
                thread.depth = gc_block.values.ijk[K_VALUE];
 8007cc0:	f8ca 7010 	str.w	r7, [sl, #16]
                if(gc_block.modal.units_imperial) {
 8007cc4:	b182      	cbz	r2, 8007ce8 <gc_execute_block+0x2698>
                    thread.peak *= MM_PER_INCH;
 8007cc6:	498d      	ldr	r1, [pc, #564]	; (8007efc <gc_execute_block+0x28ac>)
 8007cc8:	f7f8 fd64 	bl	8000794 <__aeabi_fmul>
                    thread.initial_depth *= MM_PER_INCH;
 8007ccc:	498b      	ldr	r1, [pc, #556]	; (8007efc <gc_execute_block+0x28ac>)
                    thread.peak *= MM_PER_INCH;
 8007cce:	f8ca 0008 	str.w	r0, [sl, #8]
                    thread.initial_depth *= MM_PER_INCH;
 8007cd2:	4628      	mov	r0, r5
 8007cd4:	f7f8 fd5e 	bl	8000794 <__aeabi_fmul>
                    thread.depth *= MM_PER_INCH;
 8007cd8:	4988      	ldr	r1, [pc, #544]	; (8007efc <gc_execute_block+0x28ac>)
                    thread.initial_depth *= MM_PER_INCH;
 8007cda:	f8ca 000c 	str.w	r0, [sl, #12]
                    thread.depth *= MM_PER_INCH;
 8007cde:	4638      	mov	r0, r7
 8007ce0:	f7f8 fd58 	bl	8000794 <__aeabi_fmul>
 8007ce4:	f8ca 0010 	str.w	r0, [sl, #16]
                if(gc_block.modal.diameter_mode) {
 8007ce8:	f899 300c 	ldrb.w	r3, [r9, #12]
 8007cec:	b1bb      	cbz	r3, 8007d1e <gc_execute_block+0x26ce>
                    thread.peak /= 2.0f;
 8007cee:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8007cf2:	f8da 0008 	ldr.w	r0, [sl, #8]
 8007cf6:	f7f8 fd4d 	bl	8000794 <__aeabi_fmul>
                    thread.initial_depth /= 2.0f;
 8007cfa:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
                    thread.peak /= 2.0f;
 8007cfe:	f8ca 0008 	str.w	r0, [sl, #8]
                    thread.initial_depth /= 2.0f;
 8007d02:	f8da 000c 	ldr.w	r0, [sl, #12]
 8007d06:	f7f8 fd45 	bl	8000794 <__aeabi_fmul>
                    thread.depth /= 2.0f;
 8007d0a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
                    thread.initial_depth /= 2.0f;
 8007d0e:	f8ca 000c 	str.w	r0, [sl, #12]
                    thread.depth /= 2.0f;
 8007d12:	f8da 0010 	ldr.w	r0, [sl, #16]
 8007d16:	f7f8 fd3d 	bl	8000794 <__aeabi_fmul>
 8007d1a:	f8ca 0010 	str.w	r0, [sl, #16]
                if(bit_istrue(axis_words, bit(X_AXIS))) {
 8007d1e:	9b04      	ldr	r3, [sp, #16]
 8007d20:	07df      	lsls	r7, r3, #31
 8007d22:	d533      	bpl.n	8007d8c <gc_execute_block+0x273c>
                    thread.main_taper_height = gc_block.values.xyz[X_AXIS] - gc_get_block_offset(&gc_block, X_AXIS);
 8007d24:	4d73      	ldr	r5, [pc, #460]	; (8007ef4 <gc_execute_block+0x28a4>)
 8007d26:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8007d2a:	f8d5 1084 	ldr.w	r1, [r5, #132]	; 0x84
 8007d2e:	f7f8 fc29 	bl	8000584 <__addsf3>
 8007d32:	4601      	mov	r1, r0
 8007d34:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 8007d38:	f7f8 fc22 	bl	8000580 <__aeabi_fsub>
 8007d3c:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
 8007d40:	f7f8 fc1e 	bl	8000580 <__aeabi_fsub>
                    gc_block.values.p = fabsf(thread.z_final - gc_state.position[Z_AXIS]);
 8007d44:	6f69      	ldr	r1, [r5, #116]	; 0x74
                    thread.main_taper_height = gc_block.values.xyz[X_AXIS] - gc_get_block_offset(&gc_block, X_AXIS);
 8007d46:	4607      	mov	r7, r0
 8007d48:	f8ca 0018 	str.w	r0, [sl, #24]
                    gc_block.values.p = fabsf(thread.z_final - gc_state.position[Z_AXIS]);
 8007d4c:	4630      	mov	r0, r6
 8007d4e:	f7f8 fc17 	bl	8000580 <__aeabi_fsub>
    return sqrtf(x*x + y*y);
 8007d52:	4639      	mov	r1, r7
                    gc_block.values.p = fabsf(thread.z_final - gc_state.position[Z_AXIS]);
 8007d54:	4605      	mov	r5, r0
 8007d56:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
 8007d5a:	f8c9 704c 	str.w	r7, [r9, #76]	; 0x4c
    return sqrtf(x*x + y*y);
 8007d5e:	4608      	mov	r0, r1
 8007d60:	f7f8 fd18 	bl	8000794 <__aeabi_fmul>
 8007d64:	4629      	mov	r1, r5
 8007d66:	4605      	mov	r5, r0
 8007d68:	4608      	mov	r0, r1
 8007d6a:	f7f8 fd13 	bl	8000794 <__aeabi_fmul>
 8007d6e:	4601      	mov	r1, r0
 8007d70:	4628      	mov	r0, r5
 8007d72:	f7f8 fc07 	bl	8000584 <__addsf3>
 8007d76:	f00b f939 	bl	8012fec <sqrtf>
 8007d7a:	4601      	mov	r1, r0
                    thread.pitch = thread.pitch * hypot_f(thread.main_taper_height, gc_block.values.p) / gc_block.values.p;
 8007d7c:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007d7e:	f7f8 fd09 	bl	8000794 <__aeabi_fmul>
 8007d82:	4639      	mov	r1, r7
 8007d84:	f7f8 fdba 	bl	80008fc <__aeabi_fdiv>
 8007d88:	f8ca 0000 	str.w	r0, [sl]
                if(bit_istrue(value_words, bit(Word_H)))
 8007d8c:	9b08      	ldr	r3, [sp, #32]
 8007d8e:	075d      	lsls	r5, r3, #29
                    thread.spring_passes = (uint_fast16_t)gc_block.values.h;
 8007d90:	bf44      	itt	mi
 8007d92:	f899 307c 	ldrbmi.w	r3, [r9, #124]	; 0x7c
 8007d96:	f8ca 3028 	strmi.w	r3, [sl, #40]	; 0x28
                if(bit_istrue(value_words, bit(Word_L)))
 8007d9a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8007d9c:	b11b      	cbz	r3, 8007da6 <gc_execute_block+0x2756>
                    thread.end_taper_type = (gc_taper_type)gc_block.values.l;
 8007d9e:	f899 307e 	ldrb.w	r3, [r9, #126]	; 0x7e
 8007da2:	f88a 302c 	strb.w	r3, [sl, #44]	; 0x2c
                if(bit_istrue(value_words, bit(Word_E)))
 8007da6:	9b08      	ldr	r3, [sp, #32]
                if(thread.end_taper_length <= 0.0f || thread.end_taper_type == Taper_None) {
 8007da8:	2100      	movs	r1, #0
                if(bit_istrue(value_words, bit(Word_E)))
 8007daa:	07d8      	lsls	r0, r3, #31
                    thread.end_taper_length = gc_block.values.e;
 8007dac:	bf44      	itt	mi
 8007dae:	f8d9 3034 	ldrmi.w	r3, [r9, #52]	; 0x34
 8007db2:	f8ca 301c 	strmi.w	r3, [sl, #28]
                if(thread.end_taper_length <= 0.0f || thread.end_taper_type == Taper_None) {
 8007db6:	f8da 501c 	ldr.w	r5, [sl, #28]
 8007dba:	4628      	mov	r0, r5
 8007dbc:	f7f8 fe92 	bl	8000ae4 <__aeabi_fcmple>
 8007dc0:	2800      	cmp	r0, #0
 8007dc2:	f040 8320 	bne.w	8008406 <gc_execute_block+0x2db6>
 8007dc6:	f89a 302c 	ldrb.w	r3, [sl, #44]	; 0x2c
 8007dca:	2b00      	cmp	r3, #0
 8007dcc:	f000 831b 	beq.w	8008406 <gc_execute_block+0x2db6>
                if(thread.end_taper_type != Taper_None && thread.end_taper_length > abs(thread.z_final - gc_state.position[Z_AXIS]) / 2.0f)
 8007dd0:	4b48      	ldr	r3, [pc, #288]	; (8007ef4 <gc_execute_block+0x28a4>)
 8007dd2:	4630      	mov	r0, r6
 8007dd4:	6f59      	ldr	r1, [r3, #116]	; 0x74
 8007dd6:	f7f8 fbd3 	bl	8000580 <__aeabi_fsub>
 8007dda:	f7f8 feb7 	bl	8000b4c <__aeabi_f2iz>
 8007dde:	2800      	cmp	r0, #0
 8007de0:	bfb8      	it	lt
 8007de2:	4240      	neglt	r0, r0
 8007de4:	f7f8 fc82 	bl	80006ec <__aeabi_i2f>
 8007de8:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8007dec:	f7f8 fcd2 	bl	8000794 <__aeabi_fmul>
 8007df0:	4601      	mov	r1, r0
 8007df2:	4628      	mov	r0, r5
 8007df4:	f7f8 fe8a 	bl	8000b0c <__aeabi_fcmpgt>
 8007df8:	2800      	cmp	r0, #0
 8007dfa:	f47f ab5f 	bne.w	80074bc <gc_execute_block+0x1e6c>
                if(bit_istrue(value_words, bit(Word_R)))
 8007dfe:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8007e00:	b11b      	cbz	r3, 8007e0a <gc_execute_block+0x27ba>
                    thread.depth_degression = gc_block.values.r;
 8007e02:	f8d9 3054 	ldr.w	r3, [r9, #84]	; 0x54
 8007e06:	f8ca 3014 	str.w	r3, [sl, #20]
                if(bit_istrue(value_words, bit(Word_Q)))
 8007e0a:	9b08      	ldr	r3, [sp, #32]
 8007e0c:	0419      	lsls	r1, r3, #16
                    thread.infeed_angle = gc_block.values.q;
 8007e0e:	bf44      	itt	mi
 8007e10:	f8d9 3050 	ldrmi.w	r3, [r9, #80]	; 0x50
 8007e14:	f8ca 3020 	strmi.w	r3, [sl, #32]
                bit_false(value_words, bit(Word_E)|bit(Word_H)|bit(Word_I)|bit(Word_J)|bit(Word_K)|bit(Word_L)|bit(Word_P)|bit(Word_Q)|bit(Word_R));
 8007e18:	9b08      	ldr	r3, [sp, #32]
 8007e1a:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 8007e1e:	f023 037d 	bic.w	r3, r3, #125	; 0x7d
 8007e22:	9315      	str	r3, [sp, #84]	; 0x54
                gc_parser_flags.spindle_force_sync = On;
 8007e24:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8007e28:	f043 0320 	orr.w	r3, r3, #32
 8007e2c:	f8ad 301c 	strh.w	r3, [sp, #28]
            if (gc_block.modal.canned_cycle_active) {
 8007e30:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8007e32:	2b00      	cmp	r3, #0
 8007e34:	f43e aa4a 	beq.w	80062cc <gc_execute_block+0xc7c>
                if(gc_parser_flags.canned_cycle_change) {
 8007e38:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8007e3c:	f013 0702 	ands.w	r7, r3, #2
 8007e40:	f040 808e 	bne.w	8007f60 <gc_execute_block+0x2910>
 8007e44:	9d15      	ldr	r5, [sp, #84]	; 0x54
                if(bit_isfalse(value_words, bit(Word_L)))
 8007e46:	066e      	lsls	r6, r5, #25
 8007e48:	f100 82d4 	bmi.w	80083f4 <gc_execute_block+0x2da4>
                    gc_block.values.l = 1;
 8007e4c:	2301      	movs	r3, #1
 8007e4e:	f889 307e 	strb.w	r3, [r9, #126]	; 0x7e
                if (bit_istrue(value_words, bit(Word_R))) {
 8007e52:	05a8      	lsls	r0, r5, #22
 8007e54:	d515      	bpl.n	8007e82 <gc_execute_block+0x2832>
                    if(gc_state.modal.distance_incremental)
 8007e56:	4e27      	ldr	r6, [pc, #156]	; (8007ef4 <gc_execute_block+0x28a4>)
                    gc_state.canned.retract_position = gc_block.values.r;
 8007e58:	f8d9 1054 	ldr.w	r1, [r9, #84]	; 0x54
                    if(gc_state.modal.distance_incremental)
 8007e5c:	78f3      	ldrb	r3, [r6, #3]
                    gc_state.canned.retract_position = gc_block.values.r;
 8007e5e:	6431      	str	r1, [r6, #64]	; 0x40
                    if(gc_state.modal.distance_incremental)
 8007e60:	b133      	cbz	r3, 8007e70 <gc_execute_block+0x2820>
                        gc_state.canned.retract_position += gc_state.position[plane.axis_linear];
 8007e62:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007e64:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8007e68:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8007e6a:	f7f8 fb8b 	bl	8000584 <__addsf3>
 8007e6e:	6430      	str	r0, [r6, #64]	; 0x40
                    gc_state.canned.retract_position = gc_block.modal.coord_system.xyz[plane.axis_linear] + gc_state.canned.retract_position;
 8007e70:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007e72:	4e20      	ldr	r6, [pc, #128]	; (8007ef4 <gc_execute_block+0x28a4>)
 8007e74:	3304      	adds	r3, #4
 8007e76:	6c31      	ldr	r1, [r6, #64]	; 0x40
 8007e78:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 8007e7c:	f7f8 fb82 	bl	8000584 <__addsf3>
 8007e80:	6430      	str	r0, [r6, #64]	; 0x40
                    if(bit_istrue(axis_words, bit(--idx))) {
 8007e82:	9b04      	ldr	r3, [sp, #16]
 8007e84:	0759      	lsls	r1, r3, #29
 8007e86:	d50a      	bpl.n	8007e9e <gc_execute_block+0x284e>
                        if(idx != plane.axis_linear)
 8007e88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007e8a:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 8007e8e:	4e19      	ldr	r6, [pc, #100]	; (8007ef4 <gc_execute_block+0x28a4>)
                        if(idx != plane.axis_linear)
 8007e90:	2b02      	cmp	r3, #2
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007e92:	6330      	str	r0, [r6, #48]	; 0x30
                        if(idx != plane.axis_linear)
 8007e94:	d003      	beq.n	8007e9e <gc_execute_block+0x284e>
                            gc_state.canned.xyz[idx] -= gc_state.position[idx];
 8007e96:	6f71      	ldr	r1, [r6, #116]	; 0x74
 8007e98:	f7f8 fb72 	bl	8000580 <__aeabi_fsub>
 8007e9c:	6330      	str	r0, [r6, #48]	; 0x30
                    if(bit_istrue(axis_words, bit(--idx))) {
 8007e9e:	9b04      	ldr	r3, [sp, #16]
 8007ea0:	079a      	lsls	r2, r3, #30
 8007ea2:	d50a      	bpl.n	8007eba <gc_execute_block+0x286a>
                        if(idx != plane.axis_linear)
 8007ea4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007ea6:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 8007eaa:	4e12      	ldr	r6, [pc, #72]	; (8007ef4 <gc_execute_block+0x28a4>)
                        if(idx != plane.axis_linear)
 8007eac:	2b01      	cmp	r3, #1
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007eae:	62f0      	str	r0, [r6, #44]	; 0x2c
                        if(idx != plane.axis_linear)
 8007eb0:	d003      	beq.n	8007eba <gc_execute_block+0x286a>
                            gc_state.canned.xyz[idx] -= gc_state.position[idx];
 8007eb2:	6f31      	ldr	r1, [r6, #112]	; 0x70
 8007eb4:	f7f8 fb64 	bl	8000580 <__aeabi_fsub>
 8007eb8:	62f0      	str	r0, [r6, #44]	; 0x2c
                    if(bit_istrue(axis_words, bit(--idx))) {
 8007eba:	9b04      	ldr	r3, [sp, #16]
 8007ebc:	07db      	lsls	r3, r3, #31
 8007ebe:	d509      	bpl.n	8007ed4 <gc_execute_block+0x2884>
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007ec0:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 8007ec4:	4e0b      	ldr	r6, [pc, #44]	; (8007ef4 <gc_execute_block+0x28a4>)
                        if(idx != plane.axis_linear)
 8007ec6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
                        gc_state.canned.xyz[idx] = gc_block.values.xyz[idx];
 8007ec8:	62b0      	str	r0, [r6, #40]	; 0x28
                        if(idx != plane.axis_linear)
 8007eca:	b11b      	cbz	r3, 8007ed4 <gc_execute_block+0x2884>
                            gc_state.canned.xyz[idx] -= gc_state.position[idx];
 8007ecc:	6ef1      	ldr	r1, [r6, #108]	; 0x6c
 8007ece:	f7f8 fb57 	bl	8000580 <__aeabi_fsub>
 8007ed2:	62b0      	str	r0, [r6, #40]	; 0x28
                if(gc_state.canned.retract_position < gc_state.canned.xyz[plane.axis_linear])
 8007ed4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007ed6:	4a07      	ldr	r2, [pc, #28]	; (8007ef4 <gc_execute_block+0x28a4>)
 8007ed8:	330a      	adds	r3, #10
 8007eda:	f852 a023 	ldr.w	sl, [r2, r3, lsl #2]
 8007ede:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8007ee0:	4651      	mov	r1, sl
 8007ee2:	4618      	mov	r0, r3
 8007ee4:	9308      	str	r3, [sp, #32]
 8007ee6:	f7f8 fdf3 	bl	8000ad0 <__aeabi_fcmplt>
 8007eea:	2800      	cmp	r0, #0
 8007eec:	f47e acf7 	bne.w	80068de <gc_execute_block+0x128e>
 8007ef0:	e008      	b.n	8007f04 <gc_execute_block+0x28b4>
 8007ef2:	bf00      	nop
 8007ef4:	200023dc 	.word	0x200023dc
 8007ef8:	20002620 	.word	0x20002620
 8007efc:	41cb3333 	.word	0x41cb3333
 8007f00:	20000a28 	.word	0x20000a28
                bit_false(value_words, bit(Word_R)|bit(Word_L)); // Remove single-meaning value words.
 8007f04:	f425 7110 	bic.w	r1, r5, #576	; 0x240
 8007f08:	f1a4 0249 	sub.w	r2, r4, #73	; 0x49
 8007f0c:	9b08      	ldr	r3, [sp, #32]
 8007f0e:	9115      	str	r1, [sp, #84]	; 0x54
                switch (gc_block.modal.motion) {
 8007f10:	2a10      	cmp	r2, #16
 8007f12:	f63e a9db 	bhi.w	80062cc <gc_execute_block+0xc7c>
 8007f16:	a101      	add	r1, pc, #4	; (adr r1, 8007f1c <gc_execute_block+0x28cc>)
 8007f18:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 8007f1c:	080083bd 	.word	0x080083bd
 8007f20:	080062cd 	.word	0x080062cd
 8007f24:	080062cd 	.word	0x080062cd
 8007f28:	080062cd 	.word	0x080062cd
 8007f2c:	080062cd 	.word	0x080062cd
 8007f30:	080062cd 	.word	0x080062cd
 8007f34:	080062cd 	.word	0x080062cd
 8007f38:	080062cd 	.word	0x080062cd
 8007f3c:	0800839f 	.word	0x0800839f
 8007f40:	08008379 	.word	0x08008379
 8007f44:	080083bd 	.word	0x080083bd
 8007f48:	080062cd 	.word	0x080062cd
 8007f4c:	0800839f 	.word	0x0800839f
 8007f50:	08008367 	.word	0x08008367
 8007f54:	080062cd 	.word	0x080062cd
 8007f58:	080062cd 	.word	0x080062cd
 8007f5c:	08008367 	.word	0x08008367
                    if(gc_state.modal.feed_mode == FeedMode_InverseTime)
 8007f60:	4b7a      	ldr	r3, [pc, #488]	; (800814c <gc_execute_block+0x2afc>)
 8007f62:	785b      	ldrb	r3, [r3, #1]
 8007f64:	2b01      	cmp	r3, #1
 8007f66:	f000 8257 	beq.w	8008418 <gc_execute_block+0x2dc8>
                    if(bit_isfalse(value_words, bit(Word_R)))
 8007f6a:	9d15      	ldr	r5, [sp, #84]	; 0x54
 8007f6c:	05aa      	lsls	r2, r5, #22
 8007f6e:	f57e aafb 	bpl.w	8006568 <gc_execute_block+0xf18>
                    if(!(axis_words & bit(plane.axis_linear)))
 8007f72:	9b04      	ldr	r3, [sp, #16]
 8007f74:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007f76:	40d3      	lsrs	r3, r2
 8007f78:	07db      	lsls	r3, r3, #31
 8007f7a:	f57e aaf5 	bpl.w	8006568 <gc_execute_block+0xf18>
                    gc_state.canned.prev_position = gc_state.position[plane.axis_linear];
 8007f7e:	4873      	ldr	r0, [pc, #460]	; (800814c <gc_execute_block+0x2afc>)
                    gc_state.canned.rapid_retract = On;
 8007f80:	2101      	movs	r1, #1
                    gc_state.canned.prev_position = gc_state.position[plane.axis_linear];
 8007f82:	eb00 0382 	add.w	r3, r0, r2, lsl #2
 8007f86:	6eda      	ldr	r2, [r3, #108]	; 0x6c
                    gc_state.canned.dwell = 0.0f;
 8007f88:	2300      	movs	r3, #0
                    gc_state.canned.prev_position = gc_state.position[plane.axis_linear];
 8007f8a:	63c2      	str	r2, [r0, #60]	; 0x3c
                    gc_state.canned.xyz[plane.axis_0] = 0.0f;
 8007f8c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
                    gc_state.canned.dwell = 0.0f;
 8007f8e:	6383      	str	r3, [r0, #56]	; 0x38
                    gc_state.canned.xyz[plane.axis_0] = 0.0f;
 8007f90:	320a      	adds	r2, #10
 8007f92:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
                    gc_state.canned.xyz[plane.axis_1] = 0.0f;
 8007f96:	9a0d      	ldr	r2, [sp, #52]	; 0x34
                    gc_state.canned.rapid_retract = On;
 8007f98:	f8a0 1044 	strh.w	r1, [r0, #68]	; 0x44
                    gc_state.canned.xyz[plane.axis_1] = 0.0f;
 8007f9c:	320a      	adds	r2, #10
 8007f9e:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
                    gc_state.canned.prev_position = gc_state.position[plane.axis_linear];
 8007fa2:	e750      	b.n	8007e46 <gc_execute_block+0x27f6>
                    FAIL(Status_GcodeRPMOutOfRange);
 8007fa4:	232c      	movs	r3, #44	; 0x2c
 8007fa6:	9304      	str	r3, [sp, #16]
 8007fa8:	f7fd bd97 	b.w	8005ada <gc_execute_block+0x48a>
            gc_parser_flags.laser_is_motion = On;
 8007fac:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8007fb0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007fb4:	f8ad 301c 	strh.w	r3, [sp, #28]
 8007fb8:	4b64      	ldr	r3, [pc, #400]	; (800814c <gc_execute_block+0x2afc>)
 8007fba:	7e9b      	ldrb	r3, [r3, #26]
 8007fbc:	f7fe bce2 	b.w	8006984 <gc_execute_block+0x1334>
            } else if (!gc_parser_flags.laser_disable) // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
 8007fc0:	064f      	lsls	r7, r1, #25
 8007fc2:	f53f a8eb 	bmi.w	800719c <gc_execute_block+0x1b4c>
                gc_parser_flags.spindle_force_sync = On;
 8007fc6:	f042 0220 	orr.w	r2, r2, #32
 8007fca:	f8ad 201c 	strh.w	r2, [sp, #28]
 8007fce:	f7fe bcd9 	b.w	8006984 <gc_execute_block+0x1334>
        scale_factor.xyz[idx] = 0.0f;
 8007fd2:	2200      	movs	r2, #0
    gc_state.modal.scaling_active = factor != 1.0f;
 8007fd4:	2100      	movs	r1, #0
 8007fd6:	4b5d      	ldr	r3, [pc, #372]	; (800814c <gc_execute_block+0x2afc>)
        scale_factor.ijk[--idx] = factor;
 8007fd8:	616f      	str	r7, [r5, #20]
 8007fda:	612f      	str	r7, [r5, #16]
 8007fdc:	60ef      	str	r7, [r5, #12]
    gc_state.modal.scaling_active = factor != 1.0f;
 8007fde:	7799      	strb	r1, [r3, #30]
        scale_factor.xyz[idx] = 0.0f;
 8007fe0:	60aa      	str	r2, [r5, #8]
 8007fe2:	606a      	str	r2, [r5, #4]
 8007fe4:	602a      	str	r2, [r5, #0]
    if(state.value != gc_get_g51_state().value)
 8007fe6:	2e00      	cmp	r6, #0
 8007fe8:	f43e ade7 	beq.w	8006bba <gc_execute_block+0x156a>
 8007fec:	f7fe beed 	b.w	8006dca <gc_execute_block+0x177a>
            gc_block.values.s = pos <= 0.0f ? gc_state.spindle.css.max_rpm : min(gc_state.spindle.css.max_rpm, gc_state.spindle.css.surface_speed / (pos * (float)(2.0f * M_PI)));
 8007ff0:	4b56      	ldr	r3, [pc, #344]	; (800814c <gc_execute_block+0x2afc>)
 8007ff2:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 8007ff4:	f7ff bae9 	b.w	80075ca <gc_execute_block+0x1f7a>
                if(settings_read_coord_data(SETTING_INDEX_G92, &g92_offset_stored) && !isequal_position_vector(g92_offset_stored, gc_state.g92_coord_offset))
 8007ff8:	200b      	movs	r0, #11
 8007ffa:	a918      	add	r1, sp, #96	; 0x60
 8007ffc:	f006 f898 	bl	800e130 <settings_read_coord_data>
 8008000:	b138      	cbz	r0, 8008012 <gc_execute_block+0x29c2>
 8008002:	220c      	movs	r2, #12
 8008004:	4952      	ldr	r1, [pc, #328]	; (8008150 <gc_execute_block+0x2b00>)
 8008006:	a818      	add	r0, sp, #96	; 0x60
 8008008:	f009 fe20 	bl	8011c4c <memcmp>
 800800c:	2800      	cmp	r0, #0
 800800e:	f040 816b 	bne.w	80082e8 <gc_execute_block+0x2c98>
                if (!(settings_read_coord_data(gc_state.modal.coord_system.idx, &gc_state.modal.coord_system.xyz)))
 8008012:	4950      	ldr	r1, [pc, #320]	; (8008154 <gc_execute_block+0x2b04>)
 8008014:	7b08      	ldrb	r0, [r1, #12]
 8008016:	f006 f88b 	bl	800e130 <settings_read_coord_data>
 800801a:	2800      	cmp	r0, #0
 800801c:	f43f a88e 	beq.w	800713c <gc_execute_block+0x1aec>
                hal.spindle_set_state(gc_state.modal.spindle, 0.0f);
 8008020:	4f4d      	ldr	r7, [pc, #308]	; (8008158 <gc_execute_block+0x2b08>)
 8008022:	4d4a      	ldr	r5, [pc, #296]	; (800814c <gc_execute_block+0x2afc>)
                system_flag_wco_change(); // Set to refresh immediately just in case something altered.
 8008024:	f009 fb68 	bl	80116f8 <system_flag_wco_change>
                hal.spindle_set_state(gc_state.modal.spindle, 0.0f);
 8008028:	2100      	movs	r1, #0
 800802a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800802c:	7ea8      	ldrb	r0, [r5, #26]
 800802e:	4798      	blx	r3
                hal.coolant_set_state(gc_state.modal.coolant);
 8008030:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008032:	7e68      	ldrb	r0, [r5, #25]
 8008034:	4798      	blx	r3
                sys.report.spindle = On; // Set to report change immediately
 8008036:	7d23      	ldrb	r3, [r4, #20]
 8008038:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800803c:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8008040:	7523      	strb	r3, [r4, #20]
 8008042:	f7fe be25 	b.w	8006c90 <gc_execute_block+0x1640>
                gc_state.spindle.css.active = false;
 8008046:	2300      	movs	r3, #0
 8008048:	4a40      	ldr	r2, [pc, #256]	; (800814c <gc_execute_block+0x2afc>)
 800804a:	f882 3060 	strb.w	r3, [r2, #96]	; 0x60
                protocol_buffer_synchronize(); // Empty planner buffer to ensure we get RPM at end of last CSS motion
 800804e:	f003 fd31 	bl	800bab4 <protocol_buffer_synchronize>
 8008052:	e4d1      	b.n	80079f8 <gc_execute_block+0x23a8>
            gc_state.tool_change = true;
 8008054:	2201      	movs	r2, #1
 8008056:	493d      	ldr	r1, [pc, #244]	; (800814c <gc_execute_block+0x2afc>)
            system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 8008058:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
            gc_state.tool_change = true;
 800805c:	f881 2080 	strb.w	r2, [r1, #128]	; 0x80
            system_set_exec_state_flag(EXEC_TOOL_CHANGE);   // Set up program pause for manual tool change
 8008060:	483e      	ldr	r0, [pc, #248]	; (800815c <gc_execute_block+0x2b0c>)
 8008062:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008066:	4798      	blx	r3
            protocol_execute_realtime();                    // Execute...
 8008068:	f003 fa5a 	bl	800b520 <protocol_execute_realtime>
 800806c:	f7fe bd19 	b.w	8006aa2 <gc_execute_block+0x1452>
            } else switch (gc_block.modal.motion) {
 8008070:	f104 0374 	add.w	r3, r4, #116	; 0x74
 8008074:	b2db      	uxtb	r3, r3
 8008076:	2b03      	cmp	r3, #3
 8008078:	f63e a928 	bhi.w	80062cc <gc_execute_block+0xc7c>
 800807c:	f1a4 038c 	sub.w	r3, r4, #140	; 0x8c
 8008080:	2b03      	cmp	r3, #3
 8008082:	f63e a923 	bhi.w	80062cc <gc_execute_block+0xc7c>
 8008086:	e8df f003 	tbb	[pc, r3]
 800808a:	0208      	.short	0x0208
 800808c:	0208      	.short	0x0208
                    gc_parser_flags.probe_is_no_error = On;
 800808e:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 8008092:	f043 0310 	orr.w	r3, r3, #16
 8008096:	f8ad 301c 	strh.w	r3, [sp, #28]
                    if(gc_block.modal.motion == MotionMode_ProbeAway || gc_block.modal.motion == MotionMode_ProbeAwayNoError)
 800809a:	f104 0372 	add.w	r3, r4, #114	; 0x72
 800809e:	b2db      	uxtb	r3, r3
 80080a0:	2b01      	cmp	r3, #1
 80080a2:	d805      	bhi.n	80080b0 <gc_execute_block+0x2a60>
                        gc_parser_flags.probe_is_away = On;
 80080a4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 80080a8:	f043 0308 	orr.w	r3, r3, #8
 80080ac:	f8ad 301c 	strh.w	r3, [sp, #28]
                    if (!axis_words)
 80080b0:	9b04      	ldr	r3, [sp, #16]
 80080b2:	2b00      	cmp	r3, #0
 80080b4:	f43e ac38 	beq.w	8006928 <gc_execute_block+0x12d8>
                    if (isequal_position_vector(gc_state.position, gc_block.values.xyz))
 80080b8:	220c      	movs	r2, #12
 80080ba:	4929      	ldr	r1, [pc, #164]	; (8008160 <gc_execute_block+0x2b10>)
 80080bc:	4829      	ldr	r0, [pc, #164]	; (8008164 <gc_execute_block+0x2b14>)
 80080be:	f009 fdc5 	bl	8011c4c <memcmp>
 80080c2:	2800      	cmp	r0, #0
 80080c4:	f47e a902 	bne.w	80062cc <gc_execute_block+0xc7c>
                            FAIL(Status_GcodeInvalidTarget); // [Invalid target]
 80080c8:	2321      	movs	r3, #33	; 0x21
 80080ca:	9304      	str	r3, [sp, #16]
 80080cc:	f7fd bd05 	b.w	8005ada <gc_execute_block+0x48a>
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 80080d0:	4f1e      	ldr	r7, [pc, #120]	; (800814c <gc_execute_block+0x2afc>)
 80080d2:	2100      	movs	r1, #0
 80080d4:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
 80080d8:	f7f8 fcf0 	bl	8000abc <__aeabi_fcmpeq>
                    gc_state.tool_length_offset[idx] = 0.0f;
 80080dc:	2600      	movs	r6, #0
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 80080de:	fab0 f580 	clz	r5, r0
 80080e2:	4631      	mov	r1, r6
 80080e4:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
                    gc_state.tool_length_offset[idx] = 0.0f;
 80080e8:	f8c7 6098 	str.w	r6, [r7, #152]	; 0x98
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 80080ec:	f7f8 fce6 	bl	8000abc <__aeabi_fcmpeq>
 80080f0:	4603      	mov	r3, r0
 80080f2:	4631      	mov	r1, r6
 80080f4:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 80080f8:	096d      	lsrs	r5, r5, #5
                    gc_state.tool_length_offset[idx] = 0.0f;
 80080fa:	f8c7 6094 	str.w	r6, [r7, #148]	; 0x94
 80080fe:	2b00      	cmp	r3, #0
 8008100:	bf08      	it	eq
 8008102:	2501      	moveq	r5, #1
                    tlo_changed |= gc_state.tool_length_offset[idx] != 0.0f;
 8008104:	f7f8 fcda 	bl	8000abc <__aeabi_fcmpeq>
 8008108:	2800      	cmp	r0, #0
 800810a:	bf08      	it	eq
 800810c:	2501      	moveq	r5, #1
                    gc_state.tool_length_offset[idx] = 0.0f;
 800810e:	f8c7 6090 	str.w	r6, [r7, #144]	; 0x90
        if(tlo_changed)
 8008112:	2d00      	cmp	r5, #0
 8008114:	f47f aab2 	bne.w	800767c <gc_execute_block+0x202c>
 8008118:	f7fe bd30 	b.w	8006b7c <gc_execute_block+0x152c>
                    if (bit_istrue(axis_words, bit(idx)) && gc_state.tool_length_offset[idx] != gc_block.values.xyz[idx]) {
 800811c:	9b04      	ldr	r3, [sp, #16]
 800811e:	07db      	lsls	r3, r3, #31
 8008120:	d5f7      	bpl.n	8008112 <gc_execute_block+0x2ac2>
 8008122:	f8d9 605c 	ldr.w	r6, [r9, #92]	; 0x5c
 8008126:	4b09      	ldr	r3, [pc, #36]	; (800814c <gc_execute_block+0x2afc>)
 8008128:	4631      	mov	r1, r6
 800812a:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
 800812e:	f7f8 fcc5 	bl	8000abc <__aeabi_fcmpeq>
 8008132:	2800      	cmp	r0, #0
 8008134:	f43f aa9f 	beq.w	8007676 <gc_execute_block+0x2026>
        if(tlo_changed)
 8008138:	2d00      	cmp	r5, #0
 800813a:	f47f aa9f 	bne.w	800767c <gc_execute_block+0x202c>
 800813e:	f7fe bd1d 	b.w	8006b7c <gc_execute_block+0x152c>
                    FAIL(Status_ValueWordConflict);
 8008142:	2330      	movs	r3, #48	; 0x30
 8008144:	9304      	str	r3, [sp, #16]
 8008146:	f7fd bcc8 	b.w	8005ada <gc_execute_block+0x48a>
 800814a:	bf00      	nop
 800814c:	200023dc 	.word	0x200023dc
 8008150:	20002460 	.word	0x20002460
 8008154:	200023e4 	.word	0x200023e4
 8008158:	200024bc 	.word	0x200024bc
 800815c:	200024b4 	.word	0x200024b4
 8008160:	200009dc 	.word	0x200009dc
 8008164:	20002448 	.word	0x20002448
                        if (!(ijk_words & (bit(plane.axis_0)|bit(plane.axis_1))))
 8008168:	9a08      	ldr	r2, [sp, #32]
 800816a:	4215      	tst	r5, r2
 800816c:	f000 8085 	beq.w	800827a <gc_execute_block+0x2c2a>
                        if (gc_block.modal.units_imperial) {
 8008170:	f899 200a 	ldrb.w	r2, [r9, #10]
                        bit_false(value_words, bit(Word_I)|bit(Word_J)|bit(Word_K));
 8008174:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 8008178:	9315      	str	r3, [sp, #84]	; 0x54
                        if (gc_block.modal.units_imperial) {
 800817a:	b182      	cbz	r2, 800819e <gc_execute_block+0x2b4e>
                            idx = 3;
 800817c:	2703      	movs	r7, #3
 800817e:	4da8      	ldr	r5, [pc, #672]	; (8008420 <gc_execute_block+0x2dd0>)
                                    gc_block.values.ijk[idx] *= MM_PER_INCH;
 8008180:	49a8      	ldr	r1, [pc, #672]	; (8008424 <gc_execute_block+0x2dd4>)
                                if (ijk_words & bit(--idx))
 8008182:	9b08      	ldr	r3, [sp, #32]
 8008184:	3f01      	subs	r7, #1
 8008186:	40fb      	lsrs	r3, r7
 8008188:	07db      	lsls	r3, r3, #31
 800818a:	d505      	bpl.n	8008198 <gc_execute_block+0x2b48>
                                    gc_block.values.ijk[idx] *= MM_PER_INCH;
 800818c:	6828      	ldr	r0, [r5, #0]
 800818e:	910f      	str	r1, [sp, #60]	; 0x3c
 8008190:	f7f8 fb00 	bl	8000794 <__aeabi_fmul>
 8008194:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8008196:	6028      	str	r0, [r5, #0]
                            } while(idx);
 8008198:	3d04      	subs	r5, #4
 800819a:	2f00      	cmp	r7, #0
 800819c:	d1f1      	bne.n	8008182 <gc_execute_block+0x2b32>
                        if(gc_state.modal.scaling_active) {
 800819e:	4ba2      	ldr	r3, [pc, #648]	; (8008428 <gc_execute_block+0x2dd8>)
 80081a0:	7f9b      	ldrb	r3, [r3, #30]
 80081a2:	b193      	cbz	r3, 80081ca <gc_execute_block+0x2b7a>
                            idx = 3;
 80081a4:	2503      	movs	r5, #3
 80081a6:	4f9e      	ldr	r7, [pc, #632]	; (8008420 <gc_execute_block+0x2dd0>)
                                    gc_block.values.ijk[idx] *= scale_factor.ijk[idx];
 80081a8:	4ba0      	ldr	r3, [pc, #640]	; (800842c <gc_execute_block+0x2ddc>)
                                if (ijk_words & bit(--idx))
 80081aa:	9908      	ldr	r1, [sp, #32]
 80081ac:	3d01      	subs	r5, #1
 80081ae:	40e9      	lsrs	r1, r5
 80081b0:	07ce      	lsls	r6, r1, #31
                                    gc_block.values.ijk[idx] *= scale_factor.ijk[idx];
 80081b2:	eb03 0285 	add.w	r2, r3, r5, lsl #2
                                if (ijk_words & bit(--idx))
 80081b6:	d505      	bpl.n	80081c4 <gc_execute_block+0x2b74>
                                    gc_block.values.ijk[idx] *= scale_factor.ijk[idx];
 80081b8:	6838      	ldr	r0, [r7, #0]
 80081ba:	68d1      	ldr	r1, [r2, #12]
 80081bc:	f7f8 faea 	bl	8000794 <__aeabi_fmul>
 80081c0:	4b9a      	ldr	r3, [pc, #616]	; (800842c <gc_execute_block+0x2ddc>)
 80081c2:	6038      	str	r0, [r7, #0]
                            } while(idx);
 80081c4:	3f04      	subs	r7, #4
 80081c6:	2d00      	cmp	r5, #0
 80081c8:	d1ef      	bne.n	80081aa <gc_execute_block+0x2b5a>
                        x -= gc_block.values.ijk[plane.axis_0]; // Delta x between circle center and target
 80081ca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80081cc:	4658      	mov	r0, fp
 80081ce:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 80081d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80081d4:	4619      	mov	r1, r3
 80081d6:	930f      	str	r3, [sp, #60]	; 0x3c
 80081d8:	f7f8 f9d2 	bl	8000580 <__aeabi_fsub>
                        y -= gc_block.values.ijk[plane.axis_1]; // Delta y between circle center and target
 80081dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
                        x -= gc_block.values.ijk[plane.axis_0]; // Delta x between circle center and target
 80081de:	4605      	mov	r5, r0
                        y -= gc_block.values.ijk[plane.axis_1]; // Delta y between circle center and target
 80081e0:	eb09 0283 	add.w	r2, r9, r3, lsl #2
 80081e4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 80081e6:	4650      	mov	r0, sl
 80081e8:	4611      	mov	r1, r2
 80081ea:	9208      	str	r2, [sp, #32]
 80081ec:	f7f8 f9c8 	bl	8000580 <__aeabi_fsub>
    return sqrtf(x*x + y*y);
 80081f0:	4629      	mov	r1, r5
                        y -= gc_block.values.ijk[plane.axis_1]; // Delta y between circle center and target
 80081f2:	4607      	mov	r7, r0
    return sqrtf(x*x + y*y);
 80081f4:	4628      	mov	r0, r5
 80081f6:	f7f8 facd 	bl	8000794 <__aeabi_fmul>
 80081fa:	4639      	mov	r1, r7
 80081fc:	4605      	mov	r5, r0
 80081fe:	4638      	mov	r0, r7
 8008200:	f7f8 fac8 	bl	8000794 <__aeabi_fmul>
 8008204:	4601      	mov	r1, r0
 8008206:	4628      	mov	r0, r5
 8008208:	f7f8 f9bc 	bl	8000584 <__addsf3>
 800820c:	f00a feee 	bl	8012fec <sqrtf>
 8008210:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008212:	4605      	mov	r5, r0
 8008214:	4619      	mov	r1, r3
 8008216:	4618      	mov	r0, r3
 8008218:	f7f8 fabc 	bl	8000794 <__aeabi_fmul>
 800821c:	9a08      	ldr	r2, [sp, #32]
 800821e:	4607      	mov	r7, r0
 8008220:	4611      	mov	r1, r2
 8008222:	4610      	mov	r0, r2
 8008224:	f7f8 fab6 	bl	8000794 <__aeabi_fmul>
 8008228:	4601      	mov	r1, r0
 800822a:	4638      	mov	r0, r7
 800822c:	f7f8 f9aa 	bl	8000584 <__addsf3>
 8008230:	f00a fedc 	bl	8012fec <sqrtf>
 8008234:	4607      	mov	r7, r0
                        float delta_r = fabsf(target_r - gc_block.values.r);
 8008236:	4628      	mov	r0, r5
 8008238:	4639      	mov	r1, r7
                        gc_block.values.r = hypot_f(gc_block.values.ijk[plane.axis_0], gc_block.values.ijk[plane.axis_1]);
 800823a:	f8c9 7054 	str.w	r7, [r9, #84]	; 0x54
                        float delta_r = fabsf(target_r - gc_block.values.r);
 800823e:	f7f8 f99f 	bl	8000580 <__aeabi_fsub>
 8008242:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
                        if (delta_r > 0.005f) {
 8008246:	4628      	mov	r0, r5
 8008248:	4979      	ldr	r1, [pc, #484]	; (8008430 <gc_execute_block+0x2de0>)
 800824a:	f7f8 fc5f 	bl	8000b0c <__aeabi_fcmpgt>
 800824e:	2800      	cmp	r0, #0
 8008250:	f43e a83c 	beq.w	80062cc <gc_execute_block+0xc7c>
                            if (delta_r > 0.5f)
 8008254:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008258:	4628      	mov	r0, r5
 800825a:	f7f8 fc57 	bl	8000b0c <__aeabi_fcmpgt>
 800825e:	2800      	cmp	r0, #0
 8008260:	f47f af32 	bne.w	80080c8 <gc_execute_block+0x2a78>
                            if (delta_r > (0.001f * gc_block.values.r))
 8008264:	4973      	ldr	r1, [pc, #460]	; (8008434 <gc_execute_block+0x2de4>)
 8008266:	4638      	mov	r0, r7
 8008268:	f7f8 fa94 	bl	8000794 <__aeabi_fmul>
 800826c:	4629      	mov	r1, r5
 800826e:	f7f8 fc2f 	bl	8000ad0 <__aeabi_fcmplt>
 8008272:	2800      	cmp	r0, #0
 8008274:	f43e a82a 	beq.w	80062cc <gc_execute_block+0xc7c>
 8008278:	e726      	b.n	80080c8 <gc_execute_block+0x2a78>
                            FAIL(Status_GcodeNoOffsetsInPlane);// [No offsets in plane]
 800827a:	2323      	movs	r3, #35	; 0x23
 800827c:	9304      	str	r3, [sp, #16]
 800827e:	f7fd bc2c 	b.w	8005ada <gc_execute_block+0x48a>
        bool tlo_changed = false;
 8008282:	2500      	movs	r5, #0
 8008284:	f7ff b9da 	b.w	800763c <gc_execute_block+0x1fec>
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 8008288:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800828a:	4e6b      	ldr	r6, [pc, #428]	; (8008438 <gc_execute_block+0x2de8>)
 800828c:	f88d 3050 	strb.w	r3, [sp, #80]	; 0x50
 8008290:	9b0d      	ldr	r3, [sp, #52]	; 0x34
                plan_data.spindle.rpm = gc_block.values.s;
 8008292:	f8d9 1058 	ldr.w	r1, [r9, #88]	; 0x58
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 8008296:	f88d 3051 	strb.w	r3, [sp, #81]	; 0x51
 800829a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800829c:	f899 707e 	ldrb.w	r7, [r9, #126]	; 0x7e
 80082a0:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
 80082a4:	9b14      	ldr	r3, [sp, #80]	; 0x50
                plan_data.spindle.rpm = gc_block.values.s;
 80082a6:	911c      	str	r1, [sp, #112]	; 0x70
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 80082a8:	0c1d      	lsrs	r5, r3, #16
 80082aa:	f8ad 3000 	strh.w	r3, [sp]
 80082ae:	f88d 5002 	strb.w	r5, [sp, #2]
                gc_state.canned.retract_mode = gc_state.modal.retract_mode;
 80082b2:	f816 5c0b 	ldrb.w	r5, [r6, #-11]
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 80082b6:	f106 0344 	add.w	r3, r6, #68	; 0x44
 80082ba:	e9cd 7601 	strd	r7, r6, [sp, #4]
 80082be:	495f      	ldr	r1, [pc, #380]	; (800843c <gc_execute_block+0x2dec>)
                gc_state.canned.retract_mode = gc_state.modal.retract_mode;
 80082c0:	f803 5c26 	strb.w	r5, [r3, #-38]
                mc_canned_drill(gc_state.modal.motion, gc_block.values.xyz, &plan_data, gc_state.position, plane, gc_block.values.l, &gc_state.canned);
 80082c4:	aa1b      	add	r2, sp, #108	; 0x6c
 80082c6:	f001 f983 	bl	80095d0 <mc_canned_drill>
        if(sys.cancel)
 80082ca:	7963      	ldrb	r3, [r4, #5]
 80082cc:	2b00      	cmp	r3, #0
 80082ce:	f47f ab31 	bne.w	8007934 <gc_execute_block+0x22e4>
        while(plan_data.output_commands) {
 80082d2:	9f27      	ldr	r7, [sp, #156]	; 0x9c
 80082d4:	2f00      	cmp	r7, #0
 80082d6:	f47f aada 	bne.w	800788e <gc_execute_block+0x223e>
 80082da:	3644      	adds	r6, #68	; 0x44
 80082dc:	f7ff bb70 	b.w	80079c0 <gc_execute_block+0x2370>
                            FAIL(Status_GcodeArcRadiusError); // [Arc radius error]
 80082e0:	2322      	movs	r3, #34	; 0x22
 80082e2:	9304      	str	r3, [sp, #16]
 80082e4:	f7fd bbf9 	b.w	8005ada <gc_execute_block+0x48a>
                    settings_write_coord_data(SETTING_INDEX_G92, &gc_state.g92_coord_offset); // Save G92 offsets to EEPROM
 80082e8:	200b      	movs	r0, #11
 80082ea:	4955      	ldr	r1, [pc, #340]	; (8008440 <gc_execute_block+0x2df0>)
 80082ec:	f005 ff0a 	bl	800e104 <settings_write_coord_data>
 80082f0:	e68f      	b.n	8008012 <gc_execute_block+0x29c2>
                mc_line(gc_block.values.xyz, &plan_data);
 80082f2:	a91b      	add	r1, sp, #108	; 0x6c
 80082f4:	4851      	ldr	r0, [pc, #324]	; (800843c <gc_execute_block+0x2dec>)
 80082f6:	f000 fca7 	bl	8008c48 <mc_line>
 80082fa:	f7fe bd37 	b.w	8006d6c <gc_execute_block+0x171c>
                        FAIL(Status_GcodeNoAxisWordsInPlane); // [No axis words in plane]
 80082fe:	2320      	movs	r3, #32
 8008300:	9304      	str	r3, [sp, #16]
 8008302:	f7fd bbea 	b.w	8005ada <gc_execute_block+0x48a>
                        FAIL(Status_GcodeIllegalPlane); // [The active plane is not G17]
 8008306:	232a      	movs	r3, #42	; 0x2a
 8008308:	9304      	str	r3, [sp, #16]
 800830a:	f7fd bbe6 	b.w	8005ada <gc_execute_block+0x48a>
                        if(gc_state.modal.scaling_active) {
 800830e:	4b46      	ldr	r3, [pc, #280]	; (8008428 <gc_execute_block+0x2dd8>)
 8008310:	7f9b      	ldrb	r3, [r3, #30]
 8008312:	2b00      	cmp	r3, #0
 8008314:	f43e aff3 	beq.w	80072fe <gc_execute_block+0x1cae>
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 8008318:	4d44      	ldr	r5, [pc, #272]	; (800842c <gc_execute_block+0x2ddc>)
 800831a:	f8d9 103c 	ldr.w	r1, [r9, #60]	; 0x3c
 800831e:	68e8      	ldr	r0, [r5, #12]
 8008320:	f7f8 fa38 	bl	8000794 <__aeabi_fmul>
 8008324:	4603      	mov	r3, r0
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 8008326:	6929      	ldr	r1, [r5, #16]
 8008328:	f8d9 0040 	ldr.w	r0, [r9, #64]	; 0x40
                            gc_block.values.ijk[I_VALUE] *= scale_factor.ijk[X_AXIS];
 800832c:	f8c9 303c 	str.w	r3, [r9, #60]	; 0x3c
                            gc_block.values.ijk[J_VALUE] *= scale_factor.ijk[Y_AXIS];
 8008330:	f7f8 fa30 	bl	8000794 <__aeabi_fmul>
 8008334:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
                    if (gc_block.modal.units_imperial) {
 8008338:	f7fe bfd2 	b.w	80072e0 <gc_execute_block+0x1c90>
                    if(!(value_words & (bit(Word_I)|bit(Word_J)))) {
 800833c:	f017 0f18 	tst.w	r7, #24
 8008340:	f47e af95 	bne.w	800726e <gc_execute_block+0x1c1e>
                        gc_block.values.ijk[J_VALUE] = - gc_block.values.q;
 8008344:	e9d9 2313 	ldrd	r2, r3, [r9, #76]	; 0x4c
                        gc_block.values.ijk[I_VALUE] = - gc_block.values.p;
 8008348:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 800834c:	f8c9 203c 	str.w	r2, [r9, #60]	; 0x3c
                    if (gc_block.modal.units_imperial) {
 8008350:	f899 200a 	ldrb.w	r2, [r9, #10]
                        gc_block.values.ijk[J_VALUE] = - gc_block.values.q;
 8008354:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8008358:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
                    if (gc_block.modal.units_imperial) {
 800835c:	2a00      	cmp	r2, #0
 800835e:	f43e afbb 	beq.w	80072d8 <gc_execute_block+0x1c88>
 8008362:	f7fe bfaa 	b.w	80072ba <gc_execute_block+0x1c6a>
                        gc_state.canned.spindle_off = gc_block.modal.motion == MotionMode_CannedCycle86;
 8008366:	f1a4 0656 	sub.w	r6, r4, #86	; 0x56
 800836a:	492f      	ldr	r1, [pc, #188]	; (8008428 <gc_execute_block+0x2dd8>)
 800836c:	4272      	negs	r2, r6
 800836e:	4172      	adcs	r2, r6
 8008370:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
                        gc_state.canned.rapid_retract = gc_block.modal.motion == MotionMode_CannedCycle86;
 8008374:	f881 2044 	strb.w	r2, [r1, #68]	; 0x44
                        if(bit_istrue(value_words, bit(Word_P))) {
 8008378:	05e8      	lsls	r0, r5, #23
 800837a:	f57e a8f2 	bpl.w	8006562 <gc_execute_block+0xf12>
                            if(gc_block.values.p < 0.0f)
 800837e:	f8d9 704c 	ldr.w	r7, [r9, #76]	; 0x4c
 8008382:	2100      	movs	r1, #0
 8008384:	4638      	mov	r0, r7
 8008386:	9308      	str	r3, [sp, #32]
 8008388:	f7f8 fba2 	bl	8000ad0 <__aeabi_fcmplt>
 800838c:	9b08      	ldr	r3, [sp, #32]
 800838e:	2800      	cmp	r0, #0
 8008390:	f47e a963 	bne.w	800665a <gc_execute_block+0x100a>
                            gc_state.canned.dwell = gc_block.values.p;
 8008394:	4a24      	ldr	r2, [pc, #144]	; (8008428 <gc_execute_block+0x2dd8>)
                            bit_false(value_words, bit(Word_P)); // Remove single-meaning value word.
 8008396:	f425 7550 	bic.w	r5, r5, #832	; 0x340
 800839a:	9515      	str	r5, [sp, #84]	; 0x54
                            gc_state.canned.dwell = gc_block.values.p;
 800839c:	6397      	str	r7, [r2, #56]	; 0x38
                        gc_state.canned.delta = - gc_state.canned.xyz[plane.axis_linear] + gc_state.canned.retract_position;
 800839e:	4618      	mov	r0, r3
 80083a0:	4651      	mov	r1, sl
 80083a2:	f7f8 f8ed 	bl	8000580 <__aeabi_fsub>
 80083a6:	4b20      	ldr	r3, [pc, #128]	; (8008428 <gc_execute_block+0x2dd8>)
                        if(gc_block.modal.motion == MotionMode_CannedCycle85)
 80083a8:	2c55      	cmp	r4, #85	; 0x55
                        gc_state.canned.delta = - gc_state.canned.xyz[plane.axis_linear] + gc_state.canned.retract_position;
 80083aa:	6358      	str	r0, [r3, #52]	; 0x34
                        if(gc_block.modal.motion == MotionMode_CannedCycle85)
 80083ac:	f47d af8e 	bne.w	80062cc <gc_execute_block+0xc7c>
                            gc_state.canned.rapid_retract = Off;
 80083b0:	2300      	movs	r3, #0
 80083b2:	4a1d      	ldr	r2, [pc, #116]	; (8008428 <gc_execute_block+0x2dd8>)
 80083b4:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
 80083b8:	f7fd bf88 	b.w	80062cc <gc_execute_block+0xc7c>
                        if(bit_istrue(value_words, bit(Word_Q))) {
 80083bc:	0429      	lsls	r1, r5, #16
 80083be:	d515      	bpl.n	80083ec <gc_execute_block+0x2d9c>
                            if(gc_block.values.q <= 0.0f)
 80083c0:	f8d9 7050 	ldr.w	r7, [r9, #80]	; 0x50
 80083c4:	2100      	movs	r1, #0
 80083c6:	4638      	mov	r0, r7
 80083c8:	f7f8 fb8c 	bl	8000ae4 <__aeabi_fcmple>
 80083cc:	2800      	cmp	r0, #0
 80083ce:	f47e a944 	bne.w	800665a <gc_execute_block+0x100a>
                            gc_state.canned.delta = gc_block.values.q;
 80083d2:	4b15      	ldr	r3, [pc, #84]	; (8008428 <gc_execute_block+0x2dd8>)
                            bit_false(value_words, bit(Word_Q)); // Remove single-meaning value word.
 80083d4:	f425 4502 	bic.w	r5, r5, #33280	; 0x8200
 80083d8:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 80083dc:	9515      	str	r5, [sp, #84]	; 0x54
                            gc_state.canned.delta = gc_block.values.q;
 80083de:	635f      	str	r7, [r3, #52]	; 0x34
                        gc_state.canned.dwell = 0.25f;
 80083e0:	f04f 537a 	mov.w	r3, #1048576000	; 0x3e800000
 80083e4:	4a10      	ldr	r2, [pc, #64]	; (8008428 <gc_execute_block+0x2dd8>)
 80083e6:	6393      	str	r3, [r2, #56]	; 0x38
                        break;
 80083e8:	f7fd bf70 	b.w	80062cc <gc_execute_block+0xc7c>
                        } else if(gc_parser_flags.canned_cycle_change)
 80083ec:	2f00      	cmp	r7, #0
 80083ee:	d0f7      	beq.n	80083e0 <gc_execute_block+0x2d90>
 80083f0:	f7fe b8ba 	b.w	8006568 <gc_execute_block+0xf18>
                else if(gc_block.values.l <= 0)
 80083f4:	f899 307e 	ldrb.w	r3, [r9, #126]	; 0x7e
 80083f8:	2b00      	cmp	r3, #0
 80083fa:	f47f ad2a 	bne.w	8007e52 <gc_execute_block+0x2802>
                    FAIL(Status_NonPositiveValue); // [L <= 0]
 80083fe:	2313      	movs	r3, #19
 8008400:	9304      	str	r3, [sp, #16]
 8008402:	f7fd bb6a 	b.w	8005ada <gc_execute_block+0x48a>
                    thread.end_taper_type = Taper_None;
 8008406:	2200      	movs	r2, #0
                    thread.end_taper_length = 0.0f;
 8008408:	2300      	movs	r3, #0
                    thread.end_taper_type = Taper_None;
 800840a:	f88a 202c 	strb.w	r2, [sl, #44]	; 0x2c
                    thread.end_taper_length = 0.0f;
 800840e:	f8ca 301c 	str.w	r3, [sl, #28]
                if(thread.end_taper_type != Taper_None && thread.end_taper_length > abs(thread.z_final - gc_state.position[Z_AXIS]) / 2.0f)
 8008412:	e4f4      	b.n	8007dfe <gc_execute_block+0x27ae>
                thread.cut_direction = gc_block.values.ijk[I_VALUE] < 0.0f ? -1.0f : 1.0f;
 8008414:	4b0b      	ldr	r3, [pc, #44]	; (8008444 <gc_execute_block+0x2df4>)
 8008416:	e448      	b.n	8007caa <gc_execute_block+0x265a>
                        FAIL(Status_InvalidStatement);
 8008418:	2303      	movs	r3, #3
 800841a:	9304      	str	r3, [sp, #16]
 800841c:	f7fd bb5d 	b.w	8005ada <gc_execute_block+0x48a>
 8008420:	200009c4 	.word	0x200009c4
 8008424:	41cb3333 	.word	0x41cb3333
 8008428:	200023dc 	.word	0x200023dc
 800842c:	20000a10 	.word	0x20000a10
 8008430:	3ba3d70a 	.word	0x3ba3d70a
 8008434:	3a83126f 	.word	0x3a83126f
 8008438:	20002404 	.word	0x20002404
 800843c:	200009dc 	.word	0x200009dc
 8008440:	20002460 	.word	0x20002460
 8008444:	bf800000 	.word	0xbf800000

08008448 <stream_tx_blocking>:
// called from stream drivers while tx is blocking, return false to terminate

static bool stream_tx_blocking (void)
{
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.
    return !(sys_rt_exec_state & EXEC_RESET);
 8008448:	4b03      	ldr	r3, [pc, #12]	; (8008458 <stream_tx_blocking+0x10>)
 800844a:	6818      	ldr	r0, [r3, #0]
 800844c:	f080 0020 	eor.w	r0, r0, #32
}
 8008450:	f3c0 1040 	ubfx	r0, r0, #5, #1
 8008454:	4770      	bx	lr
 8008456:	bf00      	nop
 8008458:	200024b4 	.word	0x200024b4

0800845c <grbl_enter>:
#endif

// main entry point

int grbl_enter (void)
{
 800845c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    assert(EEPROM_ADDR_PARAMETERS + SETTING_INDEX_NCOORD * (sizeof(coord_data_t) + 1) < EEPROM_ADDR_STARTUP_BLOCK);
    assert(EEPROM_ADDR_STARTUP_BLOCK + N_STARTUP_LINE * (MAX_STORED_LINE_LENGTH + 1) < EEPROM_ADDR_BUILD_INFO);

    bool looping = true, driver_ok;

    memset(&hal, 0, sizeof(HAL));  // Clear...
 8008460:	f8df b214 	ldr.w	fp, [pc, #532]	; 8008678 <grbl_enter+0x21c>
{
 8008464:	b083      	sub	sp, #12
    memset(&hal, 0, sizeof(HAL));  // Clear...
 8008466:	f44f 72a4 	mov.w	r2, #328	; 0x148
 800846a:	2100      	movs	r1, #0
 800846c:	4658      	mov	r0, fp
 800846e:	f009 fc09 	bl	8011c84 <memset>

    hal.version = HAL_VERSION; // Update when signatures and/or contract is changed - driver_init() should fail
 8008472:	2106      	movs	r1, #6
    hal.limit_interrupt_callback = limit_interrupt_handler;
 8008474:	4a6f      	ldr	r2, [pc, #444]	; (8008634 <grbl_enter+0x1d8>)
    hal.stream.enqueue_realtime_command = protocol_enqueue_realtime_command;
    hal.stream_blocking_callback = stream_tx_blocking;
    hal.protocol_enqueue_gcode = protocol_enqueue_gcode;
    hal.driver_reset = dummy_handler;

    memcpy(&hal.report, &report_fns, sizeof(report_t));
 8008476:	4b70      	ldr	r3, [pc, #448]	; (8008638 <grbl_enter+0x1dc>)
    hal.stream_blocking_callback = stream_tx_blocking;
 8008478:	4870      	ldr	r0, [pc, #448]	; (800863c <grbl_enter+0x1e0>)
    hal.version = HAL_VERSION; // Update when signatures and/or contract is changed - driver_init() should fail
 800847a:	f8cb 1000 	str.w	r1, [fp]
    hal.protocol_enqueue_gcode = protocol_enqueue_gcode;
 800847e:	4970      	ldr	r1, [pc, #448]	; (8008640 <grbl_enter+0x1e4>)
    hal.stepper_interrupt_callback = stepper_driver_interrupt_handler;
 8008480:	4d70      	ldr	r5, [pc, #448]	; (8008644 <grbl_enter+0x1e8>)
    hal.stream.enqueue_realtime_command = protocol_enqueue_realtime_command;
 8008482:	4c71      	ldr	r4, [pc, #452]	; (8008648 <grbl_enter+0x1ec>)
    hal.limit_interrupt_callback = limit_interrupt_handler;
 8008484:	f8cb 2138 	str.w	r2, [fp, #312]	; 0x138
    hal.control_interrupt_callback = control_interrupt_handler;
 8008488:	4e70      	ldr	r6, [pc, #448]	; (800864c <grbl_enter+0x1f0>)
    hal.driver_reset = dummy_handler;
 800848a:	4a71      	ldr	r2, [pc, #452]	; (8008650 <grbl_enter+0x1f4>)
    memcpy(&hal.report, &report_fns, sizeof(report_t));
 800848c:	f50b 7992 	add.w	r9, fp, #292	; 0x124
    hal.protocol_enqueue_gcode = protocol_enqueue_gcode;
 8008490:	e9cb 104b 	strd	r1, r0, [fp, #300]	; 0x12c
    memcpy(&hal.report, &report_fns, sizeof(report_t));
 8008494:	e893 0003 	ldmia.w	r3, {r0, r1}
 8008498:	e889 0003 	stmia.w	r9, {r0, r1}
    hal.stepper_interrupt_callback = stepper_driver_interrupt_handler;
 800849c:	f8cb 5134 	str.w	r5, [fp, #308]	; 0x134
    hal.stream.enqueue_realtime_command = protocol_enqueue_realtime_command;
 80084a0:	f8cb 407c 	str.w	r4, [fp, #124]	; 0x7c
    hal.driver_reset = dummy_handler;
 80084a4:	f8cb 20d4 	str.w	r2, [fp, #212]	; 0xd4
    hal.control_interrupt_callback = control_interrupt_handler;
 80084a8:	f8cb 613c 	str.w	r6, [fp, #316]	; 0x13c
#endif

#ifdef DEBUGOUT
    hal.debug_out = debug_out; // must be overridden by driver to have any effect
#endif
    driver_ok = driver_init();
 80084ac:	f7fc f864 	bl	8004578 <driver_init>
    hal.driver_settings_report = NULL;
    hal.driver_settings_restore = NULL;
#endif

#ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
    hal.driver_cap.safety_door = false;
 80084b0:	f89b 2144 	ldrb.w	r2, [fp, #324]	; 0x144
    driver_ok = driver_init();
 80084b4:	4604      	mov	r4, r0
    hal.driver_cap.safety_door = false;
 80084b6:	f36f 0282 	bfc	r2, #2, #1
 80084ba:	f88b 2144 	strb.w	r2, [fp, #324]	; 0x144
#else
    driver_ok &= hal.driver_cap.safety_door;
#endif

  #ifdef EMULATE_EEPROM
    eeprom_emu_init();
 80084be:	f7fc fe99 	bl	80051f4 <eeprom_emu_init>
  #endif
    settings_init(); // Load Grbl settings from EEPROM
 80084c2:	f006 faad 	bl	800ea20 <settings_init>

    memset(sys_position, 0, sizeof(sys_position)); // Clear machine position.
 80084c6:	2200      	movs	r2, #0
 80084c8:	4d62      	ldr	r5, [pc, #392]	; (8008654 <grbl_enter+0x1f8>)
 80084ca:	e9c5 2200 	strd	r2, r2, [r5]
 80084ce:	60aa      	str	r2, [r5, #8]

// check and configure driver

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    driver_ok = driver_ok && hal.driver_cap.amass_level >= MAX_AMASS_LEVEL;
 80084d0:	b12c      	cbz	r4, 80084de <grbl_enter+0x82>
 80084d2:	f89b 1145 	ldrb.w	r1, [fp, #325]	; 0x145
 80084d6:	f001 0006 	and.w	r0, r1, #6
 80084da:	2806      	cmp	r0, #6
 80084dc:	d00e      	beq.n	80084fc <grbl_enter+0xa0>
/*
#if AXIS_N_SETTINGS > 4
    driver_ok = driver_ok & hal.driver_cap.axes >= AXIS_N_SETTINGS;
#endif
*/
    sys.mpg_mode = false;
 80084de:	2000      	movs	r0, #0
    hal.driver_cap.amass_level = MAX_AMASS_LEVEL;
 80084e0:	f89b 2145 	ldrb.w	r2, [fp, #325]	; 0x145
    sys.mpg_mode = false;
 80084e4:	495c      	ldr	r1, [pc, #368]	; (8008658 <grbl_enter+0x1fc>)
    hal.driver_cap.amass_level = MAX_AMASS_LEVEL;
 80084e6:	f042 0206 	orr.w	r2, r2, #6
 80084ea:	f88b 2145 	strb.w	r2, [fp, #325]	; 0x145
    sys.mpg_mode = false;
 80084ee:	7208      	strb	r0, [r1, #8]
    sys.message = NULL;
 80084f0:	61c8      	str	r0, [r1, #28]
#ifdef SPINDLE_PWM_DIRECT
    driver_ok = driver_ok && hal.spindle_get_pwm != NULL && hal.spindle_update_pwm != NULL;
#endif

    if(!driver_ok) {
        hal.stream.write("GrblHAL: incompatible driver\r\n");
 80084f2:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
 80084f6:	4859      	ldr	r0, [pc, #356]	; (800865c <grbl_enter+0x200>)
 80084f8:	4798      	blx	r3
        while(true);
 80084fa:	e7fe      	b.n	80084fa <grbl_enter+0x9e>
    sys.mpg_mode = false;
 80084fc:	4c56      	ldr	r4, [pc, #344]	; (8008658 <grbl_enter+0x1fc>)
    hal.driver_cap.amass_level = MAX_AMASS_LEVEL;
 80084fe:	f041 0106 	orr.w	r1, r1, #6
 8008502:	f88b 1145 	strb.w	r1, [fp, #325]	; 0x145
    driver_ok = driver_ok && hal.driver_setup(&settings);
 8008506:	4856      	ldr	r0, [pc, #344]	; (8008660 <grbl_enter+0x204>)
    sys.mpg_mode = false;
 8008508:	7222      	strb	r2, [r4, #8]
    sys.message = NULL;
 800850a:	61e2      	str	r2, [r4, #28]
    driver_ok = driver_ok && hal.driver_setup(&settings);
 800850c:	f8db 2018 	ldr.w	r2, [fp, #24]
 8008510:	4790      	blx	r2
 8008512:	2800      	cmp	r0, #0
 8008514:	d0ed      	beq.n	80084f2 <grbl_enter+0x96>
    driver_ok = driver_ok && hal.spindle_get_pwm != NULL && hal.spindle_update_pwm != NULL;
 8008516:	f8db 2038 	ldr.w	r2, [fp, #56]	; 0x38
 800851a:	2a00      	cmp	r2, #0
 800851c:	d0e9      	beq.n	80084f2 <grbl_enter+0x96>
 800851e:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
 8008522:	2a00      	cmp	r2, #0
 8008524:	d0e5      	beq.n	80084f2 <grbl_enter+0x96>
    }

    if(hal.get_position)
 8008526:	f8db 20c0 	ldr.w	r2, [fp, #192]	; 0xc0
 800852a:	b10a      	cbz	r2, 8008530 <grbl_enter+0xd4>
        hal.get_position(&sys_position); // TODO:  restore on abort when returns true?
 800852c:	4628      	mov	r0, r5
 800852e:	4790      	blx	r2
        uint_fast16_t prior_state = sys.state;

        if(sys.message)
            free(sys.message);

        memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
 8008530:	2500      	movs	r5, #0
 8008532:	f8df 8148 	ldr.w	r8, [pc, #328]	; 800867c <grbl_enter+0x220>
 8008536:	4f4b      	ldr	r7, [pc, #300]	; (8008664 <grbl_enter+0x208>)
 8008538:	4e4b      	ldr	r6, [pc, #300]	; (8008668 <grbl_enter+0x20c>)
        memcpy(&hal.report, &report_fns, sizeof(report_t));
 800853a:	4a3f      	ldr	r2, [pc, #252]	; (8008638 <grbl_enter+0x1dc>)
        if(sys.message)
 800853c:	69e3      	ldr	r3, [r4, #28]
        memcpy(&hal.report, &report_fns, sizeof(report_t));
 800853e:	e892 0003 	ldmia.w	r2, {r0, r1}
        uint_fast16_t prior_state = sys.state;
 8008542:	6822      	ldr	r2, [r4, #0]
        memcpy(&hal.report, &report_fns, sizeof(report_t));
 8008544:	e889 0003 	stmia.w	r9, {r0, r1}
        bool prior_mpg_mode = sys.mpg_mode;
 8008548:	f894 a008 	ldrb.w	sl, [r4, #8]
        uint_fast16_t prior_state = sys.state;
 800854c:	9201      	str	r2, [sp, #4]
        if(sys.message)
 800854e:	b113      	cbz	r3, 8008556 <grbl_enter+0xfa>
            free(sys.message);
 8008550:	4618      	mov	r0, r3
 8008552:	f009 fb73 	bl	8011c3c <free>
        memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
 8008556:	2220      	movs	r2, #32
 8008558:	2100      	movs	r1, #0
 800855a:	483f      	ldr	r0, [pc, #252]	; (8008658 <grbl_enter+0x1fc>)
 800855c:	f009 fb92 	bl	8011c84 <memset>
        set_state(prior_state);
 8008560:	9801      	ldr	r0, [sp, #4]
 8008562:	f007 fa45 	bl	800f9f0 <set_state>
        sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;          // Set to 100%
        sys.override.rapid_rate = DEFAULT_RAPID_OVERRIDE;        // Set to 100%
        sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE; // Set to 100%
 8008566:	2264      	movs	r2, #100	; 0x64
        sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;          // Set to 100%
 8008568:	f246 4164 	movw	r1, #25700	; 0x6464

        if(settings.parking.flags.enabled)
 800856c:	4b3c      	ldr	r3, [pc, #240]	; (8008660 <grbl_enter+0x204>)
        sys.override.spindle_rpm = DEFAULT_SPINDLE_RPM_OVERRIDE; // Set to 100%
 800856e:	7422      	strb	r2, [r4, #16]
        if(settings.parking.flags.enabled)
 8008570:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
        sys.override.feed_rate = DEFAULT_FEED_OVERRIDE;          // Set to 100%
 8008574:	81e1      	strh	r1, [r4, #14]
        if(settings.parking.flags.enabled)
 8008576:	07da      	lsls	r2, r3, #31
 8008578:	d505      	bpl.n	8008586 <grbl_enter+0x12a>
            sys.override.control.parking_disable = settings.parking.flags.deactivate_upon_init;
 800857a:	7ca2      	ldrb	r2, [r4, #18]
 800857c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8008580:	f363 02c3 	bfi	r2, r3, #3, #1
 8008584:	74a2      	strb	r2, [r4, #18]

        memset(sys_probe_position, 0, sizeof(sys_probe_position)); // Clear probe position.
        sys_probe_state = Probe_Off;
 8008586:	4b39      	ldr	r3, [pc, #228]	; (800866c <grbl_enter+0x210>)
        memset(sys_probe_position, 0, sizeof(sys_probe_position)); // Clear probe position.
 8008588:	e9c8 5501 	strd	r5, r5, [r8, #4]
        sys_probe_state = Probe_Off;
 800858c:	701d      	strb	r5, [r3, #0]
        sys_rt_exec_state = 0;
        sys_rt_exec_alarm = 0;
 800858e:	4b38      	ldr	r3, [pc, #224]	; (8008670 <grbl_enter+0x214>)
        sys_rt_exec_state = 0;
 8008590:	603d      	str	r5, [r7, #0]
        memset(sys_probe_position, 0, sizeof(sys_probe_position)); // Clear probe position.
 8008592:	f8c8 5000 	str.w	r5, [r8]
        sys_rt_exec_alarm = 0;
 8008596:	601d      	str	r5, [r3, #0]

        flush_override_buffers();
 8008598:	f001 ffc4 	bl	800a524 <flush_override_buffers>

        // Reset Grbl primary systems.
        hal.stream.reset_read_buffer(); // Clear input stream buffer
 800859c:	f8db 3070 	ldr.w	r3, [fp, #112]	; 0x70
 80085a0:	4798      	blx	r3
        gc_init(cold_start); // Set g-code parser to default state
 80085a2:	7830      	ldrb	r0, [r6, #0]
 80085a4:	f7fc ffca 	bl	800553c <gc_init>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 80085a8:	4b2d      	ldr	r3, [pc, #180]	; (8008660 <grbl_enter+0x204>)
 80085aa:	2100      	movs	r1, #0
 80085ac:	f893 00d4 	ldrb.w	r0, [r3, #212]	; 0xd4
 80085b0:	f8db 301c 	ldr.w	r3, [fp, #28]
 80085b4:	f000 0001 	and.w	r0, r0, #1
 80085b8:	4798      	blx	r3
        plan_reset(); // Clear block buffer and planner variables
 80085ba:	f002 f8bf 	bl	800a73c <plan_reset>
        st_reset(); // Clear stepper subsystem variables.
 80085be:	f007 fef3 	bl	80103a8 <st_reset>
        limits_set_homing_axes(); // Set axes to be homed from settings.
 80085c2:	f000 fb2b 	bl	8008c1c <limits_set_homing_axes>
#ifdef ENABLE_BACKLASH_COMPENSATION
        mc_backlash_init(); // Init backlash configuration.
#endif
        // Sync cleared gcode and planner positions to current system position.
        plan_sync_position();
 80085c6:	f002 fd23 	bl	800b010 <plan_sync_position>
        gc_sync_position();
 80085ca:	4922      	ldr	r1, [pc, #136]	; (8008654 <grbl_enter+0x1f8>)
 80085cc:	4829      	ldr	r0, [pc, #164]	; (8008674 <grbl_enter+0x218>)
 80085ce:	f009 f8ab 	bl	8011728 <system_convert_array_steps_to_mpos>

        // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
        report_init_message();
 80085d2:	f003 fdc5 	bl	800c160 <report_init_message>

        if(sys.state == STATE_ESTOP)
 80085d6:	6823      	ldr	r3, [r4, #0]
 80085d8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80085dc:	d022      	beq.n	8008624 <grbl_enter+0x1c8>
            set_state(STATE_ALARM);

        if(hal.driver_cap.mpg_mode) {
 80085de:	f89b 3147 	ldrb.w	r3, [fp, #327]	; 0x147
 80085e2:	075b      	lsls	r3, r3, #29
 80085e4:	d509      	bpl.n	80085fa <grbl_enter+0x19e>
            sys.mpg_mode = prior_mpg_mode;
            hal.stream.enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 80085e6:	f1ba 0f00 	cmp.w	sl, #0
 80085ea:	bf14      	ite	ne
 80085ec:	2087      	movne	r0, #135	; 0x87
 80085ee:	2080      	moveq	r0, #128	; 0x80
 80085f0:	f8db 307c 	ldr.w	r3, [fp, #124]	; 0x7c
            sys.mpg_mode = prior_mpg_mode;
 80085f4:	f884 a008 	strb.w	sl, [r4, #8]
            hal.stream.enqueue_realtime_command(sys.mpg_mode ? CMD_STATUS_REPORT_ALL : CMD_STATUS_REPORT);
 80085f8:	4798      	blx	r3
        }

        // Start Grbl main loop. Processes program inputs and executes them.
        if(!(looping = protocol_main_loop(cold_start)))
 80085fa:	7830      	ldrb	r0, [r6, #0]
 80085fc:	f002 ffe8 	bl	800b5d0 <protocol_main_loop>
 8008600:	4682      	mov	sl, r0
 8008602:	b110      	cbz	r0, 800860a <grbl_enter+0x1ae>
            looping = hal.driver_release == NULL || hal.driver_release();

        cold_start = false;
 8008604:	7035      	strb	r5, [r6, #0]
        sys_rt_exec_state = 0;
 8008606:	603d      	str	r5, [r7, #0]
    while(looping) {
 8008608:	e797      	b.n	800853a <grbl_enter+0xde>
            looping = hal.driver_release == NULL || hal.driver_release();
 800860a:	f8db 3090 	ldr.w	r3, [fp, #144]	; 0x90
 800860e:	b16b      	cbz	r3, 800862c <grbl_enter+0x1d0>
 8008610:	4798      	blx	r3
        cold_start = false;
 8008612:	f886 a000 	strb.w	sl, [r6]
        sys_rt_exec_state = 0;
 8008616:	f8c7 a000 	str.w	sl, [r7]
    while(looping) {
 800861a:	2800      	cmp	r0, #0
 800861c:	d18d      	bne.n	800853a <grbl_enter+0xde>
    }

    return 0;
}
 800861e:	b003      	add	sp, #12
 8008620:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            set_state(STATE_ALARM);
 8008624:	2001      	movs	r0, #1
 8008626:	f007 f9e3 	bl	800f9f0 <set_state>
 800862a:	e7d8      	b.n	80085de <grbl_enter+0x182>
        cold_start = false;
 800862c:	7033      	strb	r3, [r6, #0]
        sys_rt_exec_state = 0;
 800862e:	603b      	str	r3, [r7, #0]
    while(looping) {
 8008630:	e783      	b.n	800853a <grbl_enter+0xde>
 8008632:	bf00      	nop
 8008634:	08008681 	.word	0x08008681
 8008638:	0801496c 	.word	0x0801496c
 800863c:	08008449 	.word	0x08008449
 8008640:	0800b0b9 	.word	0x0800b0b9
 8008644:	08010131 	.word	0x08010131
 8008648:	0800baf1 	.word	0x0800baf1
 800864c:	08011051 	.word	0x08011051
 8008650:	0800a4a1 	.word	0x0800a4a1
 8008654:	20002610 	.word	0x20002610
 8008658:	20002494 	.word	0x20002494
 800865c:	0801494c 	.word	0x0801494c
 8008660:	20002620 	.word	0x20002620
 8008664:	200024b4 	.word	0x200024b4
 8008668:	20000014 	.word	0x20000014
 800866c:	200024b8 	.word	0x200024b8
 8008670:	2000261c 	.word	0x2000261c
 8008674:	20002448 	.word	0x20002448
 8008678:	200024bc 	.word	0x200024bc
 800867c:	20002604 	.word	0x20002604

08008680 <limit_interrupt_handler>:
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending
    // moves in the planner and stream input buffers are all cleared and newly sent blocks will be
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.

    if (!(sys.state & (STATE_ALARM|STATE_ESTOP)) && !sys_rt_exec_alarm) {
 8008680:	f240 1201 	movw	r2, #257	; 0x101
 8008684:	4b09      	ldr	r3, [pc, #36]	; (80086ac <limit_interrupt_handler+0x2c>)
 8008686:	681b      	ldr	r3, [r3, #0]
 8008688:	421a      	tst	r2, r3
 800868a:	d000      	beq.n	800868e <limit_interrupt_handler+0xe>
 800868c:	4770      	bx	lr
{
 800868e:	b510      	push	{r4, lr}
    if (!(sys.state & (STATE_ALARM|STATE_ESTOP)) && !sys_rt_exec_alarm) {
 8008690:	4c07      	ldr	r4, [pc, #28]	; (80086b0 <limit_interrupt_handler+0x30>)
 8008692:	6823      	ldr	r3, [r4, #0]
 8008694:	b103      	cbz	r3, 8008698 <limit_interrupt_handler+0x18>
      #else
        mc_reset(); // Initiate system kill.
        system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
      #endif
    }
}
 8008696:	bd10      	pop	{r4, pc}
        mc_reset(); // Initiate system kill.
 8008698:	f001 fbb0 	bl	8009dfc <mc_reset>
        system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
 800869c:	4b05      	ldr	r3, [pc, #20]	; (80086b4 <limit_interrupt_handler+0x34>)
 800869e:	4620      	mov	r0, r4
}
 80086a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        system_set_exec_alarm(Alarm_HardLimit); // Indicate hard limit critical event
 80086a4:	2101      	movs	r1, #1
 80086a6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80086aa:	4718      	bx	r3
 80086ac:	20002494 	.word	0x20002494
 80086b0:	2000261c 	.word	0x2000261c
 80086b4:	200024bc 	.word	0x200024bc

080086b8 <limits_set_machine_positions>:

#ifndef KINEMATICS_API
// Set machine positions for homed limit switches. Don't update non-homed axes.
// NOTE: settings.max_travel[] is stored as a negative value.
void limits_set_machine_positions (axes_signals_t cycle, bool add_pulloff)
{
 80086b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80086ba:	b2c4      	uxtb	r4, r0
    uint_fast8_t idx = N_AXIS;
    float pulloff = add_pulloff ? settings.homing.pulloff : 0.0f;
 80086bc:	2900      	cmp	r1, #0
 80086be:	d043      	beq.n	8008748 <limits_set_machine_positions+0x90>
 80086c0:	4d32      	ldr	r5, [pc, #200]	; (800878c <limits_set_machine_positions+0xd4>)
 80086c2:	f8d5 60c8 	ldr.w	r6, [r5, #200]	; 0xc8

    if(settings.homing.flags.force_set_origin) {
 80086c6:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 80086ca:	071f      	lsls	r7, r3, #28
 80086cc:	d50f      	bpl.n	80086ee <limits_set_machine_positions+0x36>
        do {
            if (cycle.mask & bit(--idx))
 80086ce:	0765      	lsls	r5, r4, #29
 80086d0:	d502      	bpl.n	80086d8 <limits_set_machine_positions+0x20>
                sys_position[idx] = 0;
 80086d2:	2200      	movs	r2, #0
 80086d4:	4b2e      	ldr	r3, [pc, #184]	; (8008790 <limits_set_machine_positions+0xd8>)
 80086d6:	609a      	str	r2, [r3, #8]
            if (cycle.mask & bit(--idx))
 80086d8:	07a0      	lsls	r0, r4, #30
 80086da:	d502      	bpl.n	80086e2 <limits_set_machine_positions+0x2a>
                sys_position[idx] = 0;
 80086dc:	2200      	movs	r2, #0
 80086de:	4b2c      	ldr	r3, [pc, #176]	; (8008790 <limits_set_machine_positions+0xd8>)
 80086e0:	605a      	str	r2, [r3, #4]
            if (cycle.mask & bit(--idx))
 80086e2:	07e1      	lsls	r1, r4, #31
 80086e4:	d502      	bpl.n	80086ec <limits_set_machine_positions+0x34>
                sys_position[idx] = 0;
 80086e6:	2200      	movs	r2, #0
 80086e8:	4b29      	ldr	r3, [pc, #164]	; (8008790 <limits_set_machine_positions+0xd8>)
 80086ea:	601a      	str	r2, [r3, #0]
        if (cycle.mask & bit(--idx))
            sys_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
                                 ? lroundf((settings.max_travel[idx] + pulloff) * settings.steps_per_mm[idx])
                                 : lroundf(-pulloff * settings.steps_per_mm[idx]);
    } while(idx);
}
 80086ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (cycle.mask & bit(--idx))
 80086ee:	0762      	lsls	r2, r4, #29
            sys_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 80086f0:	f895 70cc 	ldrb.w	r7, [r5, #204]	; 0xcc
        if (cycle.mask & bit(--idx))
 80086f4:	d50b      	bpl.n	800870e <limits_set_machine_positions+0x56>
                                 : lroundf(-pulloff * settings.steps_per_mm[idx]);
 80086f6:	077b      	lsls	r3, r7, #29
 80086f8:	d429      	bmi.n	800874e <limits_set_machine_positions+0x96>
 80086fa:	4630      	mov	r0, r6
 80086fc:	68e9      	ldr	r1, [r5, #12]
 80086fe:	f7f8 f849 	bl	8000794 <__aeabi_fmul>
 8008702:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008706:	f00a fb2f 	bl	8012d68 <lroundf>
            sys_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 800870a:	4b21      	ldr	r3, [pc, #132]	; (8008790 <limits_set_machine_positions+0xd8>)
 800870c:	6098      	str	r0, [r3, #8]
        if (cycle.mask & bit(--idx))
 800870e:	07a0      	lsls	r0, r4, #30
 8008710:	d50b      	bpl.n	800872a <limits_set_machine_positions+0x72>
                                 : lroundf(-pulloff * settings.steps_per_mm[idx]);
 8008712:	07b9      	lsls	r1, r7, #30
 8008714:	d425      	bmi.n	8008762 <limits_set_machine_positions+0xaa>
 8008716:	4630      	mov	r0, r6
 8008718:	68a9      	ldr	r1, [r5, #8]
 800871a:	f7f8 f83b 	bl	8000794 <__aeabi_fmul>
 800871e:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008722:	f00a fb21 	bl	8012d68 <lroundf>
            sys_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 8008726:	4b1a      	ldr	r3, [pc, #104]	; (8008790 <limits_set_machine_positions+0xd8>)
 8008728:	6058      	str	r0, [r3, #4]
        if (cycle.mask & bit(--idx))
 800872a:	07e2      	lsls	r2, r4, #31
 800872c:	d5de      	bpl.n	80086ec <limits_set_machine_positions+0x34>
                                 : lroundf(-pulloff * settings.steps_per_mm[idx]);
 800872e:	07fb      	lsls	r3, r7, #31
 8008730:	d421      	bmi.n	8008776 <limits_set_machine_positions+0xbe>
 8008732:	4630      	mov	r0, r6
 8008734:	6869      	ldr	r1, [r5, #4]
 8008736:	f7f8 f82d 	bl	8000794 <__aeabi_fmul>
 800873a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800873e:	f00a fb13 	bl	8012d68 <lroundf>
            sys_position[idx] = bit_istrue(settings.homing.dir_mask.value, bit(idx))
 8008742:	4b13      	ldr	r3, [pc, #76]	; (8008790 <limits_set_machine_positions+0xd8>)
 8008744:	6018      	str	r0, [r3, #0]
}
 8008746:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    float pulloff = add_pulloff ? settings.homing.pulloff : 0.0f;
 8008748:	2600      	movs	r6, #0
 800874a:	4d10      	ldr	r5, [pc, #64]	; (800878c <limits_set_machine_positions+0xd4>)
 800874c:	e7bb      	b.n	80086c6 <limits_set_machine_positions+0xe>
                                 ? lroundf((settings.max_travel[idx] + pulloff) * settings.steps_per_mm[idx])
 800874e:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8008750:	4630      	mov	r0, r6
 8008752:	f7f7 ff17 	bl	8000584 <__addsf3>
 8008756:	68e9      	ldr	r1, [r5, #12]
 8008758:	f7f8 f81c 	bl	8000794 <__aeabi_fmul>
 800875c:	f00a fb04 	bl	8012d68 <lroundf>
 8008760:	e7d3      	b.n	800870a <limits_set_machine_positions+0x52>
 8008762:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8008764:	4630      	mov	r0, r6
 8008766:	f7f7 ff0d 	bl	8000584 <__addsf3>
 800876a:	68a9      	ldr	r1, [r5, #8]
 800876c:	f7f8 f812 	bl	8000794 <__aeabi_fmul>
 8008770:	f00a fafa 	bl	8012d68 <lroundf>
 8008774:	e7d7      	b.n	8008726 <limits_set_machine_positions+0x6e>
 8008776:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8008778:	4630      	mov	r0, r6
 800877a:	f7f7 ff03 	bl	8000584 <__addsf3>
 800877e:	6869      	ldr	r1, [r5, #4]
 8008780:	f7f8 f808 	bl	8000794 <__aeabi_fmul>
 8008784:	f00a faf0 	bl	8012d68 <lroundf>
 8008788:	e7db      	b.n	8008742 <limits_set_machine_positions+0x8a>
 800878a:	bf00      	nop
 800878c:	20002620 	.word	0x20002620
 8008790:	20002610 	.word	0x20002610

08008794 <limits_homing_cycle>:
// the trigger point of the limit switches. The rapid stops are handled by a system level axis lock
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
static bool limits_homing_cycle (axes_signals_t cycle)
{
 8008794:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (ABORTED) // Block if system reset has been issued.
 8008798:	4fb0      	ldr	r7, [pc, #704]	; (8008a5c <limits_homing_cycle+0x2c8>)
{
 800879a:	b09b      	sub	sp, #108	; 0x6c
    if (ABORTED) // Block if system reset has been issued.
 800879c:	f8b7 9004 	ldrh.w	r9, [r7, #4]
{
 80087a0:	f88d 0017 	strb.w	r0, [sp, #23]
    if (ABORTED) // Block if system reset has been issued.
 80087a4:	f1b9 0f00 	cmp.w	r9, #0
 80087a8:	d003      	beq.n	80087b2 <limits_homing_cycle+0x1e>
        return false;
 80087aa:	2000      	movs	r0, #0
#endif
    sys.step_control.flags = 0; // Return step control to normal operation.
    sys.homed.mask |= cycle.mask;

    return true;
}
 80087ac:	b01b      	add	sp, #108	; 0x6c
 80087ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80087b2:	4683      	mov	fp, r0
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 80087b4:	f8df 82bc 	ldr.w	r8, [pc, #700]	; 8008a74 <limits_homing_cycle+0x2e0>
    memset(&plan_data, 0, sizeof(plan_line_data_t));
 80087b8:	2234      	movs	r2, #52	; 0x34
 80087ba:	4649      	mov	r1, r9
 80087bc:	a80d      	add	r0, sp, #52	; 0x34
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 80087be:	f898 a0cd 	ldrb.w	sl, [r8, #205]	; 0xcd
    float homing_rate = settings.homing.seek_rate;
 80087c2:	f8d8 40c4 	ldr.w	r4, [r8, #196]	; 0xc4
    memset(&plan_data, 0, sizeof(plan_line_data_t));
 80087c6:	f009 fa5d 	bl	8011c84 <memset>
        step_pin[idx] = bit(idx);
 80087ca:	f04f 0c04 	mov.w	ip, #4
    plan_data.condition.system_motion = On;
 80087ce:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 80087d2:	f8df e2a4 	ldr.w	lr, [pc, #676]	; 8008a78 <limits_homing_cycle+0x2e4>
    plan_data.condition.system_motion = On;
 80087d6:	f023 0312 	bic.w	r3, r3, #18
 80087da:	f043 0312 	orr.w	r3, r3, #18
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 80087de:	f10e 0648 	add.w	r6, lr, #72	; 0x48
 80087e2:	ad0e      	add	r5, sp, #56	; 0x38
    plan_data.condition.system_motion = On;
 80087e4:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    plan_data.line_number = HOMING_CYCLE_LINE_NUMBER;
 80087e8:	f8cd 905c 	str.w	r9, [sp, #92]	; 0x5c
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 80087ec:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80087ee:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80087f0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
    plan_data.condition.spindle = gc_state.modal.spindle;
 80087f4:	f89e 601a 	ldrb.w	r6, [lr, #26]
 80087f8:	fa5f f38b 	uxtb.w	r3, fp
    plan_data.condition.coolant = gc_state.modal.coolant;
 80087fc:	f89e e019 	ldrb.w	lr, [lr, #25]
    memcpy(&plan_data.spindle, &gc_state.spindle, sizeof(spindle_t));
 8008800:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 8008804:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
    plan_data.condition.spindle = gc_state.modal.spindle;
 8008808:	f88d 6056 	strb.w	r6, [sp, #86]	; 0x56
        if (bit_istrue(cycle.mask, bit(idx)))
 800880c:	f3c3 0280 	ubfx	r2, r3, #2, #1
 8008810:	075e      	lsls	r6, r3, #29
    uint_fast8_t n_cycle = (2 * settings.homing.locate_cycles + 1);
 8008812:	f10a 0a01 	add.w	sl, sl, #1
 8008816:	9304      	str	r3, [sp, #16]
        step_pin[idx] = bit(idx);
 8008818:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
    plan_data.condition.coolant = gc_state.modal.coolant;
 800881c:	f88d e057 	strb.w	lr, [sp, #87]	; 0x57
        if (bit_istrue(cycle.mask, bit(idx)))
 8008820:	9200      	str	r2, [sp, #0]
 8008822:	f140 8115 	bpl.w	8008a50 <limits_homing_cycle+0x2bc>
            max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR) * settings.max_travel[idx]);
 8008826:	498e      	ldr	r1, [pc, #568]	; (8008a60 <limits_homing_cycle+0x2cc>)
 8008828:	f8d8 0030 	ldr.w	r0, [r8, #48]	; 0x30
 800882c:	f7f7 ffb2 	bl	8000794 <__aeabi_fmul>
 8008830:	2100      	movs	r1, #0
 8008832:	9001      	str	r0, [sp, #4]
 8008834:	f7f8 f960 	bl	8000af8 <__aeabi_fcmpge>
 8008838:	9a01      	ldr	r2, [sp, #4]
 800883a:	2800      	cmp	r0, #0
 800883c:	f000 8108 	beq.w	8008a50 <limits_homing_cycle+0x2bc>
        step_pin[idx] = bit(idx);
 8008840:	2302      	movs	r3, #2
 8008842:	9308      	str	r3, [sp, #32]
        if (bit_istrue(cycle.mask, bit(idx)))
 8008844:	9b04      	ldr	r3, [sp, #16]
 8008846:	f3c3 0140 	ubfx	r1, r3, #1, #1
 800884a:	079d      	lsls	r5, r3, #30
 800884c:	9103      	str	r1, [sp, #12]
 800884e:	d50f      	bpl.n	8008870 <limits_homing_cycle+0xdc>
            max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR) * settings.max_travel[idx]);
 8008850:	4983      	ldr	r1, [pc, #524]	; (8008a60 <limits_homing_cycle+0x2cc>)
 8008852:	f8d8 002c 	ldr.w	r0, [r8, #44]	; 0x2c
 8008856:	9201      	str	r2, [sp, #4]
 8008858:	f7f7 ff9c 	bl	8000794 <__aeabi_fmul>
 800885c:	4605      	mov	r5, r0
 800885e:	9a01      	ldr	r2, [sp, #4]
 8008860:	4629      	mov	r1, r5
 8008862:	4610      	mov	r0, r2
 8008864:	f7f8 f948 	bl	8000af8 <__aeabi_fcmpge>
 8008868:	9a01      	ldr	r2, [sp, #4]
 800886a:	2800      	cmp	r0, #0
 800886c:	f000 815d 	beq.w	8008b2a <limits_homing_cycle+0x396>
        step_pin[idx] = bit(idx);
 8008870:	2301      	movs	r3, #1
 8008872:	9307      	str	r3, [sp, #28]
        if (bit_istrue(cycle.mask, bit(idx)))
 8008874:	9b04      	ldr	r3, [sp, #16]
 8008876:	07d8      	lsls	r0, r3, #31
 8008878:	f003 0501 	and.w	r5, r3, #1
 800887c:	d50f      	bpl.n	800889e <limits_homing_cycle+0x10a>
            max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR) * settings.max_travel[idx]);
 800887e:	4978      	ldr	r1, [pc, #480]	; (8008a60 <limits_homing_cycle+0x2cc>)
 8008880:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 8008884:	9201      	str	r2, [sp, #4]
 8008886:	f7f7 ff85 	bl	8000794 <__aeabi_fmul>
 800888a:	4606      	mov	r6, r0
 800888c:	9a01      	ldr	r2, [sp, #4]
 800888e:	4631      	mov	r1, r6
 8008890:	4610      	mov	r0, r2
 8008892:	f7f8 f931 	bl	8000af8 <__aeabi_fcmpge>
 8008896:	9a01      	ldr	r2, [sp, #4]
 8008898:	2800      	cmp	r0, #0
 800889a:	f000 8144 	beq.w	8008b26 <limits_homing_cycle+0x392>
    bool approach = true;
 800889e:	f04f 0901 	mov.w	r9, #1
 80088a2:	b2eb      	uxtb	r3, r5
                    system_set_exec_alarm(Alarm_HomingFailApproach);
 80088a4:	4e6f      	ldr	r6, [pc, #444]	; (8008a64 <limits_homing_cycle+0x2d0>)
 80088a6:	4d70      	ldr	r5, [pc, #448]	; (8008a68 <limits_homing_cycle+0x2d4>)
 80088a8:	9302      	str	r3, [sp, #8]
        system_convert_array_steps_to_mpos(target, sys_position);
 80088aa:	4970      	ldr	r1, [pc, #448]	; (8008a6c <limits_homing_cycle+0x2d8>)
 80088ac:	a80a      	add	r0, sp, #40	; 0x28
 80088ae:	9201      	str	r2, [sp, #4]
 80088b0:	f008 ff3a 	bl	8011728 <system_convert_array_steps_to_mpos>
            if (bit_istrue(cycle.mask, bit(--idx))) {
 80088b4:	e9dd 3200 	ldrd	r3, r2, [sp]
 80088b8:	2b00      	cmp	r3, #0
 80088ba:	f000 80cb 	beq.w	8008a54 <limits_homing_cycle+0x2c0>
                sys_position[idx] = 0;
 80088be:	2100      	movs	r1, #0
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80088c0:	f898 30cc 	ldrb.w	r3, [r8, #204]	; 0xcc
                sys_position[idx] = 0;
 80088c4:	4869      	ldr	r0, [pc, #420]	; (8008a6c <limits_homing_cycle+0x2d8>)
 80088c6:	6081      	str	r1, [r0, #8]
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80088c8:	0759      	lsls	r1, r3, #29
 80088ca:	f100 811d 	bmi.w	8008b08 <limits_homing_cycle+0x374>
                    target[idx] = approach ? max_travel : - max_travel;
 80088ce:	f1b9 0f00 	cmp.w	r9, #0
 80088d2:	f000 811d 	beq.w	8008b10 <limits_homing_cycle+0x37c>
                    target[idx] = approach ? - max_travel : max_travel;
 80088d6:	4613      	mov	r3, r2
                axislock.mask |= step_pin[idx];
 80088d8:	2102      	movs	r1, #2
 80088da:	f89d b024 	ldrb.w	fp, [sp, #36]	; 0x24
                n_active_axis++;
 80088de:	9800      	ldr	r0, [sp, #0]
                    target[idx] = approach ? - max_travel : max_travel;
 80088e0:	930c      	str	r3, [sp, #48]	; 0x30
            if (bit_istrue(cycle.mask, bit(--idx))) {
 80088e2:	9b03      	ldr	r3, [sp, #12]
 80088e4:	b19b      	cbz	r3, 800890e <limits_homing_cycle+0x17a>
                sys_position[idx] = 0;
 80088e6:	2300      	movs	r3, #0
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80088e8:	f898 c0cc 	ldrb.w	ip, [r8, #204]	; 0xcc
                sys_position[idx] = 0;
 80088ec:	485f      	ldr	r0, [pc, #380]	; (8008a6c <limits_homing_cycle+0x2d8>)
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80088ee:	f01c 0f02 	tst.w	ip, #2
                sys_position[idx] = 0;
 80088f2:	6043      	str	r3, [r0, #4]
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 80088f4:	f040 8101 	bne.w	8008afa <limits_homing_cycle+0x366>
                    target[idx] = approach ? max_travel : - max_travel;
 80088f8:	f1b9 0f00 	cmp.w	r9, #0
 80088fc:	f000 8101 	beq.w	8008b02 <limits_homing_cycle+0x36e>
                    target[idx] = approach ? - max_travel : max_travel;
 8008900:	4610      	mov	r0, r2
 8008902:	900b      	str	r0, [sp, #44]	; 0x2c
                n_active_axis++;
 8008904:	4608      	mov	r0, r1
                axislock.mask |= step_pin[idx];
 8008906:	f89d c020 	ldrb.w	ip, [sp, #32]
 800890a:	ea4b 0b0c 	orr.w	fp, fp, ip
            if (bit_istrue(cycle.mask, bit(--idx))) {
 800890e:	9b02      	ldr	r3, [sp, #8]
 8008910:	b1a3      	cbz	r3, 800893c <limits_homing_cycle+0x1a8>
                sys_position[idx] = 0;
 8008912:	2300      	movs	r3, #0
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 8008914:	f898 c0cc 	ldrb.w	ip, [r8, #204]	; 0xcc
                sys_position[idx] = 0;
 8008918:	4954      	ldr	r1, [pc, #336]	; (8008a6c <limits_homing_cycle+0x2d8>)
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 800891a:	f01c 0f01 	tst.w	ip, #1
                n_active_axis++;
 800891e:	f100 0001 	add.w	r0, r0, #1
                sys_position[idx] = 0;
 8008922:	600b      	str	r3, [r1, #0]
                if (bit_istrue(settings.homing.dir_mask.value, bit(idx)))
 8008924:	f000 80e4 	beq.w	8008af0 <limits_homing_cycle+0x35c>
                    target[idx] = approach ? - max_travel : max_travel;
 8008928:	f1b9 0f00 	cmp.w	r9, #0
 800892c:	d001      	beq.n	8008932 <limits_homing_cycle+0x19e>
                    target[idx] = approach ? max_travel : - max_travel;
 800892e:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 8008932:	920a      	str	r2, [sp, #40]	; 0x28
                axislock.mask |= step_pin[idx];
 8008934:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8008938:	ea4b 0b02 	orr.w	fp, fp, r2
        homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 800893c:	f7f7 fed2 	bl	80006e4 <__aeabi_ui2f>
 8008940:	f00a fb54 	bl	8012fec <sqrtf>
 8008944:	4621      	mov	r1, r4
        sys.homing_axis_lock.mask = axislock.mask;
 8008946:	f887 b00b 	strb.w	fp, [r7, #11]
        homing_rate *= sqrtf(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
 800894a:	f7f7 ff23 	bl	8000794 <__aeabi_fmul>
 800894e:	4602      	mov	r2, r0
        plan_buffer_line(target, &plan_data); // Bypass mc_line(). Directly plan homing motion.
 8008950:	a90d      	add	r1, sp, #52	; 0x34
 8008952:	a80a      	add	r0, sp, #40	; 0x28
        plan_data.feed_rate = homing_rate; // Set current homing rate.
 8008954:	920d      	str	r2, [sp, #52]	; 0x34
        plan_buffer_line(target, &plan_data); // Bypass mc_line(). Directly plan homing motion.
 8008956:	f002 f89b 	bl	800aa90 <plan_buffer_line>
        sys.step_control.flags = 0;
 800895a:	2204      	movs	r2, #4
 800895c:	72ba      	strb	r2, [r7, #10]
        st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
 800895e:	f007 fe37 	bl	80105d0 <st_prep_buffer>
        st_wake_up(); // Initiate motion
 8008962:	f007 fba9 	bl	80100b8 <st_wake_up>
 8008966:	f1b9 0f00 	cmp.w	r9, #0
 800896a:	d14d      	bne.n	8008a08 <limits_homing_cycle+0x274>
 800896c:	f00b 0407 	and.w	r4, fp, #7
 8008970:	e002      	b.n	8008978 <limits_homing_cycle+0x1e4>
        } while (axislock.mask & AXES_BITMASK);
 8008972:	2c00      	cmp	r4, #0
 8008974:	f000 8082 	beq.w	8008a7c <limits_homing_cycle+0x2e8>
            st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
 8008978:	f007 fe2a 	bl	80105d0 <st_prep_buffer>
            if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 800897c:	682b      	ldr	r3, [r5, #0]
 800897e:	f013 0f64 	tst.w	r3, #100	; 0x64
 8008982:	d0f6      	beq.n	8008972 <limits_homing_cycle+0x1de>
                uint8_t rt_exec = sys_rt_exec_state;
 8008984:	682c      	ldr	r4, [r5, #0]
                if (rt_exec & EXEC_RESET)
 8008986:	06a1      	lsls	r1, r4, #26
 8008988:	d504      	bpl.n	8008994 <limits_homing_cycle+0x200>
                    system_set_exec_alarm(Alarm_HomingFailReset);
 800898a:	2106      	movs	r1, #6
 800898c:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8008990:	4837      	ldr	r0, [pc, #220]	; (8008a70 <limits_homing_cycle+0x2dc>)
 8008992:	4798      	blx	r3
                if (rt_exec & EXEC_SAFETY_DOOR)
 8008994:	0662      	lsls	r2, r4, #25
 8008996:	d504      	bpl.n	80089a2 <limits_homing_cycle+0x20e>
                    system_set_exec_alarm(Alarm_HomingFailDoor);
 8008998:	2107      	movs	r1, #7
 800899a:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 800899e:	4834      	ldr	r0, [pc, #208]	; (8008a70 <limits_homing_cycle+0x2dc>)
 80089a0:	4798      	blx	r3
                if (!approach && (hal.limits_get_state().value & cycle.mask))
 80089a2:	f1b9 0f00 	cmp.w	r9, #0
 80089a6:	f040 808e 	bne.w	8008ac6 <limits_homing_cycle+0x332>
 80089aa:	6a33      	ldr	r3, [r6, #32]
 80089ac:	4798      	blx	r3
 80089ae:	9b04      	ldr	r3, [sp, #16]
 80089b0:	4203      	tst	r3, r0
 80089b2:	d004      	beq.n	80089be <limits_homing_cycle+0x22a>
                    system_set_exec_alarm(Alarm_FailPulloff);
 80089b4:	2108      	movs	r1, #8
 80089b6:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 80089ba:	482d      	ldr	r0, [pc, #180]	; (8008a70 <limits_homing_cycle+0x2dc>)
 80089bc:	4798      	blx	r3
                if (sys_rt_exec_alarm) {
 80089be:	4b2c      	ldr	r3, [pc, #176]	; (8008a70 <limits_homing_cycle+0x2dc>)
 80089c0:	681c      	ldr	r4, [r3, #0]
 80089c2:	2c00      	cmp	r4, #0
 80089c4:	f040 808c 	bne.w	8008ae0 <limits_homing_cycle+0x34c>
                    system_clear_exec_state_flag(EXEC_CYCLE_COMPLETE);
 80089c8:	2104      	movs	r1, #4
 80089ca:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 80089ce:	4826      	ldr	r0, [pc, #152]	; (8008a68 <limits_homing_cycle+0x2d4>)
 80089d0:	4798      	blx	r3
        st_reset(); // Immediately force kill steppers and reset step segment buffer.
 80089d2:	f007 fce9 	bl	80103a8 <st_reset>
        hal.delay_ms(settings.homing.debounce_delay, 0); // Delay to allow transient dynamics to dissipate.
 80089d6:	4621      	mov	r1, r4
 80089d8:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80089da:	f8b8 00ce 	ldrh.w	r0, [r8, #206]	; 0xce
 80089de:	4798      	blx	r3
        if (approach) {
 80089e0:	f1b9 0f00 	cmp.w	r9, #0
 80089e4:	d051      	beq.n	8008a8a <limits_homing_cycle+0x2f6>
            homing_rate = settings.homing.seek_rate;
 80089e6:	f04f 0900 	mov.w	r9, #0
            max_travel = settings.homing.pulloff;
 80089ea:	f8d8 20c8 	ldr.w	r2, [r8, #200]	; 0xc8
            homing_rate = settings.homing.seek_rate;
 80089ee:	f8d8 40c4 	ldr.w	r4, [r8, #196]	; 0xc4
    } while (n_cycle-- > 0);
 80089f2:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
 80089f6:	f1ba 0f00 	cmp.w	sl, #0
 80089fa:	d055      	beq.n	8008aa8 <limits_homing_cycle+0x314>
 80089fc:	469a      	mov	sl, r3
 80089fe:	e754      	b.n	80088aa <limits_homing_cycle+0x116>
        } while (axislock.mask & AXES_BITMASK);
 8008a00:	f01b 0407 	ands.w	r4, fp, #7
 8008a04:	f000 8087 	beq.w	8008b16 <limits_homing_cycle+0x382>
                limit_state = hal.limits_get_state().value;
 8008a08:	6a33      	ldr	r3, [r6, #32]
 8008a0a:	4798      	blx	r3
                    if ((axislock.mask & step_pin[idx]) && (limit_state & bit(idx))) {
 8008a0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
                limit_state = hal.limits_get_state().value;
 8008a0e:	b2c0      	uxtb	r0, r0
                    if ((axislock.mask & step_pin[idx]) && (limit_state & bit(idx))) {
 8008a10:	ea1b 0f03 	tst.w	fp, r3
 8008a14:	d003      	beq.n	8008a1e <limits_homing_cycle+0x28a>
 8008a16:	0743      	lsls	r3, r0, #29
                        axislock.mask &= ~bit(idx);
 8008a18:	bf48      	it	mi
 8008a1a:	f00b 0bfb 	andmi.w	fp, fp, #251	; 0xfb
                    if ((axislock.mask & step_pin[idx]) && (limit_state & bit(idx))) {
 8008a1e:	9b08      	ldr	r3, [sp, #32]
 8008a20:	ea1b 0f03 	tst.w	fp, r3
 8008a24:	d003      	beq.n	8008a2e <limits_homing_cycle+0x29a>
 8008a26:	0784      	lsls	r4, r0, #30
                        axislock.mask &= ~bit(idx);
 8008a28:	bf48      	it	mi
 8008a2a:	f00b 0bfd 	andmi.w	fp, fp, #253	; 0xfd
                    if ((axislock.mask & step_pin[idx]) && (limit_state & bit(idx))) {
 8008a2e:	9b07      	ldr	r3, [sp, #28]
 8008a30:	ea1b 0f03 	tst.w	fp, r3
 8008a34:	d003      	beq.n	8008a3e <limits_homing_cycle+0x2aa>
 8008a36:	07c0      	lsls	r0, r0, #31
                        axislock.mask &= ~bit(idx);
 8008a38:	bf48      	it	mi
 8008a3a:	f00b 0bfe 	andmi.w	fp, fp, #254	; 0xfe
                sys.homing_axis_lock.mask = axislock.mask;
 8008a3e:	f887 b00b 	strb.w	fp, [r7, #11]
            st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
 8008a42:	f007 fdc5 	bl	80105d0 <st_prep_buffer>
            if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_COMPLETE)) {
 8008a46:	682b      	ldr	r3, [r5, #0]
 8008a48:	f013 0f64 	tst.w	r3, #100	; 0x64
 8008a4c:	d0d8      	beq.n	8008a00 <limits_homing_cycle+0x26c>
 8008a4e:	e799      	b.n	8008984 <limits_homing_cycle+0x1f0>
    float max_travel = 0.0f;
 8008a50:	2200      	movs	r2, #0
 8008a52:	e6f5      	b.n	8008840 <limits_homing_cycle+0xac>
 8008a54:	469b      	mov	fp, r3
        n_active_axis = 0;
 8008a56:	4618      	mov	r0, r3
            if (bit_istrue(cycle.mask, bit(--idx))) {
 8008a58:	2101      	movs	r1, #1
 8008a5a:	e742      	b.n	80088e2 <limits_homing_cycle+0x14e>
 8008a5c:	20002494 	.word	0x20002494
 8008a60:	bfc00000 	.word	0xbfc00000
 8008a64:	200024bc 	.word	0x200024bc
 8008a68:	200024b4 	.word	0x200024b4
 8008a6c:	20002610 	.word	0x20002610
 8008a70:	2000261c 	.word	0x2000261c
 8008a74:	20002620 	.word	0x20002620
 8008a78:	200023dc 	.word	0x200023dc
        st_reset(); // Immediately force kill steppers and reset step segment buffer.
 8008a7c:	f007 fc94 	bl	80103a8 <st_reset>
        hal.delay_ms(settings.homing.debounce_delay, 0); // Delay to allow transient dynamics to dissipate.
 8008a80:	4621      	mov	r1, r4
 8008a82:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8008a84:	f8b8 00ce 	ldrh.w	r0, [r8, #206]	; 0xce
 8008a88:	4798      	blx	r3
            max_travel = settings.homing.pulloff * HOMING_AXIS_LOCATE_SCALAR;
 8008a8a:	4929      	ldr	r1, [pc, #164]	; (8008b30 <limits_homing_cycle+0x39c>)
 8008a8c:	f8d8 00c8 	ldr.w	r0, [r8, #200]	; 0xc8
 8008a90:	f7f7 fe80 	bl	8000794 <__aeabi_fmul>
 8008a94:	f04f 0901 	mov.w	r9, #1
 8008a98:	4602      	mov	r2, r0
            homing_rate = settings.homing.feed_rate;
 8008a9a:	f8d8 40c0 	ldr.w	r4, [r8, #192]	; 0xc0
    } while (n_cycle-- > 0);
 8008a9e:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
 8008aa2:	f1ba 0f00 	cmp.w	sl, #0
 8008aa6:	d1a9      	bne.n	80089fc <limits_homing_cycle+0x268>
    limits_set_machine_positions(cycle, true);
 8008aa8:	f89d 0017 	ldrb.w	r0, [sp, #23]
 8008aac:	2101      	movs	r1, #1
 8008aae:	f7ff fe03 	bl	80086b8 <limits_set_machine_positions>
    return true;
 8008ab2:	2001      	movs	r0, #1
    sys.homed.mask |= cycle.mask;
 8008ab4:	7b7b      	ldrb	r3, [r7, #13]
 8008ab6:	9a04      	ldr	r2, [sp, #16]
    sys.step_control.flags = 0; // Return step control to normal operation.
 8008ab8:	f887 a00a 	strb.w	sl, [r7, #10]
    sys.homed.mask |= cycle.mask;
 8008abc:	431a      	orrs	r2, r3
 8008abe:	737a      	strb	r2, [r7, #13]
}
 8008ac0:	b01b      	add	sp, #108	; 0x6c
 8008ac2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (approach && (rt_exec & EXEC_CYCLE_COMPLETE))
 8008ac6:	0763      	lsls	r3, r4, #29
 8008ac8:	f57f af79 	bpl.w	80089be <limits_homing_cycle+0x22a>
                    system_set_exec_alarm(Alarm_HomingFailApproach);
 8008acc:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8008ad0:	2109      	movs	r1, #9
 8008ad2:	4818      	ldr	r0, [pc, #96]	; (8008b34 <limits_homing_cycle+0x3a0>)
 8008ad4:	4798      	blx	r3
                if (sys_rt_exec_alarm) {
 8008ad6:	4b17      	ldr	r3, [pc, #92]	; (8008b34 <limits_homing_cycle+0x3a0>)
 8008ad8:	681c      	ldr	r4, [r3, #0]
 8008ada:	2c00      	cmp	r4, #0
 8008adc:	f43f af74 	beq.w	80089c8 <limits_homing_cycle+0x234>
                    mc_reset(); // Stop motors, if they are running.
 8008ae0:	f001 f98c 	bl	8009dfc <mc_reset>
                    protocol_execute_realtime();
 8008ae4:	f002 fd1c 	bl	800b520 <protocol_execute_realtime>
                    return false;
 8008ae8:	2000      	movs	r0, #0
}
 8008aea:	b01b      	add	sp, #108	; 0x6c
 8008aec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    target[idx] = approach ? max_travel : - max_travel;
 8008af0:	f1b9 0f00 	cmp.w	r9, #0
 8008af4:	f47f af1d 	bne.w	8008932 <limits_homing_cycle+0x19e>
 8008af8:	e719      	b.n	800892e <limits_homing_cycle+0x19a>
                    target[idx] = approach ? - max_travel : max_travel;
 8008afa:	f1b9 0f00 	cmp.w	r9, #0
 8008afe:	f43f aeff 	beq.w	8008900 <limits_homing_cycle+0x16c>
 8008b02:	f102 4000 	add.w	r0, r2, #2147483648	; 0x80000000
 8008b06:	e6fc      	b.n	8008902 <limits_homing_cycle+0x16e>
 8008b08:	f1b9 0f00 	cmp.w	r9, #0
 8008b0c:	f43f aee3 	beq.w	80088d6 <limits_homing_cycle+0x142>
 8008b10:	f102 4300 	add.w	r3, r2, #2147483648	; 0x80000000
 8008b14:	e6e0      	b.n	80088d8 <limits_homing_cycle+0x144>
        st_reset(); // Immediately force kill steppers and reset step segment buffer.
 8008b16:	f007 fc47 	bl	80103a8 <st_reset>
        hal.delay_ms(settings.homing.debounce_delay, 0); // Delay to allow transient dynamics to dissipate.
 8008b1a:	4621      	mov	r1, r4
 8008b1c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8008b1e:	f8b8 00ce 	ldrh.w	r0, [r8, #206]	; 0xce
 8008b22:	4798      	blx	r3
        if (approach) {
 8008b24:	e75f      	b.n	80089e6 <limits_homing_cycle+0x252>
            max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR) * settings.max_travel[idx]);
 8008b26:	4632      	mov	r2, r6
 8008b28:	e6b9      	b.n	800889e <limits_homing_cycle+0x10a>
 8008b2a:	462a      	mov	r2, r5
 8008b2c:	e6a0      	b.n	8008870 <limits_homing_cycle+0xdc>
 8008b2e:	bf00      	nop
 8008b30:	40a00000 	.word	0x40a00000
 8008b34:	2000261c 	.word	0x2000261c

08008b38 <limits_go_home>:

// Perform homing cycle(s) according to configuration
bool limits_go_home (axes_signals_t cycle)
{
 8008b38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    axes_signals_t ganged = {
      .x = hal.driver_cap.axis_ganged_x,
      .y = hal.driver_cap.axis_ganged_y,
 8008b3c:	4f1f      	ldr	r7, [pc, #124]	; (8008bbc <limits_go_home+0x84>)
{
 8008b3e:	4606      	mov	r6, r0
      .y = hal.driver_cap.axis_ganged_y,
 8008b40:	f897 3147 	ldrb.w	r3, [r7, #327]	; 0x147
      .x = hal.driver_cap.axis_ganged_x,
 8008b44:	f897 4146 	ldrb.w	r4, [r7, #326]	; 0x146
      .y = hal.driver_cap.axis_ganged_y,
 8008b48:	f3c3 0200 	ubfx	r2, r3, #0, #1
      .x = hal.driver_cap.axis_ganged_x,
 8008b4c:	f3c4 14c0 	ubfx	r4, r4, #7, #1
      .z = hal.driver_cap.axis_ganged_z
 8008b50:	f3c3 0340 	ubfx	r3, r3, #1, #1
    axes_signals_t ganged = {
 8008b54:	ea44 0442 	orr.w	r4, r4, r2, lsl #1
 8008b58:	ea44 0483 	orr.w	r4, r4, r3, lsl #2
    };

    bool homed = limits_homing_cycle(cycle);
 8008b5c:	f7ff fe1a 	bl	8008794 <limits_homing_cycle>
    axes_signals_t ganged = {
 8008b60:	f004 0407 	and.w	r4, r4, #7

    ganged.mask &= cycle.mask;

    if(homed && ganged.mask && hal.stepper_disable_motors) {
 8008b64:	4605      	mov	r5, r0
    ganged.mask &= cycle.mask;
 8008b66:	4034      	ands	r4, r6
    if(homed && ganged.mask && hal.stepper_disable_motors) {
 8008b68:	b320      	cbz	r0, 8008bb4 <limits_go_home+0x7c>
 8008b6a:	b31c      	cbz	r4, 8008bb4 <limits_go_home+0x7c>
 8008b6c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8008b6e:	b30a      	cbz	r2, 8008bb4 <limits_go_home+0x7c>
        sys.homed.mask &= ~ganged.mask;
 8008b70:	f8df 804c 	ldr.w	r8, [pc, #76]	; 8008bc0 <limits_go_home+0x88>
        hal.stepper_disable_motors(ganged, SquaringMode_A);
 8008b74:	2101      	movs	r1, #1
        sys.homed.mask &= ~ganged.mask;
 8008b76:	f898 300d 	ldrb.w	r3, [r8, #13]
        hal.stepper_disable_motors(ganged, SquaringMode_A);
 8008b7a:	4620      	mov	r0, r4
        sys.homed.mask &= ~ganged.mask;
 8008b7c:	ea23 0304 	bic.w	r3, r3, r4
 8008b80:	f888 300d 	strb.w	r3, [r8, #13]
        hal.stepper_disable_motors(ganged, SquaringMode_A);
 8008b84:	4790      	blx	r2
        if((homed = limits_homing_cycle(cycle))) {
 8008b86:	4630      	mov	r0, r6
 8008b88:	f7ff fe04 	bl	8008794 <limits_homing_cycle>
        sys.homed.mask &= ~ganged.mask;
 8008b8c:	43e3      	mvns	r3, r4
        if((homed = limits_homing_cycle(cycle))) {
 8008b8e:	4605      	mov	r5, r0
 8008b90:	b160      	cbz	r0, 8008bac <limits_go_home+0x74>
            sys.homed.mask &= ~ganged.mask;
 8008b92:	f898 200d 	ldrb.w	r2, [r8, #13]
            hal.stepper_disable_motors(ganged, SquaringMode_B);
 8008b96:	4620      	mov	r0, r4
            sys.homed.mask &= ~ganged.mask;
 8008b98:	4013      	ands	r3, r2
            hal.stepper_disable_motors(ganged, SquaringMode_B);
 8008b9a:	2102      	movs	r1, #2
            sys.homed.mask &= ~ganged.mask;
 8008b9c:	f888 300d 	strb.w	r3, [r8, #13]
            hal.stepper_disable_motors(ganged, SquaringMode_B);
 8008ba0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008ba2:	4798      	blx	r3
            homed = limits_homing_cycle(cycle);
 8008ba4:	4630      	mov	r0, r6
 8008ba6:	f7ff fdf5 	bl	8008794 <limits_homing_cycle>
 8008baa:	4605      	mov	r5, r0
        }
        hal.stepper_disable_motors((axes_signals_t){0}, SquaringMode_Both);
 8008bac:	2100      	movs	r1, #0
 8008bae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008bb0:	4608      	mov	r0, r1
 8008bb2:	4798      	blx	r3
    }

    return homed;
}
 8008bb4:	4628      	mov	r0, r5
 8008bb6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008bba:	bf00      	nop
 8008bbc:	200024bc 	.word	0x200024bc
 8008bc0:	20002494 	.word	0x20002494

08008bc4 <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Also used by jogging to block travel outside soft-limit volume.
void limits_soft_check  (float *target)
{
 8008bc4:	b538      	push	{r3, r4, r5, lr}
    if (!system_check_travel_limits(target)) {
 8008bc6:	f008 fdcd 	bl	8011764 <system_check_travel_limits>
 8008bca:	b998      	cbnz	r0, 8008bf4 <limits_soft_check+0x30>
        sys.flags.soft_limit = On;
 8008bcc:	4c0f      	ldr	r4, [pc, #60]	; (8008c0c <limits_soft_check+0x48>)
        // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
        // workspace volume so just come to a controlled stop so position is not lost. When complete
        // enter alarm mode.
        if (sys.state == STATE_CYCLE) {
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 8008bce:	4d10      	ldr	r5, [pc, #64]	; (8008c10 <limits_soft_check+0x4c>)
        sys.flags.soft_limit = On;
 8008bd0:	7a63      	ldrb	r3, [r4, #9]
        if (sys.state == STATE_CYCLE) {
 8008bd2:	6821      	ldr	r1, [r4, #0]
        sys.flags.soft_limit = On;
 8008bd4:	f043 0304 	orr.w	r3, r3, #4
        if (sys.state == STATE_CYCLE) {
 8008bd8:	2908      	cmp	r1, #8
        sys.flags.soft_limit = On;
 8008bda:	7263      	strb	r3, [r4, #9]
        if (sys.state == STATE_CYCLE) {
 8008bdc:	d10b      	bne.n	8008bf6 <limits_soft_check+0x32>
            system_set_exec_state_flag(EXEC_FEED_HOLD);
 8008bde:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
 8008be2:	480c      	ldr	r0, [pc, #48]	; (8008c14 <limits_soft_check+0x50>)
 8008be4:	4798      	blx	r3
 8008be6:	e001      	b.n	8008bec <limits_soft_check+0x28>
            do {
                if(!protocol_execute_realtime())
                    return; // aborted!
            } while (sys.state != STATE_IDLE);
 8008be8:	6823      	ldr	r3, [r4, #0]
 8008bea:	b123      	cbz	r3, 8008bf6 <limits_soft_check+0x32>
                if(!protocol_execute_realtime())
 8008bec:	f002 fc98 	bl	800b520 <protocol_execute_realtime>
 8008bf0:	2800      	cmp	r0, #0
 8008bf2:	d1f9      	bne.n	8008be8 <limits_soft_check+0x24>
        }
        mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
        system_set_exec_alarm(Alarm_SoftLimit); // Indicate soft limit critical event
        protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    }
}
 8008bf4:	bd38      	pop	{r3, r4, r5, pc}
        mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8008bf6:	f001 f901 	bl	8009dfc <mc_reset>
        system_set_exec_alarm(Alarm_SoftLimit); // Indicate soft limit critical event
 8008bfa:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8008bfe:	2102      	movs	r1, #2
 8008c00:	4805      	ldr	r0, [pc, #20]	; (8008c18 <limits_soft_check+0x54>)
 8008c02:	4798      	blx	r3
}
 8008c04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        protocol_execute_realtime(); // Execute to enter critical event loop and system abort
 8008c08:	f002 bc8a 	b.w	800b520 <protocol_execute_realtime>
 8008c0c:	20002494 	.word	0x20002494
 8008c10:	200024bc 	.word	0x200024bc
 8008c14:	200024b4 	.word	0x200024b4
 8008c18:	2000261c 	.word	0x2000261c

08008c1c <limits_set_homing_axes>:
    uint_fast8_t idx = N_AXIS;

    sys.homing.mask = 0;

    do {
        sys.homing.mask |= settings.homing.cycle[--idx].mask;
 8008c1c:	4908      	ldr	r1, [pc, #32]	; (8008c40 <limits_set_homing_axes+0x24>)
{
 8008c1e:	b410      	push	{r4}
 8008c20:	4a08      	ldr	r2, [pc, #32]	; (8008c44 <limits_set_homing_axes+0x28>)
        sys.homing.mask |= settings.homing.cycle[--idx].mask;
 8008c22:	f891 40d2 	ldrb.w	r4, [r1, #210]	; 0xd2
 8008c26:	f891 30d3 	ldrb.w	r3, [r1, #211]	; 0xd3
 8008c2a:	f891 00d1 	ldrb.w	r0, [r1, #209]	; 0xd1
 8008c2e:	4323      	orrs	r3, r4
    } while(idx);

    sys.homed.mask &= sys.homing.mask;
 8008c30:	7b51      	ldrb	r1, [r2, #13]
        sys.homing.mask |= settings.homing.cycle[--idx].mask;
 8008c32:	4303      	orrs	r3, r0
    sys.homed.mask &= sys.homing.mask;
 8008c34:	4019      	ands	r1, r3
}
 8008c36:	bc10      	pop	{r4}
 8008c38:	7313      	strb	r3, [r2, #12]
    sys.homed.mask &= sys.homing.mask;
 8008c3a:	7351      	strb	r1, [r2, #13]
}
 8008c3c:	4770      	bx	lr
 8008c3e:	bf00      	nop
 8008c40:	20002620 	.word	0x20002620
 8008c44:	20002494 	.word	0x20002494

08008c48 <mc_line>:
{

    // If enabled, check for soft limit violations. Placed here all line motions are picked up
    // from everywhere in Grbl.
    // NOTE: Block jog motions. Jogging is a special case and soft limits are handled independently.
    if (!pl_data->condition.jog_motion && settings.limits.flags.soft_enabled)
 8008c48:	f891 3020 	ldrb.w	r3, [r1, #32]
{
 8008c4c:	b570      	push	{r4, r5, r6, lr}
 8008c4e:	460c      	mov	r4, r1
    if (!pl_data->condition.jog_motion && settings.limits.flags.soft_enabled)
 8008c50:	0759      	lsls	r1, r3, #29
{
 8008c52:	4606      	mov	r6, r0
    if (!pl_data->condition.jog_motion && settings.limits.flags.soft_enabled)
 8008c54:	d404      	bmi.n	8008c60 <mc_line+0x18>
 8008c56:	4b1c      	ldr	r3, [pc, #112]	; (8008cc8 <mc_line+0x80>)
 8008c58:	f893 30d4 	ldrb.w	r3, [r3, #212]	; 0xd4
 8008c5c:	079a      	lsls	r2, r3, #30
 8008c5e:	d41a      	bmi.n	8008c96 <mc_line+0x4e>
        limits_soft_check(target);

    // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
    if (sys.state != STATE_CHECK_MODE && protocol_execute_realtime()) {
 8008c60:	4d1a      	ldr	r5, [pc, #104]	; (8008ccc <mc_line+0x84>)
 8008c62:	682b      	ldr	r3, [r5, #0]
 8008c64:	2b02      	cmp	r3, #2
 8008c66:	d107      	bne.n	8008c78 <mc_line+0x30>
#ifdef KINEMATICS_API
      }
#endif
    }

    return !ABORTED;
 8008c68:	792b      	ldrb	r3, [r5, #4]
 8008c6a:	b91b      	cbnz	r3, 8008c74 <mc_line+0x2c>
 8008c6c:	7968      	ldrb	r0, [r5, #5]
 8008c6e:	f080 0001 	eor.w	r0, r0, #1
}
 8008c72:	bd70      	pop	{r4, r5, r6, pc}
 8008c74:	2000      	movs	r0, #0
 8008c76:	bd70      	pop	{r4, r5, r6, pc}
    if (sys.state != STATE_CHECK_MODE && protocol_execute_realtime()) {
 8008c78:	f002 fc52 	bl	800b520 <protocol_execute_realtime>
 8008c7c:	2800      	cmp	r0, #0
 8008c7e:	d0f3      	beq.n	8008c68 <mc_line+0x20>
 8008c80:	e004      	b.n	8008c8c <mc_line+0x44>
            if(plan_check_full_buffer())
 8008c82:	f001 fe13 	bl	800a8ac <plan_check_full_buffer>
 8008c86:	b148      	cbz	r0, 8008c9c <mc_line+0x54>
                protocol_auto_cycle_start();    // Auto-cycle start when buffer is full.
 8008c88:	f002 fa48 	bl	800b11c <protocol_auto_cycle_start>
            if(!protocol_execute_realtime())    // Check for any run-time commands
 8008c8c:	f002 fc48 	bl	800b520 <protocol_execute_realtime>
 8008c90:	2800      	cmp	r0, #0
 8008c92:	d1f6      	bne.n	8008c82 <mc_line+0x3a>
 8008c94:	e7ed      	b.n	8008c72 <mc_line+0x2a>
        limits_soft_check(target);
 8008c96:	f7ff ff95 	bl	8008bc4 <limits_soft_check>
 8008c9a:	e7e1      	b.n	8008c60 <mc_line+0x18>
        if(!plan_buffer_line(target, pl_data) && settings.flags.laser_mode && pl_data->condition.spindle.on && !pl_data->condition.spindle.ccw) {
 8008c9c:	4630      	mov	r0, r6
 8008c9e:	4621      	mov	r1, r4
 8008ca0:	f001 fef6 	bl	800aa90 <plan_buffer_line>
 8008ca4:	2800      	cmp	r0, #0
 8008ca6:	d1df      	bne.n	8008c68 <mc_line+0x20>
 8008ca8:	4b07      	ldr	r3, [pc, #28]	; (8008cc8 <mc_line+0x80>)
 8008caa:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 8008cae:	079b      	lsls	r3, r3, #30
 8008cb0:	d5da      	bpl.n	8008c68 <mc_line+0x20>
 8008cb2:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
 8008cb6:	f000 0303 	and.w	r3, r0, #3
 8008cba:	2b01      	cmp	r3, #1
 8008cbc:	d1d4      	bne.n	8008c68 <mc_line+0x20>
            hal.spindle_set_state(pl_data->condition.spindle, pl_data->spindle.rpm);
 8008cbe:	4b04      	ldr	r3, [pc, #16]	; (8008cd0 <mc_line+0x88>)
 8008cc0:	6861      	ldr	r1, [r4, #4]
 8008cc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008cc4:	4798      	blx	r3
 8008cc6:	e7cf      	b.n	8008c68 <mc_line+0x20>
 8008cc8:	20002620 	.word	0x20002620
 8008ccc:	20002494 	.word	0x20002494
 8008cd0:	200024bc 	.word	0x200024bc
 8008cd4:	00000000 	.word	0x00000000

08008cd8 <mc_arc>:
// The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolerance
// of each segment is configured in settings.arc_tolerance, which is defined to be the maximum normal
// distance from segment to the circle when the end points both lie on the circle.
void mc_arc (float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
              plane_t plane, bool is_clockwise_arc)
{
 8008cd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008cdc:	461e      	mov	r6, r3
 8008cde:	460b      	mov	r3, r1
 8008ce0:	b08f      	sub	sp, #60	; 0x3c
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008ce2:	f89d 8064 	ldrb.w	r8, [sp, #100]	; 0x64
{
 8008ce6:	4682      	mov	sl, r0
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008ce8:	f856 4028 	ldr.w	r4, [r6, r8, lsl #2]
 8008cec:	f852 1028 	ldr.w	r1, [r2, r8, lsl #2]
 8008cf0:	4620      	mov	r0, r4
{
 8008cf2:	4693      	mov	fp, r2
 8008cf4:	9301      	str	r3, [sp, #4]
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008cf6:	f7f7 fc45 	bl	8000584 <__addsf3>
    float center_axis1 = position[plane.axis_1] + offset[plane.axis_1];
 8008cfa:	f89d 7065 	ldrb.w	r7, [sp, #101]	; 0x65
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008cfe:	4681      	mov	r9, r0
    float center_axis1 = position[plane.axis_1] + offset[plane.axis_1];
 8008d00:	f856 5027 	ldr.w	r5, [r6, r7, lsl #2]
 8008d04:	f85b 1027 	ldr.w	r1, [fp, r7, lsl #2]
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008d08:	9005      	str	r0, [sp, #20]
    float center_axis1 = position[plane.axis_1] + offset[plane.axis_1];
 8008d0a:	4628      	mov	r0, r5
 8008d0c:	f7f7 fc3a 	bl	8000584 <__addsf3>
 8008d10:	f85a 1027 	ldr.w	r1, [sl, r7, lsl #2]
 8008d14:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8008d18:	9006      	str	r0, [sp, #24]
    float r_axis1 = -offset[plane.axis_1];
    float rt_axis0 = target[plane.axis_0] - center_axis0;
    float rt_axis1 = target[plane.axis_1] - center_axis1;

    // CCW angle between position and target from circle center. Only one atan2() trig computation required.
    float angular_travel = atan2f(r_axis0 * rt_axis1 - r_axis1 * rt_axis0, r_axis0 * rt_axis0 + r_axis1 * rt_axis1);
 8008d1a:	f7f7 fc31 	bl	8000580 <__aeabi_fsub>
 8008d1e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008d20:	4682      	mov	sl, r0
 8008d22:	f853 1028 	ldr.w	r1, [r3, r8, lsl #2]
 8008d26:	4648      	mov	r0, r9
 8008d28:	f7f7 fc2a 	bl	8000580 <__aeabi_fsub>
 8008d2c:	4681      	mov	r9, r0
 8008d2e:	4620      	mov	r0, r4
 8008d30:	4649      	mov	r1, r9
 8008d32:	f7f7 fd2f 	bl	8000794 <__aeabi_fmul>
 8008d36:	4651      	mov	r1, sl
 8008d38:	9002      	str	r0, [sp, #8]
 8008d3a:	4628      	mov	r0, r5
 8008d3c:	f7f7 fd2a 	bl	8000794 <__aeabi_fmul>
 8008d40:	9b02      	ldr	r3, [sp, #8]
 8008d42:	4601      	mov	r1, r0
 8008d44:	4618      	mov	r0, r3
 8008d46:	f7f7 fc1d 	bl	8000584 <__addsf3>
 8008d4a:	4603      	mov	r3, r0
 8008d4c:	4651      	mov	r1, sl
 8008d4e:	4620      	mov	r0, r4
 8008d50:	469a      	mov	sl, r3
 8008d52:	f7f7 fd1f 	bl	8000794 <__aeabi_fmul>
 8008d56:	4649      	mov	r1, r9
 8008d58:	4681      	mov	r9, r0
 8008d5a:	4628      	mov	r0, r5
 8008d5c:	f7f7 fd1a 	bl	8000794 <__aeabi_fmul>
 8008d60:	4601      	mov	r1, r0
 8008d62:	4648      	mov	r0, r9
 8008d64:	f7f7 fc0c 	bl	8000580 <__aeabi_fsub>
 8008d68:	4651      	mov	r1, sl
 8008d6a:	f00a f8b9 	bl	8012ee0 <atan2f>
    float center_axis0 = position[plane.axis_0] + offset[plane.axis_0];
 8008d6e:	eb0b 0288 	add.w	r2, fp, r8, lsl #2
 8008d72:	9203      	str	r2, [sp, #12]
 8008d74:	eb06 0288 	add.w	r2, r6, r8, lsl #2
 8008d78:	920a      	str	r2, [sp, #40]	; 0x28
{
 8008d7a:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
    float center_axis1 = position[plane.axis_1] + offset[plane.axis_1];
 8008d7e:	eb06 0287 	add.w	r2, r6, r7, lsl #2
 8008d82:	920b      	str	r2, [sp, #44]	; 0x2c
 8008d84:	eb0b 0287 	add.w	r2, fp, r7, lsl #2
    float angular_travel = atan2f(r_axis0 * rt_axis1 - r_axis1 * rt_axis0, r_axis0 * rt_axis0 + r_axis1 * rt_axis1);
 8008d88:	4606      	mov	r6, r0
{
 8008d8a:	9f18      	ldr	r7, [sp, #96]	; 0x60
    float center_axis1 = position[plane.axis_1] + offset[plane.axis_1];
 8008d8c:	9204      	str	r2, [sp, #16]

    if (is_clockwise_arc) { // Correct atan2 output per direction
 8008d8e:	2b00      	cmp	r3, #0
 8008d90:	f000 80fa 	beq.w	8008f88 <mc_arc+0x2b0>
        if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON)
 8008d94:	4996      	ldr	r1, [pc, #600]	; (8008ff0 <mc_arc+0x318>)
 8008d96:	f7f7 feaf 	bl	8000af8 <__aeabi_fcmpge>
 8008d9a:	2800      	cmp	r0, #0
 8008d9c:	f040 8115 	bne.w	8008fca <mc_arc+0x2f2>

    // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
    // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
    // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
    // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
    uint16_t segments = (uint16_t)floorf(fabsf(0.5f * angular_travel * radius) / sqrtf(settings.arc_tolerance * (2.0f * radius - settings.arc_tolerance)));
 8008da0:	4b94      	ldr	r3, [pc, #592]	; (8008ff4 <mc_arc+0x31c>)
 8008da2:	4639      	mov	r1, r7
 8008da4:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
 8008da8:	4638      	mov	r0, r7
 8008daa:	f7f7 fbeb 	bl	8000584 <__addsf3>
 8008dae:	4641      	mov	r1, r8
 8008db0:	f7f7 fbe6 	bl	8000580 <__aeabi_fsub>
 8008db4:	4641      	mov	r1, r8
 8008db6:	f7f7 fced 	bl	8000794 <__aeabi_fmul>
 8008dba:	f00a f917 	bl	8012fec <sqrtf>
 8008dbe:	4603      	mov	r3, r0
 8008dc0:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008dc4:	4638      	mov	r0, r7
 8008dc6:	461f      	mov	r7, r3
 8008dc8:	f7f7 fce4 	bl	8000794 <__aeabi_fmul>
 8008dcc:	4631      	mov	r1, r6
 8008dce:	f7f7 fce1 	bl	8000794 <__aeabi_fmul>
 8008dd2:	4639      	mov	r1, r7
 8008dd4:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8008dd8:	f7f7 fd90 	bl	80008fc <__aeabi_fdiv>
 8008ddc:	f009 ff82 	bl	8012ce4 <floorf>
 8008de0:	f7f7 feda 	bl	8000b98 <__aeabi_f2uiz>
 8008de4:	b283      	uxth	r3, r0
 8008de6:	9302      	str	r3, [sp, #8]

    if (segments) {
 8008de8:	2b00      	cmp	r3, #0
 8008dea:	f000 80c6 	beq.w	8008f7a <mc_arc+0x2a2>

        // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
        // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
        // all segments.
        if (pl_data->condition.inverse_time) {
 8008dee:	9b01      	ldr	r3, [sp, #4]
 8008df0:	f89d 8066 	ldrb.w	r8, [sp, #102]	; 0x66
 8008df4:	f893 9020 	ldrb.w	r9, [r3, #32]
            pl_data->feed_rate *= segments;
 8008df8:	9802      	ldr	r0, [sp, #8]
        if (pl_data->condition.inverse_time) {
 8008dfa:	f019 0f20 	tst.w	r9, #32
 8008dfe:	f040 80d5 	bne.w	8008fac <mc_arc+0x2d4>
 8008e02:	f7f7 fc73 	bl	80006ec <__aeabi_i2f>
 8008e06:	4607      	mov	r7, r0
            pl_data->condition.inverse_time = Off; // Force as feed absolute mode over arc segments.
        }

        float theta_per_segment = angular_travel/segments;
 8008e08:	4639      	mov	r1, r7
 8008e0a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8008e0e:	f7f7 fd75 	bl	80008fc <__aeabi_fdiv>
 8008e12:	4607      	mov	r7, r0
 8008e14:	4630      	mov	r0, r6
 8008e16:	4639      	mov	r1, r7
 8008e18:	f7f7 fcbc 	bl	8000794 <__aeabi_fmul>
 8008e1c:	4603      	mov	r3, r0
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 8008e1e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8008e20:	f85b 1028 	ldr.w	r1, [fp, r8, lsl #2]
 8008e24:	f852 0028 	ldr.w	r0, [r2, r8, lsl #2]
        float theta_per_segment = angular_travel/segments;
 8008e28:	469a      	mov	sl, r3
 8008e2a:	930c      	str	r3, [sp, #48]	; 0x30
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 8008e2c:	f7f7 fba8 	bl	8000580 <__aeabi_fsub>
 8008e30:	4639      	mov	r1, r7
 8008e32:	f7f7 fcaf 	bl	8000794 <__aeabi_fmul>
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead.
       This is important when there are successive arc motions.
    */

        // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
        float cos_T = 2.0f - theta_per_segment * theta_per_segment;
 8008e36:	4651      	mov	r1, sl
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 8008e38:	4681      	mov	r9, r0
        float cos_T = 2.0f - theta_per_segment * theta_per_segment;
 8008e3a:	4650      	mov	r0, sl
 8008e3c:	f7f7 fcaa 	bl	8000794 <__aeabi_fmul>
 8008e40:	4606      	mov	r6, r0
 8008e42:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8008e46:	4631      	mov	r1, r6
 8008e48:	f7f7 fb9a 	bl	8000580 <__aeabi_fsub>
 8008e4c:	4603      	mov	r3, r0
        float sin_T = theta_per_segment * 0.16666667f * (cos_T + 4.0f);
 8008e4e:	4631      	mov	r1, r6
 8008e50:	4869      	ldr	r0, [pc, #420]	; (8008ff8 <mc_arc+0x320>)
        float cos_T = 2.0f - theta_per_segment * theta_per_segment;
 8008e52:	461e      	mov	r6, r3
        float sin_T = theta_per_segment * 0.16666667f * (cos_T + 4.0f);
 8008e54:	f7f7 fb94 	bl	8000580 <__aeabi_fsub>
 8008e58:	4968      	ldr	r1, [pc, #416]	; (8008ffc <mc_arc+0x324>)
 8008e5a:	4607      	mov	r7, r0
 8008e5c:	4650      	mov	r0, sl
 8008e5e:	f7f7 fc99 	bl	8000794 <__aeabi_fmul>
 8008e62:	4601      	mov	r1, r0
 8008e64:	4638      	mov	r0, r7
 8008e66:	f7f7 fc95 	bl	8000794 <__aeabi_fmul>
        cos_T *= 0.5f;
 8008e6a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
        float sin_T = theta_per_segment * 0.16666667f * (cos_T + 4.0f);
 8008e6e:	4682      	mov	sl, r0
        cos_T *= 0.5f;
 8008e70:	4630      	mov	r0, r6
 8008e72:	f7f7 fc8f 	bl	8000794 <__aeabi_fmul>
        float sin_Ti;
        float cos_Ti;
        float r_axisi;
        uint32_t i, count = 0;

        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008e76:	9b02      	ldr	r3, [sp, #8]
        float linear_per_segment = (target[plane.axis_linear] - position[plane.axis_linear]) / segments;
 8008e78:	eb0b 0888 	add.w	r8, fp, r8, lsl #2
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008e7c:	2b01      	cmp	r3, #1
        cos_T *= 0.5f;
 8008e7e:	9007      	str	r0, [sp, #28]
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008e80:	d07b      	beq.n	8008f7a <mc_arc+0x2a2>
        uint32_t i, count = 0;
 8008e82:	2700      	movs	r7, #0
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008e84:	2601      	movs	r6, #1
    float r_axis0 = -offset[plane.axis_0];  // Radius vector from center to current location
 8008e86:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
    float r_axis1 = -offset[plane.axis_1];
 8008e8a:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
 8008e8e:	e03c      	b.n	8008f0a <mc_arc+0x232>

            if (count < N_ARC_CORRECTION) {
                // Apply vector rotation matrix. ~40 usec
                r_axisi = r_axis0 * sin_T + r_axis1 * cos_T;
 8008e90:	4621      	mov	r1, r4
 8008e92:	4650      	mov	r0, sl
 8008e94:	f7f7 fc7e 	bl	8000794 <__aeabi_fmul>
 8008e98:	4629      	mov	r1, r5
 8008e9a:	9008      	str	r0, [sp, #32]
 8008e9c:	9807      	ldr	r0, [sp, #28]
 8008e9e:	f7f7 fc79 	bl	8000794 <__aeabi_fmul>
 8008ea2:	9b08      	ldr	r3, [sp, #32]
 8008ea4:	4601      	mov	r1, r0
 8008ea6:	4618      	mov	r0, r3
 8008ea8:	f7f7 fb6c 	bl	8000584 <__addsf3>
 8008eac:	4603      	mov	r3, r0
                r_axis0 = r_axis0 * cos_T - r_axis1 * sin_T;
 8008eae:	4621      	mov	r1, r4
 8008eb0:	9807      	ldr	r0, [sp, #28]
                r_axisi = r_axis0 * sin_T + r_axis1 * cos_T;
 8008eb2:	461c      	mov	r4, r3
                r_axis0 = r_axis0 * cos_T - r_axis1 * sin_T;
 8008eb4:	f7f7 fc6e 	bl	8000794 <__aeabi_fmul>
 8008eb8:	4629      	mov	r1, r5
 8008eba:	4605      	mov	r5, r0
 8008ebc:	4650      	mov	r0, sl
 8008ebe:	f7f7 fc69 	bl	8000794 <__aeabi_fmul>
 8008ec2:	4601      	mov	r1, r0
 8008ec4:	4628      	mov	r0, r5
 8008ec6:	f7f7 fb5b 	bl	8000580 <__aeabi_fsub>
                r_axis1 = r_axisi;
 8008eca:	4625      	mov	r5, r4
                r_axis0 = r_axis0 * cos_T - r_axis1 * sin_T;
 8008ecc:	4604      	mov	r4, r0
                count++;
 8008ece:	3701      	adds	r7, #1
                r_axis1 = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
                count = 0;
            }

            // Update arc_target location
            position[plane.axis_0] = center_axis0 + r_axis0;
 8008ed0:	9905      	ldr	r1, [sp, #20]
 8008ed2:	4620      	mov	r0, r4
 8008ed4:	f7f7 fb56 	bl	8000584 <__addsf3>
 8008ed8:	9b03      	ldr	r3, [sp, #12]
            position[plane.axis_1] = center_axis1 + r_axis1;
 8008eda:	9906      	ldr	r1, [sp, #24]
            position[plane.axis_0] = center_axis0 + r_axis0;
 8008edc:	6018      	str	r0, [r3, #0]
            position[plane.axis_1] = center_axis1 + r_axis1;
 8008ede:	4628      	mov	r0, r5
 8008ee0:	f7f7 fb50 	bl	8000584 <__addsf3>
 8008ee4:	9b04      	ldr	r3, [sp, #16]
            position[plane.axis_linear] += linear_per_segment;
 8008ee6:	4649      	mov	r1, r9
            position[plane.axis_1] = center_axis1 + r_axis1;
 8008ee8:	6018      	str	r0, [r3, #0]
            position[plane.axis_linear] += linear_per_segment;
 8008eea:	f8d8 0000 	ldr.w	r0, [r8]
 8008eee:	f7f7 fb49 	bl	8000584 <__addsf3>

            // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
            if(!mc_line(position, pl_data))
 8008ef2:	9901      	ldr	r1, [sp, #4]
            position[plane.axis_linear] += linear_per_segment;
 8008ef4:	f8c8 0000 	str.w	r0, [r8]
            if(!mc_line(position, pl_data))
 8008ef8:	4658      	mov	r0, fp
 8008efa:	f7ff fea5 	bl	8008c48 <mc_line>
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008efe:	3601      	adds	r6, #1
            if(!mc_line(position, pl_data))
 8008f00:	2800      	cmp	r0, #0
 8008f02:	d06e      	beq.n	8008fe2 <mc_arc+0x30a>
        for (i = 1; i < segments; i++) { // Increment (segments-1).
 8008f04:	9b02      	ldr	r3, [sp, #8]
 8008f06:	429e      	cmp	r6, r3
 8008f08:	d037      	beq.n	8008f7a <mc_arc+0x2a2>
            if (count < N_ARC_CORRECTION) {
 8008f0a:	2f0b      	cmp	r7, #11
 8008f0c:	d9c0      	bls.n	8008e90 <mc_arc+0x1b8>
                cos_Ti = cosf(i * theta_per_segment);
 8008f0e:	4630      	mov	r0, r6
 8008f10:	f7f7 fbe8 	bl	80006e4 <__aeabi_ui2f>
 8008f14:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008f16:	f7f7 fc3d 	bl	8000794 <__aeabi_fmul>
 8008f1a:	4604      	mov	r4, r0
 8008f1c:	f009 feae 	bl	8012c7c <cosf>
 8008f20:	4605      	mov	r5, r0
                sin_Ti = sinf(i * theta_per_segment);
 8008f22:	4620      	mov	r0, r4
 8008f24:	f009 ff72 	bl	8012e0c <sinf>
                r_axis0 = -offset[plane.axis_0] * cos_Ti + offset[plane.axis_1] * sin_Ti;
 8008f28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
                sin_Ti = sinf(i * theta_per_segment);
 8008f2a:	4604      	mov	r4, r0
                r_axis0 = -offset[plane.axis_0] * cos_Ti + offset[plane.axis_1] * sin_Ti;
 8008f2c:	681f      	ldr	r7, [r3, #0]
 8008f2e:	4629      	mov	r1, r5
 8008f30:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
 8008f34:	4638      	mov	r0, r7
 8008f36:	f7f7 fc2d 	bl	8000794 <__aeabi_fmul>
 8008f3a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008f3c:	4621      	mov	r1, r4
 8008f3e:	681b      	ldr	r3, [r3, #0]
 8008f40:	9009      	str	r0, [sp, #36]	; 0x24
 8008f42:	4618      	mov	r0, r3
 8008f44:	9308      	str	r3, [sp, #32]
 8008f46:	f7f7 fc25 	bl	8000794 <__aeabi_fmul>
 8008f4a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008f4c:	4601      	mov	r1, r0
 8008f4e:	4610      	mov	r0, r2
 8008f50:	f7f7 fb18 	bl	8000584 <__addsf3>
 8008f54:	4602      	mov	r2, r0
                r_axis1 = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
 8008f56:	4621      	mov	r1, r4
 8008f58:	4638      	mov	r0, r7
                r_axis0 = -offset[plane.axis_0] * cos_Ti + offset[plane.axis_1] * sin_Ti;
 8008f5a:	4614      	mov	r4, r2
                r_axis1 = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
 8008f5c:	f7f7 fc1a 	bl	8000794 <__aeabi_fmul>
 8008f60:	9b08      	ldr	r3, [sp, #32]
 8008f62:	4629      	mov	r1, r5
 8008f64:	4605      	mov	r5, r0
 8008f66:	4618      	mov	r0, r3
 8008f68:	f7f7 fc14 	bl	8000794 <__aeabi_fmul>
 8008f6c:	4601      	mov	r1, r0
 8008f6e:	4628      	mov	r0, r5
 8008f70:	f7f7 fb06 	bl	8000580 <__aeabi_fsub>
                count = 0;
 8008f74:	2700      	movs	r7, #0
                r_axis1 = -offset[plane.axis_0] * sin_Ti - offset[plane.axis_1] * cos_Ti;
 8008f76:	4605      	mov	r5, r0
                count = 0;
 8008f78:	e7aa      	b.n	8008ed0 <mc_arc+0x1f8>
                return;
        }
    }
    // Ensure last segment arrives at target location.
    mc_line(target, pl_data);
 8008f7a:	9901      	ldr	r1, [sp, #4]
 8008f7c:	980d      	ldr	r0, [sp, #52]	; 0x34
}
 8008f7e:	b00f      	add	sp, #60	; 0x3c
 8008f80:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    mc_line(target, pl_data);
 8008f84:	f7ff be60 	b.w	8008c48 <mc_line>
        if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON)
 8008f88:	491d      	ldr	r1, [pc, #116]	; (8009000 <mc_arc+0x328>)
 8008f8a:	f7f7 fdab 	bl	8000ae4 <__aeabi_fcmple>
 8008f8e:	2800      	cmp	r0, #0
 8008f90:	f43f af06 	beq.w	8008da0 <mc_arc+0xc8>
            angular_travel += 2.0f * M_PI;
 8008f94:	4630      	mov	r0, r6
 8008f96:	f7f7 fa47 	bl	8000428 <__aeabi_f2d>
 8008f9a:	a313      	add	r3, pc, #76	; (adr r3, 8008fe8 <mc_arc+0x310>)
 8008f9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008fa0:	f7f7 f8e4 	bl	800016c <__adddf3>
 8008fa4:	f7f7 fa98 	bl	80004d8 <__aeabi_d2f>
 8008fa8:	4606      	mov	r6, r0
 8008faa:	e6f9      	b.n	8008da0 <mc_arc+0xc8>
            pl_data->feed_rate *= segments;
 8008fac:	f7f7 fb9e 	bl	80006ec <__aeabi_i2f>
 8008fb0:	4607      	mov	r7, r0
 8008fb2:	9a01      	ldr	r2, [sp, #4]
 8008fb4:	4639      	mov	r1, r7
 8008fb6:	6810      	ldr	r0, [r2, #0]
 8008fb8:	f7f7 fbec 	bl	8000794 <__aeabi_fmul>
            pl_data->condition.inverse_time = Off; // Force as feed absolute mode over arc segments.
 8008fbc:	9b01      	ldr	r3, [sp, #4]
 8008fbe:	f36f 1945 	bfc	r9, #5, #1
 8008fc2:	f883 9020 	strb.w	r9, [r3, #32]
            pl_data->feed_rate *= segments;
 8008fc6:	6018      	str	r0, [r3, #0]
            pl_data->condition.inverse_time = Off; // Force as feed absolute mode over arc segments.
 8008fc8:	e71e      	b.n	8008e08 <mc_arc+0x130>
            angular_travel -= 2.0f * M_PI;
 8008fca:	4630      	mov	r0, r6
 8008fcc:	f7f7 fa2c 	bl	8000428 <__aeabi_f2d>
 8008fd0:	a305      	add	r3, pc, #20	; (adr r3, 8008fe8 <mc_arc+0x310>)
 8008fd2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008fd6:	f7f7 f8c7 	bl	8000168 <__aeabi_dsub>
 8008fda:	f7f7 fa7d 	bl	80004d8 <__aeabi_d2f>
 8008fde:	4606      	mov	r6, r0
 8008fe0:	e6de      	b.n	8008da0 <mc_arc+0xc8>
}
 8008fe2:	b00f      	add	sp, #60	; 0x3c
 8008fe4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008fe8:	54442d18 	.word	0x54442d18
 8008fec:	401921fb 	.word	0x401921fb
 8008ff0:	b50637bd 	.word	0xb50637bd
 8008ff4:	20002620 	.word	0x20002620
 8008ff8:	40c00000 	.word	0x40c00000
 8008ffc:	3e2aaaab 	.word	0x3e2aaaab
 8009000:	350637bd 	.word	0x350637bd

08009004 <mc_cubic_b_spline>:
 * the mitigation offered by MIN_STEP and the small computational
 * power available on Arduino, I think it is not wise to implement it.
 */

void mc_cubic_b_spline (float *target, plan_line_data_t *pl_data, float *position, float *offset1, float *offset2)
{
 8009004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009008:	4615      	mov	r5, r2
 800900a:	b097      	sub	sp, #92	; 0x5c
 800900c:	461c      	mov	r4, r3
 800900e:	9211      	str	r2, [sp, #68]	; 0x44
 8009010:	460b      	mov	r3, r1
 8009012:	4602      	mov	r2, r0
    // Absolute first and second control points are recovered.

    float first[2] = { position[X_AXIS] + offset1[X_AXIS], position[Y_AXIS] + offset1[Y_AXIS] };
 8009014:	6829      	ldr	r1, [r5, #0]
{
 8009016:	4616      	mov	r6, r2
    float first[2] = { position[X_AXIS] + offset1[X_AXIS], position[Y_AXIS] + offset1[Y_AXIS] };
 8009018:	4608      	mov	r0, r1
 800901a:	9107      	str	r1, [sp, #28]
 800901c:	6821      	ldr	r1, [r4, #0]
{
 800901e:	e9cd 320f 	strd	r3, r2, [sp, #60]	; 0x3c
    float first[2] = { position[X_AXIS] + offset1[X_AXIS], position[Y_AXIS] + offset1[Y_AXIS] };
 8009022:	f7f7 faaf 	bl	8000584 <__addsf3>
 8009026:	4603      	mov	r3, r0
 8009028:	6869      	ldr	r1, [r5, #4]
 800902a:	9303      	str	r3, [sp, #12]
 800902c:	4608      	mov	r0, r1
 800902e:	9109      	str	r1, [sp, #36]	; 0x24
 8009030:	6861      	ldr	r1, [r4, #4]
 8009032:	f7f7 faa7 	bl	8000584 <__addsf3>
 8009036:	4603      	mov	r3, r0
    float second[2] = { target[X_AXIS] + offset2[X_AXIS], target[Y_AXIS] + offset2[Y_AXIS] };
 8009038:	6832      	ldr	r2, [r6, #0]
{
 800903a:	9c20      	ldr	r4, [sp, #128]	; 0x80
    float second[2] = { target[X_AXIS] + offset2[X_AXIS], target[Y_AXIS] + offset2[Y_AXIS] };
 800903c:	4610      	mov	r0, r2
 800903e:	6821      	ldr	r1, [r4, #0]
 8009040:	9208      	str	r2, [sp, #32]
    float first[2] = { position[X_AXIS] + offset1[X_AXIS], position[Y_AXIS] + offset1[Y_AXIS] };
 8009042:	9302      	str	r3, [sp, #8]
    float second[2] = { target[X_AXIS] + offset2[X_AXIS], target[Y_AXIS] + offset2[Y_AXIS] };
 8009044:	f7f7 fa9e 	bl	8000584 <__addsf3>
 8009048:	4603      	mov	r3, r0
 800904a:	6872      	ldr	r2, [r6, #4]
 800904c:	6861      	ldr	r1, [r4, #4]
 800904e:	4610      	mov	r0, r2
 8009050:	920a      	str	r2, [sp, #40]	; 0x28
 8009052:	9306      	str	r3, [sp, #24]
 8009054:	f7f7 fa96 	bl	8000584 <__addsf3>
    float bez_target[N_AXIS];

    memcpy(bez_target, position, sizeof(float) * N_AXIS);

    float t = 0.0f, step = BEZIER_MAX_STEP;
 8009058:	f04f 0900 	mov.w	r9, #0
        while(new_t - t >= (BEZIER_MIN_STEP)) {

//            if (new_t - t < (BEZIER_MIN_STEP))
//                break;

            const float candidate_t = 0.5f * (t + new_t),
 800905c:	f04f 5b7c 	mov.w	fp, #1056964608	; 0x3f000000
    float t = 0.0f, step = BEZIER_MAX_STEP;
 8009060:	4a60      	ldr	r2, [pc, #384]	; (80091e4 <mc_cubic_b_spline+0x1e0>)
    float second[2] = { target[X_AXIS] + offset2[X_AXIS], target[Y_AXIS] + offset2[Y_AXIS] };
 8009062:	4682      	mov	sl, r0
    memcpy(bez_target, position, sizeof(float) * N_AXIS);
 8009064:	6869      	ldr	r1, [r5, #4]
 8009066:	6828      	ldr	r0, [r5, #0]
    float t = 0.0f, step = BEZIER_MAX_STEP;
 8009068:	920b      	str	r2, [sp, #44]	; 0x2c
    memcpy(bez_target, position, sizeof(float) * N_AXIS);
 800906a:	68aa      	ldr	r2, [r5, #8]
 800906c:	ab13      	add	r3, sp, #76	; 0x4c
 800906e:	c307      	stmia	r3!, {r0, r1, r2}
        float new_t = t + step;
 8009070:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8009072:	4648      	mov	r0, r9
 8009074:	f7f7 fa86 	bl	8000584 <__addsf3>
 8009078:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800907c:	4606      	mov	r6, r0
        if(new_t > 1.0f)
 800907e:	f7f7 fd31 	bl	8000ae4 <__aeabi_fcmple>
 8009082:	b908      	cbnz	r0, 8009088 <mc_cubic_b_spline+0x84>
 8009084:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
    return (1.0f - t) * a + t * b;
 8009088:	4631      	mov	r1, r6
 800908a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800908e:	f7f7 fa77 	bl	8000580 <__aeabi_fsub>
 8009092:	4604      	mov	r4, r0
 8009094:	9803      	ldr	r0, [sp, #12]
 8009096:	4621      	mov	r1, r4
 8009098:	f7f7 fb7c 	bl	8000794 <__aeabi_fmul>
 800909c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80090a0:	4605      	mov	r5, r0
 80090a2:	4631      	mov	r1, r6
 80090a4:	4640      	mov	r0, r8
 80090a6:	f7f7 fb75 	bl	8000794 <__aeabi_fmul>
 80090aa:	4601      	mov	r1, r0
 80090ac:	4628      	mov	r0, r5
 80090ae:	f7f7 fa69 	bl	8000584 <__addsf3>
 80090b2:	9907      	ldr	r1, [sp, #28]
 80090b4:	4605      	mov	r5, r0
 80090b6:	4620      	mov	r0, r4
 80090b8:	f7f7 fb6c 	bl	8000794 <__aeabi_fmul>
 80090bc:	4631      	mov	r1, r6
 80090be:	4607      	mov	r7, r0
 80090c0:	9803      	ldr	r0, [sp, #12]
 80090c2:	f7f7 fb67 	bl	8000794 <__aeabi_fmul>
 80090c6:	4601      	mov	r1, r0
 80090c8:	4638      	mov	r0, r7
 80090ca:	f7f7 fa5b 	bl	8000584 <__addsf3>
 80090ce:	4621      	mov	r1, r4
 80090d0:	f7f7 fb60 	bl	8000794 <__aeabi_fmul>
 80090d4:	4629      	mov	r1, r5
 80090d6:	4607      	mov	r7, r0
 80090d8:	4630      	mov	r0, r6
 80090da:	f7f7 fb5b 	bl	8000794 <__aeabi_fmul>
 80090de:	4601      	mov	r1, r0
 80090e0:	4638      	mov	r0, r7
 80090e2:	f7f7 fa4f 	bl	8000584 <__addsf3>
 80090e6:	4621      	mov	r1, r4
 80090e8:	f7f7 fb54 	bl	8000794 <__aeabi_fmul>
 80090ec:	4621      	mov	r1, r4
 80090ee:	4607      	mov	r7, r0
 80090f0:	4640      	mov	r0, r8
 80090f2:	f7f7 fb4f 	bl	8000794 <__aeabi_fmul>
 80090f6:	9908      	ldr	r1, [sp, #32]
 80090f8:	4680      	mov	r8, r0
 80090fa:	4630      	mov	r0, r6
 80090fc:	f7f7 fb4a 	bl	8000794 <__aeabi_fmul>
 8009100:	4601      	mov	r1, r0
 8009102:	4640      	mov	r0, r8
 8009104:	f7f7 fa3e 	bl	8000584 <__addsf3>
 8009108:	4631      	mov	r1, r6
 800910a:	f7f7 fb43 	bl	8000794 <__aeabi_fmul>
 800910e:	4629      	mov	r1, r5
 8009110:	4605      	mov	r5, r0
 8009112:	4620      	mov	r0, r4
 8009114:	f7f7 fb3e 	bl	8000794 <__aeabi_fmul>
 8009118:	4601      	mov	r1, r0
 800911a:	4628      	mov	r0, r5
 800911c:	f7f7 fa32 	bl	8000584 <__addsf3>
 8009120:	4631      	mov	r1, r6
 8009122:	f7f7 fb37 	bl	8000794 <__aeabi_fmul>
 8009126:	4601      	mov	r1, r0
 8009128:	4638      	mov	r0, r7
 800912a:	f7f7 fa2b 	bl	8000584 <__addsf3>
 800912e:	4603      	mov	r3, r0
 8009130:	4631      	mov	r1, r6
 8009132:	4650      	mov	r0, sl
 8009134:	9300      	str	r3, [sp, #0]
 8009136:	f7f7 fb2d 	bl	8000794 <__aeabi_fmul>
 800913a:	9f02      	ldr	r7, [sp, #8]
 800913c:	4621      	mov	r1, r4
 800913e:	4605      	mov	r5, r0
 8009140:	4638      	mov	r0, r7
 8009142:	f7f7 fb27 	bl	8000794 <__aeabi_fmul>
 8009146:	4601      	mov	r1, r0
 8009148:	4628      	mov	r0, r5
 800914a:	f7f7 fa1b 	bl	8000584 <__addsf3>
 800914e:	4631      	mov	r1, r6
 8009150:	4605      	mov	r5, r0
 8009152:	4638      	mov	r0, r7
 8009154:	f7f7 fb1e 	bl	8000794 <__aeabi_fmul>
 8009158:	9909      	ldr	r1, [sp, #36]	; 0x24
 800915a:	4607      	mov	r7, r0
 800915c:	4620      	mov	r0, r4
 800915e:	f7f7 fb19 	bl	8000794 <__aeabi_fmul>
 8009162:	4601      	mov	r1, r0
 8009164:	4638      	mov	r0, r7
 8009166:	f7f7 fa0d 	bl	8000584 <__addsf3>
 800916a:	4621      	mov	r1, r4
 800916c:	f7f7 fb12 	bl	8000794 <__aeabi_fmul>
 8009170:	4629      	mov	r1, r5
 8009172:	4607      	mov	r7, r0
 8009174:	4630      	mov	r0, r6
 8009176:	f7f7 fb0d 	bl	8000794 <__aeabi_fmul>
 800917a:	4601      	mov	r1, r0
 800917c:	4638      	mov	r0, r7
 800917e:	f7f7 fa01 	bl	8000584 <__addsf3>
 8009182:	4621      	mov	r1, r4
 8009184:	f7f7 fb06 	bl	8000794 <__aeabi_fmul>
 8009188:	4621      	mov	r1, r4
 800918a:	4607      	mov	r7, r0
 800918c:	4650      	mov	r0, sl
 800918e:	f7f7 fb01 	bl	8000794 <__aeabi_fmul>
 8009192:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009194:	4680      	mov	r8, r0
 8009196:	4630      	mov	r0, r6
 8009198:	f7f7 fafc 	bl	8000794 <__aeabi_fmul>
 800919c:	4601      	mov	r1, r0
 800919e:	4640      	mov	r0, r8
 80091a0:	f7f7 f9f0 	bl	8000584 <__addsf3>
 80091a4:	4631      	mov	r1, r6
 80091a6:	f7f7 faf5 	bl	8000794 <__aeabi_fmul>
 80091aa:	4603      	mov	r3, r0
 80091ac:	4621      	mov	r1, r4
 80091ae:	4628      	mov	r0, r5
 80091b0:	461c      	mov	r4, r3
 80091b2:	f7f7 faef 	bl	8000794 <__aeabi_fmul>
 80091b6:	4601      	mov	r1, r0
 80091b8:	4620      	mov	r0, r4
 80091ba:	f7f7 f9e3 	bl	8000584 <__addsf3>
 80091be:	4631      	mov	r1, r6
 80091c0:	f7f7 fae8 	bl	8000794 <__aeabi_fmul>
 80091c4:	4601      	mov	r1, r0
 80091c6:	4638      	mov	r0, r7
 80091c8:	f7f7 f9dc 	bl	8000584 <__addsf3>
                      candidate_pos0 = eval_bezier(position[X_AXIS], first[X_AXIS], second[X_AXIS], target[X_AXIS], candidate_t),
                      candidate_pos1 = eval_bezier(position[Y_AXIS], first[Y_AXIS], second[Y_AXIS], target[Y_AXIS], candidate_t),
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
 80091cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80091ce:	f8cd a010 	str.w	sl, [sp, #16]
 80091d2:	930c      	str	r3, [sp, #48]	; 0x30
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
 80091d4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80091d6:	46b2      	mov	sl, r6
 80091d8:	930d      	str	r3, [sp, #52]	; 0x34
        bool did_reduce = false;
 80091da:	2300      	movs	r3, #0
    return (1.0f - t) * a + t * b;
 80091dc:	9001      	str	r0, [sp, #4]
        bool did_reduce = false;
 80091de:	930e      	str	r3, [sp, #56]	; 0x38
        while(new_t - t >= (BEZIER_MIN_STEP)) {
 80091e0:	e0d4      	b.n	800938c <mc_cubic_b_spline+0x388>
 80091e2:	bf00      	nop
 80091e4:	3dcccccd 	.word	0x3dcccccd
            const float candidate_t = 0.5f * (t + new_t),
 80091e8:	4649      	mov	r1, r9
 80091ea:	4650      	mov	r0, sl
 80091ec:	f7f7 f9ca 	bl	8000584 <__addsf3>
 80091f0:	4659      	mov	r1, fp
 80091f2:	f7f7 facf 	bl	8000794 <__aeabi_fmul>
 80091f6:	4604      	mov	r4, r0
    return (1.0f - t) * a + t * b;
 80091f8:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80091fc:	4621      	mov	r1, r4
 80091fe:	f7f7 f9bf 	bl	8000580 <__aeabi_fsub>
 8009202:	4605      	mov	r5, r0
 8009204:	9803      	ldr	r0, [sp, #12]
 8009206:	4629      	mov	r1, r5
 8009208:	f7f7 fac4 	bl	8000794 <__aeabi_fmul>
 800920c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8009210:	4606      	mov	r6, r0
 8009212:	4621      	mov	r1, r4
 8009214:	4640      	mov	r0, r8
 8009216:	f7f7 fabd 	bl	8000794 <__aeabi_fmul>
 800921a:	4601      	mov	r1, r0
 800921c:	4630      	mov	r0, r6
 800921e:	f7f7 f9b1 	bl	8000584 <__addsf3>
 8009222:	9907      	ldr	r1, [sp, #28]
 8009224:	4606      	mov	r6, r0
 8009226:	4628      	mov	r0, r5
 8009228:	f7f7 fab4 	bl	8000794 <__aeabi_fmul>
 800922c:	4621      	mov	r1, r4
 800922e:	4607      	mov	r7, r0
 8009230:	9803      	ldr	r0, [sp, #12]
 8009232:	f7f7 faaf 	bl	8000794 <__aeabi_fmul>
 8009236:	4601      	mov	r1, r0
 8009238:	4638      	mov	r0, r7
 800923a:	f7f7 f9a3 	bl	8000584 <__addsf3>
 800923e:	4629      	mov	r1, r5
 8009240:	f7f7 faa8 	bl	8000794 <__aeabi_fmul>
 8009244:	4631      	mov	r1, r6
 8009246:	4607      	mov	r7, r0
 8009248:	4620      	mov	r0, r4
 800924a:	f7f7 faa3 	bl	8000794 <__aeabi_fmul>
 800924e:	4601      	mov	r1, r0
 8009250:	4638      	mov	r0, r7
 8009252:	f7f7 f997 	bl	8000584 <__addsf3>
 8009256:	4629      	mov	r1, r5
 8009258:	f7f7 fa9c 	bl	8000794 <__aeabi_fmul>
 800925c:	4629      	mov	r1, r5
 800925e:	4607      	mov	r7, r0
 8009260:	4640      	mov	r0, r8
 8009262:	f7f7 fa97 	bl	8000794 <__aeabi_fmul>
 8009266:	9908      	ldr	r1, [sp, #32]
 8009268:	4680      	mov	r8, r0
 800926a:	4620      	mov	r0, r4
 800926c:	f7f7 fa92 	bl	8000794 <__aeabi_fmul>
 8009270:	4601      	mov	r1, r0
 8009272:	4640      	mov	r0, r8
 8009274:	f7f7 f986 	bl	8000584 <__addsf3>
 8009278:	4621      	mov	r1, r4
 800927a:	f7f7 fa8b 	bl	8000794 <__aeabi_fmul>
 800927e:	4631      	mov	r1, r6
 8009280:	4606      	mov	r6, r0
 8009282:	4628      	mov	r0, r5
 8009284:	f7f7 fa86 	bl	8000794 <__aeabi_fmul>
 8009288:	4601      	mov	r1, r0
 800928a:	4630      	mov	r0, r6
 800928c:	f7f7 f97a 	bl	8000584 <__addsf3>
 8009290:	4621      	mov	r1, r4
 8009292:	f7f7 fa7f 	bl	8000794 <__aeabi_fmul>
 8009296:	4601      	mov	r1, r0
 8009298:	4638      	mov	r0, r7
 800929a:	f7f7 f973 	bl	8000584 <__addsf3>
 800929e:	4629      	mov	r1, r5
 80092a0:	4680      	mov	r8, r0
 80092a2:	9802      	ldr	r0, [sp, #8]
 80092a4:	f7f7 fa76 	bl	8000794 <__aeabi_fmul>
 80092a8:	4621      	mov	r1, r4
 80092aa:	4606      	mov	r6, r0
 80092ac:	9804      	ldr	r0, [sp, #16]
 80092ae:	f7f7 fa71 	bl	8000794 <__aeabi_fmul>
 80092b2:	4601      	mov	r1, r0
 80092b4:	4630      	mov	r0, r6
 80092b6:	f7f7 f965 	bl	8000584 <__addsf3>
 80092ba:	9909      	ldr	r1, [sp, #36]	; 0x24
 80092bc:	4607      	mov	r7, r0
 80092be:	4628      	mov	r0, r5
 80092c0:	f7f7 fa68 	bl	8000794 <__aeabi_fmul>
 80092c4:	4621      	mov	r1, r4
 80092c6:	4606      	mov	r6, r0
 80092c8:	9802      	ldr	r0, [sp, #8]
 80092ca:	f7f7 fa63 	bl	8000794 <__aeabi_fmul>
 80092ce:	4601      	mov	r1, r0
 80092d0:	4630      	mov	r0, r6
 80092d2:	f7f7 f957 	bl	8000584 <__addsf3>
 80092d6:	4629      	mov	r1, r5
 80092d8:	f7f7 fa5c 	bl	8000794 <__aeabi_fmul>
 80092dc:	4639      	mov	r1, r7
 80092de:	4606      	mov	r6, r0
 80092e0:	4620      	mov	r0, r4
 80092e2:	f7f7 fa57 	bl	8000794 <__aeabi_fmul>
 80092e6:	4601      	mov	r1, r0
 80092e8:	4630      	mov	r0, r6
 80092ea:	f7f7 f94b 	bl	8000584 <__addsf3>
 80092ee:	4629      	mov	r1, r5
 80092f0:	f7f7 fa50 	bl	8000794 <__aeabi_fmul>
 80092f4:	4629      	mov	r1, r5
 80092f6:	4606      	mov	r6, r0
 80092f8:	9804      	ldr	r0, [sp, #16]
 80092fa:	f7f7 fa4b 	bl	8000794 <__aeabi_fmul>
 80092fe:	990a      	ldr	r1, [sp, #40]	; 0x28
 8009300:	9005      	str	r0, [sp, #20]
 8009302:	4620      	mov	r0, r4
 8009304:	f7f7 fa46 	bl	8000794 <__aeabi_fmul>
 8009308:	9b05      	ldr	r3, [sp, #20]
 800930a:	4601      	mov	r1, r0
 800930c:	4618      	mov	r0, r3
 800930e:	f7f7 f939 	bl	8000584 <__addsf3>
 8009312:	4621      	mov	r1, r4
 8009314:	f7f7 fa3e 	bl	8000794 <__aeabi_fmul>
 8009318:	4603      	mov	r3, r0
 800931a:	4629      	mov	r1, r5
 800931c:	4638      	mov	r0, r7
 800931e:	461d      	mov	r5, r3
 8009320:	f7f7 fa38 	bl	8000794 <__aeabi_fmul>
 8009324:	4601      	mov	r1, r0
 8009326:	4628      	mov	r0, r5
 8009328:	f7f7 f92c 	bl	8000584 <__addsf3>
 800932c:	4621      	mov	r1, r4
 800932e:	f7f7 fa31 	bl	8000794 <__aeabi_fmul>
 8009332:	4601      	mov	r1, r0
 8009334:	4630      	mov	r0, r6
 8009336:	f7f7 f925 	bl	8000584 <__addsf3>
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
 800933a:	9900      	ldr	r1, [sp, #0]
    return (1.0f - t) * a + t * b;
 800933c:	4605      	mov	r5, r0
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + new_pos0),
 800933e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8009340:	f7f7 f920 	bl	8000584 <__addsf3>
 8009344:	4659      	mov	r1, fp
 8009346:	f7f7 fa25 	bl	8000794 <__aeabi_fmul>
 800934a:	4601      	mov	r1, r0
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 800934c:	4640      	mov	r0, r8
 800934e:	f7f7 f917 	bl	8000580 <__aeabi_fsub>
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
 8009352:	9901      	ldr	r1, [sp, #4]
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8009354:	4606      	mov	r6, r0
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + new_pos1);
 8009356:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009358:	f7f7 f914 	bl	8000584 <__addsf3>
 800935c:	4659      	mov	r1, fp
 800935e:	f7f7 fa19 	bl	8000794 <__aeabi_fmul>
 8009362:	4601      	mov	r1, r0
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8009364:	4628      	mov	r0, r5
 8009366:	f7f7 f90b 	bl	8000580 <__aeabi_fsub>
 800936a:	f026 4600 	bic.w	r6, r6, #2147483648	; 0x80000000
 800936e:	f020 4100 	bic.w	r1, r0, #2147483648	; 0x80000000
 8009372:	4630      	mov	r0, r6
 8009374:	f7f7 f906 	bl	8000584 <__addsf3>

            if (dist1(candidate_pos0, candidate_pos1, interp_pos0, interp_pos1) <= (BEZIER_SIGMA))
 8009378:	4993      	ldr	r1, [pc, #588]	; (80095c8 <mc_cubic_b_spline+0x5c4>)
 800937a:	f7f7 fbb3 	bl	8000ae4 <__aeabi_fcmple>
 800937e:	b980      	cbnz	r0, 80093a2 <mc_cubic_b_spline+0x39e>
                break;

            new_t = candidate_t;
            new_pos0 = candidate_pos0;
            new_pos1 = candidate_pos1;
            did_reduce = true;
 8009380:	2301      	movs	r3, #1
            new_t = candidate_t;
 8009382:	46a2      	mov	sl, r4
            new_pos1 = candidate_pos1;
 8009384:	9501      	str	r5, [sp, #4]
            new_pos0 = candidate_pos0;
 8009386:	f8cd 8000 	str.w	r8, [sp]
            did_reduce = true;
 800938a:	930e      	str	r3, [sp, #56]	; 0x38
        while(new_t - t >= (BEZIER_MIN_STEP)) {
 800938c:	4649      	mov	r1, r9
 800938e:	4650      	mov	r0, sl
 8009390:	f7f7 f8f6 	bl	8000580 <__aeabi_fsub>
 8009394:	498d      	ldr	r1, [pc, #564]	; (80095cc <mc_cubic_b_spline+0x5c8>)
 8009396:	900b      	str	r0, [sp, #44]	; 0x2c
 8009398:	f7f7 fbae 	bl	8000af8 <__aeabi_fcmpge>
 800939c:	2800      	cmp	r0, #0
 800939e:	f47f af23 	bne.w	80091e8 <mc_cubic_b_spline+0x1e4>
        }

        // If we did not reduce the step, maybe we should enlarge it.
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 80093a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80093a4:	4656      	mov	r6, sl
 80093a6:	f8dd a010 	ldr.w	sl, [sp, #16]
 80093aa:	b1f3      	cbz	r3, 80093ea <mc_cubic_b_spline+0x3e6>
        */

        step = new_t - t;
        t = new_t;

        bez_target[X_AXIS] = new_pos0;
 80093ac:	9b00      	ldr	r3, [sp, #0]
        bez_target[Y_AXIS] = new_pos1;

        // Bail mid-spline on system abort. Runtime command check already performed by mc_line.
        if(!mc_line(bez_target, pl_data))
 80093ae:	990f      	ldr	r1, [sp, #60]	; 0x3c
        bez_target[X_AXIS] = new_pos0;
 80093b0:	9313      	str	r3, [sp, #76]	; 0x4c
        bez_target[Y_AXIS] = new_pos1;
 80093b2:	9b01      	ldr	r3, [sp, #4]
        if(!mc_line(bez_target, pl_data))
 80093b4:	a813      	add	r0, sp, #76	; 0x4c
        bez_target[Y_AXIS] = new_pos1;
 80093b6:	9314      	str	r3, [sp, #80]	; 0x50
        if(!mc_line(bez_target, pl_data))
 80093b8:	f7ff fc46 	bl	8008c48 <mc_line>
 80093bc:	2800      	cmp	r0, #0
 80093be:	f000 8100 	beq.w	80095c2 <mc_cubic_b_spline+0x5be>
    while (t < 1.0f) {
 80093c2:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80093c6:	4630      	mov	r0, r6
 80093c8:	f7f7 fb82 	bl	8000ad0 <__aeabi_fcmplt>
 80093cc:	2800      	cmp	r0, #0
 80093ce:	f000 80f8 	beq.w	80095c2 <mc_cubic_b_spline+0x5be>
 80093d2:	9b11      	ldr	r3, [sp, #68]	; 0x44
        t = new_t;
 80093d4:	46b1      	mov	r9, r6
 80093d6:	681a      	ldr	r2, [r3, #0]
 80093d8:	685b      	ldr	r3, [r3, #4]
 80093da:	9207      	str	r2, [sp, #28]
 80093dc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80093de:	9309      	str	r3, [sp, #36]	; 0x24
 80093e0:	6811      	ldr	r1, [r2, #0]
 80093e2:	6853      	ldr	r3, [r2, #4]
 80093e4:	9108      	str	r1, [sp, #32]
 80093e6:	930a      	str	r3, [sp, #40]	; 0x28
 80093e8:	e642      	b.n	8009070 <mc_cubic_b_spline+0x6c>
 80093ea:	9604      	str	r6, [sp, #16]
 80093ec:	9804      	ldr	r0, [sp, #16]
 80093ee:	9e03      	ldr	r6, [sp, #12]
 80093f0:	e0da      	b.n	80095a8 <mc_cubic_b_spline+0x5a4>
            const float candidate_t = t + 2.0f * (new_t - t);
 80093f2:	4621      	mov	r1, r4
 80093f4:	4620      	mov	r0, r4
 80093f6:	f7f7 f8c5 	bl	8000584 <__addsf3>
 80093fa:	4649      	mov	r1, r9
 80093fc:	f7f7 f8c2 	bl	8000584 <__addsf3>
            if (candidate_t >= 1.0f)
 8009400:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
            const float candidate_t = t + 2.0f * (new_t - t);
 8009404:	4604      	mov	r4, r0
            if (candidate_t >= 1.0f)
 8009406:	f7f7 fb77 	bl	8000af8 <__aeabi_fcmpge>
 800940a:	2800      	cmp	r0, #0
 800940c:	f040 80d7 	bne.w	80095be <mc_cubic_b_spline+0x5ba>
    return (1.0f - t) * a + t * b;
 8009410:	4621      	mov	r1, r4
 8009412:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009416:	f7f7 f8b3 	bl	8000580 <__aeabi_fsub>
 800941a:	4605      	mov	r5, r0
 800941c:	4630      	mov	r0, r6
 800941e:	4629      	mov	r1, r5
 8009420:	f7f7 f9b8 	bl	8000794 <__aeabi_fmul>
 8009424:	4621      	mov	r1, r4
 8009426:	4607      	mov	r7, r0
 8009428:	9806      	ldr	r0, [sp, #24]
 800942a:	f7f7 f9b3 	bl	8000794 <__aeabi_fmul>
 800942e:	4601      	mov	r1, r0
 8009430:	4638      	mov	r0, r7
 8009432:	f7f7 f8a7 	bl	8000584 <__addsf3>
 8009436:	9907      	ldr	r1, [sp, #28]
 8009438:	4607      	mov	r7, r0
 800943a:	4628      	mov	r0, r5
 800943c:	f7f7 f9aa 	bl	8000794 <__aeabi_fmul>
 8009440:	4621      	mov	r1, r4
 8009442:	4680      	mov	r8, r0
 8009444:	4630      	mov	r0, r6
 8009446:	f7f7 f9a5 	bl	8000794 <__aeabi_fmul>
 800944a:	4601      	mov	r1, r0
 800944c:	4640      	mov	r0, r8
 800944e:	f7f7 f899 	bl	8000584 <__addsf3>
 8009452:	4629      	mov	r1, r5
 8009454:	f7f7 f99e 	bl	8000794 <__aeabi_fmul>
 8009458:	4639      	mov	r1, r7
 800945a:	4680      	mov	r8, r0
 800945c:	4620      	mov	r0, r4
 800945e:	f7f7 f999 	bl	8000794 <__aeabi_fmul>
 8009462:	4601      	mov	r1, r0
 8009464:	4640      	mov	r0, r8
 8009466:	f7f7 f88d 	bl	8000584 <__addsf3>
 800946a:	4629      	mov	r1, r5
 800946c:	f7f7 f992 	bl	8000794 <__aeabi_fmul>
 8009470:	4629      	mov	r1, r5
 8009472:	4680      	mov	r8, r0
 8009474:	9806      	ldr	r0, [sp, #24]
 8009476:	f7f7 f98d 	bl	8000794 <__aeabi_fmul>
 800947a:	9908      	ldr	r1, [sp, #32]
 800947c:	9005      	str	r0, [sp, #20]
 800947e:	4620      	mov	r0, r4
 8009480:	f7f7 f988 	bl	8000794 <__aeabi_fmul>
 8009484:	9b05      	ldr	r3, [sp, #20]
 8009486:	4601      	mov	r1, r0
 8009488:	4618      	mov	r0, r3
 800948a:	f7f7 f87b 	bl	8000584 <__addsf3>
 800948e:	4621      	mov	r1, r4
 8009490:	f7f7 f980 	bl	8000794 <__aeabi_fmul>
 8009494:	4639      	mov	r1, r7
 8009496:	4607      	mov	r7, r0
 8009498:	4628      	mov	r0, r5
 800949a:	f7f7 f97b 	bl	8000794 <__aeabi_fmul>
 800949e:	4601      	mov	r1, r0
 80094a0:	4638      	mov	r0, r7
 80094a2:	f7f7 f86f 	bl	8000584 <__addsf3>
 80094a6:	4621      	mov	r1, r4
 80094a8:	f7f7 f974 	bl	8000794 <__aeabi_fmul>
 80094ac:	4601      	mov	r1, r0
 80094ae:	4640      	mov	r0, r8
 80094b0:	f7f7 f868 	bl	8000584 <__addsf3>
 80094b4:	4629      	mov	r1, r5
 80094b6:	4680      	mov	r8, r0
 80094b8:	9802      	ldr	r0, [sp, #8]
 80094ba:	f7f7 f96b 	bl	8000794 <__aeabi_fmul>
 80094be:	4621      	mov	r1, r4
 80094c0:	4607      	mov	r7, r0
 80094c2:	4650      	mov	r0, sl
 80094c4:	f7f7 f966 	bl	8000794 <__aeabi_fmul>
 80094c8:	4601      	mov	r1, r0
 80094ca:	4638      	mov	r0, r7
 80094cc:	f7f7 f85a 	bl	8000584 <__addsf3>
 80094d0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80094d2:	4607      	mov	r7, r0
 80094d4:	4628      	mov	r0, r5
 80094d6:	f7f7 f95d 	bl	8000794 <__aeabi_fmul>
 80094da:	4621      	mov	r1, r4
 80094dc:	9005      	str	r0, [sp, #20]
 80094de:	9802      	ldr	r0, [sp, #8]
 80094e0:	f7f7 f958 	bl	8000794 <__aeabi_fmul>
 80094e4:	9b05      	ldr	r3, [sp, #20]
 80094e6:	4601      	mov	r1, r0
 80094e8:	4618      	mov	r0, r3
 80094ea:	f7f7 f84b 	bl	8000584 <__addsf3>
 80094ee:	4629      	mov	r1, r5
 80094f0:	f7f7 f950 	bl	8000794 <__aeabi_fmul>
 80094f4:	4639      	mov	r1, r7
 80094f6:	9005      	str	r0, [sp, #20]
 80094f8:	4620      	mov	r0, r4
 80094fa:	f7f7 f94b 	bl	8000794 <__aeabi_fmul>
 80094fe:	9b05      	ldr	r3, [sp, #20]
 8009500:	4601      	mov	r1, r0
 8009502:	4618      	mov	r0, r3
 8009504:	f7f7 f83e 	bl	8000584 <__addsf3>
 8009508:	4629      	mov	r1, r5
 800950a:	f7f7 f943 	bl	8000794 <__aeabi_fmul>
 800950e:	4603      	mov	r3, r0
 8009510:	4629      	mov	r1, r5
 8009512:	4650      	mov	r0, sl
 8009514:	930e      	str	r3, [sp, #56]	; 0x38
 8009516:	f7f7 f93d 	bl	8000794 <__aeabi_fmul>
 800951a:	990a      	ldr	r1, [sp, #40]	; 0x28
 800951c:	9005      	str	r0, [sp, #20]
 800951e:	4620      	mov	r0, r4
 8009520:	f7f7 f938 	bl	8000794 <__aeabi_fmul>
 8009524:	9a05      	ldr	r2, [sp, #20]
 8009526:	4601      	mov	r1, r0
 8009528:	4610      	mov	r0, r2
 800952a:	f7f7 f82b 	bl	8000584 <__addsf3>
 800952e:	4621      	mov	r1, r4
 8009530:	f7f7 f930 	bl	8000794 <__aeabi_fmul>
 8009534:	4602      	mov	r2, r0
 8009536:	4629      	mov	r1, r5
 8009538:	4638      	mov	r0, r7
 800953a:	4615      	mov	r5, r2
 800953c:	f7f7 f92a 	bl	8000794 <__aeabi_fmul>
 8009540:	4601      	mov	r1, r0
 8009542:	4628      	mov	r0, r5
 8009544:	f7f7 f81e 	bl	8000584 <__addsf3>
 8009548:	4621      	mov	r1, r4
 800954a:	f7f7 f923 	bl	8000794 <__aeabi_fmul>
 800954e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8009550:	4601      	mov	r1, r0
 8009552:	4618      	mov	r0, r3
 8009554:	f7f7 f816 	bl	8000584 <__addsf3>
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
 8009558:	4641      	mov	r1, r8
    return (1.0f - t) * a + t * b;
 800955a:	4605      	mov	r5, r0
                      interp_pos0 = 0.5f * (bez_target[X_AXIS] + candidate_pos0),
 800955c:	980c      	ldr	r0, [sp, #48]	; 0x30
 800955e:	f7f7 f811 	bl	8000584 <__addsf3>
 8009562:	4659      	mov	r1, fp
 8009564:	f7f7 f916 	bl	8000794 <__aeabi_fmul>
 8009568:	4601      	mov	r1, r0
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 800956a:	9800      	ldr	r0, [sp, #0]
 800956c:	f7f7 f808 	bl	8000580 <__aeabi_fsub>
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
 8009570:	4629      	mov	r1, r5
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8009572:	4607      	mov	r7, r0
                      interp_pos1 = 0.5f * (bez_target[Y_AXIS] + candidate_pos1);
 8009574:	980d      	ldr	r0, [sp, #52]	; 0x34
 8009576:	f7f7 f805 	bl	8000584 <__addsf3>
 800957a:	4659      	mov	r1, fp
 800957c:	f7f7 f90a 	bl	8000794 <__aeabi_fmul>
 8009580:	4601      	mov	r1, r0
    return fabsf(x1 - x2) + fabsf(y1 - y2);
 8009582:	9801      	ldr	r0, [sp, #4]
 8009584:	f7f6 fffc 	bl	8000580 <__aeabi_fsub>
 8009588:	f027 4700 	bic.w	r7, r7, #2147483648	; 0x80000000
 800958c:	f020 4100 	bic.w	r1, r0, #2147483648	; 0x80000000
 8009590:	4638      	mov	r0, r7
 8009592:	f7f6 fff7 	bl	8000584 <__addsf3>
            if (dist1(new_pos0, new_pos1, interp_pos0, interp_pos1) > (BEZIER_SIGMA))
 8009596:	490c      	ldr	r1, [pc, #48]	; (80095c8 <mc_cubic_b_spline+0x5c4>)
 8009598:	f7f7 fab8 	bl	8000b0c <__aeabi_fcmpgt>
 800959c:	b978      	cbnz	r0, 80095be <mc_cubic_b_spline+0x5ba>
 800959e:	4620      	mov	r0, r4
            new_pos1 = candidate_pos1;
 80095a0:	9501      	str	r5, [sp, #4]
            new_pos0 = candidate_pos0;
 80095a2:	f8cd 8000 	str.w	r8, [sp]
            new_t = candidate_t;
 80095a6:	9404      	str	r4, [sp, #16]
        if (!did_reduce) while (new_t - t <= BEZIER_MAX_STEP) {
 80095a8:	4649      	mov	r1, r9
 80095aa:	f7f6 ffe9 	bl	8000580 <__aeabi_fsub>
 80095ae:	4906      	ldr	r1, [pc, #24]	; (80095c8 <mc_cubic_b_spline+0x5c4>)
 80095b0:	4604      	mov	r4, r0
 80095b2:	f7f7 fa97 	bl	8000ae4 <__aeabi_fcmple>
 80095b6:	940b      	str	r4, [sp, #44]	; 0x2c
 80095b8:	2800      	cmp	r0, #0
 80095ba:	f47f af1a 	bne.w	80093f2 <mc_cubic_b_spline+0x3ee>
 80095be:	9e04      	ldr	r6, [sp, #16]
 80095c0:	e6f4      	b.n	80093ac <mc_cubic_b_spline+0x3a8>
            return;
    }
}
 80095c2:	b017      	add	sp, #92	; 0x5c
 80095c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80095c8:	3dcccccd 	.word	0x3dcccccd
 80095cc:	3b03126f 	.word	0x3b03126f

080095d0 <mc_canned_drill>:

// end Bezier splines

void mc_canned_drill (motion_mode_t motion, float *target, plan_line_data_t *pl_data, float *position, plane_t plane, uint32_t repeats, gc_canned_t *canned)
{
 80095d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80095d4:	4614      	mov	r4, r2
 80095d6:	461f      	mov	r7, r3
 80095d8:	4606      	mov	r6, r0
 80095da:	460a      	mov	r2, r1
 80095dc:	b08b      	sub	sp, #44	; 0x2c
 80095de:	9d16      	ldr	r5, [sp, #88]	; 0x58
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 80095e0:	f894 3020 	ldrb.w	r3, [r4, #32]
 80095e4:	f89d 1052 	ldrb.w	r1, [sp, #82]	; 0x52

    // if current Z < R, rapid move to R
    if(position[plane.axis_linear] < canned->retract_position) {
 80095e8:	f8d5 8018 	ldr.w	r8, [r5, #24]
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 80095ec:	f043 0301 	orr.w	r3, r3, #1
    if(position[plane.axis_linear] < canned->retract_position) {
 80095f0:	f857 0021 	ldr.w	r0, [r7, r1, lsl #2]
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 80095f4:	f884 3020 	strb.w	r3, [r4, #32]
    if(position[plane.axis_linear] < canned->retract_position) {
 80095f8:	9102      	str	r1, [sp, #8]
 80095fa:	4641      	mov	r1, r8
{
 80095fc:	9601      	str	r6, [sp, #4]
 80095fe:	9204      	str	r2, [sp, #16]
    if(position[plane.axis_linear] < canned->retract_position) {
 8009600:	f7f7 fa66 	bl	8000ad0 <__aeabi_fcmplt>
 8009604:	9b02      	ldr	r3, [sp, #8]
{
 8009606:	9e15      	ldr	r6, [sp, #84]	; 0x54
    if(position[plane.axis_linear] < canned->retract_position) {
 8009608:	eb07 0983 	add.w	r9, r7, r3, lsl #2
 800960c:	009b      	lsls	r3, r3, #2
 800960e:	9303      	str	r3, [sp, #12]
 8009610:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 8009614:	9306      	str	r3, [sp, #24]
 8009616:	f89d 3051 	ldrb.w	r3, [sp, #81]	; 0x51
 800961a:	9305      	str	r3, [sp, #20]
 800961c:	b148      	cbz	r0, 8009632 <mc_canned_drill+0x62>
        position[plane.axis_linear] = canned->retract_position;
 800961e:	9b02      	ldr	r3, [sp, #8]
        if(!mc_line(position, pl_data))
 8009620:	4621      	mov	r1, r4
 8009622:	4638      	mov	r0, r7
        position[plane.axis_linear] = canned->retract_position;
 8009624:	f847 8023 	str.w	r8, [r7, r3, lsl #2]
        if(!mc_line(position, pl_data))
 8009628:	f7ff fb0e 	bl	8008c48 <mc_line>
 800962c:	2800      	cmp	r0, #0
 800962e:	f000 80b0 	beq.w	8009792 <mc_canned_drill+0x1c2>
            return;
    }

    // rapid move to X, Y
    memcpy(position, target, sizeof(float) * N_AXIS);
 8009632:	9b04      	ldr	r3, [sp, #16]
 8009634:	6819      	ldr	r1, [r3, #0]
 8009636:	685a      	ldr	r2, [r3, #4]
 8009638:	689b      	ldr	r3, [r3, #8]
 800963a:	6039      	str	r1, [r7, #0]
 800963c:	607a      	str	r2, [r7, #4]
 800963e:	60bb      	str	r3, [r7, #8]
    position[plane.axis_linear] = canned->prev_position > canned->retract_position ? canned->prev_position : canned->retract_position;
 8009640:	f8d5 a014 	ldr.w	sl, [r5, #20]
 8009644:	f8d5 8018 	ldr.w	r8, [r5, #24]
 8009648:	4651      	mov	r1, sl
 800964a:	4640      	mov	r0, r8
 800964c:	f7f7 fa54 	bl	8000af8 <__aeabi_fcmpge>
 8009650:	2800      	cmp	r0, #0
 8009652:	f000 80a1 	beq.w	8009798 <mc_canned_drill+0x1c8>
 8009656:	9b02      	ldr	r3, [sp, #8]
    if(!mc_line(position, pl_data))
 8009658:	4621      	mov	r1, r4
 800965a:	4638      	mov	r0, r7
    position[plane.axis_linear] = canned->prev_position > canned->retract_position ? canned->prev_position : canned->retract_position;
 800965c:	f847 8023 	str.w	r8, [r7, r3, lsl #2]
    if(!mc_line(position, pl_data))
 8009660:	f7ff faf2 	bl	8008c48 <mc_line>
 8009664:	2800      	cmp	r0, #0
 8009666:	f000 8094 	beq.w	8009792 <mc_canned_drill+0x1c2>
        return;

    // if current Z > R, rapid move to R
    if(position[plane.axis_linear] > canned->retract_position) {
 800966a:	f8d5 8018 	ldr.w	r8, [r5, #24]
 800966e:	9b02      	ldr	r3, [sp, #8]
 8009670:	4641      	mov	r1, r8
 8009672:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 8009676:	f7f7 fa49 	bl	8000b0c <__aeabi_fcmpgt>
 800967a:	2800      	cmp	r0, #0
 800967c:	f040 809a 	bne.w	80097b4 <mc_canned_drill+0x1e4>
        position[plane.axis_linear] = canned->retract_position;
        if(!mc_line(position, pl_data))
            return;
    }

    if(canned->retract_mode == CCRetractMode_RPos)
 8009680:	7fab      	ldrb	r3, [r5, #30]
 8009682:	2b01      	cmp	r3, #1
 8009684:	d101      	bne.n	800968a <mc_canned_drill+0xba>
        canned->prev_position = canned->retract_position;
 8009686:	69ab      	ldr	r3, [r5, #24]
 8009688:	616b      	str	r3, [r5, #20]

    while(repeats--) {
 800968a:	1e73      	subs	r3, r6, #1
 800968c:	9307      	str	r3, [sp, #28]
 800968e:	2e00      	cmp	r6, #0
 8009690:	d073      	beq.n	800977a <mc_canned_drill+0x1aa>

            position[plane.axis_linear] = current_z;
            if(!mc_line(position, pl_data)) // drill
                return;

            if(canned->dwell > 0.0f)
 8009692:	f04f 0a00 	mov.w	sl, #0
                spindle_sync(gc_state.modal.spindle, pl_data->spindle.rpm);
        }

       // rapid move to next position if incremental mode
        if(repeats && gc_state.modal.distance_incremental) {
            position[plane.axis_0] += canned->xyz[plane.axis_0];
 8009696:	9b06      	ldr	r3, [sp, #24]
 8009698:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800969c:	9308      	str	r3, [sp, #32]
            position[plane.axis_1] += canned->xyz[plane.axis_1];
 800969e:	9b05      	ldr	r3, [sp, #20]
 80096a0:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 80096a4:	9309      	str	r3, [sp, #36]	; 0x24
        while(current_z > canned->xyz[plane.axis_linear]) {
 80096a6:	9b03      	ldr	r3, [sp, #12]
        float current_z = canned->retract_position;
 80096a8:	69ae      	ldr	r6, [r5, #24]
        while(current_z > canned->xyz[plane.axis_linear]) {
 80096aa:	f855 8003 	ldr.w	r8, [r5, r3]
 80096ae:	4630      	mov	r0, r6
 80096b0:	4641      	mov	r1, r8
 80096b2:	f7f7 fa2b 	bl	8000b0c <__aeabi_fcmpgt>
 80096b6:	9b03      	ldr	r3, [sp, #12]
 80096b8:	eb05 0b03 	add.w	fp, r5, r3
 80096bc:	b9d8      	cbnz	r0, 80096f6 <mc_canned_drill+0x126>
 80096be:	e05a      	b.n	8009776 <mc_canned_drill+0x1a6>
                    position[plane.axis_linear] = canned->retract_position;
 80096c0:	69ab      	ldr	r3, [r5, #24]
 80096c2:	f8c9 3000 	str.w	r3, [r9]
            pl_data->condition.rapid_motion = canned->rapid_retract;
 80096c6:	f894 3020 	ldrb.w	r3, [r4, #32]
 80096ca:	7f2a      	ldrb	r2, [r5, #28]
            if(!mc_line(position, pl_data))
 80096cc:	4621      	mov	r1, r4
            pl_data->condition.rapid_motion = canned->rapid_retract;
 80096ce:	f362 0300 	bfi	r3, r2, #0, #1
            if(!mc_line(position, pl_data))
 80096d2:	4638      	mov	r0, r7
            pl_data->condition.rapid_motion = canned->rapid_retract;
 80096d4:	f884 3020 	strb.w	r3, [r4, #32]
            if(!mc_line(position, pl_data))
 80096d8:	f7ff fab6 	bl	8008c48 <mc_line>
 80096dc:	2800      	cmp	r0, #0
 80096de:	d058      	beq.n	8009792 <mc_canned_drill+0x1c2>
            if(canned->spindle_off)
 80096e0:	7f6b      	ldrb	r3, [r5, #29]
 80096e2:	2b00      	cmp	r3, #0
 80096e4:	d15a      	bne.n	800979c <mc_canned_drill+0x1cc>
        while(current_z > canned->xyz[plane.axis_linear]) {
 80096e6:	f8db 8000 	ldr.w	r8, [fp]
 80096ea:	4631      	mov	r1, r6
 80096ec:	4640      	mov	r0, r8
 80096ee:	f7f7 f9ef 	bl	8000ad0 <__aeabi_fcmplt>
 80096f2:	2800      	cmp	r0, #0
 80096f4:	d03f      	beq.n	8009776 <mc_canned_drill+0x1a6>
            current_z -= canned->delta;
 80096f6:	4630      	mov	r0, r6
 80096f8:	68e9      	ldr	r1, [r5, #12]
 80096fa:	f7f6 ff41 	bl	8000580 <__aeabi_fsub>
 80096fe:	4641      	mov	r1, r8
 8009700:	4606      	mov	r6, r0
            if(current_z < canned->xyz[plane.axis_linear])
 8009702:	f7f7 f9f9 	bl	8000af8 <__aeabi_fcmpge>
 8009706:	b900      	cbnz	r0, 800970a <mc_canned_drill+0x13a>
 8009708:	4646      	mov	r6, r8
            pl_data->condition.rapid_motion = Off;
 800970a:	f894 3020 	ldrb.w	r3, [r4, #32]
            if(!mc_line(position, pl_data)) // drill
 800970e:	4621      	mov	r1, r4
            pl_data->condition.rapid_motion = Off;
 8009710:	f36f 0300 	bfc	r3, #0, #1
 8009714:	f884 3020 	strb.w	r3, [r4, #32]
            if(!mc_line(position, pl_data)) // drill
 8009718:	4638      	mov	r0, r7
            position[plane.axis_linear] = current_z;
 800971a:	f8c9 6000 	str.w	r6, [r9]
            if(!mc_line(position, pl_data)) // drill
 800971e:	f7ff fa93 	bl	8008c48 <mc_line>
 8009722:	2800      	cmp	r0, #0
 8009724:	d035      	beq.n	8009792 <mc_canned_drill+0x1c2>
            if(canned->dwell > 0.0f)
 8009726:	f8d5 8010 	ldr.w	r8, [r5, #16]
 800972a:	4651      	mov	r1, sl
 800972c:	4640      	mov	r0, r8
 800972e:	f7f7 f9ed 	bl	8000b0c <__aeabi_fcmpgt>
 8009732:	b148      	cbz	r0, 8009748 <mc_canned_drill+0x178>
}

// Execute dwell in seconds.
void mc_dwell (float seconds)
{
    if (sys.state != STATE_CHECK_MODE) {
 8009734:	4b42      	ldr	r3, [pc, #264]	; (8009840 <mc_canned_drill+0x270>)
 8009736:	681b      	ldr	r3, [r3, #0]
 8009738:	2b02      	cmp	r3, #2
 800973a:	d005      	beq.n	8009748 <mc_canned_drill+0x178>
        protocol_buffer_synchronize();
 800973c:	f002 f9ba 	bl	800bab4 <protocol_buffer_synchronize>
        delay_sec(seconds, DelayMode_Dwell);
 8009740:	4640      	mov	r0, r8
 8009742:	2100      	movs	r1, #0
 8009744:	f000 fddc 	bl	800a300 <delay_sec>
            if(canned->spindle_off)
 8009748:	7f6b      	ldrb	r3, [r5, #29]
 800974a:	b12b      	cbz	r3, 8009758 <mc_canned_drill+0x188>
                hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 800974c:	4b3d      	ldr	r3, [pc, #244]	; (8009844 <mc_canned_drill+0x274>)
 800974e:	4651      	mov	r1, sl
 8009750:	f04f 0000 	mov.w	r0, #0
 8009754:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009756:	4798      	blx	r3
            switch(motion) {
 8009758:	9b01      	ldr	r3, [sp, #4]
 800975a:	2b49      	cmp	r3, #73	; 0x49
 800975c:	d1b0      	bne.n	80096c0 <mc_canned_drill+0xf0>
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 800975e:	f8d9 8000 	ldr.w	r8, [r9]
                                                   : position[plane.axis_linear] + settings.g73_retract;
 8009762:	f8db 1000 	ldr.w	r1, [fp]
 8009766:	4640      	mov	r0, r8
 8009768:	f7f7 f9a8 	bl	8000abc <__aeabi_fcmpeq>
 800976c:	b1e0      	cbz	r0, 80097a8 <mc_canned_drill+0x1d8>
 800976e:	69a8      	ldr	r0, [r5, #24]
                    position[plane.axis_linear] = position[plane.axis_linear] == canned->xyz[plane.axis_linear]
 8009770:	f8c9 0000 	str.w	r0, [r9]
                    break;
 8009774:	e7a7      	b.n	80096c6 <mc_canned_drill+0xf6>
        if(repeats && gc_state.modal.distance_incremental) {
 8009776:	9b07      	ldr	r3, [sp, #28]
 8009778:	bb3b      	cbnz	r3, 80097ca <mc_canned_drill+0x1fa>
    memcpy(target, position, sizeof(float) * N_AXIS);
 800977a:	68bb      	ldr	r3, [r7, #8]
 800977c:	6839      	ldr	r1, [r7, #0]
 800977e:	687a      	ldr	r2, [r7, #4]
 8009780:	9804      	ldr	r0, [sp, #16]
 8009782:	6001      	str	r1, [r0, #0]
 8009784:	6042      	str	r2, [r0, #4]
 8009786:	6083      	str	r3, [r0, #8]
    if(canned->retract_mode == CCRetractMode_Previous && motion != MotionMode_DrillChipBreak && target[plane.axis_linear] < canned->prev_position) {
 8009788:	7fab      	ldrb	r3, [r5, #30]
 800978a:	b913      	cbnz	r3, 8009792 <mc_canned_drill+0x1c2>
 800978c:	9b01      	ldr	r3, [sp, #4]
 800978e:	2b49      	cmp	r3, #73	; 0x49
 8009790:	d13c      	bne.n	800980c <mc_canned_drill+0x23c>
}
 8009792:	b00b      	add	sp, #44	; 0x2c
 8009794:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    position[plane.axis_linear] = canned->prev_position > canned->retract_position ? canned->prev_position : canned->retract_position;
 8009798:	46d0      	mov	r8, sl
 800979a:	e75c      	b.n	8009656 <mc_canned_drill+0x86>
                spindle_sync(gc_state.modal.spindle, pl_data->spindle.rpm);
 800979c:	4b2a      	ldr	r3, [pc, #168]	; (8009848 <mc_canned_drill+0x278>)
 800979e:	6861      	ldr	r1, [r4, #4]
 80097a0:	7e98      	ldrb	r0, [r3, #26]
 80097a2:	f005 fa6b 	bl	800ec7c <spindle_sync>
        while(current_z > canned->xyz[plane.axis_linear]) {
 80097a6:	e79e      	b.n	80096e6 <mc_canned_drill+0x116>
                                                   : position[plane.axis_linear] + settings.g73_retract;
 80097a8:	4b28      	ldr	r3, [pc, #160]	; (800984c <mc_canned_drill+0x27c>)
 80097aa:	4640      	mov	r0, r8
 80097ac:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80097ae:	f7f6 fee9 	bl	8000584 <__addsf3>
 80097b2:	e7dd      	b.n	8009770 <mc_canned_drill+0x1a0>
        position[plane.axis_linear] = canned->retract_position;
 80097b4:	9b02      	ldr	r3, [sp, #8]
        if(!mc_line(position, pl_data))
 80097b6:	4621      	mov	r1, r4
 80097b8:	4638      	mov	r0, r7
        position[plane.axis_linear] = canned->retract_position;
 80097ba:	f847 8023 	str.w	r8, [r7, r3, lsl #2]
        if(!mc_line(position, pl_data))
 80097be:	f7ff fa43 	bl	8008c48 <mc_line>
 80097c2:	2800      	cmp	r0, #0
 80097c4:	f47f af5c 	bne.w	8009680 <mc_canned_drill+0xb0>
 80097c8:	e7e3      	b.n	8009792 <mc_canned_drill+0x1c2>
        if(repeats && gc_state.modal.distance_incremental) {
 80097ca:	4b1f      	ldr	r3, [pc, #124]	; (8009848 <mc_canned_drill+0x278>)
 80097cc:	78db      	ldrb	r3, [r3, #3]
 80097ce:	b91b      	cbnz	r3, 80097d8 <mc_canned_drill+0x208>
    while(repeats--) {
 80097d0:	9b07      	ldr	r3, [sp, #28]
 80097d2:	3b01      	subs	r3, #1
 80097d4:	9307      	str	r3, [sp, #28]
 80097d6:	e766      	b.n	80096a6 <mc_canned_drill+0xd6>
            position[plane.axis_0] += canned->xyz[plane.axis_0];
 80097d8:	9b06      	ldr	r3, [sp, #24]
 80097da:	9e08      	ldr	r6, [sp, #32]
 80097dc:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80097e0:	6830      	ldr	r0, [r6, #0]
 80097e2:	f7f6 fecf 	bl	8000584 <__addsf3>
            position[plane.axis_1] += canned->xyz[plane.axis_1];
 80097e6:	9b05      	ldr	r3, [sp, #20]
            position[plane.axis_0] += canned->xyz[plane.axis_0];
 80097e8:	6030      	str	r0, [r6, #0]
            position[plane.axis_1] += canned->xyz[plane.axis_1];
 80097ea:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80097ec:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80097f0:	6830      	ldr	r0, [r6, #0]
 80097f2:	f7f6 fec7 	bl	8000584 <__addsf3>
 80097f6:	6030      	str	r0, [r6, #0]
            position[plane.axis_linear] = canned->prev_position;
 80097f8:	696b      	ldr	r3, [r5, #20]
            if(!mc_line(position, pl_data))
 80097fa:	4621      	mov	r1, r4
 80097fc:	4638      	mov	r0, r7
            position[plane.axis_linear] = canned->prev_position;
 80097fe:	f8c9 3000 	str.w	r3, [r9]
            if(!mc_line(position, pl_data))
 8009802:	f7ff fa21 	bl	8008c48 <mc_line>
 8009806:	2800      	cmp	r0, #0
 8009808:	d1e2      	bne.n	80097d0 <mc_canned_drill+0x200>
 800980a:	e7c2      	b.n	8009792 <mc_canned_drill+0x1c2>
    if(canned->retract_mode == CCRetractMode_Previous && motion != MotionMode_DrillChipBreak && target[plane.axis_linear] < canned->prev_position) {
 800980c:	696d      	ldr	r5, [r5, #20]
 800980e:	9b02      	ldr	r3, [sp, #8]
 8009810:	4629      	mov	r1, r5
 8009812:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8009816:	f7f7 f95b 	bl	8000ad0 <__aeabi_fcmplt>
 800981a:	2800      	cmp	r0, #0
 800981c:	d0b9      	beq.n	8009792 <mc_canned_drill+0x1c2>
        pl_data->condition.rapid_motion = On;
 800981e:	f894 3020 	ldrb.w	r3, [r4, #32]
        if(!mc_line(target, pl_data))
 8009822:	4621      	mov	r1, r4
        pl_data->condition.rapid_motion = On;
 8009824:	f043 0301 	orr.w	r3, r3, #1
 8009828:	f884 3020 	strb.w	r3, [r4, #32]
        if(!mc_line(target, pl_data))
 800982c:	9b04      	ldr	r3, [sp, #16]
        target[plane.axis_linear] = canned->prev_position;
 800982e:	9a02      	ldr	r2, [sp, #8]
        if(!mc_line(target, pl_data))
 8009830:	4618      	mov	r0, r3
        target[plane.axis_linear] = canned->prev_position;
 8009832:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
}
 8009836:	b00b      	add	sp, #44	; 0x2c
 8009838:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if(!mc_line(target, pl_data))
 800983c:	f7ff ba04 	b.w	8008c48 <mc_line>
 8009840:	20002494 	.word	0x20002494
 8009844:	200024bc 	.word	0x200024bc
 8009848:	200023dc 	.word	0x200023dc
 800984c:	20002620 	.word	0x20002620

08009850 <mc_thread>:
{
 8009850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009854:	4615      	mov	r5, r2
 8009856:	b08d      	sub	sp, #52	; 0x34
 8009858:	4604      	mov	r4, r0
 800985a:	460f      	mov	r7, r1
    float doc = thread->initial_depth, inv_degression = 1.0f / thread->depth_degression, thread_length;
 800985c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009860:	6951      	ldr	r1, [r2, #20]
{
 8009862:	9302      	str	r3, [sp, #8]
    float doc = thread->initial_depth, inv_degression = 1.0f / thread->depth_degression, thread_length;
 8009864:	f7f7 f84a 	bl	80008fc <__aeabi_fdiv>
    float end_taper_factor = thread->end_taper_type == Taper_None ? 0.0f : (thread->end_taper_type == Taper_Both ? 2.0f : 1.0f);
 8009868:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
    float doc = thread->initial_depth, inv_degression = 1.0f / thread->depth_degression, thread_length;
 800986c:	4681      	mov	r9, r0
 800986e:	68ee      	ldr	r6, [r5, #12]
    float end_taper_factor = thread->end_taper_type == Taper_None ? 0.0f : (thread->end_taper_type == Taper_Both ? 2.0f : 1.0f);
 8009870:	b133      	cbz	r3, 8009880 <mc_thread+0x30>
 8009872:	2b03      	cmp	r3, #3
 8009874:	f000 81b5 	beq.w	8009be2 <mc_thread+0x392>
 8009878:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 800987c:	9306      	str	r3, [sp, #24]
 800987e:	e001      	b.n	8009884 <mc_thread+0x34>
 8009880:	2300      	movs	r3, #0
 8009882:	9306      	str	r3, [sp, #24]
    float infeed_factor = tanf(thread->infeed_angle * RADDEG), infeed_offset = 0.0f;
 8009884:	49b3      	ldr	r1, [pc, #716]	; (8009b54 <mc_thread+0x304>)
 8009886:	6a28      	ldr	r0, [r5, #32]
 8009888:	f7f6 ff84 	bl	8000794 <__aeabi_fmul>
 800988c:	f009 faf4 	bl	8012e78 <tanf>
    float target[N_AXIS], target_z = thread->z_final + thread->depth * infeed_factor;;
 8009890:	f8d5 a010 	ldr.w	sl, [r5, #16]
 8009894:	f8d5 b004 	ldr.w	fp, [r5, #4]
    float infeed_factor = tanf(thread->infeed_angle * RADDEG), infeed_offset = 0.0f;
 8009898:	4601      	mov	r1, r0
 800989a:	9004      	str	r0, [sp, #16]
    float target[N_AXIS], target_z = thread->z_final + thread->depth * infeed_factor;;
 800989c:	4650      	mov	r0, sl
 800989e:	f7f6 ff79 	bl	8000794 <__aeabi_fmul>
 80098a2:	4659      	mov	r1, fp
 80098a4:	f7f6 fe6e 	bl	8000584 <__addsf3>
    uint_fast16_t pass = 1, passes = 0;
 80098a8:	f04f 0800 	mov.w	r8, #0
    memcpy(target, position, sizeof(float) * N_AXIS);
 80098ac:	6879      	ldr	r1, [r7, #4]
 80098ae:	68ba      	ldr	r2, [r7, #8]
    float target[N_AXIS], target_z = thread->z_final + thread->depth * infeed_factor;;
 80098b0:	9000      	str	r0, [sp, #0]
    memcpy(target, position, sizeof(float) * N_AXIS);
 80098b2:	6838      	ldr	r0, [r7, #0]
 80098b4:	ab09      	add	r3, sp, #36	; 0x24
 80098b6:	c307      	stmia	r3!, {r0, r1, r2}
    while(calc_thread_doc(++passes, doc, inv_degression) < thread->depth);
 80098b8:	f108 0801 	add.w	r8, r8, #1
    return cut_depth * powf((float)pass, inv_degression);
 80098bc:	4640      	mov	r0, r8
 80098be:	f7f6 ff11 	bl	80006e4 <__aeabi_ui2f>
 80098c2:	4649      	mov	r1, r9
 80098c4:	f009 fb0e 	bl	8012ee4 <powf>
 80098c8:	4601      	mov	r1, r0
 80098ca:	4630      	mov	r0, r6
 80098cc:	f7f6 ff62 	bl	8000794 <__aeabi_fmul>
 80098d0:	4601      	mov	r1, r0
    while(calc_thread_doc(++passes, doc, inv_degression) < thread->depth);
 80098d2:	4650      	mov	r0, sl
 80098d4:	f7f7 f91a 	bl	8000b0c <__aeabi_fcmpgt>
 80098d8:	2800      	cmp	r0, #0
 80098da:	d1ed      	bne.n	80098b8 <mc_thread+0x68>
    if((thread_length = thread->z_final - position[Z_AXIS]) > 0.0f)
 80098dc:	68bb      	ldr	r3, [r7, #8]
 80098de:	4658      	mov	r0, fp
 80098e0:	4619      	mov	r1, r3
 80098e2:	9307      	str	r3, [sp, #28]
 80098e4:	f7f6 fe4c 	bl	8000580 <__aeabi_fsub>
 80098e8:	2100      	movs	r1, #0
 80098ea:	4683      	mov	fp, r0
 80098ec:	f7f7 f90e 	bl	8000b0c <__aeabi_fcmpgt>
    passes += thread->spring_passes + 1;
 80098f0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80098f2:	9301      	str	r3, [sp, #4]
    if((thread_length = thread->z_final - position[Z_AXIS]) > 0.0f)
 80098f4:	2800      	cmp	r0, #0
 80098f6:	f000 8151 	beq.w	8009b9c <mc_thread+0x34c>
        thread->end_taper_length = -thread->end_taper_length;
 80098fa:	69eb      	ldr	r3, [r5, #28]
 80098fc:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8009900:	61eb      	str	r3, [r5, #28]
    if(thread->main_taper_height != 0.0f)
 8009902:	69aa      	ldr	r2, [r5, #24]
 8009904:	2100      	movs	r1, #0
 8009906:	4610      	mov	r0, r2
 8009908:	9305      	str	r3, [sp, #20]
 800990a:	9203      	str	r2, [sp, #12]
 800990c:	f7f7 f8d6 	bl	8000abc <__aeabi_fcmpeq>
 8009910:	b978      	cbnz	r0, 8009932 <mc_thread+0xe2>
    thread_length += thread->end_taper_length * end_taper_factor;
 8009912:	9b05      	ldr	r3, [sp, #20]
 8009914:	9806      	ldr	r0, [sp, #24]
 8009916:	4619      	mov	r1, r3
 8009918:	f7f6 ff3c 	bl	8000794 <__aeabi_fmul>
 800991c:	4659      	mov	r1, fp
 800991e:	f7f6 fe31 	bl	8000584 <__addsf3>
        thread->main_taper_height = thread->main_taper_height * thread_length / (thread_length - thread->end_taper_length * end_taper_factor);
 8009922:	9a03      	ldr	r2, [sp, #12]
 8009924:	4611      	mov	r1, r2
 8009926:	f7f6 ff35 	bl	8000794 <__aeabi_fmul>
 800992a:	4659      	mov	r1, fp
 800992c:	f7f6 ffe6 	bl	80008fc <__aeabi_fdiv>
 8009930:	61a8      	str	r0, [r5, #24]
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 8009932:	f894 3020 	ldrb.w	r3, [r4, #32]
    if(infeed_factor != 0.0f) {
 8009936:	2100      	movs	r1, #0
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 8009938:	f043 0301 	orr.w	r3, r3, #1
    if(infeed_factor != 0.0f) {
 800993c:	9804      	ldr	r0, [sp, #16]
    pl_data->condition.rapid_motion = On; // Set rapid motion condition flag.
 800993e:	f884 3020 	strb.w	r3, [r4, #32]
    if(infeed_factor != 0.0f) {
 8009942:	f7f7 f8bb 	bl	8000abc <__aeabi_fcmpeq>
 8009946:	2800      	cmp	r0, #0
 8009948:	f000 812a 	beq.w	8009ba0 <mc_thread+0x350>
    float infeed_factor = tanf(thread->infeed_angle * RADDEG), infeed_offset = 0.0f;
 800994c:	f8dd a010 	ldr.w	sl, [sp, #16]
    while(--passes) {
 8009950:	9b01      	ldr	r3, [sp, #4]
 8009952:	eb13 0308 	adds.w	r3, r3, r8
 8009956:	9301      	str	r3, [sp, #4]
 8009958:	f000 80dc 	beq.w	8009b14 <mc_thread+0x2c4>
 800995c:	f04f 0801 	mov.w	r8, #1
            infeed_offset = infeed_factor != 0.0f ? doc * infeed_factor : 0.0f;
 8009960:	f8dd b010 	ldr.w	fp, [sp, #16]
 8009964:	f8cd 900c 	str.w	r9, [sp, #12]
        if(thread->end_taper_type == Taper_None) {
 8009968:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 800996c:	2b00      	cmp	r3, #0
 800996e:	f000 80f7 	beq.w	8009b60 <mc_thread+0x310>
        pl_data->condition.spindle.synchronized = On;   // enable spindle sync for cut
 8009972:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
        pl_data->condition.rapid_motion = Off;          // Clear rapid motion condition flag,
 8009976:	f894 1020 	ldrb.w	r1, [r4, #32]
        pl_data->condition.spindle.synchronized = On;   // enable spindle sync for cut
 800997a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800997e:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
    if (sys.state != STATE_CHECK_MODE) {
 8009982:	4a75      	ldr	r2, [pc, #468]	; (8009b58 <mc_thread+0x308>)
        pl_data->overrides.feed_hold_disable = On;      // and disable feed hold
 8009984:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    if (sys.state != STATE_CHECK_MODE) {
 8009988:	6812      	ldr	r2, [r2, #0]
        pl_data->condition.rapid_motion = Off;          // Clear rapid motion condition flag,
 800998a:	f36f 0100 	bfc	r1, #0, #1
        pl_data->overrides.feed_hold_disable = On;      // and disable feed hold
 800998e:	f043 0302 	orr.w	r3, r3, #2
    if (sys.state != STATE_CHECK_MODE) {
 8009992:	2a02      	cmp	r2, #2
        pl_data->condition.rapid_motion = Off;          // Clear rapid motion condition flag,
 8009994:	f884 1020 	strb.w	r1, [r4, #32]
        pl_data->overrides.feed_hold_disable = On;      // and disable feed hold
 8009998:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (sys.state != STATE_CHECK_MODE) {
 800999c:	d005      	beq.n	80099aa <mc_thread+0x15a>
        protocol_buffer_synchronize();
 800999e:	f002 f889 	bl	800bab4 <protocol_buffer_synchronize>
        delay_sec(seconds, DelayMode_Dwell);
 80099a2:	2100      	movs	r1, #0
 80099a4:	486d      	ldr	r0, [pc, #436]	; (8009b5c <mc_thread+0x30c>)
 80099a6:	f000 fcab 	bl	800a300 <delay_sec>
        if(thread->end_taper_type & Taper_Entry) {
 80099aa:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 80099ae:	07da      	lsls	r2, r3, #31
 80099b0:	f140 80b3 	bpl.w	8009b1a <mc_thread+0x2ca>
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 80099b4:	6929      	ldr	r1, [r5, #16]
 80099b6:	68a8      	ldr	r0, [r5, #8]
 80099b8:	f7f6 fde2 	bl	8000580 <__aeabi_fsub>
 80099bc:	4631      	mov	r1, r6
 80099be:	f7f6 fde1 	bl	8000584 <__addsf3>
 80099c2:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80099c4:	f7f6 fee6 	bl	8000794 <__aeabi_fmul>
 80099c8:	6839      	ldr	r1, [r7, #0]
 80099ca:	f7f6 fddb 	bl	8000584 <__addsf3>
 80099ce:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 80099d0:	4621      	mov	r1, r4
 80099d2:	a809      	add	r0, sp, #36	; 0x24
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 80099d4:	9309      	str	r3, [sp, #36]	; 0x24
            if(!mc_line(target, pl_data))
 80099d6:	f7ff f937 	bl	8008c48 <mc_line>
 80099da:	2800      	cmp	r0, #0
 80099dc:	f000 809a 	beq.w	8009b14 <mc_thread+0x2c4>
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 80099e0:	68a9      	ldr	r1, [r5, #8]
 80099e2:	4630      	mov	r0, r6
 80099e4:	f7f6 fdce 	bl	8000584 <__addsf3>
 80099e8:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80099ea:	f7f6 fed3 	bl	8000794 <__aeabi_fmul>
 80099ee:	6839      	ldr	r1, [r7, #0]
 80099f0:	f7f6 fdc8 	bl	8000584 <__addsf3>
 80099f4:	4603      	mov	r3, r0
            target[Z_AXIS] -= thread->end_taper_length;
 80099f6:	69e9      	ldr	r1, [r5, #28]
 80099f8:	980b      	ldr	r0, [sp, #44]	; 0x2c
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 80099fa:	9309      	str	r3, [sp, #36]	; 0x24
            target[Z_AXIS] -= thread->end_taper_length;
 80099fc:	f7f6 fdc0 	bl	8000580 <__aeabi_fsub>
 8009a00:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009a02:	4621      	mov	r1, r4
 8009a04:	a809      	add	r0, sp, #36	; 0x24
            target[Z_AXIS] -= thread->end_taper_length;
 8009a06:	930b      	str	r3, [sp, #44]	; 0x2c
            if(!mc_line(target, pl_data))
 8009a08:	f7ff f91e 	bl	8008c48 <mc_line>
 8009a0c:	2800      	cmp	r0, #0
 8009a0e:	f000 8081 	beq.w	8009b14 <mc_thread+0x2c4>
        if(thread->end_taper_type & Taper_Exit) {
 8009a12:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 8009a16:	079b      	lsls	r3, r3, #30
 8009a18:	f140 8096 	bpl.w	8009b48 <mc_thread+0x2f8>
            target[Z_AXIS] = target_z - infeed_offset + thread->end_taper_length;
 8009a1c:	69e9      	ldr	r1, [r5, #28]
 8009a1e:	9800      	ldr	r0, [sp, #0]
 8009a20:	f7f6 fdb0 	bl	8000584 <__addsf3>
 8009a24:	4651      	mov	r1, sl
 8009a26:	f7f6 fdab 	bl	8000580 <__aeabi_fsub>
 8009a2a:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009a2c:	4621      	mov	r1, r4
 8009a2e:	a809      	add	r0, sp, #36	; 0x24
            target[Z_AXIS] = target_z - infeed_offset + thread->end_taper_length;
 8009a30:	930b      	str	r3, [sp, #44]	; 0x2c
            if(!mc_line(target, pl_data))
 8009a32:	f7ff f909 	bl	8008c48 <mc_line>
 8009a36:	2800      	cmp	r0, #0
 8009a38:	d06c      	beq.n	8009b14 <mc_thread+0x2c4>
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 8009a3a:	6929      	ldr	r1, [r5, #16]
 8009a3c:	68a8      	ldr	r0, [r5, #8]
 8009a3e:	f7f6 fd9f 	bl	8000580 <__aeabi_fsub>
 8009a42:	4631      	mov	r1, r6
 8009a44:	f7f6 fd9e 	bl	8000584 <__addsf3>
 8009a48:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009a4a:	f7f6 fea3 	bl	8000794 <__aeabi_fmul>
 8009a4e:	6839      	ldr	r1, [r7, #0]
 8009a50:	f7f6 fd98 	bl	8000584 <__addsf3>
 8009a54:	4603      	mov	r3, r0
            target[Z_AXIS] -= thread->end_taper_length;
 8009a56:	69e9      	ldr	r1, [r5, #28]
 8009a58:	980b      	ldr	r0, [sp, #44]	; 0x2c
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc - thread->depth) * thread->cut_direction;
 8009a5a:	9309      	str	r3, [sp, #36]	; 0x24
            target[Z_AXIS] -= thread->end_taper_length;
 8009a5c:	f7f6 fd90 	bl	8000580 <__aeabi_fsub>
 8009a60:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009a62:	4621      	mov	r1, r4
 8009a64:	a809      	add	r0, sp, #36	; 0x24
            target[Z_AXIS] -= thread->end_taper_length;
 8009a66:	930b      	str	r3, [sp, #44]	; 0x2c
            if(!mc_line(target, pl_data))
 8009a68:	f7ff f8ee 	bl	8008c48 <mc_line>
 8009a6c:	2800      	cmp	r0, #0
 8009a6e:	d051      	beq.n	8009b14 <mc_thread+0x2c4>
        pl_data->condition.rapid_motion = On;           // Set rapid motion condition flag and
 8009a70:	f894 3020 	ldrb.w	r3, [r4, #32]
        pl_data->condition.spindle.synchronized = Off;  // disable spindle sync for retract & reposition
 8009a74:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
        pl_data->condition.rapid_motion = On;           // Set rapid motion condition flag and
 8009a78:	f043 0301 	orr.w	r3, r3, #1
 8009a7c:	f884 3020 	strb.w	r3, [r4, #32]
        if(passes > 1) {
 8009a80:	9b01      	ldr	r3, [sp, #4]
        pl_data->condition.spindle.synchronized = Off;  // disable spindle sync for retract & reposition
 8009a82:	f36f 12c7 	bfc	r2, #7, #1
        if(passes > 1) {
 8009a86:	4598      	cmp	r8, r3
        pl_data->condition.spindle.synchronized = Off;  // disable spindle sync for retract & reposition
 8009a88:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
        if(passes > 1) {
 8009a8c:	d07d      	beq.n	8009b8a <mc_thread+0x33a>
            doc = calc_thread_doc(++pass, thread->initial_depth, inv_degression);
 8009a8e:	f108 0801 	add.w	r8, r8, #1
    return cut_depth * powf((float)pass, inv_degression);
 8009a92:	4640      	mov	r0, r8
 8009a94:	f7f6 fe26 	bl	80006e4 <__aeabi_ui2f>
 8009a98:	9903      	ldr	r1, [sp, #12]
 8009a9a:	f009 fa23 	bl	8012ee4 <powf>
 8009a9e:	68e9      	ldr	r1, [r5, #12]
 8009aa0:	f7f6 fe78 	bl	8000794 <__aeabi_fmul>
            doc = min(doc, thread->depth);
 8009aa4:	f8d5 9010 	ldr.w	r9, [r5, #16]
    return cut_depth * powf((float)pass, inv_degression);
 8009aa8:	4606      	mov	r6, r0
            doc = min(doc, thread->depth);
 8009aaa:	4649      	mov	r1, r9
 8009aac:	f7f7 f81a 	bl	8000ae4 <__aeabi_fcmple>
 8009ab0:	b900      	cbnz	r0, 8009ab4 <mc_thread+0x264>
 8009ab2:	464e      	mov	r6, r9
            infeed_offset = infeed_factor != 0.0f ? doc * infeed_factor : 0.0f;
 8009ab4:	2100      	movs	r1, #0
 8009ab6:	4658      	mov	r0, fp
 8009ab8:	f7f7 f800 	bl	8000abc <__aeabi_fcmpeq>
 8009abc:	2800      	cmp	r0, #0
 8009abe:	d146      	bne.n	8009b4e <mc_thread+0x2fe>
 8009ac0:	4631      	mov	r1, r6
 8009ac2:	4658      	mov	r0, fp
 8009ac4:	f7f6 fe66 	bl	8000794 <__aeabi_fmul>
 8009ac8:	4682      	mov	sl, r0
            target[X_AXIS] = position[X_AXIS] + (doc - thread->depth) * thread->cut_direction;
 8009aca:	4649      	mov	r1, r9
 8009acc:	4630      	mov	r0, r6
 8009ace:	f7f6 fd57 	bl	8000580 <__aeabi_fsub>
 8009ad2:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009ad4:	f7f6 fe5e 	bl	8000794 <__aeabi_fmul>
 8009ad8:	6839      	ldr	r1, [r7, #0]
 8009ada:	f7f6 fd53 	bl	8000584 <__addsf3>
 8009ade:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009ae0:	4621      	mov	r1, r4
 8009ae2:	a809      	add	r0, sp, #36	; 0x24
            target[X_AXIS] = position[X_AXIS] + (doc - thread->depth) * thread->cut_direction;
 8009ae4:	9309      	str	r3, [sp, #36]	; 0x24
            if(!mc_line(target, pl_data))
 8009ae6:	f7ff f8af 	bl	8008c48 <mc_line>
 8009aea:	b198      	cbz	r0, 8009b14 <mc_thread+0x2c4>
            pl_data->overrides.feed_hold_disable = feed_hold_disabled;
 8009aec:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8009af0:	9a02      	ldr	r2, [sp, #8]
            target[Z_AXIS] = position[Z_AXIS] - infeed_offset;
 8009af2:	4651      	mov	r1, sl
            pl_data->overrides.feed_hold_disable = feed_hold_disabled;
 8009af4:	f362 0341 	bfi	r3, r2, #1, #1
 8009af8:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
            target[Z_AXIS] = position[Z_AXIS] - infeed_offset;
 8009afc:	68b8      	ldr	r0, [r7, #8]
 8009afe:	f7f6 fd3f 	bl	8000580 <__aeabi_fsub>
 8009b02:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009b04:	4621      	mov	r1, r4
 8009b06:	a809      	add	r0, sp, #36	; 0x24
            target[Z_AXIS] = position[Z_AXIS] - infeed_offset;
 8009b08:	930b      	str	r3, [sp, #44]	; 0x2c
            if(!mc_line(target, pl_data))
 8009b0a:	f7ff f89d 	bl	8008c48 <mc_line>
 8009b0e:	2800      	cmp	r0, #0
 8009b10:	f47f af2a 	bne.w	8009968 <mc_thread+0x118>
}
 8009b14:	b00d      	add	sp, #52	; 0x34
 8009b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 8009b1a:	68a9      	ldr	r1, [r5, #8]
 8009b1c:	4630      	mov	r0, r6
 8009b1e:	f7f6 fd31 	bl	8000584 <__addsf3>
 8009b22:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009b24:	f7f6 fe36 	bl	8000794 <__aeabi_fmul>
 8009b28:	6839      	ldr	r1, [r7, #0]
 8009b2a:	f7f6 fd2b 	bl	8000584 <__addsf3>
 8009b2e:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009b30:	4621      	mov	r1, r4
 8009b32:	a809      	add	r0, sp, #36	; 0x24
            target[X_AXIS] = position[X_AXIS] + (thread->peak + doc) * thread->cut_direction;
 8009b34:	9309      	str	r3, [sp, #36]	; 0x24
            if(!mc_line(target, pl_data))
 8009b36:	f7ff f887 	bl	8008c48 <mc_line>
 8009b3a:	2800      	cmp	r0, #0
 8009b3c:	d0ea      	beq.n	8009b14 <mc_thread+0x2c4>
        if(thread->end_taper_type & Taper_Exit) {
 8009b3e:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
 8009b42:	079b      	lsls	r3, r3, #30
 8009b44:	f53f af6a 	bmi.w	8009a1c <mc_thread+0x1cc>
            target[Z_AXIS] = target_z - infeed_offset;
 8009b48:	4651      	mov	r1, sl
 8009b4a:	9800      	ldr	r0, [sp, #0]
 8009b4c:	e786      	b.n	8009a5c <mc_thread+0x20c>
            infeed_offset = infeed_factor != 0.0f ? doc * infeed_factor : 0.0f;
 8009b4e:	46da      	mov	sl, fp
 8009b50:	e7bb      	b.n	8009aca <mc_thread+0x27a>
 8009b52:	bf00      	nop
 8009b54:	3c8efa35 	.word	0x3c8efa35
 8009b58:	20002494 	.word	0x20002494
 8009b5c:	3c23d70a 	.word	0x3c23d70a
            target[X_AXIS] += (thread->peak + doc) * thread->cut_direction;
 8009b60:	68a9      	ldr	r1, [r5, #8]
 8009b62:	4630      	mov	r0, r6
 8009b64:	f7f6 fd0e 	bl	8000584 <__addsf3>
 8009b68:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009b6a:	f7f6 fe13 	bl	8000794 <__aeabi_fmul>
 8009b6e:	4601      	mov	r1, r0
 8009b70:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009b72:	f7f6 fd07 	bl	8000584 <__addsf3>
 8009b76:	4603      	mov	r3, r0
            if(!mc_line(target, pl_data))
 8009b78:	4621      	mov	r1, r4
 8009b7a:	a809      	add	r0, sp, #36	; 0x24
            target[X_AXIS] += (thread->peak + doc) * thread->cut_direction;
 8009b7c:	9309      	str	r3, [sp, #36]	; 0x24
            if(!mc_line(target, pl_data))
 8009b7e:	f7ff f863 	bl	8008c48 <mc_line>
 8009b82:	2800      	cmp	r0, #0
 8009b84:	f47f aef5 	bne.w	8009972 <mc_thread+0x122>
 8009b88:	e7c4      	b.n	8009b14 <mc_thread+0x2c4>
            target[X_AXIS] = position[X_AXIS];
 8009b8a:	683b      	ldr	r3, [r7, #0]
            if(!mc_line(target, pl_data))
 8009b8c:	4621      	mov	r1, r4
 8009b8e:	a809      	add	r0, sp, #36	; 0x24
            target[X_AXIS] = position[X_AXIS];
 8009b90:	9309      	str	r3, [sp, #36]	; 0x24
            if(!mc_line(target, pl_data))
 8009b92:	f7ff f859 	bl	8008c48 <mc_line>
}
 8009b96:	b00d      	add	sp, #52	; 0x34
 8009b98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009b9c:	69eb      	ldr	r3, [r5, #28]
 8009b9e:	e6b0      	b.n	8009902 <mc_thread+0xb2>
        infeed_offset = doc * infeed_factor;
 8009ba0:	9904      	ldr	r1, [sp, #16]
 8009ba2:	4630      	mov	r0, r6
 8009ba4:	f7f6 fdf6 	bl	8000794 <__aeabi_fmul>
 8009ba8:	4603      	mov	r3, r0
        target[X_AXIS] += (doc - thread->depth) * thread->cut_direction;
 8009baa:	4651      	mov	r1, sl
 8009bac:	4630      	mov	r0, r6
        infeed_offset = doc * infeed_factor;
 8009bae:	469a      	mov	sl, r3
        target[X_AXIS] += (doc - thread->depth) * thread->cut_direction;
 8009bb0:	f7f6 fce6 	bl	8000580 <__aeabi_fsub>
 8009bb4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009bb6:	f7f6 fded 	bl	8000794 <__aeabi_fmul>
 8009bba:	4601      	mov	r1, r0
 8009bbc:	9809      	ldr	r0, [sp, #36]	; 0x24
 8009bbe:	f7f6 fce1 	bl	8000584 <__addsf3>
 8009bc2:	4603      	mov	r3, r0
        target[Z_AXIS] -= infeed_offset;
 8009bc4:	4651      	mov	r1, sl
 8009bc6:	9807      	ldr	r0, [sp, #28]
        target[X_AXIS] += (doc - thread->depth) * thread->cut_direction;
 8009bc8:	9309      	str	r3, [sp, #36]	; 0x24
        target[Z_AXIS] -= infeed_offset;
 8009bca:	f7f6 fcd9 	bl	8000580 <__aeabi_fsub>
 8009bce:	4603      	mov	r3, r0
        if(!mc_line(target, pl_data))
 8009bd0:	4621      	mov	r1, r4
 8009bd2:	a809      	add	r0, sp, #36	; 0x24
        target[Z_AXIS] -= infeed_offset;
 8009bd4:	930b      	str	r3, [sp, #44]	; 0x2c
        if(!mc_line(target, pl_data))
 8009bd6:	f7ff f837 	bl	8008c48 <mc_line>
 8009bda:	2800      	cmp	r0, #0
 8009bdc:	f47f aeb8 	bne.w	8009950 <mc_thread+0x100>
 8009be0:	e798      	b.n	8009b14 <mc_thread+0x2c4>
    float end_taper_factor = thread->end_taper_type == Taper_None ? 0.0f : (thread->end_taper_type == Taper_Both ? 2.0f : 1.0f);
 8009be2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009be6:	9306      	str	r3, [sp, #24]
 8009be8:	e64c      	b.n	8009884 <mc_thread+0x34>
 8009bea:	bf00      	nop

08009bec <mc_jog_execute>:
{
 8009bec:	b538      	push	{r3, r4, r5, lr}
 8009bee:	460b      	mov	r3, r1
 8009bf0:	4605      	mov	r5, r0
    pl_data->condition.jog_motion = On;
 8009bf2:	f890 2020 	ldrb.w	r2, [r0, #32]
    if(settings.limits.flags.jog_soft_limited)
 8009bf6:	491b      	ldr	r1, [pc, #108]	; (8009c64 <mc_jog_execute+0x78>)
    pl_data->condition.jog_motion = On;
 8009bf8:	f022 0214 	bic.w	r2, r2, #20
    if(settings.limits.flags.jog_soft_limited)
 8009bfc:	f891 10d4 	ldrb.w	r1, [r1, #212]	; 0xd4
    pl_data->feed_rate = gc_block->values.f;
 8009c00:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    pl_data->line_number = gc_block->values.n;
 8009c02:	6f98      	ldr	r0, [r3, #120]	; 0x78
    pl_data->condition.jog_motion = On;
 8009c04:	f042 0214 	orr.w	r2, r2, #20
 8009c08:	f885 2020 	strb.w	r2, [r5, #32]
    if(settings.limits.flags.jog_soft_limited)
 8009c0c:	070a      	lsls	r2, r1, #28
    pl_data->feed_rate = gc_block->values.f;
 8009c0e:	602c      	str	r4, [r5, #0]
    pl_data->line_number = gc_block->values.n;
 8009c10:	62a8      	str	r0, [r5, #40]	; 0x28
        system_apply_jog_limits(gc_block->values.xyz);
 8009c12:	f103 045c 	add.w	r4, r3, #92	; 0x5c
    if(settings.limits.flags.jog_soft_limited)
 8009c16:	d420      	bmi.n	8009c5a <mc_jog_execute+0x6e>
    else if (settings.limits.flags.soft_enabled && !system_check_travel_limits(gc_block->values.xyz))
 8009c18:	078b      	lsls	r3, r1, #30
 8009c1a:	d417      	bmi.n	8009c4c <mc_jog_execute+0x60>
    mc_line(gc_block->values.xyz, pl_data);
 8009c1c:	4620      	mov	r0, r4
 8009c1e:	4629      	mov	r1, r5
 8009c20:	f7ff f812 	bl	8008c48 <mc_line>
    if ((sys.state == STATE_IDLE || sys.state == STATE_TOOL_CHANGE) && plan_get_current_block() != NULL) { // Check if there is a block to execute.
 8009c24:	4b10      	ldr	r3, [pc, #64]	; (8009c68 <mc_jog_execute+0x7c>)
 8009c26:	681c      	ldr	r4, [r3, #0]
 8009c28:	f434 7400 	bics.w	r4, r4, #512	; 0x200
 8009c2c:	d001      	beq.n	8009c32 <mc_jog_execute+0x46>
    return Status_OK;
 8009c2e:	2000      	movs	r0, #0
}
 8009c30:	bd38      	pop	{r3, r4, r5, pc}
    if ((sys.state == STATE_IDLE || sys.state == STATE_TOOL_CHANGE) && plan_get_current_block() != NULL) { // Check if there is a block to execute.
 8009c32:	f000 fe0d 	bl	800a850 <plan_get_current_block>
 8009c36:	2800      	cmp	r0, #0
 8009c38:	d0f9      	beq.n	8009c2e <mc_jog_execute+0x42>
        set_state(STATE_JOG);
 8009c3a:	2020      	movs	r0, #32
 8009c3c:	f005 fed8 	bl	800f9f0 <set_state>
        st_prep_buffer();
 8009c40:	f006 fcc6 	bl	80105d0 <st_prep_buffer>
        st_wake_up();  // NOTE: Manual start. No state machine required.
 8009c44:	f006 fa38 	bl	80100b8 <st_wake_up>
    return Status_OK;
 8009c48:	4620      	mov	r0, r4
}
 8009c4a:	bd38      	pop	{r3, r4, r5, pc}
    else if (settings.limits.flags.soft_enabled && !system_check_travel_limits(gc_block->values.xyz))
 8009c4c:	4620      	mov	r0, r4
 8009c4e:	f007 fd89 	bl	8011764 <system_check_travel_limits>
 8009c52:	2800      	cmp	r0, #0
 8009c54:	d1e2      	bne.n	8009c1c <mc_jog_execute+0x30>
        return Status_TravelExceeded;
 8009c56:	200f      	movs	r0, #15
}
 8009c58:	bd38      	pop	{r3, r4, r5, pc}
        system_apply_jog_limits(gc_block->values.xyz);
 8009c5a:	4620      	mov	r0, r4
 8009c5c:	f007 fe50 	bl	8011900 <system_apply_jog_limits>
 8009c60:	e7dc      	b.n	8009c1c <mc_jog_execute+0x30>
 8009c62:	bf00      	nop
 8009c64:	20002620 	.word	0x20002620
 8009c68:	20002494 	.word	0x20002494

08009c6c <mc_dwell>:
    if (sys.state != STATE_CHECK_MODE) {
 8009c6c:	4b07      	ldr	r3, [pc, #28]	; (8009c8c <mc_dwell+0x20>)
 8009c6e:	681b      	ldr	r3, [r3, #0]
 8009c70:	2b02      	cmp	r3, #2
 8009c72:	d100      	bne.n	8009c76 <mc_dwell+0xa>
 8009c74:	4770      	bx	lr
{
 8009c76:	b510      	push	{r4, lr}
 8009c78:	4604      	mov	r4, r0
        protocol_buffer_synchronize();
 8009c7a:	f001 ff1b 	bl	800bab4 <protocol_buffer_synchronize>
        delay_sec(seconds, DelayMode_Dwell);
 8009c7e:	4620      	mov	r0, r4
    }
}
 8009c80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        delay_sec(seconds, DelayMode_Dwell);
 8009c84:	2100      	movs	r1, #0
 8009c86:	f000 bb3b 	b.w	800a300 <delay_sec>
 8009c8a:	bf00      	nop
 8009c8c:	20002494 	.word	0x20002494

08009c90 <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
gc_probe_t mc_probe_cycle (float *target, plan_line_data_t *pl_data, gc_parser_flags_t parser_flags)
{
 8009c90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    // TODO: Need to update this cycle so it obeys a non-auto cycle start.
    if (sys.state == STATE_CHECK_MODE)
 8009c94:	4c37      	ldr	r4, [pc, #220]	; (8009d74 <mc_probe_cycle+0xe4>)
 8009c96:	6823      	ldr	r3, [r4, #0]
 8009c98:	2b02      	cmp	r3, #2
 8009c9a:	d02d      	beq.n	8009cf8 <mc_probe_cycle+0x68>
        return GCProbe_CheckMode;

    // Finish all queued commands and empty planner buffer before starting probe cycle.
    protocol_buffer_synchronize();
 8009c9c:	4680      	mov	r8, r0
 8009c9e:	460f      	mov	r7, r1
 8009ca0:	4616      	mov	r6, r2
 8009ca2:	f001 ff07 	bl	800bab4 <protocol_buffer_synchronize>

    if (sys.abort)
 8009ca6:	f894 9004 	ldrb.w	r9, [r4, #4]
 8009caa:	f1b9 0f00 	cmp.w	r9, #0
 8009cae:	d120      	bne.n	8009cf2 <mc_probe_cycle+0x62>
        return GCProbe_Abort; // Return if system reset has been issued.

    // Initialize probing control variables
    sys.flags.probe_succeeded = Off; // Re-initialize probe history before beginning cycle.
 8009cb0:	7a63      	ldrb	r3, [r4, #9]
    hal.probe_configure_invert_mask(parser_flags.probe_is_away);
 8009cb2:	4d31      	ldr	r5, [pc, #196]	; (8009d78 <mc_probe_cycle+0xe8>)
    sys.flags.probe_succeeded = Off; // Re-initialize probe history before beginning cycle.
 8009cb4:	f369 0341 	bfi	r3, r9, #1, #1
 8009cb8:	7263      	strb	r3, [r4, #9]
    hal.probe_configure_invert_mask(parser_flags.probe_is_away);
 8009cba:	f3c6 00c0 	ubfx	r0, r6, #3, #1
 8009cbe:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8009cc2:	4798      	blx	r3

    // After syncing, check if probe is already triggered. If so, halt and issue alarm.
    // NOTE: This probe initialization error applies to all probing cycles.
    if (hal.probe_get_state()) { // Check probe pin state.
 8009cc4:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8009cc8:	4798      	blx	r3
 8009cca:	b9c0      	cbnz	r0, 8009cfe <mc_probe_cycle+0x6e>
        hal.probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
        return GCProbe_FailInit; // Nothing else to do but bail.
    }

    // Setup and queue probing motion. Auto cycle-start should not start the cycle.
    mc_line(target, pl_data);
 8009ccc:	4639      	mov	r1, r7
 8009cce:	4640      	mov	r0, r8
 8009cd0:	f7fe ffba 	bl	8008c48 <mc_line>

    // Activate the probing state monitor in the stepper module.
    sys_probe_state = Probe_Active;
 8009cd4:	2201      	movs	r2, #1
 8009cd6:	4f29      	ldr	r7, [pc, #164]	; (8009d7c <mc_probe_cycle+0xec>)

    // Perform probing cycle. Wait here until probe is triggered or motion completes.
    system_set_exec_state_flag(EXEC_CYCLE_START);
 8009cd8:	2102      	movs	r1, #2
 8009cda:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
 8009cde:	4828      	ldr	r0, [pc, #160]	; (8009d80 <mc_probe_cycle+0xf0>)
    sys_probe_state = Probe_Active;
 8009ce0:	703a      	strb	r2, [r7, #0]
    system_set_exec_state_flag(EXEC_CYCLE_START);
 8009ce2:	4798      	blx	r3
 8009ce4:	e001      	b.n	8009cea <mc_probe_cycle+0x5a>
    do {
        if(!protocol_execute_realtime()) // Check for system abort
            return GCProbe_Abort;
    } while (sys.state != STATE_IDLE);
 8009ce6:	6823      	ldr	r3, [r4, #0]
 8009ce8:	b1ab      	cbz	r3, 8009d16 <mc_probe_cycle+0x86>
        if(!protocol_execute_realtime()) // Check for system abort
 8009cea:	f001 fc19 	bl	800b520 <protocol_execute_realtime>
 8009cee:	2800      	cmp	r0, #0
 8009cf0:	d1f9      	bne.n	8009ce6 <mc_probe_cycle+0x56>
        return GCProbe_FailInit; // Nothing else to do but bail.
 8009cf2:	2002      	movs	r0, #2
    if(settings.status_report.probe_coordinates)
        report_probe_parameters();

    // Successful probe cycle or Failed to trigger probe within travel. With or without error.
    return sys.flags.probe_succeeded ? GCProbe_Found : GCProbe_FailEnd;
}
 8009cf4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return GCProbe_CheckMode;
 8009cf8:	2000      	movs	r0, #0
}
 8009cfa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        system_set_exec_alarm(Alarm_ProbeFailInitial);
 8009cfe:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8009d02:	2104      	movs	r1, #4
 8009d04:	481f      	ldr	r0, [pc, #124]	; (8009d84 <mc_probe_cycle+0xf4>)
 8009d06:	4798      	blx	r3
        protocol_execute_realtime();
 8009d08:	f001 fc0a 	bl	800b520 <protocol_execute_realtime>
        hal.probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
 8009d0c:	4648      	mov	r0, r9
 8009d0e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8009d12:	4798      	blx	r3
 8009d14:	e7ed      	b.n	8009cf2 <mc_probe_cycle+0x62>
    if (sys_probe_state == Probe_Active) {
 8009d16:	783b      	ldrb	r3, [r7, #0]
 8009d18:	2b01      	cmp	r3, #1
 8009d1a:	d01a      	beq.n	8009d52 <mc_probe_cycle+0xc2>
        sys.flags.probe_succeeded = On; // Indicate to system the probing cycle completed successfully.
 8009d1c:	7a63      	ldrb	r3, [r4, #9]
 8009d1e:	f043 0302 	orr.w	r3, r3, #2
 8009d22:	7263      	strb	r3, [r4, #9]
    sys_probe_state = Probe_Off;            // Ensure probe state monitor is disabled.
 8009d24:	2000      	movs	r0, #0
    hal.probe_configure_invert_mask(false); // Re-initialize invert mask.
 8009d26:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
    sys_probe_state = Probe_Off;            // Ensure probe state monitor is disabled.
 8009d2a:	7038      	strb	r0, [r7, #0]
    hal.probe_configure_invert_mask(false); // Re-initialize invert mask.
 8009d2c:	4798      	blx	r3
    protocol_execute_realtime();            // Check and execute run-time commands
 8009d2e:	f001 fbf7 	bl	800b520 <protocol_execute_realtime>
    st_reset();             // Reset step segment buffer.
 8009d32:	f006 fb39 	bl	80103a8 <st_reset>
    plan_reset();           // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 8009d36:	f000 fd01 	bl	800a73c <plan_reset>
    plan_sync_position();   // Sync planner position to current machine position.
 8009d3a:	f001 f969 	bl	800b010 <plan_sync_position>
    if(settings.status_report.probe_coordinates)
 8009d3e:	4b12      	ldr	r3, [pc, #72]	; (8009d88 <mc_probe_cycle+0xf8>)
 8009d40:	f993 30bb 	ldrsb.w	r3, [r3, #187]	; 0xbb
 8009d44:	2b00      	cmp	r3, #0
 8009d46:	db12      	blt.n	8009d6e <mc_probe_cycle+0xde>
    return sys.flags.probe_succeeded ? GCProbe_Found : GCProbe_FailEnd;
 8009d48:	7a60      	ldrb	r0, [r4, #9]
 8009d4a:	f3c0 0040 	ubfx	r0, r0, #1, #1
}
 8009d4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (parser_flags.probe_is_no_error)
 8009d52:	06f3      	lsls	r3, r6, #27
 8009d54:	d505      	bpl.n	8009d62 <mc_probe_cycle+0xd2>
            memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 8009d56:	4a0d      	ldr	r2, [pc, #52]	; (8009d8c <mc_probe_cycle+0xfc>)
 8009d58:	4b0d      	ldr	r3, [pc, #52]	; (8009d90 <mc_probe_cycle+0x100>)
 8009d5a:	ca07      	ldmia	r2, {r0, r1, r2}
 8009d5c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8009d60:	e7e0      	b.n	8009d24 <mc_probe_cycle+0x94>
            system_set_exec_alarm(Alarm_ProbeFailContact);
 8009d62:	2105      	movs	r1, #5
 8009d64:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8009d68:	4806      	ldr	r0, [pc, #24]	; (8009d84 <mc_probe_cycle+0xf4>)
 8009d6a:	4798      	blx	r3
 8009d6c:	e7da      	b.n	8009d24 <mc_probe_cycle+0x94>
        report_probe_parameters();
 8009d6e:	f003 f849 	bl	800ce04 <report_probe_parameters>
 8009d72:	e7e9      	b.n	8009d48 <mc_probe_cycle+0xb8>
 8009d74:	20002494 	.word	0x20002494
 8009d78:	200024bc 	.word	0x200024bc
 8009d7c:	200024b8 	.word	0x200024b8
 8009d80:	200024b4 	.word	0x200024b4
 8009d84:	2000261c 	.word	0x2000261c
 8009d88:	20002620 	.word	0x20002620
 8009d8c:	20002610 	.word	0x20002610
 8009d90:	20002604 	.word	0x20002604

08009d94 <mc_parking_motion>:


// Plans and executes the single special motion case for parking. Independent of main planner buffer.
// NOTE: Uses the always free planner ring buffer head to store motion parameters for execution.
bool mc_parking_motion (float *parking_target, plan_line_data_t *pl_data)
{
 8009d94:	b538      	push	{r3, r4, r5, lr}
    if (sys.abort)
 8009d96:	4d10      	ldr	r5, [pc, #64]	; (8009dd8 <mc_parking_motion+0x44>)
 8009d98:	792b      	ldrb	r3, [r5, #4]
 8009d9a:	b113      	cbz	r3, 8009da2 <mc_parking_motion+0xe>
        return false; // Block during abort.
 8009d9c:	2400      	movs	r4, #0
        return true;
    } else { // no motion for execution
        system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle completed
        return false;
    }
}
 8009d9e:	4620      	mov	r0, r4
 8009da0:	bd38      	pop	{r3, r4, r5, pc}
    if (plan_buffer_line(parking_target, pl_data)) {
 8009da2:	f000 fe75 	bl	800aa90 <plan_buffer_line>
 8009da6:	4604      	mov	r4, r0
 8009da8:	b938      	cbnz	r0, 8009dba <mc_parking_motion+0x26>
        system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle completed
 8009daa:	4b0c      	ldr	r3, [pc, #48]	; (8009ddc <mc_parking_motion+0x48>)
 8009dac:	2104      	movs	r1, #4
 8009dae:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8009db2:	480b      	ldr	r0, [pc, #44]	; (8009de0 <mc_parking_motion+0x4c>)
 8009db4:	4798      	blx	r3
}
 8009db6:	4620      	mov	r0, r4
 8009db8:	bd38      	pop	{r3, r4, r5, pc}
        sys.step_control.end_motion = Off; // Allow parking motion to execute, if feed hold is active.
 8009dba:	7aab      	ldrb	r3, [r5, #10]
 8009dbc:	f023 0305 	bic.w	r3, r3, #5
 8009dc0:	f043 0304 	orr.w	r3, r3, #4
 8009dc4:	72ab      	strb	r3, [r5, #10]
        st_parking_setup_buffer(); // Setup step segment buffer for special parking motion case
 8009dc6:	f006 fbbd 	bl	8010544 <st_parking_setup_buffer>
        st_prep_buffer();
 8009dca:	f006 fc01 	bl	80105d0 <st_prep_buffer>
        st_wake_up();
 8009dce:	f006 f973 	bl	80100b8 <st_wake_up>
}
 8009dd2:	4620      	mov	r0, r4
 8009dd4:	bd38      	pop	{r3, r4, r5, pc}
 8009dd6:	bf00      	nop
 8009dd8:	20002494 	.word	0x20002494
 8009ddc:	200024bc 	.word	0x200024bc
 8009de0:	200024b4 	.word	0x200024b4

08009de4 <mc_override_ctrl_update>:

void mc_override_ctrl_update (gc_override_flags_t override_state)
{
 8009de4:	b510      	push	{r4, lr}
 8009de6:	4604      	mov	r4, r0
// Finish all queued commands before altering override control state
    protocol_buffer_synchronize();
 8009de8:	f001 fe64 	bl	800bab4 <protocol_buffer_synchronize>
    if (!sys.abort)
 8009dec:	4b02      	ldr	r3, [pc, #8]	; (8009df8 <mc_override_ctrl_update+0x14>)
 8009dee:	791a      	ldrb	r2, [r3, #4]
 8009df0:	b902      	cbnz	r2, 8009df4 <mc_override_ctrl_update+0x10>
        sys.override.control = override_state;
 8009df2:	749c      	strb	r4, [r3, #18]
}
 8009df4:	bd10      	pop	{r4, pc}
 8009df6:	bf00      	nop
 8009df8:	20002494 	.word	0x20002494

08009dfc <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
ISR_CODE void mc_reset ()
{
    // Only this function can set the system reset. Helps prevent multiple kill calls.
    if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 8009dfc:	481f      	ldr	r0, [pc, #124]	; (8009e7c <mc_reset+0x80>)
{
 8009dfe:	b570      	push	{r4, r5, r6, lr}
    if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 8009e00:	6804      	ldr	r4, [r0, #0]
 8009e02:	f014 0420 	ands.w	r4, r4, #32
 8009e06:	d128      	bne.n	8009e5a <mc_reset+0x5e>

        system_set_exec_state_flag(EXEC_RESET);
 8009e08:	4d1d      	ldr	r5, [pc, #116]	; (8009e80 <mc_reset+0x84>)
 8009e0a:	2120      	movs	r1, #32
 8009e0c:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
 8009e10:	4798      	blx	r3

        // Kill spindle and coolant.
        hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 8009e12:	2100      	movs	r1, #0
 8009e14:	4620      	mov	r0, r4
 8009e16:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8009e18:	4798      	blx	r3
        hal.coolant_set_state((coolant_state_t){0});
 8009e1a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8009e1c:	4620      	mov	r0, r4
 8009e1e:	4798      	blx	r3

        if(hal.stream.suspend_read)
 8009e20:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8009e22:	b10b      	cbz	r3, 8009e28 <mc_reset+0x2c>
            hal.stream.suspend_read(false);
 8009e24:	4620      	mov	r0, r4
 8009e26:	4798      	blx	r3

        // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
        // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
        // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
        // violated, by which, all bets are off.
        if ((sys.state & (STATE_CYCLE|STATE_HOMING|STATE_JOG)) || sys.step_control.execute_hold || sys.step_control.execute_sys_motion) {
 8009e28:	4a16      	ldr	r2, [pc, #88]	; (8009e84 <mc_reset+0x88>)
 8009e2a:	6813      	ldr	r3, [r2, #0]
 8009e2c:	f013 0f2c 	tst.w	r3, #44	; 0x2c
 8009e30:	d014      	beq.n	8009e5c <mc_reset+0x60>

            if (sys.state != STATE_HOMING)
 8009e32:	2b04      	cmp	r3, #4
 8009e34:	d018      	beq.n	8009e68 <mc_reset+0x6c>
                system_set_exec_alarm(Alarm_AbortCycle);
 8009e36:	2103      	movs	r1, #3
 8009e38:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8009e3c:	4812      	ldr	r0, [pc, #72]	; (8009e88 <mc_reset+0x8c>)
 8009e3e:	4798      	blx	r3
            else if (!sys_rt_exec_alarm)
                system_set_exec_alarm(Alarm_HomingFailReset);

            st_go_idle(); // Force kill steppers. Position has likely been lost.
 8009e40:	f006 f948 	bl	80100d4 <st_go_idle>
        }

        if(hal.system_control_get_state().e_stop)
 8009e44:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8009e46:	4798      	blx	r3
 8009e48:	0643      	lsls	r3, r0, #25
 8009e4a:	d506      	bpl.n	8009e5a <mc_reset+0x5e>
            system_set_exec_alarm(Alarm_EStop);
 8009e4c:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8009e50:	210a      	movs	r1, #10
    }
}
 8009e52:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            system_set_exec_alarm(Alarm_EStop);
 8009e56:	480c      	ldr	r0, [pc, #48]	; (8009e88 <mc_reset+0x8c>)
 8009e58:	4718      	bx	r3
}
 8009e5a:	bd70      	pop	{r4, r5, r6, pc}
        if ((sys.state & (STATE_CYCLE|STATE_HOMING|STATE_JOG)) || sys.step_control.execute_hold || sys.step_control.execute_sys_motion) {
 8009e5c:	7a92      	ldrb	r2, [r2, #10]
 8009e5e:	f012 0f06 	tst.w	r2, #6
 8009e62:	d0ef      	beq.n	8009e44 <mc_reset+0x48>
            if (sys.state != STATE_HOMING)
 8009e64:	2b04      	cmp	r3, #4
 8009e66:	d1e6      	bne.n	8009e36 <mc_reset+0x3a>
            else if (!sys_rt_exec_alarm)
 8009e68:	4807      	ldr	r0, [pc, #28]	; (8009e88 <mc_reset+0x8c>)
 8009e6a:	6803      	ldr	r3, [r0, #0]
 8009e6c:	2b00      	cmp	r3, #0
 8009e6e:	d1e7      	bne.n	8009e40 <mc_reset+0x44>
                system_set_exec_alarm(Alarm_HomingFailReset);
 8009e70:	2106      	movs	r1, #6
 8009e72:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 8009e76:	4798      	blx	r3
 8009e78:	e7e2      	b.n	8009e40 <mc_reset+0x44>
 8009e7a:	bf00      	nop
 8009e7c:	200024b4 	.word	0x200024b4
 8009e80:	200024bc 	.word	0x200024bc
 8009e84:	20002494 	.word	0x20002494
 8009e88:	2000261c 	.word	0x2000261c

08009e8c <mc_homing_cycle>:
{
 8009e8c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 8009e90:	4c70      	ldr	r4, [pc, #448]	; (800a054 <mc_homing_cycle+0x1c8>)
{
 8009e92:	4606      	mov	r6, r0
    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 8009e94:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
 8009e98:	fa5f f880 	uxtb.w	r8, r0
 8009e9c:	06d9      	lsls	r1, r3, #27
 8009e9e:	d520      	bpl.n	8009ee2 <mc_homing_cycle+0x56>
 8009ea0:	4d6d      	ldr	r5, [pc, #436]	; (800a058 <mc_homing_cycle+0x1cc>)
 8009ea2:	7b29      	ldrb	r1, [r5, #12]
 8009ea4:	f1b8 0f00 	cmp.w	r8, #0
 8009ea8:	d118      	bne.n	8009edc <mc_homing_cycle+0x50>
 8009eaa:	b9d1      	cbnz	r1, 8009ee2 <mc_homing_cycle+0x56>
        sys.homed.mask |= cycle.mask;
 8009eac:	7b6b      	ldrb	r3, [r5, #13]
        limits_set_machine_positions(cycle, false);
 8009eae:	f04f 0007 	mov.w	r0, #7
        sys.homed.mask |= cycle.mask;
 8009eb2:	f043 0307 	orr.w	r3, r3, #7
 8009eb6:	736b      	strb	r3, [r5, #13]
        limits_set_machine_positions(cycle, false);
 8009eb8:	f7fe fbfe 	bl	80086b8 <limits_set_machine_positions>
        if(!protocol_execute_realtime()) // Check for reset and set system abort.
 8009ebc:	f001 fb30 	bl	800b520 <protocol_execute_realtime>
 8009ec0:	2800      	cmp	r0, #0
 8009ec2:	d06d      	beq.n	8009fa0 <mc_homing_cycle+0x114>
        if(home_all && settings.homing.flags.manual)
 8009ec4:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
 8009ec8:	06da      	lsls	r2, r3, #27
 8009eca:	f100 80b2 	bmi.w	800a032 <mc_homing_cycle+0x1a6>
        gc_sync_position();
 8009ece:	4963      	ldr	r1, [pc, #396]	; (800a05c <mc_homing_cycle+0x1d0>)
 8009ed0:	4863      	ldr	r0, [pc, #396]	; (800a060 <mc_homing_cycle+0x1d4>)
 8009ed2:	f007 fc29 	bl	8011728 <system_convert_array_steps_to_mpos>
        plan_sync_position();
 8009ed6:	f001 f89b 	bl	800b010 <plan_sync_position>
 8009eda:	e047      	b.n	8009f6c <mc_homing_cycle+0xe0>
    if(settings.homing.flags.manual && (home_all ? sys.homing.mask : (cycle.mask & sys.homing.mask)) == 0) {
 8009edc:	ea18 0101 	ands.w	r1, r8, r1
 8009ee0:	d06a      	beq.n	8009fb8 <mc_homing_cycle+0x12c>
        if (settings.limits.flags.two_switches && hal.limits_get_state().value) {
 8009ee2:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
 8009ee6:	4f5f      	ldr	r7, [pc, #380]	; (800a064 <mc_homing_cycle+0x1d8>)
 8009ee8:	06db      	lsls	r3, r3, #27
 8009eea:	d504      	bpl.n	8009ef6 <mc_homing_cycle+0x6a>
 8009eec:	6a3b      	ldr	r3, [r7, #32]
 8009eee:	4798      	blx	r3
 8009ef0:	f010 0fff 	tst.w	r0, #255	; 0xff
 8009ef4:	d16f      	bne.n	8009fd6 <mc_homing_cycle+0x14a>
        gc_state.modal.coolant.mask = 0;
 8009ef6:	f04f 0900 	mov.w	r9, #0
        set_state(STATE_HOMING);                                // Set homing system state,
 8009efa:	2004      	movs	r0, #4
 8009efc:	f005 fd78 	bl	800f9f0 <set_state>
        hal.stream.enqueue_realtime_command(CMD_STATUS_REPORT); // force a status report and
 8009f00:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8009f02:	2080      	movs	r0, #128	; 0x80
 8009f04:	4798      	blx	r3
        delay_sec(0.1f, DelayMode_Dwell);                       // delay a bit to get it sent (or perhaps wait a bit for a request?)
 8009f06:	4649      	mov	r1, r9
 8009f08:	4857      	ldr	r0, [pc, #348]	; (800a068 <mc_homing_cycle+0x1dc>)
 8009f0a:	f000 f9f9 	bl	800a300 <delay_sec>
        hal.limits_enable(false, true); // Disable hard limits pin change register for cycle duration
 8009f0e:	2101      	movs	r1, #1
 8009f10:	4648      	mov	r0, r9
 8009f12:	69fb      	ldr	r3, [r7, #28]
 8009f14:	4798      	blx	r3
        gc_state.spindle.rpm = 0.0f;
 8009f16:	2100      	movs	r1, #0
 8009f18:	4d54      	ldr	r5, [pc, #336]	; (800a06c <mc_homing_cycle+0x1e0>)
        gc_state.modal.spindle.on = gc_state.modal.spindle.ccw = Off;
 8009f1a:	7ea8      	ldrb	r0, [r5, #26]
        gc_state.spindle.rpm = 0.0f;
 8009f1c:	64a9      	str	r1, [r5, #72]	; 0x48
        gc_state.modal.spindle.on = gc_state.modal.spindle.ccw = Off;
 8009f1e:	f020 0003 	bic.w	r0, r0, #3
 8009f22:	76a8      	strb	r0, [r5, #26]
        spindle_set_state(gc_state.modal.spindle, 0.0f);
 8009f24:	f004 fe1c 	bl	800eb60 <spindle_set_state>
        coolant_set_state(gc_state.modal.coolant);
 8009f28:	4648      	mov	r0, r9
        gc_state.modal.coolant.mask = 0;
 8009f2a:	f885 9019 	strb.w	r9, [r5, #25]
        coolant_set_state(gc_state.modal.coolant);
 8009f2e:	f7fb f837 	bl	8004fa0 <coolant_set_state>
        if (!home_all) // Perform homing cycle based on mask.
 8009f32:	f1b8 0f00 	cmp.w	r8, #0
 8009f36:	d126      	bne.n	8009f86 <mc_homing_cycle+0xfa>
            sys.homed.mask &= ~sys.homing.mask;
 8009f38:	4d47      	ldr	r5, [pc, #284]	; (800a058 <mc_homing_cycle+0x1cc>)
                if(settings.homing.cycle[idx].mask) {
 8009f3a:	f894 60d1 	ldrb.w	r6, [r4, #209]	; 0xd1
            sys.homed.mask &= ~sys.homing.mask;
 8009f3e:	7b6b      	ldrb	r3, [r5, #13]
 8009f40:	7b2a      	ldrb	r2, [r5, #12]
 8009f42:	ea23 0302 	bic.w	r3, r3, r2
 8009f46:	736b      	strb	r3, [r5, #13]
                if(settings.homing.cycle[idx].mask) {
 8009f48:	2e00      	cmp	r6, #0
 8009f4a:	d14c      	bne.n	8009fe6 <mc_homing_cycle+0x15a>
 8009f4c:	f894 00d2 	ldrb.w	r0, [r4, #210]	; 0xd2
 8009f50:	2800      	cmp	r0, #0
 8009f52:	d15a      	bne.n	800a00a <mc_homing_cycle+0x17e>
 8009f54:	f894 10d3 	ldrb.w	r1, [r4, #211]	; 0xd3
 8009f58:	2900      	cmp	r1, #0
 8009f5a:	d15d      	bne.n	800a018 <mc_homing_cycle+0x18c>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 8009f5c:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
 8009f60:	69fb      	ldr	r3, [r7, #28]
 8009f62:	f000 0001 	and.w	r0, r0, #1
 8009f66:	4798      	blx	r3
    if(cycle.mask) {
 8009f68:	2e00      	cmp	r6, #0
 8009f6a:	d1a7      	bne.n	8009ebc <mc_homing_cycle+0x30>
    return settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value
 8009f6c:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
    sys.report.homed = On;
 8009f70:	7d2a      	ldrb	r2, [r5, #20]
            : Status_OK;
 8009f72:	f003 0305 	and.w	r3, r3, #5
    sys.report.homed = On;
 8009f76:	f042 0204 	orr.w	r2, r2, #4
            : Status_OK;
 8009f7a:	2b05      	cmp	r3, #5
    sys.report.homed = On;
 8009f7c:	752a      	strb	r2, [r5, #20]
            : Status_OK;
 8009f7e:	d012      	beq.n	8009fa6 <mc_homing_cycle+0x11a>
 8009f80:	2000      	movs	r0, #0
}
 8009f82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            limits_go_home(cycle);
 8009f86:	4630      	mov	r0, r6
 8009f88:	f7fe fdd6 	bl	8008b38 <limits_go_home>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 8009f8c:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
 8009f90:	4649      	mov	r1, r9
 8009f92:	69fb      	ldr	r3, [r7, #28]
 8009f94:	f000 0001 	and.w	r0, r0, #1
 8009f98:	4798      	blx	r3
        if(!protocol_execute_realtime()) // Check for reset and set system abort.
 8009f9a:	f001 fac1 	bl	800b520 <protocol_execute_realtime>
 8009f9e:	b9c0      	cbnz	r0, 8009fd2 <mc_homing_cycle+0x146>
            return Status_Unhandled;
 8009fa0:	203b      	movs	r0, #59	; 0x3b
}
 8009fa2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value
 8009fa6:	4b2f      	ldr	r3, [pc, #188]	; (800a064 <mc_homing_cycle+0x1d8>)
 8009fa8:	6a1b      	ldr	r3, [r3, #32]
 8009faa:	4798      	blx	r3
 8009fac:	f010 0fff 	tst.w	r0, #255	; 0xff
 8009fb0:	d0e6      	beq.n	8009f80 <mc_homing_cycle+0xf4>
            : Status_OK;
 8009fb2:	202d      	movs	r0, #45	; 0x2d
}
 8009fb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        sys.homed.mask |= cycle.mask;
 8009fb8:	7b6b      	ldrb	r3, [r5, #13]
 8009fba:	ea48 0803 	orr.w	r8, r8, r3
 8009fbe:	f885 800d 	strb.w	r8, [r5, #13]
        limits_set_machine_positions(cycle, false);
 8009fc2:	f7fe fb79 	bl	80086b8 <limits_set_machine_positions>
        if(!protocol_execute_realtime()) // Check for reset and set system abort.
 8009fc6:	f001 faab 	bl	800b520 <protocol_execute_realtime>
 8009fca:	2800      	cmp	r0, #0
 8009fcc:	f47f af7f 	bne.w	8009ece <mc_homing_cycle+0x42>
 8009fd0:	e7e6      	b.n	8009fa0 <mc_homing_cycle+0x114>
 8009fd2:	4d21      	ldr	r5, [pc, #132]	; (800a058 <mc_homing_cycle+0x1cc>)
 8009fd4:	e77b      	b.n	8009ece <mc_homing_cycle+0x42>
            mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 8009fd6:	f7ff ff11 	bl	8009dfc <mc_reset>
            system_set_exec_alarm(Alarm_HardLimit);
 8009fda:	2101      	movs	r1, #1
 8009fdc:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8009fe0:	4823      	ldr	r0, [pc, #140]	; (800a070 <mc_homing_cycle+0x1e4>)
 8009fe2:	4798      	blx	r3
 8009fe4:	e7dc      	b.n	8009fa0 <mc_homing_cycle+0x114>
                    if(!limits_go_home(cycle))
 8009fe6:	4630      	mov	r0, r6
 8009fe8:	f7fe fda6 	bl	8008b38 <limits_go_home>
 8009fec:	2800      	cmp	r0, #0
 8009fee:	d1ad      	bne.n	8009f4c <mc_homing_cycle+0xc0>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 8009ff0:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
 8009ff4:	2100      	movs	r1, #0
 8009ff6:	69fb      	ldr	r3, [r7, #28]
 8009ff8:	f000 0001 	and.w	r0, r0, #1
 8009ffc:	4798      	blx	r3
        if(!protocol_execute_realtime()) // Check for reset and set system abort.
 8009ffe:	f001 fa8f 	bl	800b520 <protocol_execute_realtime>
 800a002:	2800      	cmp	r0, #0
 800a004:	f47f af5e 	bne.w	8009ec4 <mc_homing_cycle+0x38>
 800a008:	e7ca      	b.n	8009fa0 <mc_homing_cycle+0x114>
                    if(!limits_go_home(cycle))
 800a00a:	f7fe fd95 	bl	8008b38 <limits_go_home>
 800a00e:	2800      	cmp	r0, #0
 800a010:	d0ee      	beq.n	8009ff0 <mc_homing_cycle+0x164>
                if(settings.homing.cycle[idx].mask) {
 800a012:	f894 10d3 	ldrb.w	r1, [r4, #211]	; 0xd3
 800a016:	b1a9      	cbz	r1, 800a044 <mc_homing_cycle+0x1b8>
                    if(!limits_go_home(cycle))
 800a018:	4608      	mov	r0, r1
 800a01a:	f7fe fd8d 	bl	8008b38 <limits_go_home>
 800a01e:	2800      	cmp	r0, #0
 800a020:	d0e6      	beq.n	8009ff0 <mc_homing_cycle+0x164>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 800a022:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
 800a026:	2100      	movs	r1, #0
 800a028:	69fb      	ldr	r3, [r7, #28]
 800a02a:	f000 0001 	and.w	r0, r0, #1
 800a02e:	4798      	blx	r3
    if(cycle.mask) {
 800a030:	e744      	b.n	8009ebc <mc_homing_cycle+0x30>
            cycle.mask = AXES_BITMASK & ~sys.homing.mask;
 800a032:	7b28      	ldrb	r0, [r5, #12]
            sys.homed.mask = AXES_BITMASK;
 800a034:	2307      	movs	r3, #7
            cycle.mask = AXES_BITMASK & ~sys.homing.mask;
 800a036:	43c0      	mvns	r0, r0
            limits_set_machine_positions(cycle, false);
 800a038:	2100      	movs	r1, #0
 800a03a:	4018      	ands	r0, r3
            sys.homed.mask = AXES_BITMASK;
 800a03c:	736b      	strb	r3, [r5, #13]
            limits_set_machine_positions(cycle, false);
 800a03e:	f7fe fb3b 	bl	80086b8 <limits_set_machine_positions>
 800a042:	e744      	b.n	8009ece <mc_homing_cycle+0x42>
        hal.limits_enable(settings.limits.flags.hard_enabled, false);
 800a044:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
 800a048:	69fb      	ldr	r3, [r7, #28]
 800a04a:	f000 0001 	and.w	r0, r0, #1
 800a04e:	4798      	blx	r3
    if(cycle.mask) {
 800a050:	e734      	b.n	8009ebc <mc_homing_cycle+0x30>
 800a052:	bf00      	nop
 800a054:	20002620 	.word	0x20002620
 800a058:	20002494 	.word	0x20002494
 800a05c:	20002610 	.word	0x20002610
 800a060:	20002448 	.word	0x20002448
 800a064:	200024bc 	.word	0x200024bc
 800a068:	3dcccccd 	.word	0x3dcccccd
 800a06c:	200023dc 	.word	0x200023dc
 800a070:	2000261c 	.word	0x2000261c

0800a074 <uitoa>:
// Converts an uint32 variable to string.
char *uitoa (uint32_t n)
{
    char *bptr = buf + sizeof(buf);

    *--bptr = '\0';
 800a074:	2100      	movs	r1, #0
 800a076:	4a0e      	ldr	r2, [pc, #56]	; (800a0b0 <uitoa+0x3c>)
 800a078:	7351      	strb	r1, [r2, #13]

    if (n == 0)
 800a07a:	b920      	cbnz	r0, 800a086 <uitoa+0x12>
        *--bptr = '0';
 800a07c:	4610      	mov	r0, r2
 800a07e:	2330      	movs	r3, #48	; 0x30
 800a080:	f800 3f0c 	strb.w	r3, [r0, #12]!
        *--bptr = '0' + (n % 10);
        n /= 10;
    }

    return bptr;
}
 800a084:	4770      	bx	lr
{
 800a086:	b430      	push	{r4, r5}
        *--bptr = '0' + (n % 10);
 800a088:	4d0a      	ldr	r5, [pc, #40]	; (800a0b4 <uitoa+0x40>)
 800a08a:	4603      	mov	r3, r0
    *--bptr = '\0';
 800a08c:	f102 000d 	add.w	r0, r2, #13
        *--bptr = '0' + (n % 10);
 800a090:	4619      	mov	r1, r3
 800a092:	fba5 4203 	umull	r4, r2, r5, r3
 800a096:	08d2      	lsrs	r2, r2, #3
 800a098:	eb02 0482 	add.w	r4, r2, r2, lsl #2
 800a09c:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
 800a0a0:	3330      	adds	r3, #48	; 0x30
    else while (n) {
 800a0a2:	2909      	cmp	r1, #9
        *--bptr = '0' + (n % 10);
 800a0a4:	f800 3d01 	strb.w	r3, [r0, #-1]!
        n /= 10;
 800a0a8:	4613      	mov	r3, r2
    else while (n) {
 800a0aa:	d8f1      	bhi.n	800a090 <uitoa+0x1c>
}
 800a0ac:	bc30      	pop	{r4, r5}
 800a0ae:	4770      	bx	lr
 800a0b0:	20000a58 	.word	0x20000a58
 800a0b4:	cccccccd 	.word	0xcccccccd

0800a0b8 <ftoa>:
char *ftoa (float n, uint8_t decimal_places)
{
    bool isNegative;
    char *bptr = buf + sizeof(buf);

    *--bptr = '\0';
 800a0b8:	2300      	movs	r3, #0
{
 800a0ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    if ((isNegative = n < 0.0f))
        n = -n;

    n += froundvalues[decimal_places];
 800a0be:	4a3e      	ldr	r2, [pc, #248]	; (800a1b8 <ftoa+0x100>)
    *--bptr = '\0';
 800a0c0:	f8df 8104 	ldr.w	r8, [pc, #260]	; 800a1c8 <ftoa+0x110>
{
 800a0c4:	4605      	mov	r5, r0
    *--bptr = '\0';
 800a0c6:	f888 300d 	strb.w	r3, [r8, #13]
{
 800a0ca:	460e      	mov	r6, r1
 800a0cc:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    n += froundvalues[decimal_places];
 800a0d0:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 800a0d4:	f7f6 fa56 	bl	8000584 <__addsf3>
 800a0d8:	4607      	mov	r7, r0

    uint32_t a = (uint32_t)n;
 800a0da:	f7f6 fd5d 	bl	8000b98 <__aeabi_f2uiz>
 800a0de:	4604      	mov	r4, r0

    if (decimal_places) {
 800a0e0:	2e00      	cmp	r6, #0
 800a0e2:	d04e      	beq.n	800a182 <ftoa+0xca>

        n -= (float)a;
 800a0e4:	f7f6 fafe 	bl	80006e4 <__aeabi_ui2f>
 800a0e8:	4601      	mov	r1, r0
 800a0ea:	4638      	mov	r0, r7
 800a0ec:	f7f6 fa48 	bl	8000580 <__aeabi_fsub>

        uint_fast8_t decimals = decimal_places;
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 800a0f0:	2e01      	cmp	r6, #1
 800a0f2:	d05d      	beq.n	800a1b0 <ftoa+0xf8>
 800a0f4:	4637      	mov	r7, r6
            n *= 100.0f;
 800a0f6:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 800a1cc <ftoa+0x114>
 800a0fa:	4641      	mov	r1, r8
            decimals -= 2;
 800a0fc:	3f02      	subs	r7, #2
            n *= 100.0f;
 800a0fe:	f7f6 fb49 	bl	8000794 <__aeabi_fmul>
        while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
 800a102:	2f01      	cmp	r7, #1
 800a104:	d8f9      	bhi.n	800a0fa <ftoa+0x42>
        }

        if (decimals)
 800a106:	07f3      	lsls	r3, r6, #31
 800a108:	d452      	bmi.n	800a1b0 <ftoa+0xf8>
            n *= 10.0f;

        uint32_t b = (uint32_t)n;
 800a10a:	f7f6 fd45 	bl	8000b98 <__aeabi_f2uiz>

        while(decimal_places--) {
 800a10e:	1e72      	subs	r2, r6, #1
 800a110:	b2d2      	uxtb	r2, r2
    *--bptr = '\0';
 800a112:	4e2a      	ldr	r6, [pc, #168]	; (800a1bc <ftoa+0x104>)
            if(b) {
 800a114:	b190      	cbz	r0, 800a13c <ftoa+0x84>
                *--bptr = (b % 10) + '0'; // Get digit
 800a116:	4f2a      	ldr	r7, [pc, #168]	; (800a1c0 <ftoa+0x108>)
 800a118:	fba7 1300 	umull	r1, r3, r7, r0
 800a11c:	08db      	lsrs	r3, r3, #3
 800a11e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
        while(decimal_places--) {
 800a122:	3a01      	subs	r2, #1
                *--bptr = (b % 10) + '0'; // Get digit
 800a124:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
        while(decimal_places--) {
 800a128:	b2d2      	uxtb	r2, r2
                *--bptr = (b % 10) + '0'; // Get digit
 800a12a:	3130      	adds	r1, #48	; 0x30
        while(decimal_places--) {
 800a12c:	2aff      	cmp	r2, #255	; 0xff
                *--bptr = (b % 10) + '0'; // Get digit
 800a12e:	f806 1d01 	strb.w	r1, [r6, #-1]!
                b /= 10;
 800a132:	4601      	mov	r1, r0
 800a134:	4618      	mov	r0, r3
        while(decimal_places--) {
 800a136:	d026      	beq.n	800a186 <ftoa+0xce>
            if(b) {
 800a138:	2909      	cmp	r1, #9
 800a13a:	d8ed      	bhi.n	800a118 <ftoa+0x60>
            } else
                *--bptr = '0';
 800a13c:	43d3      	mvns	r3, r2
 800a13e:	441e      	add	r6, r3
 800a140:	4630      	mov	r0, r6
 800a142:	2130      	movs	r1, #48	; 0x30
 800a144:	3201      	adds	r2, #1
 800a146:	f007 fd9d 	bl	8011c84 <memset>
        }
    }

    *--bptr = '.'; // Always add decimal point (TODO: is this really needed?)
 800a14a:	232e      	movs	r3, #46	; 0x2e
 800a14c:	f806 3c01 	strb.w	r3, [r6, #-1]

    if(a == 0)
 800a150:	b1f4      	cbz	r4, 800a190 <ftoa+0xd8>
        *--bptr = '0';

    else while(a) {
        *--bptr = (a % 10) + '0'; // Get digit
 800a152:	481b      	ldr	r0, [pc, #108]	; (800a1c0 <ftoa+0x108>)
    *--bptr = '.'; // Always add decimal point (TODO: is this really needed?)
 800a154:	1e77      	subs	r7, r6, #1
        *--bptr = (a % 10) + '0'; // Get digit
 800a156:	4621      	mov	r1, r4
 800a158:	fba0 2304 	umull	r2, r3, r0, r4
 800a15c:	08db      	lsrs	r3, r3, #3
 800a15e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800a162:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
 800a166:	3230      	adds	r2, #48	; 0x30
    else while(a) {
 800a168:	2909      	cmp	r1, #9
        a /= 10;
 800a16a:	461c      	mov	r4, r3
        *--bptr = (a % 10) + '0'; // Get digit
 800a16c:	f807 2d01 	strb.w	r2, [r7, #-1]!
    else while(a) {
 800a170:	d8f1      	bhi.n	800a156 <ftoa+0x9e>
    }

    if(isNegative)
 800a172:	4628      	mov	r0, r5
 800a174:	2100      	movs	r1, #0
 800a176:	f7f6 fcab 	bl	8000ad0 <__aeabi_fcmplt>
 800a17a:	b998      	cbnz	r0, 800a1a4 <ftoa+0xec>
        *--bptr = '-';

    return bptr;
}
 800a17c:	4638      	mov	r0, r7
 800a17e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *--bptr = '\0';
 800a182:	f108 060d 	add.w	r6, r8, #13
    *--bptr = '.'; // Always add decimal point (TODO: is this really needed?)
 800a186:	232e      	movs	r3, #46	; 0x2e
 800a188:	f806 3c01 	strb.w	r3, [r6, #-1]
    if(a == 0)
 800a18c:	2c00      	cmp	r4, #0
 800a18e:	d1e0      	bne.n	800a152 <ftoa+0x9a>
        *--bptr = '0';
 800a190:	2330      	movs	r3, #48	; 0x30
    if(isNegative)
 800a192:	4628      	mov	r0, r5
 800a194:	2100      	movs	r1, #0
        *--bptr = '0';
 800a196:	f806 3c02 	strb.w	r3, [r6, #-2]
 800a19a:	1eb7      	subs	r7, r6, #2
    if(isNegative)
 800a19c:	f7f6 fc98 	bl	8000ad0 <__aeabi_fcmplt>
 800a1a0:	2800      	cmp	r0, #0
 800a1a2:	d0eb      	beq.n	800a17c <ftoa+0xc4>
        *--bptr = '-';
 800a1a4:	232d      	movs	r3, #45	; 0x2d
 800a1a6:	3f01      	subs	r7, #1
 800a1a8:	703b      	strb	r3, [r7, #0]
}
 800a1aa:	4638      	mov	r0, r7
 800a1ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            n *= 10.0f;
 800a1b0:	4904      	ldr	r1, [pc, #16]	; (800a1c4 <ftoa+0x10c>)
 800a1b2:	f7f6 faef 	bl	8000794 <__aeabi_fmul>
 800a1b6:	e7a8      	b.n	800a10a <ftoa+0x52>
 800a1b8:	08014974 	.word	0x08014974
 800a1bc:	20000a65 	.word	0x20000a65
 800a1c0:	cccccccd 	.word	0xcccccccd
 800a1c4:	41200000 	.word	0x41200000
 800a1c8:	20000a58 	.word	0x20000a58
 800a1cc:	42c80000 	.word	0x42c80000

0800a1d0 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized.
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
bool read_float (char *line, uint_fast8_t *char_counter, float *float_ptr)
{
 800a1d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    char c, *ptr = line + *char_counter;
 800a1d4:	680c      	ldr	r4, [r1, #0]
{
 800a1d6:	b083      	sub	sp, #12
    uint_fast8_t ndigit = 0;
    uint32_t intval = 0;
    bool isnegative, isdecimal = false;

    // Grab first character and increment pointer. No spaces assumed in line.
    c = *ptr++;
 800a1d8:	f810 8004 	ldrb.w	r8, [r0, r4]
{
 800a1dc:	460d      	mov	r5, r1

    // Capture initial positive/minus character
    if ((isnegative = (c == '-')) || c == '+')
 800a1de:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
{
 800a1e2:	4607      	mov	r7, r0
 800a1e4:	9201      	str	r2, [sp, #4]
    char c, *ptr = line + *char_counter;
 800a1e6:	4404      	add	r4, r0
    if ((isnegative = (c == '-')) || c == '+')
 800a1e8:	d005      	beq.n	800a1f6 <read_float+0x26>
 800a1ea:	f1b8 0f2b 	cmp.w	r8, #43	; 0x2b
 800a1ee:	d002      	beq.n	800a1f6 <read_float+0x26>
    c = *ptr++;
 800a1f0:	4643      	mov	r3, r8
 800a1f2:	3401      	adds	r4, #1
 800a1f4:	e001      	b.n	800a1fa <read_float+0x2a>
        c = *ptr++;
 800a1f6:	7863      	ldrb	r3, [r4, #1]
 800a1f8:	3402      	adds	r4, #2
    c = *ptr++;
 800a1fa:	2100      	movs	r1, #0
 800a1fc:	4608      	mov	r0, r1
 800a1fe:	460a      	mov	r2, r1
 800a200:	4689      	mov	r9, r1
 800a202:	e00b      	b.n	800a21c <read_float+0x4c>

    // Extract number into fast integer. Track decimal in terms of exponent value.
    while(true) {
        c -= '0';
        if (c <= 9) {
            ndigit++;
 800a204:	3201      	adds	r2, #1
            if (ndigit <= MAX_INT_DIGITS) {
 800a206:	2a08      	cmp	r2, #8
 800a208:	d811      	bhi.n	800a22e <read_float+0x5e>
                if (isdecimal)
 800a20a:	b109      	cbz	r1, 800a210 <read_float+0x40>
                    exp--;
 800a20c:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
                intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
 800a210:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800a214:	eb03 0040 	add.w	r0, r3, r0, lsl #1
        } else if (c == (('.'-'0') & 0xff) && !isdecimal)
            isdecimal = true;
         else
            break;

        c = *ptr++;
 800a218:	f814 3b01 	ldrb.w	r3, [r4], #1
        c -= '0';
 800a21c:	3b30      	subs	r3, #48	; 0x30
 800a21e:	b2db      	uxtb	r3, r3
        if (c <= 9) {
 800a220:	2b09      	cmp	r3, #9
 800a222:	d9ef      	bls.n	800a204 <read_float+0x34>
        } else if (c == (('.'-'0') & 0xff) && !isdecimal)
 800a224:	2bfe      	cmp	r3, #254	; 0xfe
 800a226:	d107      	bne.n	800a238 <read_float+0x68>
 800a228:	b931      	cbnz	r1, 800a238 <read_float+0x68>
            isdecimal = true;
 800a22a:	2101      	movs	r1, #1
 800a22c:	e7f4      	b.n	800a218 <read_float+0x48>
            } else if (!isdecimal)
 800a22e:	2900      	cmp	r1, #0
 800a230:	d1f2      	bne.n	800a218 <read_float+0x48>
                exp++;  // Drop overflow digits
 800a232:	f109 0901 	add.w	r9, r9, #1
 800a236:	e7ef      	b.n	800a218 <read_float+0x48>
    }

    // Return if no digits have been read.
    if (!ndigit)
 800a238:	2a00      	cmp	r2, #0
 800a23a:	d03c      	beq.n	800a2b6 <read_float+0xe6>
        return(false);

    // Convert integer into floating point.
    float fval = (float)intval;
 800a23c:	f7f6 fa52 	bl	80006e4 <__aeabi_ui2f>

    // Apply decimal. Should perform no more than two floating point multiplications for the
    // expected range of E0 to E-4.
    if (fval != 0.0f) {
 800a240:	2100      	movs	r1, #0
    float fval = (float)intval;
 800a242:	4682      	mov	sl, r0
    if (fval != 0.0f) {
 800a244:	f7f6 fc3a 	bl	8000abc <__aeabi_fcmpeq>
 800a248:	bb28      	cbnz	r0, 800a296 <read_float+0xc6>
        while (exp <= -2) {
 800a24a:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
 800a24e:	da12      	bge.n	800a276 <read_float+0xa6>
 800a250:	46cb      	mov	fp, r9
            fval *= 0.01f;
 800a252:	4e1e      	ldr	r6, [pc, #120]	; (800a2cc <read_float+0xfc>)
 800a254:	4650      	mov	r0, sl
 800a256:	4631      	mov	r1, r6
 800a258:	f7f6 fa9c 	bl	8000794 <__aeabi_fmul>
            exp += 2;
 800a25c:	f10b 0b02 	add.w	fp, fp, #2
        while (exp <= -2) {
 800a260:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
            fval *= 0.01f;
 800a264:	4682      	mov	sl, r0
        while (exp <= -2) {
 800a266:	dbf5      	blt.n	800a254 <read_float+0x84>
 800a268:	f109 0902 	add.w	r9, r9, #2
 800a26c:	f1c9 0300 	rsb	r3, r9, #0
 800a270:	f023 0301 	bic.w	r3, r3, #1
 800a274:	4499      	add	r9, r3
        }
        if (exp < 0)
 800a276:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
 800a27a:	d020      	beq.n	800a2be <read_float+0xee>
            fval *= 0.1f;
        else if (exp > 0) do {
 800a27c:	f1b9 0f00 	cmp.w	r9, #0
 800a280:	d009      	beq.n	800a296 <read_float+0xc6>
            fval *= 10.0f;
 800a282:	f8df b050 	ldr.w	fp, [pc, #80]	; 800a2d4 <read_float+0x104>
 800a286:	4650      	mov	r0, sl
 800a288:	4659      	mov	r1, fp
 800a28a:	f7f6 fa83 	bl	8000794 <__aeabi_fmul>
        } while (--exp > 0);
 800a28e:	f1b9 0901 	subs.w	r9, r9, #1
            fval *= 10.0f;
 800a292:	4682      	mov	sl, r0
        } while (--exp > 0);
 800a294:	d1f7      	bne.n	800a286 <read_float+0xb6>
    }

    // Assign floating point value with correct sign.
    *float_ptr = isnegative ? - fval : fval;
 800a296:	f1b8 0f2d 	cmp.w	r8, #45	; 0x2d
 800a29a:	bf04      	itt	eq
 800a29c:	f10a 4000 	addeq.w	r0, sl, #2147483648	; 0x80000000
 800a2a0:	4682      	moveq	sl, r0
    *char_counter = ptr - line - 1; // Set char_counter to next statement

    return true;
 800a2a2:	2001      	movs	r0, #1
    *float_ptr = isnegative ? - fval : fval;
 800a2a4:	9b01      	ldr	r3, [sp, #4]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 800a2a6:	1be4      	subs	r4, r4, r7
 800a2a8:	3c01      	subs	r4, #1
    *float_ptr = isnegative ? - fval : fval;
 800a2aa:	f8c3 a000 	str.w	sl, [r3]
    *char_counter = ptr - line - 1; // Set char_counter to next statement
 800a2ae:	602c      	str	r4, [r5, #0]
}
 800a2b0:	b003      	add	sp, #12
 800a2b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(false);
 800a2b6:	4610      	mov	r0, r2
}
 800a2b8:	b003      	add	sp, #12
 800a2ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            fval *= 0.1f;
 800a2be:	4650      	mov	r0, sl
 800a2c0:	4903      	ldr	r1, [pc, #12]	; (800a2d0 <read_float+0x100>)
 800a2c2:	f7f6 fa67 	bl	8000794 <__aeabi_fmul>
 800a2c6:	4682      	mov	sl, r0
 800a2c8:	e7e5      	b.n	800a296 <read_float+0xc6>
 800a2ca:	bf00      	nop
 800a2cc:	3c23d70a 	.word	0x3c23d70a
 800a2d0:	3dcccccd 	.word	0x3dcccccd
 800a2d4:	41200000 	.word	0x41200000

0800a2d8 <isintf>:

// Returns true if float value is a whole number (integer)
bool isintf (float value)
{
 800a2d8:	b510      	push	{r4, lr}
 800a2da:	4604      	mov	r4, r0
    return value != NAN && fabsf(value - truncf(value)) < 0.001f;
 800a2dc:	f008 fdee 	bl	8012ebc <truncf>
 800a2e0:	4601      	mov	r1, r0
 800a2e2:	4620      	mov	r0, r4
 800a2e4:	f7f6 f94c 	bl	8000580 <__aeabi_fsub>
 800a2e8:	4904      	ldr	r1, [pc, #16]	; (800a2fc <isintf+0x24>)
 800a2ea:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 800a2ee:	f7f6 fbef 	bl	8000ad0 <__aeabi_fcmplt>
}
 800a2f2:	3800      	subs	r0, #0
 800a2f4:	bf18      	it	ne
 800a2f6:	2001      	movne	r0, #1
 800a2f8:	bd10      	pop	{r4, pc}
 800a2fa:	bf00      	nop
 800a2fc:	3a83126f 	.word	0x3a83126f

0800a300 <delay_sec>:

// Non-blocking delay function used for general operation and suspend features.
void delay_sec (float seconds, delaymode_t mode)
{
 800a300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a302:	460d      	mov	r5, r1
    uint_fast16_t i = (uint_fast16_t)ceilf((1000.0f / DWELL_TIME_STEP) * seconds) + 1;
 800a304:	4914      	ldr	r1, [pc, #80]	; (800a358 <delay_sec+0x58>)
 800a306:	f7f6 fa45 	bl	8000794 <__aeabi_fmul>
 800a30a:	f008 fc77 	bl	8012bfc <ceilf>
 800a30e:	f7f6 fc43 	bl	8000b98 <__aeabi_f2uiz>

    while (--i && !sys.abort) {
 800a312:	b190      	cbz	r0, 800a33a <delay_sec+0x3a>
 800a314:	4604      	mov	r4, r0
 800a316:	4e11      	ldr	r6, [pc, #68]	; (800a35c <delay_sec+0x5c>)
 800a318:	b185      	cbz	r5, 800a33c <delay_sec+0x3c>
          // Execute rt_system() only to avoid nesting suspend loops.
          protocol_exec_rt_system();
          if (state_door_reopened()) // Bail, if safety door reopens.
              return;
        }
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 800a31a:	4d11      	ldr	r5, [pc, #68]	; (800a360 <delay_sec+0x60>)
 800a31c:	e00a      	b.n	800a334 <delay_sec+0x34>
          protocol_exec_rt_system();
 800a31e:	f000 ff2f 	bl	800b180 <protocol_exec_rt_system>
          if (state_door_reopened()) // Bail, if safety door reopens.
 800a322:	f005 fb1d 	bl	800f960 <state_door_reopened>
 800a326:	4601      	mov	r1, r0
 800a328:	b938      	cbnz	r0, 800a33a <delay_sec+0x3a>
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 800a32a:	2032      	movs	r0, #50	; 0x32
 800a32c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a32e:	4798      	blx	r3
    while (--i && !sys.abort) {
 800a330:	3c01      	subs	r4, #1
 800a332:	d002      	beq.n	800a33a <delay_sec+0x3a>
 800a334:	7933      	ldrb	r3, [r6, #4]
 800a336:	2b00      	cmp	r3, #0
 800a338:	d0f1      	beq.n	800a31e <delay_sec+0x1e>
    }
}
 800a33a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 800a33c:	4f08      	ldr	r7, [pc, #32]	; (800a360 <delay_sec+0x60>)
 800a33e:	e007      	b.n	800a350 <delay_sec+0x50>
            protocol_execute_realtime();
 800a340:	f001 f8ee 	bl	800b520 <protocol_execute_realtime>
        hal.delay_ms(DWELL_TIME_STEP, 0); // Delay DWELL_TIME_STEP increment
 800a344:	4629      	mov	r1, r5
 800a346:	2032      	movs	r0, #50	; 0x32
 800a348:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a34a:	4798      	blx	r3
    while (--i && !sys.abort) {
 800a34c:	3c01      	subs	r4, #1
 800a34e:	d0f4      	beq.n	800a33a <delay_sec+0x3a>
 800a350:	7935      	ldrb	r5, [r6, #4]
 800a352:	2d00      	cmp	r5, #0
 800a354:	d0f4      	beq.n	800a340 <delay_sec+0x40>
}
 800a356:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a358:	41a00000 	.word	0x41a00000
 800a35c:	20002494 	.word	0x20002494
 800a360:	200024bc 	.word	0x200024bc

0800a364 <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector (float *vector)
{
 800a364:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint_fast8_t idx = N_AXIS;
    float magnitude = 0.0f, inv_magnitude;

    do {
        if (vector[--idx] != 0.0f)
 800a366:	6885      	ldr	r5, [r0, #8]
{
 800a368:	4604      	mov	r4, r0
        if (vector[--idx] != 0.0f)
 800a36a:	2100      	movs	r1, #0
 800a36c:	4628      	mov	r0, r5
 800a36e:	f7f6 fba5 	bl	8000abc <__aeabi_fcmpeq>
 800a372:	b920      	cbnz	r0, 800a37e <convert_delta_vector_to_unit_vector+0x1a>
            magnitude += vector[idx] * vector[idx];
 800a374:	4629      	mov	r1, r5
 800a376:	4628      	mov	r0, r5
 800a378:	f7f6 fa0c 	bl	8000794 <__aeabi_fmul>
 800a37c:	4605      	mov	r5, r0
        if (vector[--idx] != 0.0f)
 800a37e:	6866      	ldr	r6, [r4, #4]
 800a380:	2100      	movs	r1, #0
 800a382:	4630      	mov	r0, r6
 800a384:	f7f6 fb9a 	bl	8000abc <__aeabi_fcmpeq>
 800a388:	b940      	cbnz	r0, 800a39c <convert_delta_vector_to_unit_vector+0x38>
            magnitude += vector[idx] * vector[idx];
 800a38a:	4631      	mov	r1, r6
 800a38c:	4630      	mov	r0, r6
 800a38e:	f7f6 fa01 	bl	8000794 <__aeabi_fmul>
 800a392:	4601      	mov	r1, r0
 800a394:	4628      	mov	r0, r5
 800a396:	f7f6 f8f5 	bl	8000584 <__addsf3>
 800a39a:	4605      	mov	r5, r0
        if (vector[--idx] != 0.0f)
 800a39c:	6827      	ldr	r7, [r4, #0]
 800a39e:	2100      	movs	r1, #0
 800a3a0:	4638      	mov	r0, r7
 800a3a2:	f7f6 fb8b 	bl	8000abc <__aeabi_fcmpeq>
 800a3a6:	b940      	cbnz	r0, 800a3ba <convert_delta_vector_to_unit_vector+0x56>
            magnitude += vector[idx] * vector[idx];
 800a3a8:	4639      	mov	r1, r7
 800a3aa:	4638      	mov	r0, r7
 800a3ac:	f7f6 f9f2 	bl	8000794 <__aeabi_fmul>
 800a3b0:	4601      	mov	r1, r0
 800a3b2:	4628      	mov	r0, r5
 800a3b4:	f7f6 f8e6 	bl	8000584 <__addsf3>
 800a3b8:	4605      	mov	r5, r0
    } while(idx);

    idx = N_AXIS;
    magnitude = sqrtf(magnitude);
 800a3ba:	4628      	mov	r0, r5
 800a3bc:	f008 fe16 	bl	8012fec <sqrtf>
 800a3c0:	4606      	mov	r6, r0
    inv_magnitude = 1.0f / magnitude;
 800a3c2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800a3c6:	4631      	mov	r1, r6
 800a3c8:	f7f6 fa98 	bl	80008fc <__aeabi_fdiv>
 800a3cc:	4605      	mov	r5, r0

    do {
        vector[--idx] *= inv_magnitude;
 800a3ce:	68a0      	ldr	r0, [r4, #8]
 800a3d0:	4629      	mov	r1, r5
 800a3d2:	f7f6 f9df 	bl	8000794 <__aeabi_fmul>
 800a3d6:	4629      	mov	r1, r5
 800a3d8:	60a0      	str	r0, [r4, #8]
 800a3da:	6860      	ldr	r0, [r4, #4]
 800a3dc:	f7f6 f9da 	bl	8000794 <__aeabi_fmul>
 800a3e0:	4603      	mov	r3, r0
 800a3e2:	4639      	mov	r1, r7
 800a3e4:	6063      	str	r3, [r4, #4]
 800a3e6:	4628      	mov	r0, r5
 800a3e8:	f7f6 f9d4 	bl	8000794 <__aeabi_fmul>
 800a3ec:	4603      	mov	r3, r0
    } while(idx);

    return magnitude;
}
 800a3ee:	4630      	mov	r0, r6
        vector[--idx] *= inv_magnitude;
 800a3f0:	6023      	str	r3, [r4, #0]
}
 800a3f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800a3f4 <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum (float *max_value, float *unit_vec)
{
 800a3f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint_fast8_t idx = N_AXIS;
    float limit_value = SOME_LARGE_VALUE;

    do {
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 800a3f6:	688d      	ldr	r5, [r1, #8]
{
 800a3f8:	460c      	mov	r4, r1
 800a3fa:	4606      	mov	r6, r0
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 800a3fc:	2100      	movs	r1, #0
 800a3fe:	4628      	mov	r0, r5
 800a400:	f7f6 fb5c 	bl	8000abc <__aeabi_fcmpeq>
 800a404:	bb70      	cbnz	r0, 800a464 <limit_value_by_axis_maximum+0x70>
            limit_value = min(limit_value, fabsf(max_value[idx] / unit_vec[idx]));
 800a406:	4629      	mov	r1, r5
 800a408:	68b0      	ldr	r0, [r6, #8]
 800a40a:	f7f6 fa77 	bl	80008fc <__aeabi_fdiv>
 800a40e:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 800a412:	4628      	mov	r0, r5
 800a414:	4917      	ldr	r1, [pc, #92]	; (800a474 <limit_value_by_axis_maximum+0x80>)
 800a416:	f7f6 fb65 	bl	8000ae4 <__aeabi_fcmple>
 800a41a:	b318      	cbz	r0, 800a464 <limit_value_by_axis_maximum+0x70>
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 800a41c:	6867      	ldr	r7, [r4, #4]
 800a41e:	2100      	movs	r1, #0
 800a420:	4638      	mov	r0, r7
 800a422:	f7f6 fb4b 	bl	8000abc <__aeabi_fcmpeq>
 800a426:	b950      	cbnz	r0, 800a43e <limit_value_by_axis_maximum+0x4a>
            limit_value = min(limit_value, fabsf(max_value[idx] / unit_vec[idx]));
 800a428:	4639      	mov	r1, r7
 800a42a:	6870      	ldr	r0, [r6, #4]
 800a42c:	f7f6 fa66 	bl	80008fc <__aeabi_fdiv>
 800a430:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
 800a434:	4639      	mov	r1, r7
 800a436:	4628      	mov	r0, r5
 800a438:	f7f6 fb54 	bl	8000ae4 <__aeabi_fcmple>
 800a43c:	b1b8      	cbz	r0, 800a46e <limit_value_by_axis_maximum+0x7a>
        if (unit_vec[--idx] != 0.0f)  // Avoid divide by zero.
 800a43e:	6824      	ldr	r4, [r4, #0]
 800a440:	2100      	movs	r1, #0
 800a442:	4620      	mov	r0, r4
 800a444:	f7f6 fb3a 	bl	8000abc <__aeabi_fcmpeq>
 800a448:	b950      	cbnz	r0, 800a460 <limit_value_by_axis_maximum+0x6c>
            limit_value = min(limit_value, fabsf(max_value[idx] / unit_vec[idx]));
 800a44a:	4621      	mov	r1, r4
 800a44c:	6830      	ldr	r0, [r6, #0]
 800a44e:	f7f6 fa55 	bl	80008fc <__aeabi_fdiv>
 800a452:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 800a456:	4621      	mov	r1, r4
 800a458:	4628      	mov	r0, r5
 800a45a:	f7f6 fb43 	bl	8000ae4 <__aeabi_fcmple>
 800a45e:	b118      	cbz	r0, 800a468 <limit_value_by_axis_maximum+0x74>
    } while(idx);

    return limit_value;
}
 800a460:	4628      	mov	r0, r5
 800a462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    float limit_value = SOME_LARGE_VALUE;
 800a464:	4d03      	ldr	r5, [pc, #12]	; (800a474 <limit_value_by_axis_maximum+0x80>)
 800a466:	e7d9      	b.n	800a41c <limit_value_by_axis_maximum+0x28>
            limit_value = min(limit_value, fabsf(max_value[idx] / unit_vec[idx]));
 800a468:	4625      	mov	r5, r4
}
 800a46a:	4628      	mov	r0, r5
 800a46c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            limit_value = min(limit_value, fabsf(max_value[idx] / unit_vec[idx]));
 800a46e:	463d      	mov	r5, r7
 800a470:	e7e5      	b.n	800a43e <limit_value_by_axis_maximum+0x4a>
 800a472:	bf00      	nop
 800a474:	7e967699 	.word	0x7e967699

0800a478 <calc_checksum>:
// calculate checksum byte for EEPROM data
uint8_t calc_checksum (uint8_t *data, uint32_t size) {

    uint8_t checksum = 0;

    while(size--) {
 800a478:	b179      	cbz	r1, 800a49a <calc_checksum+0x22>
 800a47a:	4602      	mov	r2, r0
    uint8_t checksum = 0;
 800a47c:	2000      	movs	r0, #0
uint8_t calc_checksum (uint8_t *data, uint32_t size) {
 800a47e:	b410      	push	{r4}
 800a480:	1854      	adds	r4, r2, r1
        checksum = (checksum << 1) | (checksum >> 7);
        checksum += *(data++);
 800a482:	f812 1b01 	ldrb.w	r1, [r2], #1
        checksum = (checksum << 1) | (checksum >> 7);
 800a486:	09c3      	lsrs	r3, r0, #7
 800a488:	ea43 0340 	orr.w	r3, r3, r0, lsl #1
        checksum += *(data++);
 800a48c:	440b      	add	r3, r1
    while(size--) {
 800a48e:	42a2      	cmp	r2, r4
        checksum += *(data++);
 800a490:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    while(size--) {
 800a494:	d1f5      	bne.n	800a482 <calc_checksum+0xa>
    }

    return checksum;
}
 800a496:	bc10      	pop	{r4}
 800a498:	4770      	bx	lr
    uint8_t checksum = 0;
 800a49a:	4608      	mov	r0, r1
}
 800a49c:	4770      	bx	lr
 800a49e:	bf00      	nop

0800a4a0 <dummy_handler>:

void dummy_handler (void)
{
    // NOOP
}
 800a4a0:	4770      	bx	lr
 800a4a2:	bf00      	nop

0800a4a4 <enqueue_feed_override>:

static override_queue_t feed = {0}, accessory = {0};

ISR_CODE void enqueue_feed_override (uint8_t cmd)
{
    uint_fast8_t bptr = (feed.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 800a4a4:	4a06      	ldr	r2, [pc, #24]	; (800a4c0 <enqueue_feed_override+0x1c>)
 800a4a6:	6813      	ldr	r3, [r2, #0]

    if(bptr != feed.tail) {         // If not buffer full
 800a4a8:	6851      	ldr	r1, [r2, #4]
    uint_fast8_t bptr = (feed.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 800a4aa:	3301      	adds	r3, #1
 800a4ac:	f003 030f 	and.w	r3, r3, #15
    if(bptr != feed.tail) {         // If not buffer full
 800a4b0:	4299      	cmp	r1, r3
 800a4b2:	d003      	beq.n	800a4bc <enqueue_feed_override+0x18>
        feed.buf[feed.head] = cmd;  // add data to buffer
 800a4b4:	6811      	ldr	r1, [r2, #0]
        feed.head = bptr;           // and update pointer
 800a4b6:	6013      	str	r3, [r2, #0]
        feed.buf[feed.head] = cmd;  // add data to buffer
 800a4b8:	440a      	add	r2, r1
 800a4ba:	7210      	strb	r0, [r2, #8]
    }
}
 800a4bc:	4770      	bx	lr
 800a4be:	bf00      	nop
 800a4c0:	20000a80 	.word	0x20000a80

0800a4c4 <get_feed_override>:

// Returns 0 if no commands enqueued
uint8_t get_feed_override (void)
{
    uint8_t data = 0;
    uint_fast8_t bptr = feed.tail;
 800a4c4:	4a06      	ldr	r2, [pc, #24]	; (800a4e0 <get_feed_override+0x1c>)
 800a4c6:	6853      	ldr	r3, [r2, #4]

    if(bptr != feed.head) {
 800a4c8:	6811      	ldr	r1, [r2, #0]
 800a4ca:	4299      	cmp	r1, r3
 800a4cc:	d006      	beq.n	800a4dc <get_feed_override+0x18>
        data = feed.buf[bptr++];                    // Get next character, increment tmp pointer
 800a4ce:	1c59      	adds	r1, r3, #1
        feed.tail = bptr & (OVERRIDE_BUFSIZE - 1);  // and update pointer
 800a4d0:	f001 010f 	and.w	r1, r1, #15
        data = feed.buf[bptr++];                    // Get next character, increment tmp pointer
 800a4d4:	4413      	add	r3, r2
 800a4d6:	7a18      	ldrb	r0, [r3, #8]
        feed.tail = bptr & (OVERRIDE_BUFSIZE - 1);  // and update pointer
 800a4d8:	6051      	str	r1, [r2, #4]
 800a4da:	4770      	bx	lr
    uint8_t data = 0;
 800a4dc:	2000      	movs	r0, #0
    }

    return data;
}
 800a4de:	4770      	bx	lr
 800a4e0:	20000a80 	.word	0x20000a80

0800a4e4 <enqueue_accessory_override>:

ISR_CODE void enqueue_accessory_override (uint8_t cmd)
{
    uint_fast8_t bptr = (accessory.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 800a4e4:	4a06      	ldr	r2, [pc, #24]	; (800a500 <enqueue_accessory_override+0x1c>)
 800a4e6:	6813      	ldr	r3, [r2, #0]

    if(bptr != accessory.tail) {                // If not buffer full
 800a4e8:	6851      	ldr	r1, [r2, #4]
    uint_fast8_t bptr = (accessory.head + 1) & (OVERRIDE_BUFSIZE - 1);    // Get next head pointer
 800a4ea:	3301      	adds	r3, #1
 800a4ec:	f003 030f 	and.w	r3, r3, #15
    if(bptr != accessory.tail) {                // If not buffer full
 800a4f0:	4299      	cmp	r1, r3
 800a4f2:	d003      	beq.n	800a4fc <enqueue_accessory_override+0x18>
        accessory.buf[accessory.head] = cmd;    // add data to buffer
 800a4f4:	6811      	ldr	r1, [r2, #0]
        accessory.head = bptr;                  // and update pointer
 800a4f6:	6013      	str	r3, [r2, #0]
        accessory.buf[accessory.head] = cmd;    // add data to buffer
 800a4f8:	440a      	add	r2, r1
 800a4fa:	7210      	strb	r0, [r2, #8]
    }
}
 800a4fc:	4770      	bx	lr
 800a4fe:	bf00      	nop
 800a500:	20000a68 	.word	0x20000a68

0800a504 <get_accessory_override>:

// Returns 0 if no commands enqueued
uint8_t get_accessory_override (void)
{
    uint8_t data = 0;
    uint_fast8_t bptr = accessory.tail;
 800a504:	4a06      	ldr	r2, [pc, #24]	; (800a520 <get_accessory_override+0x1c>)
 800a506:	6853      	ldr	r3, [r2, #4]

    if(bptr != accessory.head) {
 800a508:	6811      	ldr	r1, [r2, #0]
 800a50a:	4299      	cmp	r1, r3
 800a50c:	d006      	beq.n	800a51c <get_accessory_override+0x18>
        data = accessory.buf[bptr++];                   // Get next character, increment tmp pointer
 800a50e:	1c59      	adds	r1, r3, #1
        accessory.tail = bptr & (OVERRIDE_BUFSIZE - 1); // and update pointer
 800a510:	f001 010f 	and.w	r1, r1, #15
        data = accessory.buf[bptr++];                   // Get next character, increment tmp pointer
 800a514:	4413      	add	r3, r2
 800a516:	7a18      	ldrb	r0, [r3, #8]
        accessory.tail = bptr & (OVERRIDE_BUFSIZE - 1); // and update pointer
 800a518:	6051      	str	r1, [r2, #4]
 800a51a:	4770      	bx	lr
    uint8_t data = 0;
 800a51c:	2000      	movs	r0, #0
    }

    return data;
}
 800a51e:	4770      	bx	lr
 800a520:	20000a68 	.word	0x20000a68

0800a524 <flush_override_buffers>:

void flush_override_buffers () {
    feed.head = feed.tail = accessory.head = accessory.tail = 0;
 800a524:	2300      	movs	r3, #0
 800a526:	4903      	ldr	r1, [pc, #12]	; (800a534 <flush_override_buffers+0x10>)
 800a528:	4a03      	ldr	r2, [pc, #12]	; (800a538 <flush_override_buffers+0x14>)
 800a52a:	604b      	str	r3, [r1, #4]
 800a52c:	600b      	str	r3, [r1, #0]
 800a52e:	6053      	str	r3, [r2, #4]
 800a530:	6013      	str	r3, [r2, #0]
}
 800a532:	4770      	bx	lr
 800a534:	20000a68 	.word	0x20000a68
 800a538:	20000a80 	.word	0x20000a80

0800a53c <planner_recalculate>:
  to compute an optimal plan, so select carefully. ARM versions should have enough memory and speed for
  look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate ()
{
 800a53c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Initialize block index to the last block in the planner buffer.
    uint_fast8_t block_index = plan_prev_block_index(block_buffer_head);
 800a540:	4b79      	ldr	r3, [pc, #484]	; (800a728 <planner_recalculate+0x1ec>)
{
 800a542:	b085      	sub	sp, #20
    uint_fast8_t block_index = plan_prev_block_index(block_buffer_head);
 800a544:	681b      	ldr	r3, [r3, #0]
 800a546:	9301      	str	r3, [sp, #4]
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a548:	2b00      	cmp	r3, #0
 800a54a:	f000 80ca 	beq.w	800a6e2 <planner_recalculate+0x1a6>

    // Bail. Can't do anything with one only one plan-able block.
    if (block_index == block_buffer_planned)
 800a54e:	4a77      	ldr	r2, [pc, #476]	; (800a72c <planner_recalculate+0x1f0>)
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a550:	1e5d      	subs	r5, r3, #1
    if (block_index == block_buffer_planned)
 800a552:	6817      	ldr	r7, [r2, #0]
 800a554:	9202      	str	r2, [sp, #8]
 800a556:	42af      	cmp	r7, r5
 800a558:	f000 80a4 	beq.w	800a6a4 <planner_recalculate+0x168>
    // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
    // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
    // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
    float entry_speed_sqr;
    plan_block_t *next;
    plan_block_t *current = &block_buffer[block_index];
 800a55c:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 800a738 <planner_recalculate+0x1fc>
 800a560:	eb05 0445 	add.w	r4, r5, r5, lsl #1
 800a564:	eb08 1444 	add.w	r4, r8, r4, lsl #5

    // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 800a568:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800a56a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800a56c:	f7f6 f912 	bl	8000794 <__aeabi_fmul>
 800a570:	4601      	mov	r1, r0
 800a572:	f7f6 f807 	bl	8000584 <__addsf3>
 800a576:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a578:	4606      	mov	r6, r0
 800a57a:	9103      	str	r1, [sp, #12]
 800a57c:	f7f6 fab2 	bl	8000ae4 <__aeabi_fcmple>
 800a580:	f104 0320 	add.w	r3, r4, #32
 800a584:	2800      	cmp	r0, #0
 800a586:	f000 8090 	beq.w	800a6aa <planner_recalculate+0x16e>
 800a58a:	601e      	str	r6, [r3, #0]
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a58c:	2d00      	cmp	r5, #0
 800a58e:	f040 8092 	bne.w	800a6b6 <planner_recalculate+0x17a>
 800a592:	2323      	movs	r3, #35	; 0x23

    block_index = plan_prev_block_index(block_index);
    if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 800a594:	42bb      	cmp	r3, r7
 800a596:	f000 8093 	beq.w	800a6c0 <planner_recalculate+0x184>
 800a59a:	f8df 9194 	ldr.w	r9, [pc, #404]	; 800a730 <planner_recalculate+0x1f4>
 800a59e:	e027      	b.n	800a5f0 <planner_recalculate+0xb4>
        next = current;
        current = &block_buffer[block_index];
        block_index = plan_prev_block_index(block_index);

        // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
        if (block_index == block_buffer_tail)
 800a5a0:	f8d9 1000 	ldr.w	r1, [r9]
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a5a4:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
        if (block_index == block_buffer_tail)
 800a5a8:	4551      	cmp	r1, sl
 800a5aa:	d02f      	beq.n	800a60c <planner_recalculate+0xd0>
            st_update_plan_block_parameters();

        // Compute maximum entry speed decelerating over the current block from its exit speed.
        if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 800a5ac:	442b      	add	r3, r5
 800a5ae:	eb08 1b43 	add.w	fp, r8, r3, lsl #5
 800a5b2:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
 800a5b6:	f8db 0020 	ldr.w	r0, [fp, #32]
 800a5ba:	4629      	mov	r1, r5
 800a5bc:	f7f6 fa7e 	bl	8000abc <__aeabi_fcmpeq>
 800a5c0:	b998      	cbnz	r0, 800a5ea <planner_recalculate+0xae>
            entry_speed_sqr = next->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 800a5c2:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 800a5c6:	f8db 0028 	ldr.w	r0, [fp, #40]	; 0x28
 800a5ca:	f7f6 f8e3 	bl	8000794 <__aeabi_fmul>
 800a5ce:	4601      	mov	r1, r0
 800a5d0:	f7f5 ffd8 	bl	8000584 <__addsf3>
 800a5d4:	6a31      	ldr	r1, [r6, #32]
 800a5d6:	f7f5 ffd5 	bl	8000584 <__addsf3>
            current->entry_speed_sqr = entry_speed_sqr < current->max_entry_speed_sqr ? entry_speed_sqr : current->max_entry_speed_sqr;
 800a5da:	4629      	mov	r1, r5
            entry_speed_sqr = next->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 800a5dc:	4606      	mov	r6, r0
            current->entry_speed_sqr = entry_speed_sqr < current->max_entry_speed_sqr ? entry_speed_sqr : current->max_entry_speed_sqr;
 800a5de:	f7f6 fa81 	bl	8000ae4 <__aeabi_fcmple>
 800a5e2:	b900      	cbnz	r0, 800a5e6 <planner_recalculate+0xaa>
 800a5e4:	462e      	mov	r6, r5
 800a5e6:	f8cb 6020 	str.w	r6, [fp, #32]
    } else while (block_index != block_buffer_planned) { // Three or more plan-able blocks
 800a5ea:	45ba      	cmp	sl, r7
 800a5ec:	d015      	beq.n	800a61a <planner_recalculate+0xde>
 800a5ee:	4653      	mov	r3, sl
        current = &block_buffer[block_index];
 800a5f0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 800a5f4:	4626      	mov	r6, r4
 800a5f6:	005d      	lsls	r5, r3, #1
 800a5f8:	eb08 1442 	add.w	r4, r8, r2, lsl #5
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a5fc:	2b00      	cmp	r3, #0
 800a5fe:	d1cf      	bne.n	800a5a0 <planner_recalculate+0x64>
 800a600:	f04f 0a23 	mov.w	sl, #35	; 0x23
        if (block_index == block_buffer_tail)
 800a604:	f8d9 1000 	ldr.w	r1, [r9]
 800a608:	4551      	cmp	r1, sl
 800a60a:	d1cf      	bne.n	800a5ac <planner_recalculate+0x70>
 800a60c:	9301      	str	r3, [sp, #4]
            st_update_plan_block_parameters();
 800a60e:	f005 ff83 	bl	8010518 <st_update_plan_block_parameters>
 800a612:	9b02      	ldr	r3, [sp, #8]
 800a614:	681f      	ldr	r7, [r3, #0]
 800a616:	9b01      	ldr	r3, [sp, #4]
 800a618:	e7c8      	b.n	800a5ac <planner_recalculate+0x70>
 800a61a:	4b43      	ldr	r3, [pc, #268]	; (800a728 <planner_recalculate+0x1ec>)
 800a61c:	681b      	ldr	r3, [r3, #0]
 800a61e:	9301      	str	r3, [sp, #4]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a620:	2f23      	cmp	r7, #35	; 0x23
 800a622:	bf08      	it	eq
 800a624:	2400      	moveq	r4, #0
    // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
    // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
    next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
    block_index = plan_next_block_index(block_buffer_planned);

    while (block_index != block_buffer_head) {
 800a626:	9b01      	ldr	r3, [sp, #4]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a628:	bf18      	it	ne
 800a62a:	1c7c      	addne	r4, r7, #1
    next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
 800a62c:	eb07 0b47 	add.w	fp, r7, r7, lsl #1
    while (block_index != block_buffer_head) {
 800a630:	429c      	cmp	r4, r3
    next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
 800a632:	eb08 1b4b 	add.w	fp, r8, fp, lsl #5
    while (block_index != block_buffer_head) {
 800a636:	d035      	beq.n	800a6a4 <planner_recalculate+0x168>

        current = next;
        next = &block_buffer[block_index];
 800a638:	eb04 0644 	add.w	r6, r4, r4, lsl #1
 800a63c:	eb08 1646 	add.w	r6, r8, r6, lsl #5

        // Any acceleration detected in the forward pass automatically moves the optimal planned
        // pointer forward, since everything before this is all optimal. In other words, nothing
        // can improve the plan from the buffer tail to the planned pointer by logic.
        if (current->entry_speed_sqr < next->entry_speed_sqr) {
 800a640:	f8d6 a020 	ldr.w	sl, [r6, #32]
 800a644:	f8db 9020 	ldr.w	r9, [fp, #32]
 800a648:	4650      	mov	r0, sl
 800a64a:	4649      	mov	r1, r9
 800a64c:	f7f6 fa5e 	bl	8000b0c <__aeabi_fcmpgt>
        next = &block_buffer[block_index];
 800a650:	0065      	lsls	r5, r4, #1
        if (current->entry_speed_sqr < next->entry_speed_sqr) {
 800a652:	b1a0      	cbz	r0, 800a67e <planner_recalculate+0x142>
            entry_speed_sqr = current->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 800a654:	f8db 1028 	ldr.w	r1, [fp, #40]	; 0x28
 800a658:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
 800a65c:	f7f6 f89a 	bl	8000794 <__aeabi_fmul>
 800a660:	4601      	mov	r1, r0
 800a662:	f7f5 ff8f 	bl	8000584 <__addsf3>
 800a666:	4649      	mov	r1, r9
 800a668:	f7f5 ff8c 	bl	8000584 <__addsf3>
        // If true, current block is full-acceleration and we can move the planned pointer forward.
            if (entry_speed_sqr < next->entry_speed_sqr) {
 800a66c:	4651      	mov	r1, sl
            entry_speed_sqr = current->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 800a66e:	4683      	mov	fp, r0
            if (entry_speed_sqr < next->entry_speed_sqr) {
 800a670:	f7f6 fa2e 	bl	8000ad0 <__aeabi_fcmplt>
 800a674:	b118      	cbz	r0, 800a67e <planner_recalculate+0x142>
            entry_speed_sqr = current->entry_speed_sqr + 2.0f * current->acceleration * current->millimeters;
 800a676:	46da      	mov	sl, fp
                next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
 800a678:	4627      	mov	r7, r4
 800a67a:	f8c6 b020 	str.w	fp, [r6, #32]

        // Any block set at its maximum entry speed also creates an optimal plan up to this
        // point in the buffer. When the plan is bracketed by either the beginning of the
        // buffer and a maximum entry speed or two maximum entry speeds, every block in between
        // cannot logically be further improved. Hence, we don't have to recompute them anymore.
        if (next->entry_speed_sqr == next->max_entry_speed_sqr)
 800a67e:	4425      	add	r5, r4
 800a680:	eb08 1545 	add.w	r5, r8, r5, lsl #5
 800a684:	4650      	mov	r0, sl
 800a686:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800a688:	f7f6 fa18 	bl	8000abc <__aeabi_fcmpeq>
 800a68c:	2800      	cmp	r0, #0
 800a68e:	bf18      	it	ne
 800a690:	4627      	movne	r7, r4
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a692:	2c23      	cmp	r4, #35	; 0x23
    while (block_index != block_buffer_head) {
 800a694:	9b01      	ldr	r3, [sp, #4]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a696:	f104 0401 	add.w	r4, r4, #1
 800a69a:	d01d      	beq.n	800a6d8 <planner_recalculate+0x19c>
    while (block_index != block_buffer_head) {
 800a69c:	429c      	cmp	r4, r3
 800a69e:	d11e      	bne.n	800a6de <planner_recalculate+0x1a2>
 800a6a0:	9b02      	ldr	r3, [sp, #8]
 800a6a2:	601f      	str	r7, [r3, #0]
            block_buffer_planned = block_index;

        block_index = plan_next_block_index(block_index);
    }
}
 800a6a4:	b005      	add	sp, #20
 800a6a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 800a6aa:	9903      	ldr	r1, [sp, #12]
 800a6ac:	460e      	mov	r6, r1
 800a6ae:	601e      	str	r6, [r3, #0]
    return block_index == 0 ? (BLOCK_BUFFER_SIZE - 1) : block_index - 1;
 800a6b0:	2d00      	cmp	r5, #0
 800a6b2:	f43f af6e 	beq.w	800a592 <planner_recalculate+0x56>
 800a6b6:	9b01      	ldr	r3, [sp, #4]
 800a6b8:	3b02      	subs	r3, #2
    if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
 800a6ba:	42bb      	cmp	r3, r7
 800a6bc:	f47f af6d 	bne.w	800a59a <planner_recalculate+0x5e>
        if (block_index == block_buffer_tail)
 800a6c0:	4b1b      	ldr	r3, [pc, #108]	; (800a730 <planner_recalculate+0x1f4>)
 800a6c2:	681b      	ldr	r3, [r3, #0]
 800a6c4:	42bb      	cmp	r3, r7
 800a6c6:	d1ab      	bne.n	800a620 <planner_recalculate+0xe4>
            st_update_plan_block_parameters();
 800a6c8:	f005 ff26 	bl	8010518 <st_update_plan_block_parameters>
 800a6cc:	4b16      	ldr	r3, [pc, #88]	; (800a728 <planner_recalculate+0x1ec>)
 800a6ce:	681b      	ldr	r3, [r3, #0]
 800a6d0:	9301      	str	r3, [sp, #4]
 800a6d2:	9b02      	ldr	r3, [sp, #8]
 800a6d4:	681f      	ldr	r7, [r3, #0]
 800a6d6:	e7a3      	b.n	800a620 <planner_recalculate+0xe4>
    while (block_index != block_buffer_head) {
 800a6d8:	2b00      	cmp	r3, #0
 800a6da:	d0e1      	beq.n	800a6a0 <planner_recalculate+0x164>
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a6dc:	2400      	movs	r4, #0
        next = &block_buffer[block_index];
 800a6de:	46b3      	mov	fp, r6
 800a6e0:	e7aa      	b.n	800a638 <planner_recalculate+0xfc>
    if (block_index == block_buffer_planned)
 800a6e2:	4b12      	ldr	r3, [pc, #72]	; (800a72c <planner_recalculate+0x1f0>)
 800a6e4:	681f      	ldr	r7, [r3, #0]
 800a6e6:	9302      	str	r3, [sp, #8]
 800a6e8:	2f23      	cmp	r7, #35	; 0x23
 800a6ea:	d0db      	beq.n	800a6a4 <planner_recalculate+0x168>
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 800a6ec:	f8df 8048 	ldr.w	r8, [pc, #72]	; 800a738 <planner_recalculate+0x1fc>
 800a6f0:	f8d8 1d4c 	ldr.w	r1, [r8, #3404]	; 0xd4c
 800a6f4:	f8d8 0d48 	ldr.w	r0, [r8, #3400]	; 0xd48
 800a6f8:	f7f6 f84c 	bl	8000794 <__aeabi_fmul>
 800a6fc:	4601      	mov	r1, r0
 800a6fe:	f7f5 ff41 	bl	8000584 <__addsf3>
 800a702:	f8d8 5d44 	ldr.w	r5, [r8, #3396]	; 0xd44
 800a706:	4604      	mov	r4, r0
 800a708:	4629      	mov	r1, r5
 800a70a:	f7f6 f9eb 	bl	8000ae4 <__aeabi_fcmple>
 800a70e:	b120      	cbz	r0, 800a71a <planner_recalculate+0x1de>
 800a710:	f8c8 4d40 	str.w	r4, [r8, #3392]	; 0xd40
 800a714:	2322      	movs	r3, #34	; 0x22
    plan_block_t *current = &block_buffer[block_index];
 800a716:	4c07      	ldr	r4, [pc, #28]	; (800a734 <planner_recalculate+0x1f8>)
 800a718:	e73c      	b.n	800a594 <planner_recalculate+0x58>
    current->entry_speed_sqr = min(current->max_entry_speed_sqr, 2.0f * current->acceleration * current->millimeters);
 800a71a:	462c      	mov	r4, r5
 800a71c:	2322      	movs	r3, #34	; 0x22
 800a71e:	f8c8 4d40 	str.w	r4, [r8, #3392]	; 0xd40
    plan_block_t *current = &block_buffer[block_index];
 800a722:	4c04      	ldr	r4, [pc, #16]	; (800a734 <planner_recalculate+0x1f8>)
 800a724:	e736      	b.n	800a594 <planner_recalculate+0x58>
 800a726:	bf00      	nop
 800a728:	20001818 	.word	0x20001818
 800a72c:	2000181c 	.word	0x2000181c
 800a730:	20001820 	.word	0x20001820
 800a734:	200017b8 	.word	0x200017b8
 800a738:	20000a98 	.word	0x20000a98

0800a73c <plan_reset>:
    block_buffer_planned = 0;   // = block_buffer_tail;
}


void plan_reset ()
{
 800a73c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    static bool soft_reset = false;
    memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 800a740:	2400      	movs	r4, #0
    plan_reset_buffer(soft_reset);
 800a742:	f8df 8088 	ldr.w	r8, [pc, #136]	; 800a7cc <plan_reset+0x90>
    memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 800a746:	4a1b      	ldr	r2, [pc, #108]	; (800a7b4 <plan_reset+0x78>)
    if((block_buffer_tail = soft_reset ? BLOCK_BUFFER_SIZE : 0))
 800a748:	f898 1000 	ldrb.w	r1, [r8]
    memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 800a74c:	e9c2 4400 	strd	r4, r4, [r2]
 800a750:	e9c2 4402 	strd	r4, r4, [r2, #8]
 800a754:	e9c2 4404 	strd	r4, r4, [r2, #16]
 800a758:	6194      	str	r4, [r2, #24]
    if((block_buffer_tail = soft_reset ? BLOCK_BUFFER_SIZE : 0))
 800a75a:	b341      	cbz	r1, 800a7ae <plan_reset+0x72>
 800a75c:	2723      	movs	r7, #35	; 0x23
 800a75e:	4e16      	ldr	r6, [pc, #88]	; (800a7b8 <plan_reset+0x7c>)
 800a760:	f8df 9064 	ldr.w	r9, [pc, #100]	; 800a7c8 <plan_reset+0x8c>
    if(block->message) {
 800a764:	f8d6 0d78 	ldr.w	r0, [r6, #3448]	; 0xd78
          block_buffer_tail--;
 800a768:	f8c9 7000 	str.w	r7, [r9]
    if(block->message) {
 800a76c:	b118      	cbz	r0, 800a776 <plan_reset+0x3a>
        free(block->message);
 800a76e:	f007 fa65 	bl	8011c3c <free>
        block->message = NULL;
 800a772:	f8c6 4d78 	str.w	r4, [r6, #3448]	; 0xd78
    while(block->output_commands) {
 800a776:	f8d6 5d7c 	ldr.w	r5, [r6, #3452]	; 0xd7c
 800a77a:	b13d      	cbz	r5, 800a78c <plan_reset+0x50>
        output_command_t *next = block->output_commands->next;
 800a77c:	4628      	mov	r0, r5
 800a77e:	68ad      	ldr	r5, [r5, #8]
        free(block->output_commands);
 800a780:	f007 fa5c 	bl	8011c3c <free>
        block->output_commands = next;
 800a784:	f8c6 5d7c 	str.w	r5, [r6, #3452]	; 0xd7c
    while(block->output_commands) {
 800a788:	2d00      	cmp	r5, #0
 800a78a:	d1f7      	bne.n	800a77c <plan_reset+0x40>
    } while(block_buffer_tail);
 800a78c:	3f01      	subs	r7, #1
 800a78e:	1c7b      	adds	r3, r7, #1
 800a790:	f1a6 0660 	sub.w	r6, r6, #96	; 0x60
 800a794:	d1e6      	bne.n	800a764 <plan_reset+0x28>
    block_buffer_head = 0;      // Empty = tail
 800a796:	2200      	movs	r2, #0
    next_buffer_head = 1;       // plan_next_block_index(block_buffer_head)
 800a798:	2301      	movs	r3, #1
    block_buffer_head = 0;      // Empty = tail
 800a79a:	4c08      	ldr	r4, [pc, #32]	; (800a7bc <plan_reset+0x80>)
    block_buffer_planned = 0;   // = block_buffer_tail;
 800a79c:	4808      	ldr	r0, [pc, #32]	; (800a7c0 <plan_reset+0x84>)
    next_buffer_head = 1;       // plan_next_block_index(block_buffer_head)
 800a79e:	4909      	ldr	r1, [pc, #36]	; (800a7c4 <plan_reset+0x88>)
    block_buffer_head = 0;      // Empty = tail
 800a7a0:	6022      	str	r2, [r4, #0]
    block_buffer_planned = 0;   // = block_buffer_tail;
 800a7a2:	6002      	str	r2, [r0, #0]
    soft_reset = true;
 800a7a4:	f888 3000 	strb.w	r3, [r8]
    next_buffer_head = 1;       // plan_next_block_index(block_buffer_head)
 800a7a8:	600b      	str	r3, [r1, #0]
}
 800a7aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if((block_buffer_tail = soft_reset ? BLOCK_BUFFER_SIZE : 0))
 800a7ae:	4b06      	ldr	r3, [pc, #24]	; (800a7c8 <plan_reset+0x8c>)
 800a7b0:	6019      	str	r1, [r3, #0]
 800a7b2:	e7f0      	b.n	800a796 <plan_reset+0x5a>
 800a7b4:	20001828 	.word	0x20001828
 800a7b8:	20000a98 	.word	0x20000a98
 800a7bc:	20001818 	.word	0x20001818
 800a7c0:	2000181c 	.word	0x2000181c
 800a7c4:	20001824 	.word	0x20001824
 800a7c8:	20001820 	.word	0x20001820
 800a7cc:	20001844 	.word	0x20001844

0800a7d0 <plan_discard_current_block>:


void plan_discard_current_block ()
{
 800a7d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
 800a7d4:	4b14      	ldr	r3, [pc, #80]	; (800a828 <plan_discard_current_block+0x58>)
 800a7d6:	4f15      	ldr	r7, [pc, #84]	; (800a82c <plan_discard_current_block+0x5c>)
 800a7d8:	681b      	ldr	r3, [r3, #0]
 800a7da:	683d      	ldr	r5, [r7, #0]
 800a7dc:	42ab      	cmp	r3, r5
 800a7de:	d021      	beq.n	800a824 <plan_discard_current_block+0x54>
        uint_fast8_t block_index = plan_next_block_index(block_buffer_tail);
        plan_cleanup(&block_buffer[block_buffer_tail]);
 800a7e0:	4e13      	ldr	r6, [pc, #76]	; (800a830 <plan_discard_current_block+0x60>)
 800a7e2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 800a7e6:	eb06 1643 	add.w	r6, r6, r3, lsl #5
    if(block->message) {
 800a7ea:	6db0      	ldr	r0, [r6, #88]	; 0x58
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a7ec:	2d23      	cmp	r5, #35	; 0x23
 800a7ee:	bf0c      	ite	eq
 800a7f0:	f04f 0800 	moveq.w	r8, #0
 800a7f4:	f105 0801 	addne.w	r8, r5, #1
    if(block->message) {
 800a7f8:	b118      	cbz	r0, 800a802 <plan_discard_current_block+0x32>
        free(block->message);
 800a7fa:	f007 fa1f 	bl	8011c3c <free>
        block->message = NULL;
 800a7fe:	2300      	movs	r3, #0
 800a800:	65b3      	str	r3, [r6, #88]	; 0x58
    while(block->output_commands) {
 800a802:	6df4      	ldr	r4, [r6, #92]	; 0x5c
 800a804:	b134      	cbz	r4, 800a814 <plan_discard_current_block+0x44>
        output_command_t *next = block->output_commands->next;
 800a806:	4620      	mov	r0, r4
 800a808:	68a4      	ldr	r4, [r4, #8]
        free(block->output_commands);
 800a80a:	f007 fa17 	bl	8011c3c <free>
        block->output_commands = next;
 800a80e:	65f4      	str	r4, [r6, #92]	; 0x5c
    while(block->output_commands) {
 800a810:	2c00      	cmp	r4, #0
 800a812:	d1f8      	bne.n	800a806 <plan_discard_current_block+0x36>
        // Push block_buffer_planned pointer, if encountered.
        if (block_buffer_tail == block_buffer_planned)
 800a814:	4b07      	ldr	r3, [pc, #28]	; (800a834 <plan_discard_current_block+0x64>)
            block_buffer_planned = block_index;
        block_buffer_tail = block_index;
 800a816:	f8c7 8000 	str.w	r8, [r7]
        if (block_buffer_tail == block_buffer_planned)
 800a81a:	681a      	ldr	r2, [r3, #0]
 800a81c:	4295      	cmp	r5, r2
            block_buffer_planned = block_index;
 800a81e:	bf08      	it	eq
 800a820:	f8c3 8000 	streq.w	r8, [r3]
    }
}
 800a824:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a828:	20001818 	.word	0x20001818
 800a82c:	20001820 	.word	0x20001820
 800a830:	20000a98 	.word	0x20000a98
 800a834:	2000181c 	.word	0x2000181c

0800a838 <plan_get_system_motion_block>:


// Returns address of planner buffer block used by system motions. Called by segment generator.
plan_block_t *plan_get_system_motion_block ()
{
    return &block_buffer[block_buffer_head];
 800a838:	4b03      	ldr	r3, [pc, #12]	; (800a848 <plan_get_system_motion_block+0x10>)
 800a83a:	4804      	ldr	r0, [pc, #16]	; (800a84c <plan_get_system_motion_block+0x14>)
 800a83c:	681b      	ldr	r3, [r3, #0]
 800a83e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
}
 800a842:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 800a846:	4770      	bx	lr
 800a848:	20001818 	.word	0x20001818
 800a84c:	20000a98 	.word	0x20000a98

0800a850 <plan_get_current_block>:


// Returns address of first planner block, if available. Called by various main program functions.
plan_block_t *plan_get_current_block ()
{
    return block_buffer_head == block_buffer_tail ? NULL : &block_buffer[block_buffer_tail];
 800a850:	4b06      	ldr	r3, [pc, #24]	; (800a86c <plan_get_current_block+0x1c>)
 800a852:	4a07      	ldr	r2, [pc, #28]	; (800a870 <plan_get_current_block+0x20>)
 800a854:	681b      	ldr	r3, [r3, #0]
 800a856:	6812      	ldr	r2, [r2, #0]
 800a858:	429a      	cmp	r2, r3
 800a85a:	bf1d      	ittte	ne
 800a85c:	4805      	ldrne	r0, [pc, #20]	; (800a874 <plan_get_current_block+0x24>)
 800a85e:	eb03 0343 	addne.w	r3, r3, r3, lsl #1
 800a862:	eb00 1043 	addne.w	r0, r0, r3, lsl #5
 800a866:	2000      	moveq	r0, #0
}
 800a868:	4770      	bx	lr
 800a86a:	bf00      	nop
 800a86c:	20001820 	.word	0x20001820
 800a870:	20001818 	.word	0x20001818
 800a874:	20000a98 	.word	0x20000a98

0800a878 <plan_get_exec_block_exit_speed_sqr>:


inline float plan_get_exec_block_exit_speed_sqr ()
{
    uint_fast8_t block_index = plan_next_block_index(block_buffer_tail);
 800a878:	4b09      	ldr	r3, [pc, #36]	; (800a8a0 <plan_get_exec_block_exit_speed_sqr+0x28>)
    return block_index == block_buffer_head ? 0.0f : block_buffer[block_index].entry_speed_sqr;
 800a87a:	4a0a      	ldr	r2, [pc, #40]	; (800a8a4 <plan_get_exec_block_exit_speed_sqr+0x2c>)
    uint_fast8_t block_index = plan_next_block_index(block_buffer_tail);
 800a87c:	681b      	ldr	r3, [r3, #0]
    return block_index == block_buffer_head ? 0.0f : block_buffer[block_index].entry_speed_sqr;
 800a87e:	6812      	ldr	r2, [r2, #0]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a880:	2b23      	cmp	r3, #35	; 0x23
 800a882:	bf0c      	ite	eq
 800a884:	2300      	moveq	r3, #0
 800a886:	3301      	addne	r3, #1
    return block_index == block_buffer_head ? 0.0f : block_buffer[block_index].entry_speed_sqr;
 800a888:	429a      	cmp	r2, r3
 800a88a:	d006      	beq.n	800a89a <plan_get_exec_block_exit_speed_sqr+0x22>
 800a88c:	4a06      	ldr	r2, [pc, #24]	; (800a8a8 <plan_get_exec_block_exit_speed_sqr+0x30>)
 800a88e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800a892:	eb02 1343 	add.w	r3, r2, r3, lsl #5
 800a896:	6a18      	ldr	r0, [r3, #32]
 800a898:	4770      	bx	lr
 800a89a:	2000      	movs	r0, #0
}
 800a89c:	4770      	bx	lr
 800a89e:	bf00      	nop
 800a8a0:	20001820 	.word	0x20001820
 800a8a4:	20001818 	.word	0x20001818
 800a8a8:	20000a98 	.word	0x20000a98

0800a8ac <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
bool plan_check_full_buffer ()
{
    return block_buffer_tail == next_buffer_head;
 800a8ac:	4a04      	ldr	r2, [pc, #16]	; (800a8c0 <plan_check_full_buffer+0x14>)
 800a8ae:	4b05      	ldr	r3, [pc, #20]	; (800a8c4 <plan_check_full_buffer+0x18>)
 800a8b0:	6810      	ldr	r0, [r2, #0]
 800a8b2:	681b      	ldr	r3, [r3, #0]
}
 800a8b4:	1ac0      	subs	r0, r0, r3
 800a8b6:	fab0 f080 	clz	r0, r0
 800a8ba:	0940      	lsrs	r0, r0, #5
 800a8bc:	4770      	bx	lr
 800a8be:	bf00      	nop
 800a8c0:	20001820 	.word	0x20001820
 800a8c4:	20001824 	.word	0x20001824

0800a8c8 <plan_compute_profile_nominal_speed>:


// Computes and returns block nominal speed based on running condition and override values.
// NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
float plan_compute_profile_nominal_speed (plan_block_t *block)
{
 800a8c8:	b530      	push	{r4, r5, lr}
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a8ca:	f990 3016 	ldrsb.w	r3, [r0, #22]
{
 800a8ce:	4604      	mov	r4, r0
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a8d0:	2b00      	cmp	r3, #0
{
 800a8d2:	b089      	sub	sp, #36	; 0x24
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a8d4:	db30      	blt.n	800a938 <plan_compute_profile_nominal_speed+0x70>
 800a8d6:	6b85      	ldr	r5, [r0, #56]	; 0x38

    if (block->condition.rapid_motion)
 800a8d8:	7d23      	ldrb	r3, [r4, #20]
 800a8da:	07da      	lsls	r2, r3, #31
 800a8dc:	d515      	bpl.n	800a90a <plan_compute_profile_nominal_speed+0x42>
        nominal_speed *= (0.01f * sys.override.rapid_rate);
 800a8de:	4b1d      	ldr	r3, [pc, #116]	; (800a954 <plan_compute_profile_nominal_speed+0x8c>)
 800a8e0:	7bd8      	ldrb	r0, [r3, #15]
 800a8e2:	f7f5 ff03 	bl	80006ec <__aeabi_i2f>
 800a8e6:	491c      	ldr	r1, [pc, #112]	; (800a958 <plan_compute_profile_nominal_speed+0x90>)
 800a8e8:	f7f5 ff54 	bl	8000794 <__aeabi_fmul>
 800a8ec:	4629      	mov	r1, r5
 800a8ee:	f7f5 ff51 	bl	8000794 <__aeabi_fmul>
 800a8f2:	4604      	mov	r4, r0
        if (nominal_speed > block->rapid_rate)
            nominal_speed = block->rapid_rate;
    }

// TODO: if nominal speed is outside bounds when synchronized motion is on then (?? retract and) abort, ignore overrides?
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 800a8f4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800a8f8:	4620      	mov	r0, r4
 800a8fa:	f7f6 f8fd 	bl	8000af8 <__aeabi_fcmpge>
 800a8fe:	b908      	cbnz	r0, 800a904 <plan_compute_profile_nominal_speed+0x3c>
 800a900:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
}
 800a904:	4620      	mov	r0, r4
 800a906:	b009      	add	sp, #36	; 0x24
 800a908:	bd30      	pop	{r4, r5, pc}
        if (!block->condition.no_feed_override)
 800a90a:	06db      	lsls	r3, r3, #27
 800a90c:	d40b      	bmi.n	800a926 <plan_compute_profile_nominal_speed+0x5e>
            nominal_speed *= (0.01f * sys.override.feed_rate);
 800a90e:	4b11      	ldr	r3, [pc, #68]	; (800a954 <plan_compute_profile_nominal_speed+0x8c>)
 800a910:	7b98      	ldrb	r0, [r3, #14]
 800a912:	f7f5 feeb 	bl	80006ec <__aeabi_i2f>
 800a916:	4910      	ldr	r1, [pc, #64]	; (800a958 <plan_compute_profile_nominal_speed+0x90>)
 800a918:	f7f5 ff3c 	bl	8000794 <__aeabi_fmul>
 800a91c:	4601      	mov	r1, r0
 800a91e:	4628      	mov	r0, r5
 800a920:	f7f5 ff38 	bl	8000794 <__aeabi_fmul>
 800a924:	4605      	mov	r5, r0
        if (nominal_speed > block->rapid_rate)
 800a926:	6b64      	ldr	r4, [r4, #52]	; 0x34
 800a928:	4629      	mov	r1, r5
 800a92a:	4620      	mov	r0, r4
 800a92c:	f7f6 f8da 	bl	8000ae4 <__aeabi_fcmple>
 800a930:	2800      	cmp	r0, #0
 800a932:	d1df      	bne.n	800a8f4 <plan_compute_profile_nominal_speed+0x2c>
 800a934:	462c      	mov	r4, r5
 800a936:	e7dd      	b.n	800a8f4 <plan_compute_profile_nominal_speed+0x2c>
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a938:	4b08      	ldr	r3, [pc, #32]	; (800a95c <plan_compute_profile_nominal_speed+0x94>)
 800a93a:	6b85      	ldr	r5, [r0, #56]	; 0x38
 800a93c:	2101      	movs	r1, #1
 800a93e:	4668      	mov	r0, sp
 800a940:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800a944:	4798      	blx	r3
 800a946:	4628      	mov	r0, r5
 800a948:	9902      	ldr	r1, [sp, #8]
 800a94a:	f7f5 ff23 	bl	8000794 <__aeabi_fmul>
 800a94e:	4605      	mov	r5, r0
 800a950:	e7c2      	b.n	800a8d8 <plan_compute_profile_nominal_speed+0x10>
 800a952:	bf00      	nop
 800a954:	20002494 	.word	0x20002494
 800a958:	3c23d70a 	.word	0x3c23d70a
 800a95c:	200024bc 	.word	0x200024bc

0800a960 <plan_update_velocity_profile_parameters>:
}

// Re-calculates buffered motions profile parameters upon a motion-based override change.
void plan_update_velocity_profile_parameters ()
{
    uint_fast8_t block_index = block_buffer_tail;
 800a960:	4b43      	ldr	r3, [pc, #268]	; (800aa70 <plan_update_velocity_profile_parameters+0x110>)
{
 800a962:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint_fast8_t block_index = block_buffer_tail;
 800a966:	681d      	ldr	r5, [r3, #0]
    plan_block_t *block;
    float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.

    while (block_index != block_buffer_head) {
 800a968:	4b42      	ldr	r3, [pc, #264]	; (800aa74 <plan_update_velocity_profile_parameters+0x114>)
{
 800a96a:	b089      	sub	sp, #36	; 0x24
    while (block_index != block_buffer_head) {
 800a96c:	681b      	ldr	r3, [r3, #0]
 800a96e:	429d      	cmp	r5, r3
 800a970:	d078      	beq.n	800aa64 <plan_update_velocity_profile_parameters+0x104>
    float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 800a972:	f8df 8114 	ldr.w	r8, [pc, #276]	; 800aa88 <plan_update_velocity_profile_parameters+0x128>
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 800a976:	f04f 5a7e 	mov.w	sl, #1065353216	; 0x3f800000
 800a97a:	46c3      	mov	fp, r8
 800a97c:	4699      	mov	r9, r3
 800a97e:	4f3e      	ldr	r7, [pc, #248]	; (800aa78 <plan_update_velocity_profile_parameters+0x118>)
 800a980:	e02b      	b.n	800a9da <plan_update_velocity_profile_parameters+0x7a>
        nominal_speed *= (0.01f * sys.override.rapid_rate);
 800a982:	4b3e      	ldr	r3, [pc, #248]	; (800aa7c <plan_update_velocity_profile_parameters+0x11c>)
 800a984:	7bd8      	ldrb	r0, [r3, #15]
 800a986:	f7f5 feb1 	bl	80006ec <__aeabi_i2f>
 800a98a:	493d      	ldr	r1, [pc, #244]	; (800aa80 <plan_update_velocity_profile_parameters+0x120>)
 800a98c:	f7f5 ff02 	bl	8000794 <__aeabi_fmul>
 800a990:	4641      	mov	r1, r8
 800a992:	f7f5 feff 	bl	8000794 <__aeabi_fmul>
 800a996:	4604      	mov	r4, r0
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 800a998:	4651      	mov	r1, sl
 800a99a:	4620      	mov	r0, r4
 800a99c:	f7f6 f8ac 	bl	8000af8 <__aeabi_fcmpge>
 800a9a0:	b900      	cbnz	r0, 800a9a4 <plan_update_velocity_profile_parameters+0x44>
 800a9a2:	4654      	mov	r4, sl
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800a9a4:	4659      	mov	r1, fp
 800a9a6:	4620      	mov	r0, r4
 800a9a8:	f7f6 f8b0 	bl	8000b0c <__aeabi_fcmpgt>
        block = &block_buffer[block_index];
        prev_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), prev_nominal_speed);
 800a9ac:	f8d6 8030 	ldr.w	r8, [r6, #48]	; 0x30
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800a9b0:	2800      	cmp	r0, #0
 800a9b2:	d04c      	beq.n	800aa4e <plan_update_velocity_profile_parameters+0xee>
 800a9b4:	4659      	mov	r1, fp
 800a9b6:	4658      	mov	r0, fp
 800a9b8:	f7f5 feec 	bl	8000794 <__aeabi_fmul>
 800a9bc:	4683      	mov	fp, r0
    if (block->max_entry_speed_sqr > block->max_junction_speed_sqr)
 800a9be:	4659      	mov	r1, fp
 800a9c0:	4640      	mov	r0, r8
 800a9c2:	f7f6 f88f 	bl	8000ae4 <__aeabi_fcmple>
 800a9c6:	b900      	cbnz	r0, 800a9ca <plan_update_velocity_profile_parameters+0x6a>
 800a9c8:	46d8      	mov	r8, fp
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800a9ca:	2d23      	cmp	r5, #35	; 0x23
 800a9cc:	f8c6 8024 	str.w	r8, [r6, #36]	; 0x24
 800a9d0:	d043      	beq.n	800aa5a <plan_update_velocity_profile_parameters+0xfa>
 800a9d2:	3501      	adds	r5, #1
    while (block_index != block_buffer_head) {
 800a9d4:	454d      	cmp	r5, r9
 800a9d6:	d046      	beq.n	800aa66 <plan_update_velocity_profile_parameters+0x106>
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 800a9d8:	46a3      	mov	fp, r4
        block = &block_buffer[block_index];
 800a9da:	eb05 0645 	add.w	r6, r5, r5, lsl #1
 800a9de:	eb07 1646 	add.w	r6, r7, r6, lsl #5
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a9e2:	f996 3016 	ldrsb.w	r3, [r6, #22]
 800a9e6:	f8d6 8038 	ldr.w	r8, [r6, #56]	; 0x38
 800a9ea:	2b00      	cmp	r3, #0
        block = &block_buffer[block_index];
 800a9ec:	ea4f 0445 	mov.w	r4, r5, lsl #1
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800a9f0:	da0d      	bge.n	800aa0e <plan_update_velocity_profile_parameters+0xae>
 800a9f2:	4b24      	ldr	r3, [pc, #144]	; (800aa84 <plan_update_velocity_profile_parameters+0x124>)
 800a9f4:	2101      	movs	r1, #1
 800a9f6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 800a9fa:	4668      	mov	r0, sp
 800a9fc:	4798      	blx	r3
 800a9fe:	4640      	mov	r0, r8
 800aa00:	9902      	ldr	r1, [sp, #8]
 800aa02:	f7f5 fec7 	bl	8000794 <__aeabi_fmul>
 800aa06:	4680      	mov	r8, r0
 800aa08:	4b1a      	ldr	r3, [pc, #104]	; (800aa74 <plan_update_velocity_profile_parameters+0x114>)
 800aa0a:	f8d3 9000 	ldr.w	r9, [r3]
    if (block->condition.rapid_motion)
 800aa0e:	1963      	adds	r3, r4, r5
 800aa10:	eb07 1343 	add.w	r3, r7, r3, lsl #5
 800aa14:	7d1b      	ldrb	r3, [r3, #20]
 800aa16:	07da      	lsls	r2, r3, #31
 800aa18:	d4b3      	bmi.n	800a982 <plan_update_velocity_profile_parameters+0x22>
        if (!block->condition.no_feed_override)
 800aa1a:	06db      	lsls	r3, r3, #27
 800aa1c:	d40b      	bmi.n	800aa36 <plan_update_velocity_profile_parameters+0xd6>
            nominal_speed *= (0.01f * sys.override.feed_rate);
 800aa1e:	4b17      	ldr	r3, [pc, #92]	; (800aa7c <plan_update_velocity_profile_parameters+0x11c>)
 800aa20:	7b98      	ldrb	r0, [r3, #14]
 800aa22:	f7f5 fe63 	bl	80006ec <__aeabi_i2f>
 800aa26:	4916      	ldr	r1, [pc, #88]	; (800aa80 <plan_update_velocity_profile_parameters+0x120>)
 800aa28:	f7f5 feb4 	bl	8000794 <__aeabi_fmul>
 800aa2c:	4601      	mov	r1, r0
 800aa2e:	4640      	mov	r0, r8
 800aa30:	f7f5 feb0 	bl	8000794 <__aeabi_fmul>
 800aa34:	4680      	mov	r8, r0
        if (nominal_speed > block->rapid_rate)
 800aa36:	442c      	add	r4, r5
 800aa38:	eb07 1444 	add.w	r4, r7, r4, lsl #5
 800aa3c:	6b64      	ldr	r4, [r4, #52]	; 0x34
 800aa3e:	4641      	mov	r1, r8
 800aa40:	4620      	mov	r0, r4
 800aa42:	f7f6 f84f 	bl	8000ae4 <__aeabi_fcmple>
 800aa46:	2800      	cmp	r0, #0
 800aa48:	d1a6      	bne.n	800a998 <plan_update_velocity_profile_parameters+0x38>
 800aa4a:	4644      	mov	r4, r8
 800aa4c:	e7a4      	b.n	800a998 <plan_update_velocity_profile_parameters+0x38>
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800aa4e:	4621      	mov	r1, r4
 800aa50:	4620      	mov	r0, r4
 800aa52:	f7f5 fe9f 	bl	8000794 <__aeabi_fmul>
 800aa56:	4683      	mov	fp, r0
 800aa58:	e7b1      	b.n	800a9be <plan_update_velocity_profile_parameters+0x5e>
    while (block_index != block_buffer_head) {
 800aa5a:	f1b9 0f00 	cmp.w	r9, #0
 800aa5e:	d002      	beq.n	800aa66 <plan_update_velocity_profile_parameters+0x106>
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800aa60:	2500      	movs	r5, #0
 800aa62:	e7b9      	b.n	800a9d8 <plan_update_velocity_profile_parameters+0x78>
    float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculation.
 800aa64:	4c08      	ldr	r4, [pc, #32]	; (800aa88 <plan_update_velocity_profile_parameters+0x128>)
        block_index = plan_next_block_index(block_index);
    }
    pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming block.
 800aa66:	4b09      	ldr	r3, [pc, #36]	; (800aa8c <plan_update_velocity_profile_parameters+0x12c>)
 800aa68:	619c      	str	r4, [r3, #24]
}
 800aa6a:	b009      	add	sp, #36	; 0x24
 800aa6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800aa70:	20001820 	.word	0x20001820
 800aa74:	20001818 	.word	0x20001818
 800aa78:	20000a98 	.word	0x20000a98
 800aa7c:	20002494 	.word	0x20002494
 800aa80:	3c23d70a 	.word	0x3c23d70a
 800aa84:	200024bc 	.word	0x200024bc
 800aa88:	7e967699 	.word	0x7e967699
 800aa8c:	20001828 	.word	0x20001828

0800aa90 <plan_buffer_line>:
   The system motion condition tells the planner to plan a motion in the always unused block buffer
   head. It avoids changing the planner state and preserves the buffer to ensure subsequent gcode
   motions are still planned correctly, while the stepper module only points to the block buffer head
   to execute the special system motion. */
bool plan_buffer_line (float *target, plan_line_data_t *pl_data)
{
 800aa90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aa94:	4603      	mov	r3, r0
 800aa96:	460f      	mov	r7, r1
    // Prepare and initialize new block. Copy relevant pl_data for block execution.
    plan_block_t *block = &block_buffer[block_buffer_head];
 800aa98:	4ab6      	ldr	r2, [pc, #728]	; (800ad74 <plan_buffer_line+0x2e4>)
 800aa9a:	4eb7      	ldr	r6, [pc, #732]	; (800ad78 <plan_buffer_line+0x2e8>)
 800aa9c:	f8d2 9000 	ldr.w	r9, [r2]
{
 800aaa0:	b097      	sub	sp, #92	; 0x5c
 800aaa2:	eb09 0549 	add.w	r5, r9, r9, lsl #1
    plan_block_t *block = &block_buffer[block_buffer_head];
 800aaa6:	eb06 1845 	add.w	r8, r6, r5, lsl #5
    int32_t target_steps[N_AXIS], position_steps[N_AXIS], delta_steps;
    uint_fast8_t idx;
    float unit_vec[N_AXIS];

    memset(block, 0, sizeof(plan_block_t));                         // Zero all block values.
 800aaaa:	2260      	movs	r2, #96	; 0x60
 800aaac:	2100      	movs	r1, #0
 800aaae:	4640      	mov	r0, r8
{
 800aab0:	469a      	mov	sl, r3
 800aab2:	9301      	str	r3, [sp, #4]
    memset(block, 0, sizeof(plan_block_t));                         // Zero all block values.
 800aab4:	f007 f8e6 	bl	8011c84 <memset>
    memcpy(&block->spindle, &pl_data->spindle, sizeof(spindle_t));  // Copy spindle data (RPM etc)
 800aab8:	46bc      	mov	ip, r7
 800aaba:	f85c 0f04 	ldr.w	r0, [ip, #4]!
 800aabe:	016d      	lsls	r5, r5, #5
 800aac0:	f8dc 1004 	ldr.w	r1, [ip, #4]
 800aac4:	f8dc 2008 	ldr.w	r2, [ip, #8]
 800aac8:	f8dc 300c 	ldr.w	r3, [ip, #12]
 800aacc:	f105 043c 	add.w	r4, r5, #60	; 0x3c
 800aad0:	4434      	add	r4, r6
 800aad2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800aad4:	f8dc 0010 	ldr.w	r0, [ip, #16]
 800aad8:	f8dc 1014 	ldr.w	r1, [ip, #20]
 800aadc:	f8dc 2018 	ldr.w	r2, [ip, #24]
 800aae0:	3558      	adds	r5, #88	; 0x58
 800aae2:	c407      	stmia	r4!, {r0, r1, r2}
    block->condition = pl_data->condition;
 800aae4:	6a39      	ldr	r1, [r7, #32]
    block->overrides = pl_data->overrides;
 800aae6:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
    block->line_number = pl_data->line_number;
 800aaea:	6abb      	ldr	r3, [r7, #40]	; 0x28
    block->condition = pl_data->condition;
 800aaec:	f8c8 1014 	str.w	r1, [r8, #20]
    block->line_number = pl_data->line_number;
 800aaf0:	f8c8 301c 	str.w	r3, [r8, #28]
    block->overrides = pl_data->overrides;
 800aaf4:	f888 2018 	strb.w	r2, [r8, #24]
    block->message = pl_data->message;
    block->output_commands = pl_data->output_commands;
 800aaf8:	1973      	adds	r3, r6, r5
    block->message = pl_data->message;
 800aafa:	e9d7 120b 	ldrd	r1, r2, [r7, #44]	; 0x2c
 800aafe:	5171      	str	r1, [r6, r5]
 800ab00:	605a      	str	r2, [r3, #4]

    // Copy position data based on type of motion being planned.
    memcpy(position_steps, block->condition.system_motion ? sys_position : pl.position, sizeof(position_steps));
 800ab02:	f898 b014 	ldrb.w	fp, [r8, #20]
 800ab06:	4a9d      	ldr	r2, [pc, #628]	; (800ad7c <plan_buffer_line+0x2ec>)
 800ab08:	f01b 0f02 	tst.w	fp, #2
 800ab0c:	4b9c      	ldr	r3, [pc, #624]	; (800ad80 <plan_buffer_line+0x2f0>)
 800ab0e:	bf08      	it	eq
 800ab10:	4613      	moveq	r3, r2
        // Calculate target position in absolute steps, number of steps for each axis, and determine max step events.
        // Also, compute individual axes distance for move and prep unit vector calculations.
        // NOTE: Computes true distance from converted step values.

#ifndef KINEMATICS_API
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab12:	4a9c      	ldr	r2, [pc, #624]	; (800ad84 <plan_buffer_line+0x2f4>)
    memcpy(position_steps, block->condition.system_motion ? sys_position : pl.position, sizeof(position_steps));
 800ab14:	ad08      	add	r5, sp, #32
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab16:	68d4      	ldr	r4, [r2, #12]
    memcpy(position_steps, block->condition.system_motion ? sys_position : pl.position, sizeof(position_steps));
 800ab18:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ab1c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab20:	f8da 1008 	ldr.w	r1, [sl, #8]
 800ab24:	4620      	mov	r0, r4
 800ab26:	f7f5 fe35 	bl	8000794 <__aeabi_fmul>
 800ab2a:	f008 f91d 	bl	8012d68 <lroundf>
#endif
        delta_steps = target_steps[idx] - position_steps[idx];
 800ab2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        block->steps[idx] = labs(delta_steps);
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ab30:	f8d8 500c 	ldr.w	r5, [r8, #12]
        delta_steps = target_steps[idx] - position_steps[idx];
 800ab34:	1ac3      	subs	r3, r0, r3
        block->steps[idx] = labs(delta_steps);
 800ab36:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 800ab3a:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ab3e:	428d      	cmp	r5, r1
 800ab40:	bf38      	it	cc
 800ab42:	460d      	movcc	r5, r1
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab44:	4602      	mov	r2, r0
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ab46:	e9c8 1502 	strd	r1, r5, [r8, #8]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ab4a:	4618      	mov	r0, r3
 800ab4c:	9302      	str	r3, [sp, #8]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab4e:	9207      	str	r2, [sp, #28]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ab50:	f7f5 fdcc 	bl	80006ec <__aeabi_i2f>
 800ab54:	4621      	mov	r1, r4
 800ab56:	f7f5 fed1 	bl	80008fc <__aeabi_fdiv>

        // Set direction bits. Bit enabled always means direction is negative.
        if (delta_steps < 0)
 800ab5a:	9b02      	ldr	r3, [sp, #8]
 800ab5c:	ea4f 0a49 	mov.w	sl, r9, lsl #1
 800ab60:	2b00      	cmp	r3, #0
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ab62:	900d      	str	r0, [sp, #52]	; 0x34
        if (delta_steps < 0)
 800ab64:	da05      	bge.n	800ab72 <plan_buffer_line+0xe2>
            block->direction_bits.mask |= bit(idx);
 800ab66:	f898 3010 	ldrb.w	r3, [r8, #16]
 800ab6a:	f043 0304 	orr.w	r3, r3, #4
 800ab6e:	f888 3010 	strb.w	r3, [r8, #16]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab72:	4b84      	ldr	r3, [pc, #528]	; (800ad84 <plan_buffer_line+0x2f4>)
 800ab74:	9a01      	ldr	r2, [sp, #4]
 800ab76:	689b      	ldr	r3, [r3, #8]
 800ab78:	6851      	ldr	r1, [r2, #4]
 800ab7a:	4618      	mov	r0, r3
 800ab7c:	9302      	str	r3, [sp, #8]
 800ab7e:	f7f5 fe09 	bl	8000794 <__aeabi_fmul>
 800ab82:	f008 f8f1 	bl	8012d68 <lroundf>
        delta_steps = target_steps[idx] - position_steps[idx];
 800ab86:	9c09      	ldr	r4, [sp, #36]	; 0x24
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ab88:	4601      	mov	r1, r0
        delta_steps = target_steps[idx] - position_steps[idx];
 800ab8a:	1b04      	subs	r4, r0, r4
        block->steps[idx] = labs(delta_steps);
 800ab8c:	ea84 70e4 	eor.w	r0, r4, r4, asr #31
 800ab90:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ab94:	4285      	cmp	r5, r0
 800ab96:	bf38      	it	cc
 800ab98:	4605      	movcc	r5, r0
        block->steps[idx] = labs(delta_steps);
 800ab9a:	eb0a 0209 	add.w	r2, sl, r9
 800ab9e:	eb06 1242 	add.w	r2, r6, r2, lsl #5
 800aba2:	6050      	str	r0, [r2, #4]
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800aba4:	60d5      	str	r5, [r2, #12]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800aba6:	4620      	mov	r0, r4
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800aba8:	9203      	str	r2, [sp, #12]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800abaa:	9106      	str	r1, [sp, #24]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800abac:	f7f5 fd9e 	bl	80006ec <__aeabi_i2f>
 800abb0:	9b02      	ldr	r3, [sp, #8]
 800abb2:	4619      	mov	r1, r3
 800abb4:	f7f5 fea2 	bl	80008fc <__aeabi_fdiv>
        if (delta_steps < 0)
 800abb8:	2c00      	cmp	r4, #0
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800abba:	900c      	str	r0, [sp, #48]	; 0x30
        if (delta_steps < 0)
 800abbc:	da04      	bge.n	800abc8 <plan_buffer_line+0x138>
            block->direction_bits.mask |= bit(idx);
 800abbe:	9a03      	ldr	r2, [sp, #12]
 800abc0:	7c13      	ldrb	r3, [r2, #16]
 800abc2:	f043 0302 	orr.w	r3, r3, #2
 800abc6:	7413      	strb	r3, [r2, #16]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800abc8:	4b6e      	ldr	r3, [pc, #440]	; (800ad84 <plan_buffer_line+0x2f4>)
 800abca:	9a01      	ldr	r2, [sp, #4]
 800abcc:	685b      	ldr	r3, [r3, #4]
 800abce:	6811      	ldr	r1, [r2, #0]
 800abd0:	4618      	mov	r0, r3
 800abd2:	9302      	str	r3, [sp, #8]
 800abd4:	f7f5 fdde 	bl	8000794 <__aeabi_fmul>
 800abd8:	f008 f8c6 	bl	8012d68 <lroundf>
        delta_steps = target_steps[idx] - position_steps[idx];
 800abdc:	9c08      	ldr	r4, [sp, #32]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800abde:	4601      	mov	r1, r0
        delta_steps = target_steps[idx] - position_steps[idx];
 800abe0:	1b04      	subs	r4, r0, r4
        block->steps[idx] = labs(delta_steps);
 800abe2:	ea84 70e4 	eor.w	r0, r4, r4, asr #31
 800abe6:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800abea:	4285      	cmp	r5, r0
 800abec:	bf38      	it	cc
 800abee:	4605      	movcc	r5, r0
        block->steps[idx] = labs(delta_steps);
 800abf0:	eb0a 0209 	add.w	r2, sl, r9
 800abf4:	ea4f 1c42 	mov.w	ip, r2, lsl #5
 800abf8:	eb06 1242 	add.w	r2, r6, r2, lsl #5
 800abfc:	f846 000c 	str.w	r0, [r6, ip]
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ac00:	60d5      	str	r5, [r2, #12]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ac02:	4620      	mov	r0, r4
        block->step_event_count = max(block->step_event_count, block->steps[idx]);
 800ac04:	9203      	str	r2, [sp, #12]
        target_steps[idx] = lroundf(target[idx] * settings.steps_per_mm[idx]);
 800ac06:	9105      	str	r1, [sp, #20]
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ac08:	f7f5 fd70 	bl	80006ec <__aeabi_i2f>
 800ac0c:	9b02      	ldr	r3, [sp, #8]
 800ac0e:	4619      	mov	r1, r3
 800ac10:	f7f5 fe74 	bl	80008fc <__aeabi_fdiv>
        if (delta_steps < 0)
 800ac14:	2c00      	cmp	r4, #0
        unit_vec[idx] = (float)delta_steps / settings.steps_per_mm[idx]; // Store unit vector numerator
 800ac16:	900b      	str	r0, [sp, #44]	; 0x2c
        if (delta_steps < 0)
 800ac18:	da04      	bge.n	800ac24 <plan_buffer_line+0x194>
            block->direction_bits.mask |= bit(idx);
 800ac1a:	9a03      	ldr	r2, [sp, #12]
 800ac1c:	7c13      	ldrb	r3, [r2, #16]
 800ac1e:	f043 0301 	orr.w	r3, r3, #1
 800ac22:	7413      	strb	r3, [r2, #16]

    } while(idx);

    // Calculate RPMs to be used for Constant Surface Speed calculations
    if(block->condition.is_rpm_pos_adjusted) {
 800ac24:	f01b 0f80 	tst.w	fp, #128	; 0x80
 800ac28:	d105      	bne.n	800ac36 <plan_buffer_line+0x1a6>
        } else
            block->spindle.css.target_rpm = block->spindle.css.max_rpm;
    }

    // Bail if this is a zero-length block. Highly unlikely to occur.
    if (block->step_event_count == 0)
 800ac2a:	2d00      	cmp	r5, #0
 800ac2c:	d15e      	bne.n	800acec <plan_buffer_line+0x25c>
        return false;
 800ac2e:	4628      	mov	r0, r5
        // Finish up by recalculating the plan with the new block.
        planner_recalculate();
    }

    return true;
}
 800ac30:	b017      	add	sp, #92	; 0x5c
 800ac32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if((pos = (float)position_steps[block->spindle.css.axis] / settings.steps_per_mm[block->spindle.css.axis] - block->spindle.css.tool_offset) > 0.0f) {
 800ac36:	eb0a 0309 	add.w	r3, sl, r9
 800ac3a:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800ac3e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ac40:	f8d3 b04c 	ldr.w	fp, [r3, #76]	; 0x4c
 800ac44:	9303      	str	r3, [sp, #12]
 800ac46:	ab16      	add	r3, sp, #88	; 0x58
 800ac48:	eb03 0182 	add.w	r1, r3, r2, lsl #2
 800ac4c:	f851 0c38 	ldr.w	r0, [r1, #-56]
 800ac50:	0094      	lsls	r4, r2, #2
 800ac52:	9202      	str	r2, [sp, #8]
 800ac54:	f7f5 fd4a 	bl	80006ec <__aeabi_i2f>
 800ac58:	4b4a      	ldr	r3, [pc, #296]	; (800ad84 <plan_buffer_line+0x2f4>)
 800ac5a:	441c      	add	r4, r3
 800ac5c:	6861      	ldr	r1, [r4, #4]
 800ac5e:	f7f5 fe4d 	bl	80008fc <__aeabi_fdiv>
 800ac62:	4659      	mov	r1, fp
 800ac64:	f7f5 fc8c 	bl	8000580 <__aeabi_fsub>
 800ac68:	2100      	movs	r1, #0
 800ac6a:	4604      	mov	r4, r0
 800ac6c:	f7f5 ff4e 	bl	8000b0c <__aeabi_fcmpgt>
 800ac70:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800ac74:	2800      	cmp	r0, #0
 800ac76:	f000 80e2 	beq.w	800ae3e <plan_buffer_line+0x3ae>
            block->spindle.rpm = block->spindle.css.surface_speed / (pos * (float)(2.0f * M_PI));
 800ac7a:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800ac7c:	4942      	ldr	r1, [pc, #264]	; (800ad88 <plan_buffer_line+0x2f8>)
 800ac7e:	9203      	str	r2, [sp, #12]
 800ac80:	9302      	str	r3, [sp, #8]
 800ac82:	f7f5 fd87 	bl	8000794 <__aeabi_fmul>
 800ac86:	4621      	mov	r1, r4
 800ac88:	f7f5 fe38 	bl	80008fc <__aeabi_fdiv>
            if(block->spindle.rpm > block->spindle.css.max_rpm)
 800ac8c:	9b02      	ldr	r3, [sp, #8]
 800ac8e:	6c9c      	ldr	r4, [r3, #72]	; 0x48
            block->spindle.rpm = block->spindle.css.surface_speed / (pos * (float)(2.0f * M_PI));
 800ac90:	63d8      	str	r0, [r3, #60]	; 0x3c
            if(block->spindle.rpm > block->spindle.css.max_rpm)
 800ac92:	4621      	mov	r1, r4
 800ac94:	f7f5 ff3a 	bl	8000b0c <__aeabi_fcmpgt>
 800ac98:	9a03      	ldr	r2, [sp, #12]
 800ac9a:	2800      	cmp	r0, #0
 800ac9c:	f040 80c5 	bne.w	800ae2a <plan_buffer_line+0x39a>
        if((pos = target[block->spindle.css.axis] - block->spindle.css.tool_offset) > 0.0f) {
 800aca0:	9b01      	ldr	r3, [sp, #4]
 800aca2:	4659      	mov	r1, fp
 800aca4:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800aca8:	f7f5 fc6a 	bl	8000580 <__aeabi_fsub>
 800acac:	2100      	movs	r1, #0
 800acae:	4604      	mov	r4, r0
 800acb0:	f7f5 ff2c 	bl	8000b0c <__aeabi_fcmpgt>
 800acb4:	2800      	cmp	r0, #0
 800acb6:	f000 80bb 	beq.w	800ae30 <plan_buffer_line+0x3a0>
            block->spindle.css.target_rpm = block->spindle.css.surface_speed / (pos * (float)(2.0f * M_PI));
 800acba:	eb0a 0b09 	add.w	fp, sl, r9
 800acbe:	eb06 1b4b 	add.w	fp, r6, fp, lsl #5
 800acc2:	4931      	ldr	r1, [pc, #196]	; (800ad88 <plan_buffer_line+0x2f8>)
 800acc4:	f8db 0040 	ldr.w	r0, [fp, #64]	; 0x40
 800acc8:	f7f5 fd64 	bl	8000794 <__aeabi_fmul>
 800accc:	4621      	mov	r1, r4
 800acce:	f7f5 fe15 	bl	80008fc <__aeabi_fdiv>
            if(block->spindle.css.target_rpm > block->spindle.css.max_rpm)
 800acd2:	f8db 4048 	ldr.w	r4, [fp, #72]	; 0x48
            block->spindle.css.target_rpm = block->spindle.css.surface_speed / (pos * (float)(2.0f * M_PI));
 800acd6:	f8cb 0044 	str.w	r0, [fp, #68]	; 0x44
            if(block->spindle.css.target_rpm > block->spindle.css.max_rpm)
 800acda:	4621      	mov	r1, r4
 800acdc:	f7f5 ff16 	bl	8000b0c <__aeabi_fcmpgt>
 800ace0:	2800      	cmp	r0, #0
 800ace2:	d0a2      	beq.n	800ac2a <plan_buffer_line+0x19a>
                block->spindle.css.target_rpm = block->spindle.css.max_rpm;
 800ace4:	f8cb 4044 	str.w	r4, [fp, #68]	; 0x44
    if (block->step_event_count == 0)
 800ace8:	2d00      	cmp	r5, #0
 800acea:	d0a0      	beq.n	800ac2e <plan_buffer_line+0x19e>
    pl_data->message = NULL;         // Indicate message is already queued for display on execution
 800acec:	2300      	movs	r3, #0
    block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 800acee:	ac0b      	add	r4, sp, #44	; 0x2c
    pl_data->output_commands = NULL; // Indicate commands are already queued for execution
 800acf0:	e9c7 330b 	strd	r3, r3, [r7, #44]	; 0x2c
    block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 800acf4:	4620      	mov	r0, r4
 800acf6:	f7ff fb35 	bl	800a364 <convert_delta_vector_to_unit_vector>
 800acfa:	4603      	mov	r3, r0
 800acfc:	eb0a 0509 	add.w	r5, sl, r9
 800ad00:	eb06 1545 	add.w	r5, r6, r5, lsl #5
    block->acceleration = limit_value_by_axis_maximum(settings.acceleration, unit_vec);
 800ad04:	4621      	mov	r1, r4
    block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 800ad06:	62eb      	str	r3, [r5, #44]	; 0x2c
    block->acceleration = limit_value_by_axis_maximum(settings.acceleration, unit_vec);
 800ad08:	4820      	ldr	r0, [pc, #128]	; (800ad8c <plan_buffer_line+0x2fc>)
 800ad0a:	f7ff fb73 	bl	800a3f4 <limit_value_by_axis_maximum>
 800ad0e:	4603      	mov	r3, r0
    block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 800ad10:	4621      	mov	r1, r4
 800ad12:	481f      	ldr	r0, [pc, #124]	; (800ad90 <plan_buffer_line+0x300>)
    block->acceleration = limit_value_by_axis_maximum(settings.acceleration, unit_vec);
 800ad14:	62ab      	str	r3, [r5, #40]	; 0x28
    block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 800ad16:	f7ff fb6d 	bl	800a3f4 <limit_value_by_axis_maximum>
    if (block->condition.rapid_motion)
 800ad1a:	f895 b014 	ldrb.w	fp, [r5, #20]
    block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 800ad1e:	6368      	str	r0, [r5, #52]	; 0x34
    if (block->condition.rapid_motion)
 800ad20:	f01b 0f01 	tst.w	fp, #1
 800ad24:	d124      	bne.n	800ad70 <plan_buffer_line+0x2e0>
        block->programmed_rate = pl_data->feed_rate;
 800ad26:	6839      	ldr	r1, [r7, #0]
        if (block->condition.inverse_time)
 800ad28:	f01b 0f20 	tst.w	fp, #32
        block->programmed_rate = pl_data->feed_rate;
 800ad2c:	63a9      	str	r1, [r5, #56]	; 0x38
        if (block->condition.inverse_time)
 800ad2e:	d11c      	bne.n	800ad6a <plan_buffer_line+0x2da>
    if ((block_buffer_head == block_buffer_tail) || (block->condition.system_motion)) {
 800ad30:	4b18      	ldr	r3, [pc, #96]	; (800ad94 <plan_buffer_line+0x304>)
 800ad32:	4a10      	ldr	r2, [pc, #64]	; (800ad74 <plan_buffer_line+0x2e4>)
 800ad34:	681b      	ldr	r3, [r3, #0]
 800ad36:	6812      	ldr	r2, [r2, #0]
 800ad38:	429a      	cmp	r2, r3
 800ad3a:	d002      	beq.n	800ad42 <plan_buffer_line+0x2b2>
 800ad3c:	f01b 0f02 	tst.w	fp, #2
 800ad40:	d02a      	beq.n	800ad98 <plan_buffer_line+0x308>
        block->entry_speed_sqr = 0.0f;
 800ad42:	2200      	movs	r2, #0
 800ad44:	eb0a 0309 	add.w	r3, sl, r9
 800ad48:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800ad4c:	621a      	str	r2, [r3, #32]
        block->max_junction_speed_sqr = 0.0f; // Starting from rest. Enforce start from zero velocity.
 800ad4e:	631a      	str	r2, [r3, #48]	; 0x30
    if (!block->condition.system_motion) {
 800ad50:	eb0a 0309 	add.w	r3, sl, r9
 800ad54:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800ad58:	7d1a      	ldrb	r2, [r3, #20]
 800ad5a:	f103 0510 	add.w	r5, r3, #16
 800ad5e:	0790      	lsls	r0, r2, #30
 800ad60:	d570      	bpl.n	800ae44 <plan_buffer_line+0x3b4>
    return true;
 800ad62:	2001      	movs	r0, #1
}
 800ad64:	b017      	add	sp, #92	; 0x5c
 800ad66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            block->programmed_rate *= block->millimeters;
 800ad6a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800ad6c:	f7f5 fd12 	bl	8000794 <__aeabi_fmul>
 800ad70:	63a8      	str	r0, [r5, #56]	; 0x38
 800ad72:	e7dd      	b.n	800ad30 <plan_buffer_line+0x2a0>
 800ad74:	20001818 	.word	0x20001818
 800ad78:	20000a98 	.word	0x20000a98
 800ad7c:	20001828 	.word	0x20001828
 800ad80:	20002610 	.word	0x20002610
 800ad84:	20002620 	.word	0x20002620
 800ad88:	3e22f983 	.word	0x3e22f983
 800ad8c:	2000263c 	.word	0x2000263c
 800ad90:	20002630 	.word	0x20002630
 800ad94:	20001820 	.word	0x20001820
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800ad98:	4f91      	ldr	r7, [pc, #580]	; (800afe0 <plan_buffer_line+0x550>)
 800ad9a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800ad9c:	f8d7 b014 	ldr.w	fp, [r7, #20]
 800ada0:	4628      	mov	r0, r5
 800ada2:	4659      	mov	r1, fp
 800ada4:	f7f5 fcf6 	bl	8000794 <__aeabi_fmul>
 800ada8:	4603      	mov	r3, r0
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800adaa:	4659      	mov	r1, fp
 800adac:	4628      	mov	r0, r5
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800adae:	9301      	str	r3, [sp, #4]
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800adb0:	f7f5 fbe6 	bl	8000580 <__aeabi_fsub>
 800adb4:	4603      	mov	r3, r0
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800adb6:	693d      	ldr	r5, [r7, #16]
 800adb8:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800adbc:	4629      	mov	r1, r5
 800adbe:	4658      	mov	r0, fp
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800adc0:	9310      	str	r3, [sp, #64]	; 0x40
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800adc2:	f7f5 fce7 	bl	8000794 <__aeabi_fmul>
 800adc6:	9b01      	ldr	r3, [sp, #4]
 800adc8:	4601      	mov	r1, r0
 800adca:	9003      	str	r0, [sp, #12]
 800adcc:	f103 4000 	add.w	r0, r3, #2147483648	; 0x80000000
 800add0:	f7f5 fbd6 	bl	8000580 <__aeabi_fsub>
 800add4:	4603      	mov	r3, r0
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800add6:	4629      	mov	r1, r5
 800add8:	4658      	mov	r0, fp
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800adda:	461d      	mov	r5, r3
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800addc:	f7f5 fbd0 	bl	8000580 <__aeabi_fsub>
 800ade0:	4602      	mov	r2, r0
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800ade2:	68fb      	ldr	r3, [r7, #12]
 800ade4:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800ade8:	4618      	mov	r0, r3
 800adea:	4659      	mov	r1, fp
 800adec:	9302      	str	r3, [sp, #8]
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800adee:	920f      	str	r2, [sp, #60]	; 0x3c
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800adf0:	f7f5 fcd0 	bl	8000794 <__aeabi_fmul>
 800adf4:	4607      	mov	r7, r0
 800adf6:	4628      	mov	r0, r5
 800adf8:	4639      	mov	r1, r7
 800adfa:	f7f5 fbc1 	bl	8000580 <__aeabi_fsub>
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800adfe:	9b02      	ldr	r3, [sp, #8]
            junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
 800ae00:	4605      	mov	r5, r0
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800ae02:	4619      	mov	r1, r3
 800ae04:	4658      	mov	r0, fp
 800ae06:	f7f5 fbbb 	bl	8000580 <__aeabi_fsub>
 800ae0a:	4603      	mov	r3, r0
        if (junction_cos_theta > 0.999999f)
 800ae0c:	4975      	ldr	r1, [pc, #468]	; (800afe4 <plan_buffer_line+0x554>)
 800ae0e:	4628      	mov	r0, r5
            junction_unit_vec[idx] = unit_vec[idx] - pl.previous_unit_vec[idx];
 800ae10:	930e      	str	r3, [sp, #56]	; 0x38
        if (junction_cos_theta > 0.999999f)
 800ae12:	f7f5 fe7b 	bl	8000b0c <__aeabi_fcmpgt>
 800ae16:	2800      	cmp	r0, #0
 800ae18:	f000 808c 	beq.w	800af34 <plan_buffer_line+0x4a4>
            block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED;
 800ae1c:	2200      	movs	r2, #0
 800ae1e:	eb0a 0309 	add.w	r3, sl, r9
 800ae22:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800ae26:	631a      	str	r2, [r3, #48]	; 0x30
 800ae28:	e792      	b.n	800ad50 <plan_buffer_line+0x2c0>
                block->spindle.rpm = block->spindle.css.max_rpm;
 800ae2a:	9b02      	ldr	r3, [sp, #8]
 800ae2c:	63dc      	str	r4, [r3, #60]	; 0x3c
 800ae2e:	e737      	b.n	800aca0 <plan_buffer_line+0x210>
            block->spindle.css.target_rpm = block->spindle.css.max_rpm;
 800ae30:	eb0a 0309 	add.w	r3, sl, r9
 800ae34:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800ae38:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800ae3a:	645a      	str	r2, [r3, #68]	; 0x44
 800ae3c:	e6f5      	b.n	800ac2a <plan_buffer_line+0x19a>
            block->spindle.rpm = block->spindle.css.max_rpm;
 800ae3e:	6c99      	ldr	r1, [r3, #72]	; 0x48
 800ae40:	63d9      	str	r1, [r3, #60]	; 0x3c
 800ae42:	e72d      	b.n	800aca0 <plan_buffer_line+0x210>
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800ae44:	f993 1016 	ldrsb.w	r1, [r3, #22]
 800ae48:	2900      	cmp	r1, #0
 800ae4a:	db7f      	blt.n	800af4c <plan_buffer_line+0x4bc>
 800ae4c:	6b9f      	ldr	r7, [r3, #56]	; 0x38
    if (block->condition.rapid_motion)
 800ae4e:	07d1      	lsls	r1, r2, #31
 800ae50:	d555      	bpl.n	800aefe <plan_buffer_line+0x46e>
        nominal_speed *= (0.01f * sys.override.rapid_rate);
 800ae52:	4b65      	ldr	r3, [pc, #404]	; (800afe8 <plan_buffer_line+0x558>)
 800ae54:	7bd8      	ldrb	r0, [r3, #15]
 800ae56:	f7f5 fc49 	bl	80006ec <__aeabi_i2f>
 800ae5a:	4964      	ldr	r1, [pc, #400]	; (800afec <plan_buffer_line+0x55c>)
 800ae5c:	f7f5 fc9a 	bl	8000794 <__aeabi_fmul>
 800ae60:	4639      	mov	r1, r7
 800ae62:	f7f5 fc97 	bl	8000794 <__aeabi_fmul>
 800ae66:	4605      	mov	r5, r0
    return nominal_speed > MINIMUM_FEED_RATE ? nominal_speed : MINIMUM_FEED_RATE;
 800ae68:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800ae6c:	4628      	mov	r0, r5
 800ae6e:	f7f5 fe43 	bl	8000af8 <__aeabi_fcmpge>
 800ae72:	b908      	cbnz	r0, 800ae78 <plan_buffer_line+0x3e8>
 800ae74:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 800ae78:	f8df b164 	ldr.w	fp, [pc, #356]	; 800afe0 <plan_buffer_line+0x550>
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800ae7c:	4629      	mov	r1, r5
        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 800ae7e:	f8db 3018 	ldr.w	r3, [fp, #24]
 800ae82:	f8d8 7030 	ldr.w	r7, [r8, #48]	; 0x30
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800ae86:	4618      	mov	r0, r3
 800ae88:	9301      	str	r3, [sp, #4]
 800ae8a:	f7f5 fe21 	bl	8000ad0 <__aeabi_fcmplt>
 800ae8e:	2800      	cmp	r0, #0
 800ae90:	d02f      	beq.n	800aef2 <plan_buffer_line+0x462>
 800ae92:	9b01      	ldr	r3, [sp, #4]
 800ae94:	4619      	mov	r1, r3
 800ae96:	4618      	mov	r0, r3
 800ae98:	f7f5 fc7c 	bl	8000794 <__aeabi_fmul>
 800ae9c:	4601      	mov	r1, r0
    if (block->max_entry_speed_sqr > block->max_junction_speed_sqr)
 800ae9e:	4638      	mov	r0, r7
 800aea0:	9101      	str	r1, [sp, #4]
 800aea2:	f7f5 fe1f 	bl	8000ae4 <__aeabi_fcmple>
 800aea6:	b908      	cbnz	r0, 800aeac <plan_buffer_line+0x41c>
 800aea8:	9901      	ldr	r1, [sp, #4]
 800aeaa:	460f      	mov	r7, r1
        if(!block->condition.backlash_motion) {
 800aeac:	44d1      	add	r9, sl
 800aeae:	eb06 1649 	add.w	r6, r6, r9, lsl #5
 800aeb2:	f8c8 7024 	str.w	r7, [r8, #36]	; 0x24
 800aeb6:	7d33      	ldrb	r3, [r6, #20]
        pl.previous_nominal_speed = plan_compute_profile_parameters(block, plan_compute_profile_nominal_speed(block), pl.previous_nominal_speed);
 800aeb8:	f8cb 5018 	str.w	r5, [fp, #24]
        if(!block->condition.backlash_motion) {
 800aebc:	071b      	lsls	r3, r3, #28
 800aebe:	d409      	bmi.n	800aed4 <plan_buffer_line+0x444>
            memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 800aec0:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 800aec4:	4c4a      	ldr	r4, [pc, #296]	; (800aff0 <plan_buffer_line+0x560>)
            memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 800aec6:	ab05      	add	r3, sp, #20
            memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
 800aec8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 800aecc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800aed0:	e88b 0007 	stmia.w	fp, {r0, r1, r2}
        block_buffer_head = next_buffer_head;
 800aed4:	4a47      	ldr	r2, [pc, #284]	; (800aff4 <plan_buffer_line+0x564>)
 800aed6:	4948      	ldr	r1, [pc, #288]	; (800aff8 <plan_buffer_line+0x568>)
 800aed8:	6813      	ldr	r3, [r2, #0]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800aeda:	2b23      	cmp	r3, #35	; 0x23
        block_buffer_head = next_buffer_head;
 800aedc:	600b      	str	r3, [r1, #0]
    return block_index == (BLOCK_BUFFER_SIZE - 1) ? 0 : block_index + 1;
 800aede:	bf0c      	ite	eq
 800aee0:	2300      	moveq	r3, #0
 800aee2:	3301      	addne	r3, #1
        next_buffer_head = plan_next_block_index(block_buffer_head);
 800aee4:	6013      	str	r3, [r2, #0]
        planner_recalculate();
 800aee6:	f7ff fb29 	bl	800a53c <planner_recalculate>
    return true;
 800aeea:	2001      	movs	r0, #1
}
 800aeec:	b017      	add	sp, #92	; 0x5c
 800aeee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    block->max_entry_speed_sqr = nominal_speed > prev_nominal_speed ? (prev_nominal_speed * prev_nominal_speed) : (nominal_speed * nominal_speed);
 800aef2:	4629      	mov	r1, r5
 800aef4:	4628      	mov	r0, r5
 800aef6:	f7f5 fc4d 	bl	8000794 <__aeabi_fmul>
 800aefa:	4601      	mov	r1, r0
 800aefc:	e7cf      	b.n	800ae9e <plan_buffer_line+0x40e>
        if (!block->condition.no_feed_override)
 800aefe:	06d2      	lsls	r2, r2, #27
 800af00:	d40b      	bmi.n	800af1a <plan_buffer_line+0x48a>
            nominal_speed *= (0.01f * sys.override.feed_rate);
 800af02:	4b39      	ldr	r3, [pc, #228]	; (800afe8 <plan_buffer_line+0x558>)
 800af04:	7b98      	ldrb	r0, [r3, #14]
 800af06:	f7f5 fbf1 	bl	80006ec <__aeabi_i2f>
 800af0a:	4938      	ldr	r1, [pc, #224]	; (800afec <plan_buffer_line+0x55c>)
 800af0c:	f7f5 fc42 	bl	8000794 <__aeabi_fmul>
 800af10:	4601      	mov	r1, r0
 800af12:	4638      	mov	r0, r7
 800af14:	f7f5 fc3e 	bl	8000794 <__aeabi_fmul>
 800af18:	4607      	mov	r7, r0
        if (nominal_speed > block->rapid_rate)
 800af1a:	eb0a 0309 	add.w	r3, sl, r9
 800af1e:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800af22:	6b5d      	ldr	r5, [r3, #52]	; 0x34
 800af24:	4639      	mov	r1, r7
 800af26:	4628      	mov	r0, r5
 800af28:	f7f5 fddc 	bl	8000ae4 <__aeabi_fcmple>
 800af2c:	2800      	cmp	r0, #0
 800af2e:	d19b      	bne.n	800ae68 <plan_buffer_line+0x3d8>
 800af30:	463d      	mov	r5, r7
 800af32:	e799      	b.n	800ae68 <plan_buffer_line+0x3d8>
        else if (junction_cos_theta < -0.999999f) {
 800af34:	4628      	mov	r0, r5
 800af36:	4931      	ldr	r1, [pc, #196]	; (800affc <plan_buffer_line+0x56c>)
 800af38:	f7f5 fdca 	bl	8000ad0 <__aeabi_fcmplt>
 800af3c:	b1a0      	cbz	r0, 800af68 <plan_buffer_line+0x4d8>
            block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 800af3e:	4a30      	ldr	r2, [pc, #192]	; (800b000 <plan_buffer_line+0x570>)
 800af40:	eb0a 0309 	add.w	r3, sl, r9
 800af44:	eb06 1343 	add.w	r3, r6, r3, lsl #5
 800af48:	631a      	str	r2, [r3, #48]	; 0x30
 800af4a:	e701      	b.n	800ad50 <plan_buffer_line+0x2c0>
    float nominal_speed = block->condition.spindle.synchronized ? block->programmed_rate * hal.spindle_get_data(SpindleData_RPM).rpm : block->programmed_rate;
 800af4c:	4a2d      	ldr	r2, [pc, #180]	; (800b004 <plan_buffer_line+0x574>)
 800af4e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
 800af50:	2101      	movs	r1, #1
 800af52:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 800af56:	a80e      	add	r0, sp, #56	; 0x38
 800af58:	4798      	blx	r3
 800af5a:	4638      	mov	r0, r7
 800af5c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800af5e:	f7f5 fc19 	bl	8000794 <__aeabi_fmul>
 800af62:	792a      	ldrb	r2, [r5, #4]
 800af64:	4607      	mov	r7, r0
 800af66:	e772      	b.n	800ae4e <plan_buffer_line+0x3be>
            convert_delta_vector_to_unit_vector(junction_unit_vec);
 800af68:	a80e      	add	r0, sp, #56	; 0x38
 800af6a:	f7ff f9fb 	bl	800a364 <convert_delta_vector_to_unit_vector>
            float junction_acceleration = limit_value_by_axis_maximum(settings.acceleration, junction_unit_vec);
 800af6e:	a90e      	add	r1, sp, #56	; 0x38
 800af70:	4825      	ldr	r0, [pc, #148]	; (800b008 <plan_buffer_line+0x578>)
 800af72:	f7ff fa3f 	bl	800a3f4 <limit_value_by_axis_maximum>
            float sin_theta_d2 = sqrtf(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 800af76:	9903      	ldr	r1, [sp, #12]
            float junction_acceleration = limit_value_by_axis_maximum(settings.acceleration, junction_unit_vec);
 800af78:	4683      	mov	fp, r0
            float sin_theta_d2 = sqrtf(0.5f * (1.0f - junction_cos_theta)); // Trig half angle identity. Always positive.
 800af7a:	9801      	ldr	r0, [sp, #4]
 800af7c:	f7f5 fb02 	bl	8000584 <__addsf3>
 800af80:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800af84:	4605      	mov	r5, r0
 800af86:	4638      	mov	r0, r7
 800af88:	f7f5 fafc 	bl	8000584 <__addsf3>
 800af8c:	4601      	mov	r1, r0
 800af8e:	4628      	mov	r0, r5
 800af90:	f7f5 faf8 	bl	8000584 <__addsf3>
 800af94:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800af98:	f7f5 fbfc 	bl	8000794 <__aeabi_fmul>
 800af9c:	f008 f826 	bl	8012fec <sqrtf>
 800afa0:	4605      	mov	r5, r0
            block->max_junction_speed_sqr = max(MINIMUM_JUNCTION_SPEED * MINIMUM_JUNCTION_SPEED,
 800afa2:	4658      	mov	r0, fp
 800afa4:	4629      	mov	r1, r5
 800afa6:	f7f5 fbf5 	bl	8000794 <__aeabi_fmul>
 800afaa:	4b18      	ldr	r3, [pc, #96]	; (800b00c <plan_buffer_line+0x57c>)
 800afac:	eb0a 0709 	add.w	r7, sl, r9
 800afb0:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800afb2:	f7f5 fbef 	bl	8000794 <__aeabi_fmul>
 800afb6:	4629      	mov	r1, r5
 800afb8:	4605      	mov	r5, r0
 800afba:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800afbe:	f7f5 fadf 	bl	8000580 <__aeabi_fsub>
 800afc2:	4601      	mov	r1, r0
 800afc4:	4628      	mov	r0, r5
 800afc6:	f7f5 fc99 	bl	80008fc <__aeabi_fdiv>
 800afca:	2100      	movs	r1, #0
 800afcc:	4605      	mov	r5, r0
 800afce:	eb06 1747 	add.w	r7, r6, r7, lsl #5
 800afd2:	f7f5 fd91 	bl	8000af8 <__aeabi_fcmpge>
 800afd6:	b900      	cbnz	r0, 800afda <plan_buffer_line+0x54a>
 800afd8:	2500      	movs	r5, #0
 800afda:	633d      	str	r5, [r7, #48]	; 0x30
 800afdc:	e6b8      	b.n	800ad50 <plan_buffer_line+0x2c0>
 800afde:	bf00      	nop
 800afe0:	20001828 	.word	0x20001828
 800afe4:	3f7fffef 	.word	0x3f7fffef
 800afe8:	20002494 	.word	0x20002494
 800afec:	3c23d70a 	.word	0x3c23d70a
 800aff0:	20001834 	.word	0x20001834
 800aff4:	20001824 	.word	0x20001824
 800aff8:	20001818 	.word	0x20001818
 800affc:	bf7fffef 	.word	0xbf7fffef
 800b000:	7e967699 	.word	0x7e967699
 800b004:	200024bc 	.word	0x200024bc
 800b008:	2000263c 	.word	0x2000263c
 800b00c:	20002620 	.word	0x20002620

0800b010 <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position ()
{
    memcpy(pl.position, sys_position, sizeof(pl.position));
 800b010:	4a02      	ldr	r2, [pc, #8]	; (800b01c <plan_sync_position+0xc>)
 800b012:	4b03      	ldr	r3, [pc, #12]	; (800b020 <plan_sync_position+0x10>)
 800b014:	ca07      	ldmia	r2, {r0, r1, r2}
 800b016:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 800b01a:	4770      	bx	lr
 800b01c:	20002610 	.word	0x20002610
 800b020:	20001828 	.word	0x20001828

0800b024 <plan_get_block_buffer_available>:


// Returns the number of available blocks are in the planner buffer.
uint8_t plan_get_block_buffer_available ()
{
    return (uint8_t)(block_buffer_head >= block_buffer_tail ? ((BLOCK_BUFFER_SIZE - 1) - (block_buffer_head - block_buffer_tail)) : (block_buffer_tail - block_buffer_head - 1));
 800b024:	4b05      	ldr	r3, [pc, #20]	; (800b03c <plan_get_block_buffer_available+0x18>)
 800b026:	4a06      	ldr	r2, [pc, #24]	; (800b040 <plan_get_block_buffer_available+0x1c>)
 800b028:	6818      	ldr	r0, [r3, #0]
 800b02a:	6812      	ldr	r2, [r2, #0]
 800b02c:	4282      	cmp	r2, r0
 800b02e:	bf2c      	ite	cs
 800b030:	3023      	addcs	r0, #35	; 0x23
 800b032:	f100 30ff 	addcc.w	r0, r0, #4294967295	; 0xffffffff
 800b036:	1a80      	subs	r0, r0, r2
 800b038:	b2c0      	uxtb	r0, r0
}
 800b03a:	4770      	bx	lr
 800b03c:	20001820 	.word	0x20001820
 800b040:	20001818 	.word	0x20001818

0800b044 <plan_cycle_reinitialize>:


// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize ()
{
 800b044:	b508      	push	{r3, lr}
    // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
    st_update_plan_block_parameters();
 800b046:	f005 fa67 	bl	8010518 <st_update_plan_block_parameters>
    block_buffer_planned = block_buffer_tail;
 800b04a:	4a04      	ldr	r2, [pc, #16]	; (800b05c <plan_cycle_reinitialize+0x18>)
 800b04c:	4b04      	ldr	r3, [pc, #16]	; (800b060 <plan_cycle_reinitialize+0x1c>)
 800b04e:	6812      	ldr	r2, [r2, #0]
 800b050:	601a      	str	r2, [r3, #0]
    planner_recalculate();
}
 800b052:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    planner_recalculate();
 800b056:	f7ff ba71 	b.w	800a53c <planner_recalculate>
 800b05a:	bf00      	nop
 800b05c:	20001820 	.word	0x20001820
 800b060:	2000181c 	.word	0x2000181c

0800b064 <plan_feed_override>:

// Set feed overrides
void plan_feed_override (uint_fast8_t feed_override, uint_fast8_t rapid_override)
{
 800b064:	b508      	push	{r3, lr}
    if(sys.override.control.feed_rate_disable)
 800b066:	4b11      	ldr	r3, [pc, #68]	; (800b0ac <plan_feed_override+0x48>)
 800b068:	7c9a      	ldrb	r2, [r3, #18]
 800b06a:	07d2      	lsls	r2, r2, #31
 800b06c:	d41d      	bmi.n	800b0aa <plan_feed_override+0x46>
        return;

    feed_override = max(min(feed_override, MAX_FEED_RATE_OVERRIDE), MIN_FEED_RATE_OVERRIDE);
 800b06e:	28c8      	cmp	r0, #200	; 0xc8
 800b070:	bf28      	it	cs
 800b072:	20c8      	movcs	r0, #200	; 0xc8
 800b074:	280a      	cmp	r0, #10
 800b076:	bf38      	it	cc
 800b078:	200a      	movcc	r0, #10

    if ((feed_override != sys.override.feed_rate) || (rapid_override != sys.override.rapid_rate)) {
 800b07a:	7b9a      	ldrb	r2, [r3, #14]
 800b07c:	4282      	cmp	r2, r0
 800b07e:	d102      	bne.n	800b086 <plan_feed_override+0x22>
 800b080:	7bda      	ldrb	r2, [r3, #15]
 800b082:	428a      	cmp	r2, r1
 800b084:	d011      	beq.n	800b0aa <plan_feed_override+0x46>
      sys.override.feed_rate = (uint8_t)feed_override;
      sys.override.rapid_rate = (uint8_t)rapid_override;
      sys.report.overrides = On; // Set to report change immediately
 800b086:	7d1a      	ldrb	r2, [r3, #20]
      sys.override.feed_rate = (uint8_t)feed_override;
 800b088:	7398      	strb	r0, [r3, #14]
      sys.report.overrides = On; // Set to report change immediately
 800b08a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b08e:	751a      	strb	r2, [r3, #20]
      sys.override.rapid_rate = (uint8_t)rapid_override;
 800b090:	73d9      	strb	r1, [r3, #15]
      plan_update_velocity_profile_parameters();
 800b092:	f7ff fc65 	bl	800a960 <plan_update_velocity_profile_parameters>
    st_update_plan_block_parameters();
 800b096:	f005 fa3f 	bl	8010518 <st_update_plan_block_parameters>
    block_buffer_planned = block_buffer_tail;
 800b09a:	4a05      	ldr	r2, [pc, #20]	; (800b0b0 <plan_feed_override+0x4c>)
 800b09c:	4b05      	ldr	r3, [pc, #20]	; (800b0b4 <plan_feed_override+0x50>)
 800b09e:	6812      	ldr	r2, [r2, #0]
 800b0a0:	601a      	str	r2, [r3, #0]
      plan_cycle_reinitialize();
    }
}
 800b0a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    planner_recalculate();
 800b0a6:	f7ff ba49 	b.w	800a53c <planner_recalculate>
}
 800b0aa:	bd08      	pop	{r3, pc}
 800b0ac:	20002494 	.word	0x20002494
 800b0b0:	20001820 	.word	0x20001820
 800b0b4:	2000181c 	.word	0x2000181c

0800b0b8 <protocol_enqueue_gcode>:
static const char *msg = "(MSG,";
static void protocol_exec_rt_suspend();

// add gcode to execute not originating from normal input stream
bool protocol_enqueue_gcode (char *gcode)
{
 800b0b8:	b508      	push	{r3, lr}
    bool ok = xcommand[0] == '\0' &&
 800b0ba:	4b14      	ldr	r3, [pc, #80]	; (800b10c <protocol_enqueue_gcode+0x54>)
               (sys.state == STATE_IDLE || (sys.state & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 800b0bc:	781b      	ldrb	r3, [r3, #0]
 800b0be:	b9db      	cbnz	r3, 800b0f8 <protocol_enqueue_gcode+0x40>
 800b0c0:	4b13      	ldr	r3, [pc, #76]	; (800b110 <protocol_enqueue_gcode+0x58>)
 800b0c2:	681b      	ldr	r3, [r3, #0]
    bool ok = xcommand[0] == '\0' &&
 800b0c4:	b9d3      	cbnz	r3, 800b0fc <protocol_enqueue_gcode+0x44>
                 bit_isfalse(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 800b0c6:	4b13      	ldr	r3, [pc, #76]	; (800b114 <protocol_enqueue_gcode+0x5c>)
 800b0c8:	681b      	ldr	r3, [r3, #0]
               (sys.state == STATE_IDLE || (sys.state & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 800b0ca:	061b      	lsls	r3, r3, #24
 800b0cc:	d414      	bmi.n	800b0f8 <protocol_enqueue_gcode+0x40>

    if(ok && gc_state.file_run)
 800b0ce:	4b12      	ldr	r3, [pc, #72]	; (800b118 <protocol_enqueue_gcode+0x60>)
 800b0d0:	f893 207d 	ldrb.w	r2, [r3, #125]	; 0x7d
 800b0d4:	b13a      	cbz	r2, 800b0e6 <protocol_enqueue_gcode+0x2e>
        ok = gc_state.modal.program_flow != ProgramFlow_Running || strncmp((char *)gcode, "$J=", 3);
 800b0d6:	7e1b      	ldrb	r3, [r3, #24]
 800b0d8:	b92b      	cbnz	r3, 800b0e6 <protocol_enqueue_gcode+0x2e>
 800b0da:	7803      	ldrb	r3, [r0, #0]
 800b0dc:	2b24      	cmp	r3, #36	; 0x24
 800b0de:	d102      	bne.n	800b0e6 <protocol_enqueue_gcode+0x2e>
 800b0e0:	7843      	ldrb	r3, [r0, #1]
 800b0e2:	2b4a      	cmp	r3, #74	; 0x4a
 800b0e4:	d005      	beq.n	800b0f2 <protocol_enqueue_gcode+0x3a>

    if(ok)
        strcpy(xcommand, gcode);
 800b0e6:	4601      	mov	r1, r0
 800b0e8:	4808      	ldr	r0, [pc, #32]	; (800b10c <protocol_enqueue_gcode+0x54>)
 800b0ea:	f007 f98f 	bl	801240c <strcpy>
 800b0ee:	2001      	movs	r0, #1

    return ok;
}
 800b0f0:	bd08      	pop	{r3, pc}
        ok = gc_state.modal.program_flow != ProgramFlow_Running || strncmp((char *)gcode, "$J=", 3);
 800b0f2:	7883      	ldrb	r3, [r0, #2]
    if(ok)
 800b0f4:	3b3d      	subs	r3, #61	; 0x3d
 800b0f6:	d1f6      	bne.n	800b0e6 <protocol_enqueue_gcode+0x2e>
 800b0f8:	2000      	movs	r0, #0
}
 800b0fa:	bd08      	pop	{r3, pc}
               (sys.state == STATE_IDLE || (sys.state & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 800b0fc:	f413 7308 	ands.w	r3, r3, #544	; 0x220
 800b100:	d0fa      	beq.n	800b0f8 <protocol_enqueue_gcode+0x40>
                 bit_isfalse(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 800b102:	4b04      	ldr	r3, [pc, #16]	; (800b114 <protocol_enqueue_gcode+0x5c>)
 800b104:	681b      	ldr	r3, [r3, #0]
               (sys.state == STATE_IDLE || (sys.state & (STATE_JOG|STATE_TOOL_CHANGE))) &&
 800b106:	061b      	lsls	r3, r3, #24
 800b108:	d5e1      	bpl.n	800b0ce <protocol_enqueue_gcode+0x16>
 800b10a:	e7f5      	b.n	800b0f8 <protocol_enqueue_gcode+0x40>
 800b10c:	20001964 	.word	0x20001964
 800b110:	20002494 	.word	0x20002494
 800b114:	200024b4 	.word	0x200024b4
 800b118:	200023dc 	.word	0x200023dc

0800b11c <protocol_auto_cycle_start>:
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start ()
{
 800b11c:	b510      	push	{r4, lr}
    if (plan_get_current_block() != NULL) // Check if there are any blocks in the buffer.
 800b11e:	f7ff fb97 	bl	800a850 <plan_get_current_block>
 800b122:	b138      	cbz	r0, 800b134 <protocol_auto_cycle_start+0x18>
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
}
 800b124:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 800b128:	4b03      	ldr	r3, [pc, #12]	; (800b138 <protocol_auto_cycle_start+0x1c>)
 800b12a:	2102      	movs	r1, #2
 800b12c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800b130:	4802      	ldr	r0, [pc, #8]	; (800b13c <protocol_auto_cycle_start+0x20>)
 800b132:	4718      	bx	r3
}
 800b134:	bd10      	pop	{r4, pc}
 800b136:	bf00      	nop
 800b138:	200024bc 	.word	0x200024bc
 800b13c:	200024b4 	.word	0x200024b4

0800b140 <protocol_message>:
}

// Dangerous? This fn may be called from stepper ISR and will block (possibly forever?) if a previous message is beeing displayed...
// Use a real queue or "double buffering" instead of spin lock?
void protocol_message (char *message)
{
 800b140:	b570      	push	{r4, r5, r6, lr}
 800b142:	4605      	mov	r5, r0
 800b144:	4c0b      	ldr	r4, [pc, #44]	; (800b174 <protocol_message+0x34>)
    static volatile bool spin_lock = false;

    while(spin_lock);
 800b146:	7823      	ldrb	r3, [r4, #0]
 800b148:	2b00      	cmp	r3, #0
 800b14a:	d1fc      	bne.n	800b146 <protocol_message+0x6>

    spin_lock = true;
 800b14c:	2301      	movs	r3, #1

    if(message) {
        if(sys.message)
 800b14e:	4e0a      	ldr	r6, [pc, #40]	; (800b178 <protocol_message+0x38>)
    spin_lock = true;
 800b150:	7023      	strb	r3, [r4, #0]
        if(sys.message)
 800b152:	69f0      	ldr	r0, [r6, #28]
    if(message) {
 800b154:	b135      	cbz	r5, 800b164 <protocol_message+0x24>
        if(sys.message)
 800b156:	b108      	cbz	r0, 800b15c <protocol_message+0x1c>
            free(sys.message);
        sys.message = message;
    } else if(sys.message) {
        hal.show_message(sys.message);
        free(sys.message);
 800b158:	f006 fd70 	bl	8011c3c <free>
        sys.message = NULL;
 800b15c:	61f5      	str	r5, [r6, #28]
    }

    spin_lock = false;
 800b15e:	2300      	movs	r3, #0
 800b160:	7023      	strb	r3, [r4, #0]
}
 800b162:	bd70      	pop	{r4, r5, r6, pc}
    } else if(sys.message) {
 800b164:	2800      	cmp	r0, #0
 800b166:	d0fa      	beq.n	800b15e <protocol_message+0x1e>
        hal.show_message(sys.message);
 800b168:	4b04      	ldr	r3, [pc, #16]	; (800b17c <protocol_message+0x3c>)
 800b16a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800b16e:	4798      	blx	r3
        free(sys.message);
 800b170:	69f0      	ldr	r0, [r6, #28]
 800b172:	e7f1      	b.n	800b158 <protocol_message+0x18>
 800b174:	20001951 	.word	0x20001951
 800b178:	20002494 	.word	0x20002494
 800b17c:	200024bc 	.word	0x200024bc

0800b180 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
bool protocol_exec_rt_system ()
{
 800b180:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint_fast16_t rt_exec;

    // Display message if provided
    if(sys.message)
 800b184:	4dac      	ldr	r5, [pc, #688]	; (800b438 <protocol_exec_rt_system+0x2b8>)
 800b186:	69e8      	ldr	r0, [r5, #28]
 800b188:	2800      	cmp	r0, #0
 800b18a:	f000 80e5 	beq.w	800b358 <protocol_exec_rt_system+0x1d8>
 800b18e:	4eab      	ldr	r6, [pc, #684]	; (800b43c <protocol_exec_rt_system+0x2bc>)
    while(spin_lock);
 800b190:	7833      	ldrb	r3, [r6, #0]
 800b192:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 800b196:	2b00      	cmp	r3, #0
 800b198:	d1fa      	bne.n	800b190 <protocol_exec_rt_system+0x10>
    spin_lock = true;
 800b19a:	2201      	movs	r2, #1
        hal.show_message(sys.message);
 800b19c:	4ca8      	ldr	r4, [pc, #672]	; (800b440 <protocol_exec_rt_system+0x2c0>)
    spin_lock = true;
 800b19e:	7032      	strb	r2, [r6, #0]
        hal.show_message(sys.message);
 800b1a0:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 800b1a4:	4798      	blx	r3
        free(sys.message);
 800b1a6:	69e8      	ldr	r0, [r5, #28]
 800b1a8:	f006 fd48 	bl	8011c3c <free>
        sys.message = NULL;
 800b1ac:	61ef      	str	r7, [r5, #28]
    spin_lock = false;
 800b1ae:	7037      	strb	r7, [r6, #0]
        protocol_message(NULL);

    if (sys_rt_exec_alarm && (rt_exec = system_clear_exec_alarm())) { // Enter only if any bit flag is true
 800b1b0:	4ea4      	ldr	r6, [pc, #656]	; (800b444 <protocol_exec_rt_system+0x2c4>)
 800b1b2:	6833      	ldr	r3, [r6, #0]
 800b1b4:	b143      	cbz	r3, 800b1c8 <protocol_exec_rt_system+0x48>
 800b1b6:	2100      	movs	r1, #0
 800b1b8:	4630      	mov	r0, r6
 800b1ba:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b1be:	4798      	blx	r3
 800b1c0:	4607      	mov	r7, r0
 800b1c2:	2800      	cmp	r0, #0
 800b1c4:	f040 8088 	bne.w	800b2d8 <protocol_exec_rt_system+0x158>
 800b1c8:	4e9f      	ldr	r6, [pc, #636]	; (800b448 <protocol_exec_rt_system+0x2c8>)
            }
            system_clear_exec_alarm(); // Clear alarm
        }
    }

    if (sys_rt_exec_state && (rt_exec = system_clear_exec_states())) { // Get and clear volatile sys_rt_exec_state atomically.
 800b1ca:	6833      	ldr	r3, [r6, #0]
 800b1cc:	b133      	cbz	r3, 800b1dc <protocol_exec_rt_system+0x5c>
 800b1ce:	2100      	movs	r1, #0
 800b1d0:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b1d4:	489c      	ldr	r0, [pc, #624]	; (800b448 <protocol_exec_rt_system+0x2c8>)
 800b1d6:	4798      	blx	r3
 800b1d8:	4606      	mov	r6, r0
 800b1da:	b9b8      	cbnz	r0, 800b20c <protocol_exec_rt_system+0x8c>
        // Let state machine handle any remaining requests
        if(rt_exec)
            update_state(rt_exec);
    }

    if(hal.execute_realtime)
 800b1dc:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800b1e0:	b10b      	cbz	r3, 800b1e6 <protocol_exec_rt_system+0x66>
        hal.execute_realtime(sys.state);
 800b1e2:	6828      	ldr	r0, [r5, #0]
 800b1e4:	4798      	blx	r3

    if(!sys.flags.delay_overrides) {
 800b1e6:	7a6b      	ldrb	r3, [r5, #9]
 800b1e8:	065a      	lsls	r2, r3, #25
 800b1ea:	f140 80ba 	bpl.w	800b362 <protocol_exec_rt_system+0x1e2>
 800b1ee:	682b      	ldr	r3, [r5, #0]
            }
        }
    } // End execute overrides.

    // Reload step segment buffer
    if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG))
 800b1f0:	f013 0ffc 	tst.w	r3, #252	; 0xfc
 800b1f4:	f040 80b2 	bne.w	800b35c <protocol_exec_rt_system+0x1dc>
        st_prep_buffer();

    return !ABORTED;
 800b1f8:	792b      	ldrb	r3, [r5, #4]
 800b1fa:	b113      	cbz	r3, 800b202 <protocol_exec_rt_system+0x82>
 800b1fc:	2000      	movs	r0, #0
}
 800b1fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return !ABORTED;
 800b202:	7968      	ldrb	r0, [r5, #5]
 800b204:	f080 0001 	eor.w	r0, r0, #1
}
 800b208:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (rt_exec & EXEC_RESET) {
 800b20c:	f010 0320 	ands.w	r3, r0, #32
 800b210:	f040 814b 	bne.w	800b4aa <protocol_exec_rt_system+0x32a>
        if(rt_exec & EXEC_STOP) { // Experimental for now, must be verified. Do NOT move to interrupt context!
 800b214:	06f0      	lsls	r0, r6, #27
 800b216:	d542      	bpl.n	800b29e <protocol_exec_rt_system+0x11e>
            if(sys.override.control.sync)
 800b218:	f995 1012 	ldrsb.w	r1, [r5, #18]
            gc_state.tool_change = false;
 800b21c:	f04f 0800 	mov.w	r8, #0
            if(sys.override.control.sync)
 800b220:	2900      	cmp	r1, #0
            sys.cancel = true;
 800b222:	f04f 0001 	mov.w	r0, #1
            gc_state.spindle.rpm = sys.spindle_rpm = 0.0f;
 800b226:	f04f 0100 	mov.w	r1, #0
            sys.flags.feed_hold_pending = Off;
 800b22a:	7a6a      	ldrb	r2, [r5, #9]
                sys.override.control = gc_state.modal.override_ctrl;
 800b22c:	4f87      	ldr	r7, [pc, #540]	; (800b44c <protocol_exec_rt_system+0x2cc>)
            sys.step_control.flags = 0;
 800b22e:	72ab      	strb	r3, [r5, #10]
            sys.flags.feed_hold_pending = Off;
 800b230:	f022 0360 	bic.w	r3, r2, #96	; 0x60
 800b234:	726b      	strb	r3, [r5, #9]
                sys.override.control = gc_state.modal.override_ctrl;
 800b236:	bfb8      	it	lt
 800b238:	7efb      	ldrblt	r3, [r7, #27]
            gc_state.spindle.rpm = sys.spindle_rpm = 0.0f;
 800b23a:	61a9      	str	r1, [r5, #24]
                sys.override.control = gc_state.modal.override_ctrl;
 800b23c:	bfb8      	it	lt
 800b23e:	74ab      	strblt	r3, [r5, #18]
            gc_state.spindle.rpm = sys.spindle_rpm = 0.0f;
 800b240:	64b9      	str	r1, [r7, #72]	; 0x48
            hal.spindle_set_state(gc_state.modal.spindle, 0.0f);
 800b242:	6b23      	ldr	r3, [r4, #48]	; 0x30
            sys.cancel = true;
 800b244:	7168      	strb	r0, [r5, #5]
            gc_state.tool_change = false;
 800b246:	f887 8080 	strb.w	r8, [r7, #128]	; 0x80
            hal.spindle_set_state(gc_state.modal.spindle, 0.0f);
 800b24a:	4640      	mov	r0, r8
            gc_state.modal.coolant.value = 0;
 800b24c:	f887 8019 	strb.w	r8, [r7, #25]
            gc_state.modal.spindle.value = 0;
 800b250:	f887 801a 	strb.w	r8, [r7, #26]
            gc_state.modal.spindle_rpm_mode = SpindleSpeedMode_RPM;
 800b254:	f887 801c 	strb.w	r8, [r7, #28]
            hal.spindle_set_state(gc_state.modal.spindle, 0.0f);
 800b258:	4798      	blx	r3
            hal.coolant_set_state(gc_state.modal.coolant);
 800b25a:	7e78      	ldrb	r0, [r7, #25]
 800b25c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b25e:	4798      	blx	r3
            sys.report.spindle = sys.report.coolant = On; // Set to report change immediately
 800b260:	7d2b      	ldrb	r3, [r5, #20]
            hal.driver_reset();
 800b262:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
            sys.report.spindle = sys.report.coolant = On; // Set to report change immediately
 800b266:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800b26a:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 800b26e:	752b      	strb	r3, [r5, #20]
            hal.driver_reset();
 800b270:	4790      	blx	r2
            if(hal.stream.suspend_read && hal.stream.suspend_read(false))
 800b272:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800b274:	b123      	cbz	r3, 800b280 <protocol_exec_rt_system+0x100>
 800b276:	4640      	mov	r0, r8
 800b278:	4798      	blx	r3
 800b27a:	2800      	cmp	r0, #0
 800b27c:	f040 8147 	bne.w	800b50e <protocol_exec_rt_system+0x38e>
            plan_reset();
 800b280:	f7ff fa5c 	bl	800a73c <plan_reset>
            st_reset();
 800b284:	f005 f890 	bl	80103a8 <st_reset>
            gc_sync_position();
 800b288:	4871      	ldr	r0, [pc, #452]	; (800b450 <protocol_exec_rt_system+0x2d0>)
 800b28a:	4972      	ldr	r1, [pc, #456]	; (800b454 <protocol_exec_rt_system+0x2d4>)
 800b28c:	f006 fa4c 	bl	8011728 <system_convert_array_steps_to_mpos>
            plan_sync_position();
 800b290:	f7ff febe 	bl	800b010 <plan_sync_position>
            flush_override_buffers();
 800b294:	f7ff f946 	bl	800a524 <flush_override_buffers>
            set_state(STATE_IDLE);
 800b298:	2000      	movs	r0, #0
 800b29a:	f004 fba9 	bl	800f9f0 <set_state>
        if (rt_exec & EXEC_STATUS_REPORT)
 800b29e:	07f1      	lsls	r1, r6, #31
 800b2a0:	f100 812d 	bmi.w	800b4fe <protocol_exec_rt_system+0x37e>
        if(rt_exec & EXEC_GCODE_REPORT)
 800b2a4:	0532      	lsls	r2, r6, #20
 800b2a6:	f100 8127 	bmi.w	800b4f8 <protocol_exec_rt_system+0x378>
        if (rt_exec & EXEC_PID_REPORT)
 800b2aa:	0573      	lsls	r3, r6, #21
 800b2ac:	f100 8121 	bmi.w	800b4f2 <protocol_exec_rt_system+0x372>
        if(sys.flags.feed_hold_pending) {
 800b2b0:	7a6b      	ldrb	r3, [r5, #9]
        rt_exec &= ~(EXEC_STOP|EXEC_STATUS_REPORT|EXEC_GCODE_REPORT|EXEC_PID_REPORT); // clear requests already processed
 800b2b2:	f426 6041 	bic.w	r0, r6, #3088	; 0xc10
        if(sys.flags.feed_hold_pending) {
 800b2b6:	069f      	lsls	r7, r3, #26
        rt_exec &= ~(EXEC_STOP|EXEC_STATUS_REPORT|EXEC_GCODE_REPORT|EXEC_PID_REPORT); // clear requests already processed
 800b2b8:	f020 0001 	bic.w	r0, r0, #1
        if(sys.flags.feed_hold_pending) {
 800b2bc:	f140 8115 	bpl.w	800b4ea <protocol_exec_rt_system+0x36a>
            if(rt_exec & EXEC_CYCLE_START)
 800b2c0:	07b6      	lsls	r6, r6, #30
 800b2c2:	f100 810f 	bmi.w	800b4e4 <protocol_exec_rt_system+0x364>
            else if(!sys.override.control.feed_hold_disable)
 800b2c6:	7cab      	ldrb	r3, [r5, #18]
 800b2c8:	0799      	lsls	r1, r3, #30
 800b2ca:	f100 810e 	bmi.w	800b4ea <protocol_exec_rt_system+0x36a>
                rt_exec |= EXEC_FEED_HOLD;
 800b2ce:	f040 0008 	orr.w	r0, r0, #8
            update_state(rt_exec);
 800b2d2:	f004 fb53 	bl	800f97c <update_state>
 800b2d6:	e781      	b.n	800b1dc <protocol_exec_rt_system+0x5c>
        set_state((alarm_code_t)rt_exec == Alarm_EStop ? STATE_ESTOP : STATE_ALARM); // Set system alarm state
 800b2d8:	fa5f f880 	uxtb.w	r8, r0
 800b2dc:	f1b8 0f0a 	cmp.w	r8, #10
 800b2e0:	f000 80d3 	beq.w	800b48a <protocol_exec_rt_system+0x30a>
 800b2e4:	2001      	movs	r0, #1
 800b2e6:	f004 fb83 	bl	800f9f0 <set_state>
        report_alarm_message((alarm_code_t)rt_exec);
 800b2ea:	4640      	mov	r0, r8
        if ((alarm_code_t)rt_exec == Alarm_HardLimit || (alarm_code_t)rt_exec == Alarm_SoftLimit || (alarm_code_t)rt_exec == Alarm_EStop) {
 800b2ec:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
        report_alarm_message((alarm_code_t)rt_exec);
 800b2f0:	f000 fe9a 	bl	800c028 <report_alarm_message>
        if ((alarm_code_t)rt_exec == Alarm_HardLimit || (alarm_code_t)rt_exec == Alarm_SoftLimit || (alarm_code_t)rt_exec == Alarm_EStop) {
 800b2f4:	f1b8 0f01 	cmp.w	r8, #1
 800b2f8:	f63f af66 	bhi.w	800b1c8 <protocol_exec_rt_system+0x48>
            system_set_exec_alarm(rt_exec);
 800b2fc:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b300:	4639      	mov	r1, r7
 800b302:	4630      	mov	r0, r6
 800b304:	4798      	blx	r3
            hal.report.feedback_message((alarm_code_t)rt_exec == Alarm_EStop ? Message_EStop : Message_CriticalEvent);
 800b306:	2001      	movs	r0, #1
 800b308:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 800b30c:	4e4e      	ldr	r6, [pc, #312]	; (800b448 <protocol_exec_rt_system+0x2c8>)
 800b30e:	4798      	blx	r3
            system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 800b310:	2120      	movs	r1, #32
 800b312:	4630      	mov	r0, r6
 800b314:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
                    system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 800b318:	4637      	mov	r7, r6
            system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 800b31a:	4798      	blx	r3
            while (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 800b31c:	6833      	ldr	r3, [r6, #0]
 800b31e:	069b      	lsls	r3, r3, #26
 800b320:	d414      	bmi.n	800b34c <protocol_exec_rt_system+0x1cc>
                if(bit_istrue(sys_rt_exec_state, EXEC_STATUS_REPORT)) {
 800b322:	6833      	ldr	r3, [r6, #0]
 800b324:	07da      	lsls	r2, r3, #31
 800b326:	f140 80d7 	bpl.w	800b4d8 <protocol_exec_rt_system+0x358>
                    system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 800b32a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800b32e:	2101      	movs	r1, #1
 800b330:	4638      	mov	r0, r7
 800b332:	4798      	blx	r3
                    report_realtime_status();
 800b334:	f002 fa0e 	bl	800d754 <report_realtime_status>
                if(hal.execute_realtime)
 800b338:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800b33c:	2b00      	cmp	r3, #0
 800b33e:	d0ed      	beq.n	800b31c <protocol_exec_rt_system+0x19c>
                    hal.execute_realtime(STATE_ESTOP);
 800b340:	f44f 7080 	mov.w	r0, #256	; 0x100
 800b344:	4798      	blx	r3
            while (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 800b346:	6833      	ldr	r3, [r6, #0]
 800b348:	069b      	lsls	r3, r3, #26
 800b34a:	d5ea      	bpl.n	800b322 <protocol_exec_rt_system+0x1a2>
            system_clear_exec_alarm(); // Clear alarm
 800b34c:	2100      	movs	r1, #0
 800b34e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b352:	483c      	ldr	r0, [pc, #240]	; (800b444 <protocol_exec_rt_system+0x2c4>)
 800b354:	4798      	blx	r3
 800b356:	e738      	b.n	800b1ca <protocol_exec_rt_system+0x4a>
 800b358:	4c39      	ldr	r4, [pc, #228]	; (800b440 <protocol_exec_rt_system+0x2c0>)
 800b35a:	e729      	b.n	800b1b0 <protocol_exec_rt_system+0x30>
        st_prep_buffer();
 800b35c:	f005 f938 	bl	80105d0 <st_prep_buffer>
 800b360:	e74a      	b.n	800b1f8 <protocol_exec_rt_system+0x78>
        if((rt_exec = get_feed_override())) {
 800b362:	f7ff f8af 	bl	800a4c4 <get_feed_override>
 800b366:	b198      	cbz	r0, 800b390 <protocol_exec_rt_system+0x210>
            uint_fast8_t new_f_override = sys.override.feed_rate, new_r_override = sys.override.rapid_rate;
 800b368:	7bae      	ldrb	r6, [r5, #14]
 800b36a:	7bef      	ldrb	r7, [r5, #15]
                switch(rt_exec) {
 800b36c:	3890      	subs	r0, #144	; 0x90
 800b36e:	2807      	cmp	r0, #7
 800b370:	d806      	bhi.n	800b380 <protocol_exec_rt_system+0x200>
 800b372:	e8df f000 	tbb	[pc, r0]
 800b376:	8804      	.short	0x8804
 800b378:	80828486 	.word	0x80828486
 800b37c:	7c7e      	.short	0x7c7e
                        new_r_override = RAPID_OVERRIDE_MEDIUM;
 800b37e:	2664      	movs	r6, #100	; 0x64
            } while((rt_exec = get_feed_override()));
 800b380:	f7ff f8a0 	bl	800a4c4 <get_feed_override>
 800b384:	2800      	cmp	r0, #0
 800b386:	d1f1      	bne.n	800b36c <protocol_exec_rt_system+0x1ec>
            plan_feed_override(new_f_override, new_r_override);
 800b388:	4639      	mov	r1, r7
 800b38a:	4630      	mov	r0, r6
 800b38c:	f7ff fe6a 	bl	800b064 <plan_feed_override>
        if((rt_exec = get_accessory_override())) {
 800b390:	f7ff f8b8 	bl	800a504 <get_accessory_override>
 800b394:	2800      	cmp	r0, #0
 800b396:	f43f af2a 	beq.w	800b1ee <protocol_exec_rt_system+0x6e>
            bool spindle_stop = false;
 800b39a:	f04f 0900 	mov.w	r9, #0
            coolant_state_t coolant_state = gc_state.modal.coolant;
 800b39e:	4f2b      	ldr	r7, [pc, #172]	; (800b44c <protocol_exec_rt_system+0x2cc>)
            uint_fast8_t last_s_override = sys.override.spindle_rpm;
 800b3a0:	7c2e      	ldrb	r6, [r5, #16]
            coolant_state_t coolant_state = gc_state.modal.coolant;
 800b3a2:	f897 8019 	ldrb.w	r8, [r7, #25]
                switch(rt_exec) {
 800b3a6:	f1a0 0399 	sub.w	r3, r0, #153	; 0x99
 800b3aa:	2b08      	cmp	r3, #8
 800b3ac:	f200 808c 	bhi.w	800b4c8 <protocol_exec_rt_system+0x348>
 800b3b0:	e8df f003 	tbb	[pc, r3]
 800b3b4:	57595b05 	.word	0x57595b05
 800b3b8:	388a5255 	.word	0x388a5255
 800b3bc:	2a          	.byte	0x2a
 800b3bd:	00          	.byte	0x00
            bool spindle_stop = false;
 800b3be:	2664      	movs	r6, #100	; 0x64
            } while((rt_exec = get_accessory_override()));
 800b3c0:	f7ff f8a0 	bl	800a504 <get_accessory_override>
 800b3c4:	2800      	cmp	r0, #0
 800b3c6:	d1ee      	bne.n	800b3a6 <protocol_exec_rt_system+0x226>
            spindle_set_override(last_s_override);
 800b3c8:	4630      	mov	r0, r6
 800b3ca:	f003 fc31 	bl	800ec30 <spindle_set_override>
            if(coolant_state.value != gc_state.modal.coolant.value) {
 800b3ce:	7e7b      	ldrb	r3, [r7, #25]
 800b3d0:	fa5f f288 	uxtb.w	r2, r8
 800b3d4:	429a      	cmp	r2, r3
 800b3d6:	d004      	beq.n	800b3e2 <protocol_exec_rt_system+0x262>
                coolant_set_state(coolant_state); // Report flag set in coolant_set_state().
 800b3d8:	4640      	mov	r0, r8
 800b3da:	f7f9 fde1 	bl	8004fa0 <coolant_set_state>
                gc_state.modal.coolant = coolant_state;
 800b3de:	f887 8019 	strb.w	r8, [r7, #25]
            if (spindle_stop && sys.state == STATE_HOLD && gc_state.modal.spindle.on) {
 800b3e2:	682b      	ldr	r3, [r5, #0]
 800b3e4:	f1b9 0f00 	cmp.w	r9, #0
 800b3e8:	f43f af02 	beq.w	800b1f0 <protocol_exec_rt_system+0x70>
 800b3ec:	2b10      	cmp	r3, #16
 800b3ee:	f47f aeff 	bne.w	800b1f0 <protocol_exec_rt_system+0x70>
 800b3f2:	7eba      	ldrb	r2, [r7, #26]
 800b3f4:	07d0      	lsls	r0, r2, #31
 800b3f6:	f57f aefb 	bpl.w	800b1f0 <protocol_exec_rt_system+0x70>
                if (!sys.override.spindle_stop.value)
 800b3fa:	7c6a      	ldrb	r2, [r5, #17]
 800b3fc:	2a00      	cmp	r2, #0
 800b3fe:	f040 8089 	bne.w	800b514 <protocol_exec_rt_system+0x394>
                    sys.override.spindle_stop.initiate = On;
 800b402:	2202      	movs	r2, #2
 800b404:	746a      	strb	r2, [r5, #17]
 800b406:	e6f3      	b.n	800b1f0 <protocol_exec_rt_system+0x70>
                        if (hal.driver_cap.mist_control && ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD)))) {
 800b408:	f894 3144 	ldrb.w	r3, [r4, #324]	; 0x144
 800b40c:	07db      	lsls	r3, r3, #31
 800b40e:	d5d7      	bpl.n	800b3c0 <protocol_exec_rt_system+0x240>
 800b410:	682b      	ldr	r3, [r5, #0]
 800b412:	2b00      	cmp	r3, #0
 800b414:	d176      	bne.n	800b504 <protocol_exec_rt_system+0x384>
                            coolant_state.mist = !coolant_state.mist;
 800b416:	f088 0302 	eor.w	r3, r8, #2
 800b41a:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800b41e:	f363 0841 	bfi	r8, r3, #1, #1
 800b422:	e7cd      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 800b424:	682b      	ldr	r3, [r5, #0]
 800b426:	b113      	cbz	r3, 800b42e <protocol_exec_rt_system+0x2ae>
 800b428:	f013 0f18 	tst.w	r3, #24
 800b42c:	d0c8      	beq.n	800b3c0 <protocol_exec_rt_system+0x240>
                            coolant_state.flood = !coolant_state.flood;
 800b42e:	ea6f 0308 	mvn.w	r3, r8
 800b432:	f363 0800 	bfi	r8, r3, #0, #1
 800b436:	e7c3      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
 800b438:	20002494 	.word	0x20002494
 800b43c:	20001951 	.word	0x20001951
 800b440:	200024bc 	.word	0x200024bc
 800b444:	2000261c 	.word	0x2000261c
 800b448:	200024b4 	.word	0x200024b4
 800b44c:	200023dc 	.word	0x200023dc
 800b450:	20002448 	.word	0x20002448
 800b454:	20002610 	.word	0x20002610
                        spindle_stop = !spindle_stop;
 800b458:	f089 0901 	eor.w	r9, r9, #1
                        break;
 800b45c:	e7b0      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT;
 800b45e:	3e01      	subs	r6, #1
                        break;
 800b460:	e7ae      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 800b462:	3601      	adds	r6, #1
                        break;
 800b464:	e7ac      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT;
 800b466:	3e0a      	subs	r6, #10
                        break;
 800b468:	e7aa      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT;
 800b46a:	360a      	adds	r6, #10
                        break;
 800b46c:	e7a8      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                        new_r_override = RAPID_OVERRIDE_LOW;
 800b46e:	2719      	movs	r7, #25
                        break;
 800b470:	e786      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_r_override = RAPID_OVERRIDE_MEDIUM;
 800b472:	2732      	movs	r7, #50	; 0x32
                        break;
 800b474:	e784      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_r_override = DEFAULT_RAPID_OVERRIDE;
 800b476:	2764      	movs	r7, #100	; 0x64
                        break;
 800b478:	e782      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_f_override -= FEED_OVERRIDE_FINE_INCREMENT;
 800b47a:	3e01      	subs	r6, #1
                        break;
 800b47c:	e780      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_f_override += FEED_OVERRIDE_FINE_INCREMENT;
 800b47e:	3601      	adds	r6, #1
                        break;
 800b480:	e77e      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT;
 800b482:	3e0a      	subs	r6, #10
                        break;
 800b484:	e77c      	b.n	800b380 <protocol_exec_rt_system+0x200>
                        new_f_override += FEED_OVERRIDE_COARSE_INCREMENT;
 800b486:	360a      	adds	r6, #10
                        break;
 800b488:	e77a      	b.n	800b380 <protocol_exec_rt_system+0x200>
        set_state((alarm_code_t)rt_exec == Alarm_EStop ? STATE_ESTOP : STATE_ALARM); // Set system alarm state
 800b48a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800b48e:	f004 faaf 	bl	800f9f0 <set_state>
        report_alarm_message((alarm_code_t)rt_exec);
 800b492:	4640      	mov	r0, r8
 800b494:	f000 fdc8 	bl	800c028 <report_alarm_message>
            system_set_exec_alarm(rt_exec);
 800b498:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b49c:	4639      	mov	r1, r7
 800b49e:	4630      	mov	r0, r6
 800b4a0:	4798      	blx	r3
            hal.report.feedback_message((alarm_code_t)rt_exec == Alarm_EStop ? Message_EStop : Message_CriticalEvent);
 800b4a2:	200c      	movs	r0, #12
 800b4a4:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 800b4a8:	e730      	b.n	800b30c <protocol_exec_rt_system+0x18c>
            hal.driver_reset();
 800b4aa:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800b4ae:	4798      	blx	r3
            sys.abort = !hal.system_control_get_state().e_stop;  // Only place this is set true.
 800b4b0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800b4b2:	4798      	blx	r3
 800b4b4:	f000 0040 	and.w	r0, r0, #64	; 0x40
 800b4b8:	2800      	cmp	r0, #0
 800b4ba:	bf0d      	iteet	eq
 800b4bc:	2301      	moveq	r3, #1
 800b4be:	2300      	movne	r3, #0
            return !sys.abort; // Nothing else to do but exit.
 800b4c0:	2001      	movne	r0, #1
 800b4c2:	2000      	moveq	r0, #0
            sys.abort = !hal.system_control_get_state().e_stop;  // Only place this is set true.
 800b4c4:	712b      	strb	r3, [r5, #4]
            return !sys.abort; // Nothing else to do but exit.
 800b4c6:	e69a      	b.n	800b1fe <protocol_exec_rt_system+0x7e>
                        if(hal.driver_rt_command_execute)
 800b4c8:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 800b4cc:	2b00      	cmp	r3, #0
 800b4ce:	f43f af77 	beq.w	800b3c0 <protocol_exec_rt_system+0x240>
                            hal.driver_rt_command_execute(rt_exec);
 800b4d2:	b2c0      	uxtb	r0, r0
 800b4d4:	4798      	blx	r3
 800b4d6:	e773      	b.n	800b3c0 <protocol_exec_rt_system+0x240>
                if(hal.execute_realtime)
 800b4d8:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800b4dc:	2b00      	cmp	r3, #0
 800b4de:	f43f af1d 	beq.w	800b31c <protocol_exec_rt_system+0x19c>
 800b4e2:	e72d      	b.n	800b340 <protocol_exec_rt_system+0x1c0>
                sys.flags.feed_hold_pending = Off;
 800b4e4:	f36f 1345 	bfc	r3, #5, #1
 800b4e8:	726b      	strb	r3, [r5, #9]
        if(rt_exec)
 800b4ea:	2800      	cmp	r0, #0
 800b4ec:	f43f ae76 	beq.w	800b1dc <protocol_exec_rt_system+0x5c>
 800b4f0:	e6ef      	b.n	800b2d2 <protocol_exec_rt_system+0x152>
            report_pid_log();
 800b4f2:	f002 fd6b 	bl	800dfcc <report_pid_log>
 800b4f6:	e6db      	b.n	800b2b0 <protocol_exec_rt_system+0x130>
            report_gcode_modes();
 800b4f8:	f001 fd6a 	bl	800cfd0 <report_gcode_modes>
 800b4fc:	e6d5      	b.n	800b2aa <protocol_exec_rt_system+0x12a>
            report_realtime_status();
 800b4fe:	f002 f929 	bl	800d754 <report_realtime_status>
 800b502:	e6cf      	b.n	800b2a4 <protocol_exec_rt_system+0x124>
                        if (hal.driver_cap.mist_control && ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD)))) {
 800b504:	f013 0f18 	tst.w	r3, #24
 800b508:	f43f af5a 	beq.w	800b3c0 <protocol_exec_rt_system+0x240>
 800b50c:	e783      	b.n	800b416 <protocol_exec_rt_system+0x296>
                hal.stream.cancel_read_buffer(); // flush pending blocks (after M6)
 800b50e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800b510:	4798      	blx	r3
 800b512:	e6b5      	b.n	800b280 <protocol_exec_rt_system+0x100>
                else if (sys.override.spindle_stop.enabled)
 800b514:	07d1      	lsls	r1, r2, #31
                    sys.override.spindle_stop.restore = On;
 800b516:	bf44      	itt	mi
 800b518:	f042 0204 	orrmi.w	r2, r2, #4
 800b51c:	746a      	strbmi	r2, [r5, #17]
 800b51e:	e667      	b.n	800b1f0 <protocol_exec_rt_system+0x70>

0800b520 <protocol_execute_realtime>:
{
 800b520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(protocol_exec_rt_system()) {
 800b522:	f7ff fe2d 	bl	800b180 <protocol_exec_rt_system>
        if (sys.suspend)
 800b526:	4c24      	ldr	r4, [pc, #144]	; (800b5b8 <protocol_execute_realtime+0x98>)
    if(protocol_exec_rt_system()) {
 800b528:	b120      	cbz	r0, 800b534 <protocol_execute_realtime+0x14>
        if (sys.suspend)
 800b52a:	79a3      	ldrb	r3, [r4, #6]
 800b52c:	b9cb      	cbnz	r3, 800b562 <protocol_execute_realtime+0x42>
        if((sys.state == STATE_IDLE || sys.state == STATE_ALARM) && settings_dirty.is_dirty && !gc_state.file_run)
 800b52e:	6823      	ldr	r3, [r4, #0]
 800b530:	2b01      	cmp	r3, #1
 800b532:	d90a      	bls.n	800b54a <protocol_execute_realtime+0x2a>
    return !ABORTED;
 800b534:	7923      	ldrb	r3, [r4, #4]
 800b536:	b933      	cbnz	r3, 800b546 <protocol_execute_realtime+0x26>
 800b538:	7963      	ldrb	r3, [r4, #5]
 800b53a:	b923      	cbnz	r3, 800b546 <protocol_execute_realtime+0x26>
 800b53c:	2001      	movs	r0, #1
}
 800b53e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if((sys.state == STATE_IDLE || sys.state == STATE_ALARM) && settings_dirty.is_dirty && !gc_state.file_run)
 800b540:	6823      	ldr	r3, [r4, #0]
 800b542:	2b01      	cmp	r3, #1
 800b544:	d901      	bls.n	800b54a <protocol_execute_realtime+0x2a>
{
 800b546:	2000      	movs	r0, #0
}
 800b548:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if((sys.state == STATE_IDLE || sys.state == STATE_ALARM) && settings_dirty.is_dirty && !gc_state.file_run)
 800b54a:	4b1c      	ldr	r3, [pc, #112]	; (800b5bc <protocol_execute_realtime+0x9c>)
 800b54c:	781b      	ldrb	r3, [r3, #0]
 800b54e:	2b00      	cmp	r3, #0
 800b550:	d0f0      	beq.n	800b534 <protocol_execute_realtime+0x14>
 800b552:	4b1b      	ldr	r3, [pc, #108]	; (800b5c0 <protocol_execute_realtime+0xa0>)
 800b554:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 800b558:	2b00      	cmp	r3, #0
 800b55a:	d1eb      	bne.n	800b534 <protocol_execute_realtime+0x14>
            eeprom_emu_sync_physical();
 800b55c:	f7f9 fec4 	bl	80052e8 <eeprom_emu_sync_physical>
 800b560:	e7e8      	b.n	800b534 <protocol_execute_realtime+0x14>

        // Handle spindle overrides during suspend
        state_suspend_manager();

        // If door closed keep issuing cycle start requests until resumed
        if(sys.state == STATE_SAFETY_DOOR && !hal.system_control_get_state().safety_door_ajar)
 800b562:	4e18      	ldr	r6, [pc, #96]	; (800b5c4 <protocol_execute_realtime+0xa4>)
            system_set_exec_state_flag(EXEC_CYCLE_START);
 800b564:	4f18      	ldr	r7, [pc, #96]	; (800b5c8 <protocol_execute_realtime+0xa8>)

        // Check for sleep conditions and execute auto-park, if timeout duration elapses.
        // Sleep is valid for both hold and door states, if the spindle or coolant are on or
        // set to be re-enabled.
        if(settings.flags.sleep_enable)
 800b566:	4d19      	ldr	r5, [pc, #100]	; (800b5cc <protocol_execute_realtime+0xac>)
        if (sys.abort)
 800b568:	7923      	ldrb	r3, [r4, #4]
 800b56a:	2b00      	cmp	r3, #0
 800b56c:	d1e8      	bne.n	800b540 <protocol_execute_realtime+0x20>
        state_suspend_manager();
 800b56e:	f004 fd35 	bl	800ffdc <state_suspend_manager>
        if(sys.state == STATE_SAFETY_DOOR && !hal.system_control_get_state().safety_door_ajar)
 800b572:	6823      	ldr	r3, [r4, #0]
 800b574:	2b40      	cmp	r3, #64	; 0x40
 800b576:	d009      	beq.n	800b58c <protocol_execute_realtime+0x6c>
        if(settings.flags.sleep_enable)
 800b578:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
 800b57c:	065b      	lsls	r3, r3, #25
 800b57e:	d412      	bmi.n	800b5a6 <protocol_execute_realtime+0x86>
            sleep_check();

        protocol_exec_rt_system();
 800b580:	f7ff fdfe 	bl	800b180 <protocol_exec_rt_system>
    while (sys.suspend) {
 800b584:	79a3      	ldrb	r3, [r4, #6]
 800b586:	2b00      	cmp	r3, #0
 800b588:	d1ee      	bne.n	800b568 <protocol_execute_realtime+0x48>
 800b58a:	e7d0      	b.n	800b52e <protocol_execute_realtime+0xe>
        if(sys.state == STATE_SAFETY_DOOR && !hal.system_control_get_state().safety_door_ajar)
 800b58c:	6c33      	ldr	r3, [r6, #64]	; 0x40
 800b58e:	4798      	blx	r3
 800b590:	0702      	lsls	r2, r0, #28
 800b592:	d4f1      	bmi.n	800b578 <protocol_execute_realtime+0x58>
            system_set_exec_state_flag(EXEC_CYCLE_START);
 800b594:	f8d6 3080 	ldr.w	r3, [r6, #128]	; 0x80
 800b598:	2102      	movs	r1, #2
 800b59a:	4638      	mov	r0, r7
 800b59c:	4798      	blx	r3
        if(settings.flags.sleep_enable)
 800b59e:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
 800b5a2:	065b      	lsls	r3, r3, #25
 800b5a4:	d5ec      	bpl.n	800b580 <protocol_execute_realtime+0x60>
            sleep_check();
 800b5a6:	f003 fabd 	bl	800eb24 <sleep_check>
        protocol_exec_rt_system();
 800b5aa:	f7ff fde9 	bl	800b180 <protocol_exec_rt_system>
    while (sys.suspend) {
 800b5ae:	79a3      	ldrb	r3, [r4, #6]
 800b5b0:	2b00      	cmp	r3, #0
 800b5b2:	d1d9      	bne.n	800b568 <protocol_execute_realtime+0x48>
 800b5b4:	e7bb      	b.n	800b52e <protocol_execute_realtime+0xe>
 800b5b6:	bf00      	nop
 800b5b8:	20002494 	.word	0x20002494
 800b5bc:	200023d4 	.word	0x200023d4
 800b5c0:	200023dc 	.word	0x200023dc
 800b5c4:	200024bc 	.word	0x200024bc
 800b5c8:	200024b4 	.word	0x200024b4
 800b5cc:	20002620 	.word	0x20002620

0800b5d0 <protocol_main_loop>:
{
 800b5d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (hal.system_control_get_state().e_stop) {
 800b5d4:	4fa3      	ldr	r7, [pc, #652]	; (800b864 <protocol_main_loop+0x294>)
{
 800b5d6:	b083      	sub	sp, #12
    if (hal.system_control_get_state().e_stop) {
 800b5d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
{
 800b5da:	4605      	mov	r5, r0
    if (hal.system_control_get_state().e_stop) {
 800b5dc:	4798      	blx	r3
 800b5de:	0641      	lsls	r1, r0, #25
 800b5e0:	f100 821b 	bmi.w	800ba1a <protocol_main_loop+0x44a>
    } else if (settings.homing.flags.enabled && sys.homing.mask && settings.homing.flags.init_lock && sys.homing.mask != sys.homed.mask) {
 800b5e4:	4ca0      	ldr	r4, [pc, #640]	; (800b868 <protocol_main_loop+0x298>)
 800b5e6:	f8df 829c 	ldr.w	r8, [pc, #668]	; 800b884 <protocol_main_loop+0x2b4>
 800b5ea:	f894 30d0 	ldrb.w	r3, [r4, #208]	; 0xd0
 800b5ee:	07da      	lsls	r2, r3, #31
 800b5f0:	d509      	bpl.n	800b606 <protocol_main_loop+0x36>
 800b5f2:	f898 200c 	ldrb.w	r2, [r8, #12]
 800b5f6:	b132      	cbz	r2, 800b606 <protocol_main_loop+0x36>
 800b5f8:	075e      	lsls	r6, r3, #29
 800b5fa:	d504      	bpl.n	800b606 <protocol_main_loop+0x36>
 800b5fc:	f898 300d 	ldrb.w	r3, [r8, #13]
 800b600:	4293      	cmp	r3, r2
 800b602:	f040 8230 	bne.w	800ba66 <protocol_main_loop+0x496>
    } else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value) {
 800b606:	f894 30d4 	ldrb.w	r3, [r4, #212]	; 0xd4
 800b60a:	f003 0305 	and.w	r3, r3, #5
 800b60e:	2b05      	cmp	r3, #5
 800b610:	d05f      	beq.n	800b6d2 <protocol_main_loop+0x102>
    } else if(cold_start && (settings.flags.force_initialization_alarm || hal.system_control_get_state().reset)) {
 800b612:	2d00      	cmp	r5, #0
 800b614:	d052      	beq.n	800b6bc <protocol_main_loop+0xec>
 800b616:	f894 30bd 	ldrb.w	r3, [r4, #189]	; 0xbd
 800b61a:	07dc      	lsls	r4, r3, #31
 800b61c:	d403      	bmi.n	800b626 <protocol_main_loop+0x56>
 800b61e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b620:	4798      	blx	r3
 800b622:	07c0      	lsls	r0, r0, #31
 800b624:	d54a      	bpl.n	800b6bc <protocol_main_loop+0xec>
        set_state(STATE_ALARM); // Ensure alarm state is set.
 800b626:	2001      	movs	r0, #1
 800b628:	f004 f9e2 	bl	800f9f0 <set_state>
        hal.report.feedback_message(Message_AlarmLock);
 800b62c:	2002      	movs	r0, #2
 800b62e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800b632:	4798      	blx	r3
    line_flags_t line_flags = {0};
 800b634:	2300      	movs	r3, #0
    bool nocaps = false, gcode_error = false;
 800b636:	461c      	mov	r4, r3
 800b638:	461d      	mov	r5, r3
    char eol = '\0';
 800b63a:	469a      	mov	sl, r3
    line_flags_t line_flags = {0};
 800b63c:	461e      	mov	r6, r3
    user_message.show = keep_rt_commands = false;
 800b63e:	4a8b      	ldr	r2, [pc, #556]	; (800b86c <protocol_main_loop+0x29c>)
    xcommand[0] = '\0';
 800b640:	f8df 9244 	ldr.w	r9, [pc, #580]	; 800b888 <protocol_main_loop+0x2b8>
    user_message.show = keep_rt_commands = false;
 800b644:	7013      	strb	r3, [r2, #0]
 800b646:	4a8a      	ldr	r2, [pc, #552]	; (800b870 <protocol_main_loop+0x2a0>)
    xcommand[0] = '\0';
 800b648:	f889 3000 	strb.w	r3, [r9]
    user_message.show = keep_rt_commands = false;
 800b64c:	7313      	strb	r3, [r2, #12]
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 800b64e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b650:	4798      	blx	r3
 800b652:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b656:	4683      	mov	fp, r0
 800b658:	f000 80b5 	beq.w	800b7c6 <protocol_main_loop+0x1f6>
            if(c == ASCII_CAN) {
 800b65c:	f1bb 0f18 	cmp.w	fp, #24
 800b660:	f000 80eb 	beq.w	800b83a <protocol_main_loop+0x26a>
            } else if ((c == '\n') || (c == '\r')) { // End of line reached
 800b664:	f1bb 0f0a 	cmp.w	fp, #10
 800b668:	f000 80dd 	beq.w	800b826 <protocol_main_loop+0x256>
 800b66c:	f1bb 0f0d 	cmp.w	fp, #13
 800b670:	f000 80d9 	beq.w	800b826 <protocol_main_loop+0x256>
            } else if (c <= (nocaps ? ' ' - 1 : ' ') || line_flags.value) {
 800b674:	2d00      	cmp	r5, #0
 800b676:	bf14      	ite	ne
 800b678:	231f      	movne	r3, #31
 800b67a:	2320      	moveq	r3, #32
 800b67c:	459b      	cmp	fp, r3
 800b67e:	465a      	mov	r2, fp
 800b680:	f340 8126 	ble.w	800b8d0 <protocol_main_loop+0x300>
 800b684:	f016 0fff 	tst.w	r6, #255	; 0xff
 800b688:	f040 8122 	bne.w	800b8d0 <protocol_main_loop+0x300>
                switch(c) {
 800b68c:	f1bb 0f3b 	cmp.w	fp, #59	; 0x3b
 800b690:	dc7e      	bgt.n	800b790 <protocol_main_loop+0x1c0>
 800b692:	f1bb 0f23 	cmp.w	fp, #35	; 0x23
 800b696:	dd38      	ble.n	800b70a <protocol_main_loop+0x13a>
 800b698:	f1ab 0324 	sub.w	r3, fp, #36	; 0x24
 800b69c:	2b17      	cmp	r3, #23
 800b69e:	d834      	bhi.n	800b70a <protocol_main_loop+0x13a>
 800b6a0:	e8df f003 	tbb	[pc, r3]
 800b6a4:	33333379 	.word	0x33333379
 800b6a8:	3333335a 	.word	0x3333335a
 800b6ac:	48333333 	.word	0x48333333
 800b6b0:	33333333 	.word	0x33333333
 800b6b4:	33333333 	.word	0x33333333
 800b6b8:	27333333 	.word	0x27333333
    } else if (sys.state & (STATE_ALARM|STATE_SLEEP)) {
 800b6bc:	f8d8 3000 	ldr.w	r3, [r8]
 800b6c0:	f013 0081 	ands.w	r0, r3, #129	; 0x81
 800b6c4:	d1af      	bne.n	800b626 <protocol_main_loop+0x56>
        set_state(STATE_IDLE);
 800b6c6:	f004 f993 	bl	800f9f0 <set_state>
        system_execute_startup(line); // Execute startup script.
 800b6ca:	486a      	ldr	r0, [pc, #424]	; (800b874 <protocol_main_loop+0x2a4>)
 800b6cc:	f005 fce4 	bl	8011098 <system_execute_startup>
 800b6d0:	e7b0      	b.n	800b634 <protocol_main_loop+0x64>
    } else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value) {
 800b6d2:	6a3b      	ldr	r3, [r7, #32]
 800b6d4:	4798      	blx	r3
 800b6d6:	f010 0fff 	tst.w	r0, #255	; 0xff
 800b6da:	d09a      	beq.n	800b612 <protocol_main_loop+0x42>
        set_state(STATE_ALARM); // Ensure alarm state is active.
 800b6dc:	2001      	movs	r0, #1
 800b6de:	f004 f987 	bl	800f9f0 <set_state>
        report_alarm_message(Alarm_LimitsEngaged);
 800b6e2:	200c      	movs	r0, #12
 800b6e4:	f000 fca0 	bl	800c028 <report_alarm_message>
        hal.report.feedback_message(Message_CheckLimits);
 800b6e8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800b6ec:	2007      	movs	r0, #7
 800b6ee:	4798      	blx	r3
 800b6f0:	e7a0      	b.n	800b634 <protocol_main_loop+0x64>
                        if(!keep_rt_commands) {
 800b6f2:	4b5e      	ldr	r3, [pc, #376]	; (800b86c <protocol_main_loop+0x29c>)
 800b6f4:	781b      	ldrb	r3, [r3, #0]
 800b6f6:	b943      	cbnz	r3, 800b70a <protocol_main_loop+0x13a>
                                keep_rt_commands = true;
 800b6f8:	2201      	movs	r2, #1
                            if((line_flags.comment_semicolon = !line_flags.comment_parentheses))
 800b6fa:	f046 0304 	orr.w	r3, r6, #4
                                keep_rt_commands = true;
 800b6fe:	495b      	ldr	r1, [pc, #364]	; (800b86c <protocol_main_loop+0x29c>)
                            if((line_flags.comment_semicolon = !line_flags.comment_parentheses))
 800b700:	461e      	mov	r6, r3
                if (line_flags.value == 0 && !(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 800b702:	b2db      	uxtb	r3, r3
                                keep_rt_commands = true;
 800b704:	700a      	strb	r2, [r1, #0]
                if (line_flags.value == 0 && !(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 800b706:	2b00      	cmp	r3, #0
 800b708:	d1a1      	bne.n	800b64e <protocol_main_loop+0x7e>
 800b70a:	4b5b      	ldr	r3, [pc, #364]	; (800b878 <protocol_main_loop+0x2a8>)
 800b70c:	681a      	ldr	r2, [r3, #0]
 800b70e:	2aff      	cmp	r2, #255	; 0xff
 800b710:	bf8c      	ite	hi
 800b712:	2101      	movhi	r1, #1
 800b714:	2100      	movls	r1, #0
 800b716:	f361 0600 	bfi	r6, r1, #0, #1
 800b71a:	d898      	bhi.n	800b64e <protocol_main_loop+0x7e>
                    line[char_counter++] = nocaps ? c : CAPS(c);
 800b71c:	2d00      	cmp	r5, #0
 800b71e:	d143      	bne.n	800b7a8 <protocol_main_loop+0x1d8>
 800b720:	f1ab 0161 	sub.w	r1, fp, #97	; 0x61
 800b724:	b289      	uxth	r1, r1
 800b726:	2919      	cmp	r1, #25
 800b728:	f240 8187 	bls.w	800ba3a <protocol_main_loop+0x46a>
 800b72c:	2500      	movs	r5, #0
 800b72e:	fa5f fb8b 	uxtb.w	fp, fp
 800b732:	e03c      	b.n	800b7ae <protocol_main_loop+0x1de>
                        if(char_counter == 0)
 800b734:	4b50      	ldr	r3, [pc, #320]	; (800b878 <protocol_main_loop+0x2a8>)
 800b736:	681a      	ldr	r2, [r3, #0]
 800b738:	2a00      	cmp	r2, #0
 800b73a:	d1e8      	bne.n	800b70e <protocol_main_loop+0x13e>
                            line_flags.block_delete = sys.flags.block_delete_enabled;
 800b73c:	f898 1009 	ldrb.w	r1, [r8, #9]
 800b740:	f3c1 1100 	ubfx	r1, r1, #4, #1
 800b744:	f361 06c3 	bfi	r6, r1, #3, #1
                if (line_flags.value == 0 && !(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 800b748:	f016 0fff 	tst.w	r6, #255	; 0xff
 800b74c:	f47f af7f 	bne.w	800b64e <protocol_main_loop+0x7e>
 800b750:	f362 0600 	bfi	r6, r2, #0, #1
                    line[char_counter++] = nocaps ? c : CAPS(c);
 800b754:	bb45      	cbnz	r5, 800b7a8 <protocol_main_loop+0x1d8>
 800b756:	e7e9      	b.n	800b72c <protocol_main_loop+0x15c>
                        if(!keep_rt_commands) {
 800b758:	4b44      	ldr	r3, [pc, #272]	; (800b86c <protocol_main_loop+0x29c>)
 800b75a:	781b      	ldrb	r3, [r3, #0]
 800b75c:	2b00      	cmp	r3, #0
 800b75e:	d1d4      	bne.n	800b70a <protocol_main_loop+0x13a>
                                if(hal.show_message) {
 800b760:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
                            if((line_flags.comment_parentheses = !line_flags.comment_semicolon)) {
 800b764:	f046 0302 	orr.w	r3, r6, #2
 800b768:	461e      	mov	r6, r3
                                if(hal.show_message) {
 800b76a:	b14a      	cbz	r2, 800b780 <protocol_main_loop+0x1b0>
                                    if(user_message.message == NULL)
 800b76c:	4a40      	ldr	r2, [pc, #256]	; (800b870 <protocol_main_loop+0x2a0>)
 800b76e:	6812      	ldr	r2, [r2, #0]
 800b770:	2a00      	cmp	r2, #0
 800b772:	f000 8183 	beq.w	800ba7c <protocol_main_loop+0x4ac>
                                        user_message.idx = 0;
 800b776:	2100      	movs	r1, #0
                                        user_message.tracker = 1;
 800b778:	2201      	movs	r2, #1
                                        user_message.idx = 0;
 800b77a:	483d      	ldr	r0, [pc, #244]	; (800b870 <protocol_main_loop+0x2a0>)
                                        user_message.tracker = 1;
 800b77c:	e9c0 1201 	strd	r1, r2, [r0, #4]
                                keep_rt_commands = true;
 800b780:	2201      	movs	r2, #1
 800b782:	493a      	ldr	r1, [pc, #232]	; (800b86c <protocol_main_loop+0x29c>)
 800b784:	b2db      	uxtb	r3, r3
 800b786:	700a      	strb	r2, [r1, #0]
                if (line_flags.value == 0 && !(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 800b788:	2b00      	cmp	r3, #0
 800b78a:	f47f af60 	bne.w	800b64e <protocol_main_loop+0x7e>
 800b78e:	e7bc      	b.n	800b70a <protocol_main_loop+0x13a>
                switch(c) {
 800b790:	f1bb 0f5b 	cmp.w	fp, #91	; 0x5b
 800b794:	d1b9      	bne.n	800b70a <protocol_main_loop+0x13a>
                        if(char_counter == 0)
 800b796:	4b38      	ldr	r3, [pc, #224]	; (800b878 <protocol_main_loop+0x2a8>)
 800b798:	681a      	ldr	r2, [r3, #0]
 800b79a:	2a00      	cmp	r2, #0
 800b79c:	d1b7      	bne.n	800b70e <protocol_main_loop+0x13e>
                            nocaps = keep_rt_commands = true;
 800b79e:	2101      	movs	r1, #1
 800b7a0:	4832      	ldr	r0, [pc, #200]	; (800b86c <protocol_main_loop+0x29c>)
                if (line_flags.value == 0 && !(line_flags.overflow = char_counter >= (LINE_BUFFER_SIZE - 1)))
 800b7a2:	f362 0600 	bfi	r6, r2, #0, #1
                            nocaps = keep_rt_commands = true;
 800b7a6:	7001      	strb	r1, [r0, #0]
                    line[char_counter++] = nocaps ? c : CAPS(c);
 800b7a8:	2501      	movs	r5, #1
 800b7aa:	fa5f fb8b 	uxtb.w	fp, fp
 800b7ae:	4831      	ldr	r0, [pc, #196]	; (800b874 <protocol_main_loop+0x2a4>)
 800b7b0:	1c51      	adds	r1, r2, #1
 800b7b2:	f800 b002 	strb.w	fp, [r0, r2]
 800b7b6:	6019      	str	r1, [r3, #0]
        while((c = hal.stream.read()) != SERIAL_NO_DATA) {
 800b7b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b7ba:	4798      	blx	r3
 800b7bc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800b7c0:	4683      	mov	fp, r0
 800b7c2:	f47f af4b 	bne.w	800b65c <protocol_main_loop+0x8c>
        if(xcommand[0] != '\0') {
 800b7c6:	f899 3000 	ldrb.w	r3, [r9]
 800b7ca:	b183      	cbz	r3, 800b7ee <protocol_main_loop+0x21e>
            if (xcommand[0] == '$') // Grbl '$' system command
 800b7cc:	2b24      	cmp	r3, #36	; 0x24
 800b7ce:	f000 80e8 	beq.w	800b9a2 <protocol_main_loop+0x3d2>
            else if (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog state.
 800b7d2:	f240 1121 	movw	r1, #289	; 0x121
 800b7d6:	f8d8 3000 	ldr.w	r3, [r8]
 800b7da:	4019      	ands	r1, r3
 800b7dc:	f000 80cc 	beq.w	800b978 <protocol_main_loop+0x3a8>
                hal.report.status_message(Status_SystemGClock);
 800b7e0:	2009      	movs	r0, #9
 800b7e2:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 800b7e6:	4798      	blx	r3
            xcommand[0] = '\0';
 800b7e8:	2300      	movs	r3, #0
 800b7ea:	f889 3000 	strb.w	r3, [r9]
    if (plan_get_current_block() != NULL) // Check if there are any blocks in the buffer.
 800b7ee:	f7ff f82f 	bl	800a850 <plan_get_current_block>
 800b7f2:	b120      	cbz	r0, 800b7fe <protocol_main_loop+0x22e>
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 800b7f4:	2102      	movs	r1, #2
 800b7f6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b7fa:	4820      	ldr	r0, [pc, #128]	; (800b87c <protocol_main_loop+0x2ac>)
 800b7fc:	4798      	blx	r3
        if(!protocol_execute_realtime() && sys.abort) // Runtime command check point.
 800b7fe:	f7ff fe8f 	bl	800b520 <protocol_execute_realtime>
 800b802:	b920      	cbnz	r0, 800b80e <protocol_main_loop+0x23e>
 800b804:	f898 3004 	ldrb.w	r3, [r8, #4]
 800b808:	2b00      	cmp	r3, #0
 800b80a:	f040 80ce 	bne.w	800b9aa <protocol_main_loop+0x3da>
        sys.cancel = false;
 800b80e:	2200      	movs	r2, #0
        if(settings.flags.sleep_enable)
 800b810:	4b15      	ldr	r3, [pc, #84]	; (800b868 <protocol_main_loop+0x298>)
        sys.cancel = false;
 800b812:	f888 2005 	strb.w	r2, [r8, #5]
        if(settings.flags.sleep_enable)
 800b816:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 800b81a:	065b      	lsls	r3, r3, #25
 800b81c:	f57f af17 	bpl.w	800b64e <protocol_main_loop+0x7e>
            sleep_check();
 800b820:	f003 f980 	bl	800eb24 <sleep_check>
 800b824:	e713      	b.n	800b64e <protocol_main_loop+0x7e>
                if(char_counter == 0 && eol && eol != c) {
 800b826:	4b14      	ldr	r3, [pc, #80]	; (800b878 <protocol_main_loop+0x2a8>)
 800b828:	681a      	ldr	r2, [r3, #0]
 800b82a:	bb7a      	cbnz	r2, 800b88c <protocol_main_loop+0x2bc>
 800b82c:	f1ba 0f00 	cmp.w	sl, #0
 800b830:	d02c      	beq.n	800b88c <protocol_main_loop+0x2bc>
 800b832:	45da      	cmp	sl, fp
 800b834:	d02a      	beq.n	800b88c <protocol_main_loop+0x2bc>
                    eol = '\0';
 800b836:	4692      	mov	sl, r2
 800b838:	e709      	b.n	800b64e <protocol_main_loop+0x7e>
                eol = xcommand[0] = '\0';
 800b83a:	2400      	movs	r4, #0
                keep_rt_commands = nocaps = gcode_error = user_message.show = false;
 800b83c:	480c      	ldr	r0, [pc, #48]	; (800b870 <protocol_main_loop+0x2a0>)
                if (sys.state == STATE_JOG) // Block all other states from invoking motion cancel.
 800b83e:	f8d8 3000 	ldr.w	r3, [r8]
                char_counter = line_flags.value = 0;
 800b842:	490d      	ldr	r1, [pc, #52]	; (800b878 <protocol_main_loop+0x2a8>)
                gc_state.last_error = Status_OK;
 800b844:	4a0e      	ldr	r2, [pc, #56]	; (800b880 <protocol_main_loop+0x2b0>)
                keep_rt_commands = nocaps = gcode_error = user_message.show = false;
 800b846:	7304      	strb	r4, [r0, #12]
 800b848:	4808      	ldr	r0, [pc, #32]	; (800b86c <protocol_main_loop+0x29c>)
                if (sys.state == STATE_JOG) // Block all other states from invoking motion cancel.
 800b84a:	2b20      	cmp	r3, #32
                char_counter = line_flags.value = 0;
 800b84c:	4626      	mov	r6, r4
                eol = xcommand[0] = '\0';
 800b84e:	f889 4000 	strb.w	r4, [r9]
                keep_rt_commands = nocaps = gcode_error = user_message.show = false;
 800b852:	7004      	strb	r4, [r0, #0]
                char_counter = line_flags.value = 0;
 800b854:	600c      	str	r4, [r1, #0]
                gc_state.last_error = Status_OK;
 800b856:	f882 4081 	strb.w	r4, [r2, #129]	; 0x81
                if (sys.state == STATE_JOG) // Block all other states from invoking motion cancel.
 800b85a:	d075      	beq.n	800b948 <protocol_main_loop+0x378>
                keep_rt_commands = nocaps = gcode_error = user_message.show = false;
 800b85c:	4625      	mov	r5, r4
                eol = xcommand[0] = '\0';
 800b85e:	46a2      	mov	sl, r4
 800b860:	e6f5      	b.n	800b64e <protocol_main_loop+0x7e>
 800b862:	bf00      	nop
 800b864:	200024bc 	.word	0x200024bc
 800b868:	20002620 	.word	0x20002620
 800b86c:	2000184c 	.word	0x2000184c
 800b870:	20001954 	.word	0x20001954
 800b874:	20001850 	.word	0x20001850
 800b878:	20001848 	.word	0x20001848
 800b87c:	200024b4 	.word	0x200024b4
 800b880:	200023dc 	.word	0x200023dc
 800b884:	20002494 	.word	0x20002494
 800b888:	20001964 	.word	0x20001964
                    eol = (char)c;
 800b88c:	9301      	str	r3, [sp, #4]
                if(!protocol_execute_realtime()) // Runtime command check point.
 800b88e:	f7ff fe47 	bl	800b520 <protocol_execute_realtime>
                    eol = (char)c;
 800b892:	fa5f fa8b 	uxtb.w	sl, fp
                if(!protocol_execute_realtime()) // Runtime command check point.
 800b896:	9b01      	ldr	r3, [sp, #4]
 800b898:	2800      	cmp	r0, #0
 800b89a:	f000 8086 	beq.w	800b9aa <protocol_main_loop+0x3da>
                line[char_counter] = '\0'; // Set string termination character.
 800b89e:	2000      	movs	r0, #0
 800b8a0:	6819      	ldr	r1, [r3, #0]
 800b8a2:	4a7c      	ldr	r2, [pc, #496]	; (800ba94 <protocol_main_loop+0x4c4>)
 800b8a4:	5450      	strb	r0, [r2, r1]
                if (line_flags.overflow) // Report line overflow error.
 800b8a6:	f016 0001 	ands.w	r0, r6, #1
 800b8aa:	d042      	beq.n	800b932 <protocol_main_loop+0x362>
                    gc_state.last_error = Status_Overflow;
 800b8ac:	220b      	movs	r2, #11
 800b8ae:	4610      	mov	r0, r2
 800b8b0:	4979      	ldr	r1, [pc, #484]	; (800ba98 <protocol_main_loop+0x4c8>)
 800b8b2:	f881 2081 	strb.w	r2, [r1, #129]	; 0x81
                keep_rt_commands = nocaps = user_message.show = false;
 800b8b6:	2500      	movs	r5, #0
                hal.report.status_message(gc_state.last_error);
 800b8b8:	f8d7 2124 	ldr.w	r2, [r7, #292]	; 0x124
 800b8bc:	9301      	str	r3, [sp, #4]
 800b8be:	4790      	blx	r2
                keep_rt_commands = nocaps = user_message.show = false;
 800b8c0:	4b76      	ldr	r3, [pc, #472]	; (800ba9c <protocol_main_loop+0x4cc>)
                char_counter = line_flags.value = 0;
 800b8c2:	462e      	mov	r6, r5
                keep_rt_commands = nocaps = user_message.show = false;
 800b8c4:	731d      	strb	r5, [r3, #12]
 800b8c6:	4b76      	ldr	r3, [pc, #472]	; (800baa0 <protocol_main_loop+0x4d0>)
 800b8c8:	701d      	strb	r5, [r3, #0]
                char_counter = line_flags.value = 0;
 800b8ca:	9b01      	ldr	r3, [sp, #4]
 800b8cc:	601d      	str	r5, [r3, #0]
 800b8ce:	e6be      	b.n	800b64e <protocol_main_loop+0x7e>
                if(c >= ' ' && line_flags.comment_parentheses) {
 800b8d0:	f1bb 0f1f 	cmp.w	fp, #31
 800b8d4:	f77f aebb 	ble.w	800b64e <protocol_main_loop+0x7e>
 800b8d8:	07b1      	lsls	r1, r6, #30
 800b8da:	f57f aeb8 	bpl.w	800b64e <protocol_main_loop+0x7e>
                    if(user_message.tracker == 5)
 800b8de:	4b6f      	ldr	r3, [pc, #444]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b8e0:	689b      	ldr	r3, [r3, #8]
 800b8e2:	2b05      	cmp	r3, #5
 800b8e4:	d07b      	beq.n	800b9de <protocol_main_loop+0x40e>
                    else if(user_message.tracker > 0 && CAPS(c) == msg[user_message.tracker])
 800b8e6:	b163      	cbz	r3, 800b902 <protocol_main_loop+0x332>
 800b8e8:	fa1f f18b 	uxth.w	r1, fp
 800b8ec:	f1a1 0061 	sub.w	r0, r1, #97	; 0x61
 800b8f0:	2819      	cmp	r0, #25
 800b8f2:	bf98      	it	ls
 800b8f4:	f001 025f 	andls.w	r2, r1, #95	; 0x5f
 800b8f8:	496a      	ldr	r1, [pc, #424]	; (800baa4 <protocol_main_loop+0x4d4>)
 800b8fa:	5c59      	ldrb	r1, [r3, r1]
 800b8fc:	4291      	cmp	r1, r2
 800b8fe:	f000 809f 	beq.w	800ba40 <protocol_main_loop+0x470>
                        user_message.tracker = 0;
 800b902:	2200      	movs	r2, #0
 800b904:	4613      	mov	r3, r2
 800b906:	4965      	ldr	r1, [pc, #404]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b908:	608a      	str	r2, [r1, #8]
                    if (c == ')') {
 800b90a:	f1bb 0f29 	cmp.w	fp, #41	; 0x29
 800b90e:	f47f ae9e 	bne.w	800b64e <protocol_main_loop+0x7e>
                        keep_rt_commands = false;
 800b912:	2100      	movs	r1, #0
                        user_message.show = user_message.show || user_message.tracker == 5;
 800b914:	4a61      	ldr	r2, [pc, #388]	; (800ba9c <protocol_main_loop+0x4cc>)
                        keep_rt_commands = false;
 800b916:	4862      	ldr	r0, [pc, #392]	; (800baa0 <protocol_main_loop+0x4d0>)
                        user_message.show = user_message.show || user_message.tracker == 5;
 800b918:	7b12      	ldrb	r2, [r2, #12]
                        line_flags.comment_parentheses = Off;
 800b91a:	f36f 0641 	bfc	r6, #1, #1
                        keep_rt_commands = false;
 800b91e:	7001      	strb	r1, [r0, #0]
                        user_message.show = user_message.show || user_message.tracker == 5;
 800b920:	b922      	cbnz	r2, 800b92c <protocol_main_loop+0x35c>
 800b922:	f1a3 0205 	sub.w	r2, r3, #5
 800b926:	fab2 f282 	clz	r2, r2
 800b92a:	0952      	lsrs	r2, r2, #5
 800b92c:	4b5b      	ldr	r3, [pc, #364]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b92e:	731a      	strb	r2, [r3, #12]
 800b930:	e68d      	b.n	800b64e <protocol_main_loop+0x7e>
                else if ((line[0] == '\0' || char_counter == 0) && !user_message.show) // Empty or comment line. For syncing purposes.
 800b932:	7812      	ldrb	r2, [r2, #0]
 800b934:	b182      	cbz	r2, 800b958 <protocol_main_loop+0x388>
 800b936:	bb19      	cbnz	r1, 800b980 <protocol_main_loop+0x3b0>
 800b938:	4958      	ldr	r1, [pc, #352]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b93a:	7b09      	ldrb	r1, [r1, #12]
 800b93c:	bb01      	cbnz	r1, 800b980 <protocol_main_loop+0x3b0>
                    gc_state.last_error = Status_OK;
 800b93e:	2100      	movs	r1, #0
 800b940:	4a55      	ldr	r2, [pc, #340]	; (800ba98 <protocol_main_loop+0x4c8>)
 800b942:	f882 1081 	strb.w	r1, [r2, #129]	; 0x81
 800b946:	e7b6      	b.n	800b8b6 <protocol_main_loop+0x2e6>
                    system_set_exec_state_flag(EXEC_MOTION_CANCEL);
 800b948:	2180      	movs	r1, #128	; 0x80
 800b94a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800b94e:	4856      	ldr	r0, [pc, #344]	; (800baa8 <protocol_main_loop+0x4d8>)
                keep_rt_commands = nocaps = gcode_error = user_message.show = false;
 800b950:	4625      	mov	r5, r4
                eol = xcommand[0] = '\0';
 800b952:	46a2      	mov	sl, r4
                    system_set_exec_state_flag(EXEC_MOTION_CANCEL);
 800b954:	4798      	blx	r3
 800b956:	e67a      	b.n	800b64e <protocol_main_loop+0x7e>
                else if ((line[0] == '\0' || char_counter == 0) && !user_message.show) // Empty or comment line. For syncing purposes.
 800b958:	4a50      	ldr	r2, [pc, #320]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b95a:	7b12      	ldrb	r2, [r2, #12]
 800b95c:	2a00      	cmp	r2, #0
 800b95e:	d0ee      	beq.n	800b93e <protocol_main_loop+0x36e>
                } else if (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_JOG)) // Everything else is gcode. Block if in alarm, eStop or jog mode.
 800b960:	f240 1121 	movw	r1, #289	; 0x121
 800b964:	f8d8 2000 	ldr.w	r2, [r8]
 800b968:	4211      	tst	r1, r2
 800b96a:	d027      	beq.n	800b9bc <protocol_main_loop+0x3ec>
                    gc_state.last_error = Status_SystemGClock;
 800b96c:	2209      	movs	r2, #9
 800b96e:	494a      	ldr	r1, [pc, #296]	; (800ba98 <protocol_main_loop+0x4c8>)
 800b970:	4610      	mov	r0, r2
 800b972:	f881 2081 	strb.w	r2, [r1, #129]	; 0x81
 800b976:	e79e      	b.n	800b8b6 <protocol_main_loop+0x2e6>
                gc_execute_block(xcommand, NULL);
 800b978:	484c      	ldr	r0, [pc, #304]	; (800baac <protocol_main_loop+0x4dc>)
 800b97a:	f7f9 fe69 	bl	8005650 <gc_execute_block>
 800b97e:	e733      	b.n	800b7e8 <protocol_main_loop+0x218>
                else if (line[0] == '$') {// Grbl '$' system command
 800b980:	2a24      	cmp	r2, #36	; 0x24
 800b982:	d020      	beq.n	800b9c6 <protocol_main_loop+0x3f6>
                } else if (line[0] == '[' && hal.user_command_execute) {
 800b984:	2a5b      	cmp	r2, #91	; 0x5b
 800b986:	d1eb      	bne.n	800b960 <protocol_main_loop+0x390>
 800b988:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 800b98c:	2a00      	cmp	r2, #0
 800b98e:	d0e7      	beq.n	800b960 <protocol_main_loop+0x390>
                    gc_state.last_error = hal.user_command_execute(line);
 800b990:	4840      	ldr	r0, [pc, #256]	; (800ba94 <protocol_main_loop+0x4c4>)
 800b992:	9301      	str	r3, [sp, #4]
 800b994:	4790      	blx	r2
 800b996:	4a40      	ldr	r2, [pc, #256]	; (800ba98 <protocol_main_loop+0x4c8>)
                    gcode_error = false;
 800b998:	2400      	movs	r4, #0
                    gc_state.last_error = hal.user_command_execute(line);
 800b99a:	9b01      	ldr	r3, [sp, #4]
 800b99c:	f882 0081 	strb.w	r0, [r2, #129]	; 0x81
 800b9a0:	e789      	b.n	800b8b6 <protocol_main_loop+0x2e6>
                system_execute_line(xcommand);
 800b9a2:	4842      	ldr	r0, [pc, #264]	; (800baac <protocol_main_loop+0x4dc>)
 800b9a4:	f005 fba0 	bl	80110e8 <system_execute_line>
 800b9a8:	e71e      	b.n	800b7e8 <protocol_main_loop+0x218>
            return !sys.flags.exit;                   // Bail to main() program loop to reset system.
 800b9aa:	f898 0009 	ldrb.w	r0, [r8, #9]
 800b9ae:	f080 0008 	eor.w	r0, r0, #8
 800b9b2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
}
 800b9b6:	b003      	add	sp, #12
 800b9b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                else if(!gcode_error) { // Parse and execute g-code block.
 800b9bc:	b1ec      	cbz	r4, 800b9fa <protocol_main_loop+0x42a>
 800b9be:	4a36      	ldr	r2, [pc, #216]	; (800ba98 <protocol_main_loop+0x4c8>)
 800b9c0:	f892 0081 	ldrb.w	r0, [r2, #129]	; 0x81
 800b9c4:	e777      	b.n	800b8b6 <protocol_main_loop+0x2e6>
                    if((gc_state.last_error = system_execute_line(line)) == Status_LimitsEngaged) {
 800b9c6:	4833      	ldr	r0, [pc, #204]	; (800ba94 <protocol_main_loop+0x4c4>)
 800b9c8:	9301      	str	r3, [sp, #4]
 800b9ca:	f005 fb8d 	bl	80110e8 <system_execute_line>
 800b9ce:	4d32      	ldr	r5, [pc, #200]	; (800ba98 <protocol_main_loop+0x4c8>)
 800b9d0:	282d      	cmp	r0, #45	; 0x2d
 800b9d2:	9b01      	ldr	r3, [sp, #4]
 800b9d4:	f885 0081 	strb.w	r0, [r5, #129]	; 0x81
 800b9d8:	d036      	beq.n	800ba48 <protocol_main_loop+0x478>
                    gcode_error = false;
 800b9da:	2400      	movs	r4, #0
 800b9dc:	e76b      	b.n	800b8b6 <protocol_main_loop+0x2e6>
                        user_message.message[user_message.idx++] = c == ')' ? '\0' : c;
 800b9de:	f1bb 0f29 	cmp.w	fp, #41	; 0x29
 800b9e2:	bf14      	ite	ne
 800b9e4:	46dc      	movne	ip, fp
 800b9e6:	f04f 0c00 	moveq.w	ip, #0
 800b9ea:	492c      	ldr	r1, [pc, #176]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b9ec:	c906      	ldmia	r1, {r1, r2}
 800b9ee:	f801 c002 	strb.w	ip, [r1, r2]
 800b9f2:	492a      	ldr	r1, [pc, #168]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b9f4:	1c50      	adds	r0, r2, #1
 800b9f6:	6048      	str	r0, [r1, #4]
 800b9f8:	e787      	b.n	800b90a <protocol_main_loop+0x33a>
                    gc_state.last_error = gc_execute_block(line, user_message.show ? user_message.message : NULL);
 800b9fa:	4928      	ldr	r1, [pc, #160]	; (800ba9c <protocol_main_loop+0x4cc>)
 800b9fc:	7b0a      	ldrb	r2, [r1, #12]
 800b9fe:	b1d2      	cbz	r2, 800ba36 <protocol_main_loop+0x466>
 800ba00:	6809      	ldr	r1, [r1, #0]
 800ba02:	4824      	ldr	r0, [pc, #144]	; (800ba94 <protocol_main_loop+0x4c4>)
 800ba04:	9301      	str	r3, [sp, #4]
 800ba06:	f7f9 fe23 	bl	8005650 <gc_execute_block>
 800ba0a:	4a23      	ldr	r2, [pc, #140]	; (800ba98 <protocol_main_loop+0x4c8>)
                    gcode_error = gc_state.last_error != Status_OK;
 800ba0c:	1e04      	subs	r4, r0, #0
 800ba0e:	bf18      	it	ne
 800ba10:	2401      	movne	r4, #1
 800ba12:	9b01      	ldr	r3, [sp, #4]
                    gc_state.last_error = gc_execute_block(line, user_message.show ? user_message.message : NULL);
 800ba14:	f882 0081 	strb.w	r0, [r2, #129]	; 0x81
                    gcode_error = gc_state.last_error != Status_OK;
 800ba18:	e74d      	b.n	800b8b6 <protocol_main_loop+0x2e6>
        set_state(STATE_ESTOP);
 800ba1a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800ba1e:	f003 ffe7 	bl	800f9f0 <set_state>
        report_alarm_message(Alarm_EStop);
 800ba22:	200a      	movs	r0, #10
 800ba24:	f000 fb00 	bl	800c028 <report_alarm_message>
        hal.report.feedback_message(Message_EStop);
 800ba28:	200c      	movs	r0, #12
 800ba2a:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800ba2e:	4798      	blx	r3
 800ba30:	f8df 807c 	ldr.w	r8, [pc, #124]	; 800bab0 <protocol_main_loop+0x4e0>
 800ba34:	e5fe      	b.n	800b634 <protocol_main_loop+0x64>
                    gc_state.last_error = gc_execute_block(line, user_message.show ? user_message.message : NULL);
 800ba36:	4621      	mov	r1, r4
 800ba38:	e7e3      	b.n	800ba02 <protocol_main_loop+0x432>
                    line[char_counter++] = nocaps ? c : CAPS(c);
 800ba3a:	f00b 0b5f 	and.w	fp, fp, #95	; 0x5f
 800ba3e:	e6b6      	b.n	800b7ae <protocol_main_loop+0x1de>
                        user_message.tracker++;
 800ba40:	4a16      	ldr	r2, [pc, #88]	; (800ba9c <protocol_main_loop+0x4cc>)
 800ba42:	3301      	adds	r3, #1
 800ba44:	6093      	str	r3, [r2, #8]
 800ba46:	e760      	b.n	800b90a <protocol_main_loop+0x33a>
                        set_state(STATE_ALARM); // Ensure alarm state is active.
 800ba48:	2001      	movs	r0, #1
 800ba4a:	f003 ffd1 	bl	800f9f0 <set_state>
                        report_alarm_message(Alarm_LimitsEngaged);
 800ba4e:	200c      	movs	r0, #12
 800ba50:	f000 faea 	bl	800c028 <report_alarm_message>
                        hal.report.feedback_message(Message_CheckLimits);
 800ba54:	2007      	movs	r0, #7
 800ba56:	f8d7 2128 	ldr.w	r2, [r7, #296]	; 0x128
 800ba5a:	4790      	blx	r2
                    gcode_error = false;
 800ba5c:	2400      	movs	r4, #0
 800ba5e:	f895 0081 	ldrb.w	r0, [r5, #129]	; 0x81
 800ba62:	9b01      	ldr	r3, [sp, #4]
 800ba64:	e727      	b.n	800b8b6 <protocol_main_loop+0x2e6>
        set_state(STATE_ALARM); // Ensure alarm state is active.
 800ba66:	2001      	movs	r0, #1
 800ba68:	f003 ffc2 	bl	800f9f0 <set_state>
        report_alarm_message(Alarm_HomingRequried);
 800ba6c:	200b      	movs	r0, #11
 800ba6e:	f000 fadb 	bl	800c028 <report_alarm_message>
        hal.report.feedback_message(Message_HomingCycleRequired);
 800ba72:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 800ba76:	200d      	movs	r0, #13
 800ba78:	4798      	blx	r3
 800ba7a:	e5db      	b.n	800b634 <protocol_main_loop+0x64>
                                        user_message.message = malloc(LINE_BUFFER_SIZE);
 800ba7c:	f240 1001 	movw	r0, #257	; 0x101
 800ba80:	9301      	str	r3, [sp, #4]
 800ba82:	f006 f8d3 	bl	8011c2c <malloc>
 800ba86:	4b05      	ldr	r3, [pc, #20]	; (800ba9c <protocol_main_loop+0x4cc>)
 800ba88:	6018      	str	r0, [r3, #0]
                                    if(user_message.message) {
 800ba8a:	9b01      	ldr	r3, [sp, #4]
 800ba8c:	2800      	cmp	r0, #0
 800ba8e:	f43f ae77 	beq.w	800b780 <protocol_main_loop+0x1b0>
 800ba92:	e670      	b.n	800b776 <protocol_main_loop+0x1a6>
 800ba94:	20001850 	.word	0x20001850
 800ba98:	200023dc 	.word	0x200023dc
 800ba9c:	20001954 	.word	0x20001954
 800baa0:	2000184c 	.word	0x2000184c
 800baa4:	080149a0 	.word	0x080149a0
 800baa8:	200024b4 	.word	0x200024b4
 800baac:	20001964 	.word	0x20001964
 800bab0:	20002494 	.word	0x20002494

0800bab4 <protocol_buffer_synchronize>:
{
 800bab4:	b538      	push	{r3, r4, r5, lr}
    if (plan_get_current_block() != NULL) // Check if there are any blocks in the buffer.
 800bab6:	f7fe fecb 	bl	800a850 <plan_get_current_block>
 800baba:	b128      	cbz	r0, 800bac8 <protocol_buffer_synchronize+0x14>
        system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 800babc:	4b09      	ldr	r3, [pc, #36]	; (800bae4 <protocol_buffer_synchronize+0x30>)
 800babe:	2102      	movs	r1, #2
 800bac0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bac4:	4808      	ldr	r0, [pc, #32]	; (800bae8 <protocol_buffer_synchronize+0x34>)
 800bac6:	4798      	blx	r3
    while ((ok = protocol_execute_realtime()) && (plan_get_current_block() || sys.state == STATE_CYCLE));
 800bac8:	4d08      	ldr	r5, [pc, #32]	; (800baec <protocol_buffer_synchronize+0x38>)
 800baca:	f7ff fd29 	bl	800b520 <protocol_execute_realtime>
 800bace:	4604      	mov	r4, r0
 800bad0:	b130      	cbz	r0, 800bae0 <protocol_buffer_synchronize+0x2c>
 800bad2:	f7fe febd 	bl	800a850 <plan_get_current_block>
 800bad6:	2800      	cmp	r0, #0
 800bad8:	d1f7      	bne.n	800baca <protocol_buffer_synchronize+0x16>
 800bada:	682b      	ldr	r3, [r5, #0]
 800badc:	2b08      	cmp	r3, #8
 800bade:	d0f4      	beq.n	800baca <protocol_buffer_synchronize+0x16>
}
 800bae0:	4620      	mov	r0, r4
 800bae2:	bd38      	pop	{r3, r4, r5, pc}
 800bae4:	200024bc 	.word	0x200024bc
 800bae8:	200024b4 	.word	0x200024b4
 800baec:	20002494 	.word	0x20002494

0800baf0 <protocol_enqueue_realtime_command>:

    // 1. Process characters in the ranges 0x - 1x and 8x-Ax
    // Characters with functions assigned are always acted upon even when the input stream
    // is redirected to a non-interactive stream such as from a SD card.

    switch ((unsigned char)c) {
 800baf0:	1ec3      	subs	r3, r0, #3
{
 800baf2:	b510      	push	{r4, lr}
 800baf4:	2b9f      	cmp	r3, #159	; 0x9f
 800baf6:	f200 80a2 	bhi.w	800bc3e <protocol_enqueue_realtime_command+0x14e>
 800bafa:	e8df f013 	tbh	[pc, r3, lsl #1]
 800bafe:	012d      	.short	0x012d
 800bb00:	00dc00a0 	.word	0x00dc00a0
 800bb04:	00a000a0 	.word	0x00a000a0
 800bb08:	00a000a0 	.word	0x00a000a0
 800bb0c:	00a0013d 	.word	0x00a0013d
 800bb10:	013d00a0 	.word	0x013d00a0
 800bb14:	00a000a0 	.word	0x00a000a0
 800bb18:	00a000a0 	.word	0x00a000a0
 800bb1c:	00a000a0 	.word	0x00a000a0
 800bb20:	00a000a0 	.word	0x00a000a0
 800bb24:	00a000a0 	.word	0x00a000a0
 800bb28:	01000124 	.word	0x01000124
 800bb2c:	00a000a0 	.word	0x00a000a0
 800bb30:	00a000a0 	.word	0x00a000a0
 800bb34:	00a000a0 	.word	0x00a000a0
 800bb38:	00a000a0 	.word	0x00a000a0
 800bb3c:	00a000a0 	.word	0x00a000a0
 800bb40:	00a000a0 	.word	0x00a000a0
 800bb44:	00a000a0 	.word	0x00a000a0
 800bb48:	00a000a0 	.word	0x00a000a0
 800bb4c:	00a000a0 	.word	0x00a000a0
 800bb50:	00a000a0 	.word	0x00a000a0
 800bb54:	00a000a0 	.word	0x00a000a0
 800bb58:	00a000a0 	.word	0x00a000a0
 800bb5c:	00a000a0 	.word	0x00a000a0
 800bb60:	00a000a0 	.word	0x00a000a0
 800bb64:	00a000a0 	.word	0x00a000a0
 800bb68:	00a000a0 	.word	0x00a000a0
 800bb6c:	00a000a0 	.word	0x00a000a0
 800bb70:	00a000a0 	.word	0x00a000a0
 800bb74:	00a000a0 	.word	0x00a000a0
 800bb78:	00a000a0 	.word	0x00a000a0
 800bb7c:	00a000a0 	.word	0x00a000a0
 800bb80:	00a000a0 	.word	0x00a000a0
 800bb84:	00a000a0 	.word	0x00a000a0
 800bb88:	00a000a0 	.word	0x00a000a0
 800bb8c:	00a000a0 	.word	0x00a000a0
 800bb90:	00a000a0 	.word	0x00a000a0
 800bb94:	00a000a0 	.word	0x00a000a0
 800bb98:	00a000a0 	.word	0x00a000a0
 800bb9c:	00a000a0 	.word	0x00a000a0
 800bba0:	00a000a0 	.word	0x00a000a0
 800bba4:	00a000a0 	.word	0x00a000a0
 800bba8:	00a000a0 	.word	0x00a000a0
 800bbac:	00a000a0 	.word	0x00a000a0
 800bbb0:	00a000a0 	.word	0x00a000a0
 800bbb4:	00a000a0 	.word	0x00a000a0
 800bbb8:	00a000a0 	.word	0x00a000a0
 800bbbc:	00a000a0 	.word	0x00a000a0
 800bbc0:	00a000a0 	.word	0x00a000a0
 800bbc4:	00a000a0 	.word	0x00a000a0
 800bbc8:	00a000a0 	.word	0x00a000a0
 800bbcc:	00a000a0 	.word	0x00a000a0
 800bbd0:	00a000a0 	.word	0x00a000a0
 800bbd4:	00a000a0 	.word	0x00a000a0
 800bbd8:	00a000a0 	.word	0x00a000a0
 800bbdc:	00a000a0 	.word	0x00a000a0
 800bbe0:	00a000a0 	.word	0x00a000a0
 800bbe4:	00a000a0 	.word	0x00a000a0
 800bbe8:	00a000a0 	.word	0x00a000a0
 800bbec:	00a000a0 	.word	0x00a000a0
 800bbf0:	00a000a0 	.word	0x00a000a0
 800bbf4:	00a000a0 	.word	0x00a000a0
 800bbf8:	00b200dc 	.word	0x00b200dc
 800bbfc:	011b00d0 	.word	0x011b00d0
 800bc00:	00ef00e4 	.word	0x00ef00e4
 800bc04:	00d800a0 	.word	0x00d800a0
 800bc08:	00a0010d 	.word	0x00a0010d
 800bc0c:	00a000a0 	.word	0x00a000a0
 800bc10:	00a000a0 	.word	0x00a000a0
 800bc14:	00a000a0 	.word	0x00a000a0
 800bc18:	00be00be 	.word	0x00be00be
 800bc1c:	00be00be 	.word	0x00be00be
 800bc20:	00be00be 	.word	0x00be00be
 800bc24:	00be00be 	.word	0x00be00be
 800bc28:	00c200a0 	.word	0x00c200a0
 800bc2c:	00c200c2 	.word	0x00c200c2
 800bc30:	00c200c2 	.word	0x00c200c2
 800bc34:	00a000c2 	.word	0x00a000c2
 800bc38:	00c200c2 	.word	0x00c200c2
 800bc3c:	00f7      	.short	0x00f7
            drop = true;
            enqueue_accessory_override((uint8_t)c);
            break;

        default:
            if(c < ' ' || (c >= 0x7F && c <= 0xBF))
 800bc3e:	281f      	cmp	r0, #31
 800bc40:	d933      	bls.n	800bcaa <protocol_enqueue_realtime_command+0x1ba>
 800bc42:	f1a0 037f 	sub.w	r3, r0, #127	; 0x7f
 800bc46:	2b40      	cmp	r3, #64	; 0x40
 800bc48:	d92f      	bls.n	800bcaa <protocol_enqueue_realtime_command+0x1ba>

    // 2. Process printable ASCII characters and top-bit set characters
    //    If legacy realtime commands are disabled they are returned to the input stream
    //    when appering in settings ($ commands) or comments

    if(!drop) switch ((unsigned char)c) {
 800bc4a:	283f      	cmp	r0, #63	; 0x3f
 800bc4c:	f000 809b 	beq.w	800bd86 <protocol_enqueue_realtime_command+0x296>
 800bc50:	287e      	cmp	r0, #126	; 0x7e
 800bc52:	d11a      	bne.n	800bc8a <protocol_enqueue_realtime_command+0x19a>
                drop = true;
            }
            break;

        case CMD_CYCLE_START_LEGACY:
            if(!keep_rt_commands || settings.legacy_rt_commands) {
 800bc54:	4b51      	ldr	r3, [pc, #324]	; (800bd9c <protocol_enqueue_realtime_command+0x2ac>)
 800bc56:	781b      	ldrb	r3, [r3, #0]
 800bc58:	b11b      	cbz	r3, 800bc62 <protocol_enqueue_realtime_command+0x172>
 800bc5a:	4b51      	ldr	r3, [pc, #324]	; (800bda0 <protocol_enqueue_realtime_command+0x2b0>)
 800bc5c:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 800bc60:	b150      	cbz	r0, 800bc78 <protocol_enqueue_realtime_command+0x188>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 800bc62:	4b50      	ldr	r3, [pc, #320]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bc64:	4850      	ldr	r0, [pc, #320]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bc66:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bc6a:	2102      	movs	r1, #2
 800bc6c:	4798      	blx	r3
                // Cancel any pending tool change
                gc_state.tool_change = false;
 800bc6e:	2200      	movs	r2, #0
                drop = true;
 800bc70:	2001      	movs	r0, #1
                gc_state.tool_change = false;
 800bc72:	4b4e      	ldr	r3, [pc, #312]	; (800bdac <protocol_enqueue_realtime_command+0x2bc>)
 800bc74:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
            break;
    }

    return drop;
}
 800bc78:	bd10      	pop	{r4, pc}
            enqueue_feed_override(c);
 800bc7a:	f7fe fc13 	bl	800a4a4 <enqueue_feed_override>
            drop = true;
 800bc7e:	2001      	movs	r0, #1
}
 800bc80:	bd10      	pop	{r4, pc}
            enqueue_accessory_override((uint8_t)c);
 800bc82:	f7fe fc2f 	bl	800a4e4 <enqueue_accessory_override>
            drop = true;
 800bc86:	2001      	movs	r0, #1
}
 800bc88:	bd10      	pop	{r4, pc}
    if(!drop) switch ((unsigned char)c) {
 800bc8a:	2821      	cmp	r0, #33	; 0x21
 800bc8c:	d174      	bne.n	800bd78 <protocol_enqueue_realtime_command+0x288>
            if(!keep_rt_commands || settings.legacy_rt_commands) {
 800bc8e:	4b43      	ldr	r3, [pc, #268]	; (800bd9c <protocol_enqueue_realtime_command+0x2ac>)
 800bc90:	781b      	ldrb	r3, [r3, #0]
 800bc92:	b123      	cbz	r3, 800bc9e <protocol_enqueue_realtime_command+0x1ae>
 800bc94:	4b42      	ldr	r3, [pc, #264]	; (800bda0 <protocol_enqueue_realtime_command+0x2b0>)
 800bc96:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 800bc9a:	2800      	cmp	r0, #0
 800bc9c:	d0ec      	beq.n	800bc78 <protocol_enqueue_realtime_command+0x188>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 800bc9e:	4b41      	ldr	r3, [pc, #260]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bca0:	2108      	movs	r1, #8
 800bca2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bca6:	4840      	ldr	r0, [pc, #256]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bca8:	4798      	blx	r3
                drop = true;
 800bcaa:	2001      	movs	r0, #1
}
 800bcac:	bd10      	pop	{r4, pc}
            sys.report.value = (uint16_t)-1;
 800bcae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800bcb2:	4b3f      	ldr	r3, [pc, #252]	; (800bdb0 <protocol_enqueue_realtime_command+0x2c0>)
 800bcb4:	829a      	strh	r2, [r3, #20]
                system_set_exec_state_flag(EXEC_STATUS_REPORT);
 800bcb6:	4b3b      	ldr	r3, [pc, #236]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bcb8:	2101      	movs	r1, #1
 800bcba:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bcbe:	483a      	ldr	r0, [pc, #232]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bcc0:	4798      	blx	r3
                drop = true;
 800bcc2:	2001      	movs	r0, #1
}
 800bcc4:	bd10      	pop	{r4, pc}
            if(!hal.driver_cap.safety_door) {
 800bcc6:	4b37      	ldr	r3, [pc, #220]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bcc8:	f893 2144 	ldrb.w	r2, [r3, #324]	; 0x144
 800bccc:	0752      	lsls	r2, r2, #29
 800bcce:	d54c      	bpl.n	800bd6a <protocol_enqueue_realtime_command+0x27a>
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
 800bcd0:	4b32      	ldr	r3, [pc, #200]	; (800bd9c <protocol_enqueue_realtime_command+0x2ac>)
 800bcd2:	781b      	ldrb	r3, [r3, #0]
 800bcd4:	2b00      	cmp	r3, #0
 800bcd6:	d0e8      	beq.n	800bcaa <protocol_enqueue_realtime_command+0x1ba>
{
 800bcd8:	2000      	movs	r0, #0
}
 800bcda:	bd10      	pop	{r4, pc}
            char_counter = 0;
 800bcdc:	2100      	movs	r1, #0
 800bcde:	4a35      	ldr	r2, [pc, #212]	; (800bdb4 <protocol_enqueue_realtime_command+0x2c4>)
            hal.stream.cancel_read_buffer();
 800bce0:	4b30      	ldr	r3, [pc, #192]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
            char_counter = 0;
 800bce2:	6011      	str	r1, [r2, #0]
            hal.stream.cancel_read_buffer();
 800bce4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bce6:	4798      	blx	r3
            drop = true;
 800bce8:	2001      	movs	r0, #1
}
 800bcea:	bd10      	pop	{r4, pc}
            system_set_exec_state_flag(EXEC_PID_REPORT);
 800bcec:	4b2d      	ldr	r3, [pc, #180]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bcee:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800bcf2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bcf6:	482c      	ldr	r0, [pc, #176]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bcf8:	4798      	blx	r3
            drop = true;
 800bcfa:	2001      	movs	r0, #1
}
 800bcfc:	bd10      	pop	{r4, pc}
            system_set_exec_state_flag(EXEC_STOP);
 800bcfe:	4c29      	ldr	r4, [pc, #164]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bd00:	4829      	ldr	r0, [pc, #164]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bd02:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800bd06:	2110      	movs	r1, #16
 800bd08:	4798      	blx	r3
            char_counter = 0;
 800bd0a:	2100      	movs	r1, #0
 800bd0c:	4a29      	ldr	r2, [pc, #164]	; (800bdb4 <protocol_enqueue_realtime_command+0x2c4>)
            hal.stream.cancel_read_buffer();
 800bd0e:	6f63      	ldr	r3, [r4, #116]	; 0x74
            char_counter = 0;
 800bd10:	6011      	str	r1, [r2, #0]
            hal.stream.cancel_read_buffer();
 800bd12:	4798      	blx	r3
            drop = true;
 800bd14:	2001      	movs	r0, #1
}
 800bd16:	bd10      	pop	{r4, pc}
            if(!hal.driver_cap.program_stop) // Not available as realtime command if HAL supports physical switch
 800bd18:	4b22      	ldr	r3, [pc, #136]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bd1a:	f893 3145 	ldrb.w	r3, [r3, #325]	; 0x145
 800bd1e:	071b      	lsls	r3, r3, #28
 800bd20:	d4d6      	bmi.n	800bcd0 <protocol_enqueue_realtime_command+0x1e0>
                sys.flags.optional_stop_disable = !sys.flags.optional_stop_disable;
 800bd22:	4923      	ldr	r1, [pc, #140]	; (800bdb0 <protocol_enqueue_realtime_command+0x2c0>)
 800bd24:	7a4b      	ldrb	r3, [r1, #9]
 800bd26:	43da      	mvns	r2, r3
 800bd28:	f3c2 12c0 	ubfx	r2, r2, #7, #1
 800bd2c:	f362 13c7 	bfi	r3, r2, #7, #1
 800bd30:	724b      	strb	r3, [r1, #9]
    if(!drop) switch ((unsigned char)c) {
 800bd32:	e7cd      	b.n	800bcd0 <protocol_enqueue_realtime_command+0x1e0>
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 800bd34:	4b1b      	ldr	r3, [pc, #108]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bd36:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800bd3a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bd3e:	481a      	ldr	r0, [pc, #104]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bd40:	4798      	blx	r3
            drop = true;
 800bd42:	2001      	movs	r0, #1
}
 800bd44:	bd10      	pop	{r4, pc}
            if(!hal.system_control_get_state().e_stop)
 800bd46:	4b17      	ldr	r3, [pc, #92]	; (800bda4 <protocol_enqueue_realtime_command+0x2b4>)
 800bd48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800bd4a:	4798      	blx	r3
 800bd4c:	0641      	lsls	r1, r0, #25
 800bd4e:	d4ac      	bmi.n	800bcaa <protocol_enqueue_realtime_command+0x1ba>
                mc_reset();
 800bd50:	f7fe f854 	bl	8009dfc <mc_reset>
            drop = true;
 800bd54:	2001      	movs	r0, #1
}
 800bd56:	bd10      	pop	{r4, pc}
            mc_reset();
 800bd58:	f7fe f850 	bl	8009dfc <mc_reset>
            sys.flags.exit = On;
 800bd5c:	4a14      	ldr	r2, [pc, #80]	; (800bdb0 <protocol_enqueue_realtime_command+0x2c0>)
            drop = true;
 800bd5e:	2001      	movs	r0, #1
            sys.flags.exit = On;
 800bd60:	7a53      	ldrb	r3, [r2, #9]
 800bd62:	f043 0308 	orr.w	r3, r3, #8
 800bd66:	7253      	strb	r3, [r2, #9]
}
 800bd68:	bd10      	pop	{r4, pc}
                system_set_exec_state_flag(EXEC_SAFETY_DOOR);
 800bd6a:	2140      	movs	r1, #64	; 0x40
 800bd6c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bd70:	480d      	ldr	r0, [pc, #52]	; (800bda8 <protocol_enqueue_realtime_command+0x2b8>)
 800bd72:	4798      	blx	r3
                drop = true;
 800bd74:	2001      	movs	r0, #1
}
 800bd76:	bd10      	pop	{r4, pc}
            drop = !(keep_rt_commands || (unsigned char)c < 0x7F);
 800bd78:	4b08      	ldr	r3, [pc, #32]	; (800bd9c <protocol_enqueue_realtime_command+0x2ac>)
 800bd7a:	781b      	ldrb	r3, [r3, #0]
 800bd7c:	2b00      	cmp	r3, #0
 800bd7e:	d1ab      	bne.n	800bcd8 <protocol_enqueue_realtime_command+0x1e8>
 800bd80:	287e      	cmp	r0, #126	; 0x7e
 800bd82:	d9a9      	bls.n	800bcd8 <protocol_enqueue_realtime_command+0x1e8>
 800bd84:	e791      	b.n	800bcaa <protocol_enqueue_realtime_command+0x1ba>
            if(!keep_rt_commands || settings.legacy_rt_commands) {
 800bd86:	4b05      	ldr	r3, [pc, #20]	; (800bd9c <protocol_enqueue_realtime_command+0x2ac>)
 800bd88:	781b      	ldrb	r3, [r3, #0]
 800bd8a:	2b00      	cmp	r3, #0
 800bd8c:	d093      	beq.n	800bcb6 <protocol_enqueue_realtime_command+0x1c6>
 800bd8e:	4b04      	ldr	r3, [pc, #16]	; (800bda0 <protocol_enqueue_realtime_command+0x2b0>)
 800bd90:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 800bd94:	2800      	cmp	r0, #0
 800bd96:	f43f af6f 	beq.w	800bc78 <protocol_enqueue_realtime_command+0x188>
 800bd9a:	e78c      	b.n	800bcb6 <protocol_enqueue_realtime_command+0x1c6>
 800bd9c:	2000184c 	.word	0x2000184c
 800bda0:	20002620 	.word	0x20002620
 800bda4:	200024bc 	.word	0x200024bc
 800bda8:	200024b4 	.word	0x200024b4
 800bdac:	200023dc 	.word	0x200023dc
 800bdb0:	20002494 	.word	0x20002494
 800bdb4:	20001848 	.word	0x20001848

0800bdb8 <get_rate_value_mm>:
    return buf;
}

// Convert rate value to null terminated string (mm).
static char *get_rate_value_mm (float value)
{
 800bdb8:	b508      	push	{r3, lr}
    return uitoa((uint32_t)value);
 800bdba:	f7f4 feed 	bl	8000b98 <__aeabi_f2uiz>
}
 800bdbe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return uitoa((uint32_t)value);
 800bdc2:	f7fe b957 	b.w	800a074 <uitoa>
 800bdc6:	bf00      	nop

0800bdc8 <get_rate_value_inch>:

// Convert rate value to null terminated string (mm).
static char *get_rate_value_inch (float value)
{
 800bdc8:	b508      	push	{r3, lr}
    return uitoa((uint32_t)(value * INCH_PER_MM));
 800bdca:	4904      	ldr	r1, [pc, #16]	; (800bddc <get_rate_value_inch+0x14>)
 800bdcc:	f7f4 fce2 	bl	8000794 <__aeabi_fmul>
 800bdd0:	f7f4 fee2 	bl	8000b98 <__aeabi_f2uiz>
}
 800bdd4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return uitoa((uint32_t)(value * INCH_PER_MM));
 800bdd8:	f7fe b94c 	b.w	800a074 <uitoa>
 800bddc:	3d21428b 	.word	0x3d21428b

0800bde0 <get_axis_values_mm>:
    buf[0] = '\0';
 800bde0:	2300      	movs	r3, #0
{
 800bde2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    for (idx = 0; idx < N_AXIS; idx++) {
 800bde6:	461c      	mov	r4, r3
    buf[0] = '\0';
 800bde8:	4f20      	ldr	r7, [pc, #128]	; (800be6c <get_axis_values_mm+0x8c>)
{
 800bdea:	4605      	mov	r5, r0
            strcat(buf, ",");
 800bdec:	463e      	mov	r6, r7
 800bdee:	f8df 8080 	ldr.w	r8, [pc, #128]	; 800be70 <get_axis_values_mm+0x90>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 800bdf2:	f8df 9080 	ldr.w	r9, [pc, #128]	; 800be74 <get_axis_values_mm+0x94>
    buf[0] = '\0';
 800bdf6:	703b      	strb	r3, [r7, #0]
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 800bdf8:	b9ac      	cbnz	r4, 800be26 <get_axis_values_mm+0x46>
 800bdfa:	f899 3004 	ldrb.w	r3, [r9, #4]
 800bdfe:	bb03      	cbnz	r3, 800be42 <get_axis_values_mm+0x62>
            strcat(buf, ftoa(axis_values[idx], N_DECIMAL_COORDVALUE_MM));
 800be00:	2103      	movs	r1, #3
 800be02:	6828      	ldr	r0, [r5, #0]
 800be04:	f7fe f958 	bl	800a0b8 <ftoa>
 800be08:	4601      	mov	r1, r0
 800be0a:	4630      	mov	r0, r6
 800be0c:	f006 faef 	bl	80123ee <strcat>
            strcat(buf, ",");
 800be10:	4630      	mov	r0, r6
 800be12:	f7f4 f99d 	bl	8000150 <strlen>
    for (idx = 0; idx < N_AXIS; idx++) {
 800be16:	3401      	adds	r4, #1
            strcat(buf, ",");
 800be18:	f8b8 3000 	ldrh.w	r3, [r8]
    for (idx = 0; idx < N_AXIS; idx++) {
 800be1c:	2c03      	cmp	r4, #3
            strcat(buf, ",");
 800be1e:	523b      	strh	r3, [r7, r0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800be20:	d00c      	beq.n	800be3c <get_axis_values_mm+0x5c>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 800be22:	2c00      	cmp	r4, #0
 800be24:	d0e9      	beq.n	800bdfa <get_axis_values_mm+0x1a>
            strcat(buf, ftoa(axis_values[idx], N_DECIMAL_COORDVALUE_MM));
 800be26:	2103      	movs	r1, #3
 800be28:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 800be2c:	f7fe f944 	bl	800a0b8 <ftoa>
 800be30:	4601      	mov	r1, r0
 800be32:	4630      	mov	r0, r6
 800be34:	f006 fadb 	bl	80123ee <strcat>
        if (idx < (N_AXIS - 1))
 800be38:	2c02      	cmp	r4, #2
 800be3a:	d1e9      	bne.n	800be10 <get_axis_values_mm+0x30>
}
 800be3c:	480b      	ldr	r0, [pc, #44]	; (800be6c <get_axis_values_mm+0x8c>)
 800be3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            strcat(buf, ftoa(axis_values[idx] * 2.0f, N_DECIMAL_COORDVALUE_MM));
 800be42:	6829      	ldr	r1, [r5, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800be44:	2401      	movs	r4, #1
            strcat(buf, ftoa(axis_values[idx] * 2.0f, N_DECIMAL_COORDVALUE_MM));
 800be46:	4608      	mov	r0, r1
 800be48:	f7f4 fb9c 	bl	8000584 <__addsf3>
 800be4c:	2103      	movs	r1, #3
 800be4e:	f7fe f933 	bl	800a0b8 <ftoa>
 800be52:	4682      	mov	sl, r0
 800be54:	4630      	mov	r0, r6
 800be56:	f7f4 f97b 	bl	8000150 <strlen>
 800be5a:	4651      	mov	r1, sl
 800be5c:	4438      	add	r0, r7
 800be5e:	f006 fabd 	bl	80123dc <stpcpy>
            strcat(buf, ",");
 800be62:	f8b8 3000 	ldrh.w	r3, [r8]
 800be66:	8003      	strh	r3, [r0, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800be68:	e7dd      	b.n	800be26 <get_axis_values_mm+0x46>
 800be6a:	bf00      	nop
 800be6c:	20001a68 	.word	0x20001a68
 800be70:	080149a4 	.word	0x080149a4
 800be74:	200023dc 	.word	0x200023dc

0800be78 <get_axis_values_inches>:
{
 800be78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    buf[0] = '\0';
 800be7c:	2300      	movs	r3, #0
    for (idx = 0; idx < N_AXIS; idx++) {
 800be7e:	461c      	mov	r4, r3
    buf[0] = '\0';
 800be80:	4f23      	ldr	r7, [pc, #140]	; (800bf10 <get_axis_values_inches+0x98>)
{
 800be82:	4605      	mov	r5, r0
    buf[0] = '\0';
 800be84:	703b      	strb	r3, [r7, #0]
            strcat(buf, ",");
 800be86:	463e      	mov	r6, r7
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 800be88:	f8df 8090 	ldr.w	r8, [pc, #144]	; 800bf1c <get_axis_values_inches+0xa4>
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM * 2.0f, N_DECIMAL_COORDVALUE_INCH));
 800be8c:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800bf20 <get_axis_values_inches+0xa8>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 800be90:	4b20      	ldr	r3, [pc, #128]	; (800bf14 <get_axis_values_inches+0x9c>)
 800be92:	b9c4      	cbnz	r4, 800bec6 <get_axis_values_inches+0x4e>
 800be94:	791b      	ldrb	r3, [r3, #4]
 800be96:	bb3b      	cbnz	r3, 800bee8 <get_axis_values_inches+0x70>
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 800be98:	4641      	mov	r1, r8
 800be9a:	6828      	ldr	r0, [r5, #0]
 800be9c:	f7f4 fc7a 	bl	8000794 <__aeabi_fmul>
 800bea0:	2104      	movs	r1, #4
 800bea2:	f7fe f909 	bl	800a0b8 <ftoa>
 800bea6:	4601      	mov	r1, r0
 800bea8:	4630      	mov	r0, r6
 800beaa:	f006 faa0 	bl	80123ee <strcat>
            strcat(buf, ",");
 800beae:	4630      	mov	r0, r6
 800beb0:	f7f4 f94e 	bl	8000150 <strlen>
 800beb4:	4b18      	ldr	r3, [pc, #96]	; (800bf18 <get_axis_values_inches+0xa0>)
    for (idx = 0; idx < N_AXIS; idx++) {
 800beb6:	3401      	adds	r4, #1
            strcat(buf, ",");
 800beb8:	881b      	ldrh	r3, [r3, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800beba:	2c03      	cmp	r4, #3
            strcat(buf, ",");
 800bebc:	523b      	strh	r3, [r7, r0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800bebe:	d010      	beq.n	800bee2 <get_axis_values_inches+0x6a>
        if(idx == X_AXIS && gc_state.modal.diameter_mode)
 800bec0:	4b14      	ldr	r3, [pc, #80]	; (800bf14 <get_axis_values_inches+0x9c>)
 800bec2:	2c00      	cmp	r4, #0
 800bec4:	d0e6      	beq.n	800be94 <get_axis_values_inches+0x1c>
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM, N_DECIMAL_COORDVALUE_INCH));
 800bec6:	4641      	mov	r1, r8
 800bec8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 800becc:	f7f4 fc62 	bl	8000794 <__aeabi_fmul>
 800bed0:	2104      	movs	r1, #4
 800bed2:	f7fe f8f1 	bl	800a0b8 <ftoa>
 800bed6:	4601      	mov	r1, r0
 800bed8:	4630      	mov	r0, r6
 800beda:	f006 fa88 	bl	80123ee <strcat>
        if (idx < (N_AXIS - 1))
 800bede:	2c02      	cmp	r4, #2
 800bee0:	d1e5      	bne.n	800beae <get_axis_values_inches+0x36>
}
 800bee2:	480b      	ldr	r0, [pc, #44]	; (800bf10 <get_axis_values_inches+0x98>)
 800bee4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            strcat(buf, ftoa(axis_values[idx] * INCH_PER_MM * 2.0f, N_DECIMAL_COORDVALUE_INCH));
 800bee8:	4649      	mov	r1, r9
 800beea:	6828      	ldr	r0, [r5, #0]
 800beec:	f7f4 fc52 	bl	8000794 <__aeabi_fmul>
 800bef0:	2104      	movs	r1, #4
 800bef2:	f7fe f8e1 	bl	800a0b8 <ftoa>
 800bef6:	4604      	mov	r4, r0
 800bef8:	4630      	mov	r0, r6
 800befa:	f7f4 f929 	bl	8000150 <strlen>
 800befe:	4621      	mov	r1, r4
 800bf00:	4438      	add	r0, r7
 800bf02:	f006 fa6b 	bl	80123dc <stpcpy>
            strcat(buf, ",");
 800bf06:	4b04      	ldr	r3, [pc, #16]	; (800bf18 <get_axis_values_inches+0xa0>)
    for (idx = 0; idx < N_AXIS; idx++) {
 800bf08:	2401      	movs	r4, #1
            strcat(buf, ",");
 800bf0a:	881b      	ldrh	r3, [r3, #0]
 800bf0c:	8003      	strh	r3, [r0, #0]
    for (idx = 0; idx < N_AXIS; idx++) {
 800bf0e:	e7da      	b.n	800bec6 <get_axis_values_inches+0x4e>
 800bf10:	20001a68 	.word	0x20001a68
 800bf14:	200023dc 	.word	0x200023dc
 800bf18:	080149a4 	.word	0x080149a4
 800bf1c:	3d21428b 	.word	0x3d21428b
 800bf20:	3da1428b 	.word	0x3da1428b

0800bf24 <appendbuf.constprop.0>:
static char *appendbuf (int argc, ...)
 800bf24:	b40f      	push	{r0, r1, r2, r3}
 800bf26:	b430      	push	{r4, r5}
 800bf28:	b082      	sub	sp, #8
    va_start(list, argc);
 800bf2a:	ab05      	add	r3, sp, #20
 800bf2c:	461c      	mov	r4, r3
    char c, *s = buf, *arg;
 800bf2e:	480a      	ldr	r0, [pc, #40]	; (800bf58 <appendbuf.constprop.0+0x34>)
    va_start(list, argc);
 800bf30:	9301      	str	r3, [sp, #4]
    while(argc--) {
 800bf32:	ad08      	add	r5, sp, #32
        arg = va_arg(list, char *);
 800bf34:	4603      	mov	r3, r0
 800bf36:	f854 1b04 	ldr.w	r1, [r4], #4
            c = *s++ = *arg++;
 800bf3a:	f811 2b01 	ldrb.w	r2, [r1], #1
 800bf3e:	4618      	mov	r0, r3
 800bf40:	f803 2b01 	strb.w	r2, [r3], #1
        } while(c);
 800bf44:	2a00      	cmp	r2, #0
 800bf46:	d1f8      	bne.n	800bf3a <appendbuf.constprop.0+0x16>
    while(argc--) {
 800bf48:	42a5      	cmp	r5, r4
 800bf4a:	d1f3      	bne.n	800bf34 <appendbuf.constprop.0+0x10>
}
 800bf4c:	4802      	ldr	r0, [pc, #8]	; (800bf58 <appendbuf.constprop.0+0x34>)
 800bf4e:	b002      	add	sp, #8
 800bf50:	bc30      	pop	{r4, r5}
 800bf52:	b004      	add	sp, #16
 800bf54:	4770      	bx	lr
 800bf56:	bf00      	nop
 800bf58:	20001a68 	.word	0x20001a68

0800bf5c <appendbuf.constprop.1>:
static char *appendbuf (int argc, ...)
 800bf5c:	b40f      	push	{r0, r1, r2, r3}
 800bf5e:	b410      	push	{r4}
 800bf60:	b083      	sub	sp, #12
    va_start(list, argc);
 800bf62:	ac05      	add	r4, sp, #20
        arg = va_arg(list, char *);
 800bf64:	9805      	ldr	r0, [sp, #20]
 800bf66:	4a0b      	ldr	r2, [pc, #44]	; (800bf94 <appendbuf.constprop.1+0x38>)
    va_start(list, argc);
 800bf68:	9401      	str	r4, [sp, #4]
            c = *s++ = *arg++;
 800bf6a:	f810 1b01 	ldrb.w	r1, [r0], #1
 800bf6e:	4613      	mov	r3, r2
 800bf70:	f802 1b01 	strb.w	r1, [r2], #1
        } while(c);
 800bf74:	2900      	cmp	r1, #0
 800bf76:	d1f8      	bne.n	800bf6a <appendbuf.constprop.1+0xe>
        arg = va_arg(list, char *);
 800bf78:	6861      	ldr	r1, [r4, #4]
 800bf7a:	3b01      	subs	r3, #1
            c = *s++ = *arg++;
 800bf7c:	f811 2b01 	ldrb.w	r2, [r1], #1
 800bf80:	f803 2f01 	strb.w	r2, [r3, #1]!
        } while(c);
 800bf84:	2a00      	cmp	r2, #0
 800bf86:	d1f9      	bne.n	800bf7c <appendbuf.constprop.1+0x20>
}
 800bf88:	4802      	ldr	r0, [pc, #8]	; (800bf94 <appendbuf.constprop.1+0x38>)
 800bf8a:	b003      	add	sp, #12
 800bf8c:	bc10      	pop	{r4}
 800bf8e:	b004      	add	sp, #16
 800bf90:	4770      	bx	lr
 800bf92:	bf00      	nop
 800bf94:	20001a68 	.word	0x20001a68

0800bf98 <report_init>:
}

void report_init (void)
{
    current_alarm = Alarm_None;
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 800bf98:	4b0c      	ldr	r3, [pc, #48]	; (800bfcc <report_init+0x34>)
 800bf9a:	480d      	ldr	r0, [pc, #52]	; (800bfd0 <report_init+0x38>)
 800bf9c:	f893 10bc 	ldrb.w	r1, [r3, #188]	; 0xbc
{
 800bfa0:	b430      	push	{r4, r5}
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 800bfa2:	f001 0101 	and.w	r1, r1, #1
 800bfa6:	2900      	cmp	r1, #0
 800bfa8:	4c0a      	ldr	r4, [pc, #40]	; (800bfd4 <report_init+0x3c>)
 800bfaa:	4b0b      	ldr	r3, [pc, #44]	; (800bfd8 <report_init+0x40>)
 800bfac:	bf08      	it	eq
 800bfae:	4603      	moveq	r3, r0
    current_alarm = Alarm_None;
 800bfb0:	f04f 0000 	mov.w	r0, #0
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 800bfb4:	4a09      	ldr	r2, [pc, #36]	; (800bfdc <report_init+0x44>)
 800bfb6:	bf08      	it	eq
 800bfb8:	4622      	moveq	r2, r4
    current_alarm = Alarm_None;
 800bfba:	4909      	ldr	r1, [pc, #36]	; (800bfe0 <report_init+0x48>)
 800bfbc:	4d09      	ldr	r5, [pc, #36]	; (800bfe4 <report_init+0x4c>)
    get_rate_value = settings.flags.report_inches ? get_rate_value_inch : get_rate_value_mm;
 800bfbe:	4c0a      	ldr	r4, [pc, #40]	; (800bfe8 <report_init+0x50>)
    current_alarm = Alarm_None;
 800bfc0:	7008      	strb	r0, [r1, #0]
    get_axis_values = settings.flags.report_inches ? get_axis_values_inches : get_axis_values_mm;
 800bfc2:	602a      	str	r2, [r5, #0]
    get_rate_value = settings.flags.report_inches ? get_rate_value_inch : get_rate_value_mm;
 800bfc4:	6023      	str	r3, [r4, #0]
}
 800bfc6:	bc30      	pop	{r4, r5}
 800bfc8:	4770      	bx	lr
 800bfca:	bf00      	nop
 800bfcc:	20002620 	.word	0x20002620
 800bfd0:	0800bdb9 	.word	0x0800bdb9
 800bfd4:	0800bde1 	.word	0x0800bde1
 800bfd8:	0800bdc9 	.word	0x0800bdc9
 800bfdc:	0800be79 	.word	0x0800be79
 800bfe0:	20001a92 	.word	0x20001a92
 800bfe4:	20001a98 	.word	0x20001a98
 800bfe8:	20001a9c 	.word	0x20001a9c

0800bfec <report_status_message>:
// 'error:'  to indicate some error event with the line or some critical system error during
// operation. Errors events can originate from the g-code parser, settings module, or asynchronously
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
status_code_t report_status_message (status_code_t status_code)
{
 800bfec:	b538      	push	{r3, r4, r5, lr}
    switch(status_code) {
 800bfee:	4604      	mov	r4, r0
        case Status_OK: // STATUS_OK
            hal.stream.write("ok\r\n");
            break;

        default:
            hal.stream.write(appendbuf(3, "error:", uitoa((uint32_t)status_code), "\r\n"));
 800bff0:	4b09      	ldr	r3, [pc, #36]	; (800c018 <report_status_message+0x2c>)
    switch(status_code) {
 800bff2:	b920      	cbnz	r0, 800bffe <report_status_message+0x12>
            hal.stream.write("ok\r\n");
 800bff4:	4809      	ldr	r0, [pc, #36]	; (800c01c <report_status_message+0x30>)
 800bff6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800bff8:	4798      	blx	r3
            break;
    }

    return status_code;
}
 800bffa:	4620      	mov	r0, r4
 800bffc:	bd38      	pop	{r3, r4, r5, pc}
            hal.stream.write(appendbuf(3, "error:", uitoa((uint32_t)status_code), "\r\n"));
 800bffe:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 800c000:	f7fe f838 	bl	800a074 <uitoa>
 800c004:	4b06      	ldr	r3, [pc, #24]	; (800c020 <report_status_message+0x34>)
 800c006:	4602      	mov	r2, r0
 800c008:	4906      	ldr	r1, [pc, #24]	; (800c024 <report_status_message+0x38>)
 800c00a:	2003      	movs	r0, #3
 800c00c:	f7ff ff8a 	bl	800bf24 <appendbuf.constprop.0>
 800c010:	47a8      	blx	r5
}
 800c012:	4620      	mov	r0, r4
 800c014:	bd38      	pop	{r3, r4, r5, pc}
 800c016:	bf00      	nop
 800c018:	200024bc 	.word	0x200024bc
 800c01c:	080149a8 	.word	0x080149a8
 800c020:	08014968 	.word	0x08014968
 800c024:	080149b0 	.word	0x080149b0

0800c028 <report_alarm_message>:


// Prints alarm messages.
alarm_code_t report_alarm_message (alarm_code_t alarm_code)
{
 800c028:	b570      	push	{r4, r5, r6, lr}
    current_alarm = alarm_code;
 800c02a:	4b0a      	ldr	r3, [pc, #40]	; (800c054 <report_alarm_message+0x2c>)
    hal.stream.write_all(appendbuf(3, "ALARM:", uitoa((uint32_t)alarm_code), "\r\n"));
 800c02c:	4d0a      	ldr	r5, [pc, #40]	; (800c058 <report_alarm_message+0x30>)
{
 800c02e:	4604      	mov	r4, r0
    hal.stream.write_all(appendbuf(3, "ALARM:", uitoa((uint32_t)alarm_code), "\r\n"));
 800c030:	6eae      	ldr	r6, [r5, #104]	; 0x68
    current_alarm = alarm_code;
 800c032:	7018      	strb	r0, [r3, #0]
    hal.stream.write_all(appendbuf(3, "ALARM:", uitoa((uint32_t)alarm_code), "\r\n"));
 800c034:	f7fe f81e 	bl	800a074 <uitoa>
 800c038:	4b08      	ldr	r3, [pc, #32]	; (800c05c <report_alarm_message+0x34>)
 800c03a:	4602      	mov	r2, r0
 800c03c:	4908      	ldr	r1, [pc, #32]	; (800c060 <report_alarm_message+0x38>)
 800c03e:	2003      	movs	r0, #3
 800c040:	f7ff ff70 	bl	800bf24 <appendbuf.constprop.0>
 800c044:	47b0      	blx	r6
    hal.delay_ms(500, NULL); // Force delay to ensure message clears output stream buffer.
 800c046:	2100      	movs	r1, #0
 800c048:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800c04c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800c04e:	4798      	blx	r3

    return alarm_code;
}
 800c050:	4620      	mov	r0, r4
 800c052:	bd70      	pop	{r4, r5, r6, pc}
 800c054:	20001a92 	.word	0x20001a92
 800c058:	200024bc 	.word	0x200024bc
 800c05c:	08014968 	.word	0x08014968
 800c060:	080149b8 	.word	0x080149b8

0800c064 <report_feedback_message>:
// user feedback for things that are not of the status/alarm message protocol. These are
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
message_code_t report_feedback_message(message_code_t message_code)
{
 800c064:	b538      	push	{r3, r4, r5, lr}
 800c066:	4604      	mov	r4, r0
    hal.stream.write_all("[MSG:");
 800c068:	4d2b      	ldr	r5, [pc, #172]	; (800c118 <report_feedback_message+0xb4>)
 800c06a:	482c      	ldr	r0, [pc, #176]	; (800c11c <report_feedback_message+0xb8>)
 800c06c:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c06e:	4798      	blx	r3

    switch(message_code) {
 800c070:	2c0e      	cmp	r4, #14
 800c072:	d849      	bhi.n	800c108 <report_feedback_message+0xa4>
 800c074:	e8df f004 	tbb	[pc, r4]
 800c078:	1c181410 	.word	0x1c181410
 800c07c:	2c282420 	.word	0x2c282420
 800c080:	3c383430 	.word	0x3c383430
 800c084:	4440      	.short	0x4440
 800c086:	08          	.byte	0x08
 800c087:	00          	.byte	0x00
        case Message_HomingCycleRequired:
            hal.stream.write_all("Homing cycle required");
            break;

        case Message_CycleStartToRerun:
            hal.stream.write_all("Cycle start to rerun job");
 800c088:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c08a:	4825      	ldr	r0, [pc, #148]	; (800c120 <report_feedback_message+0xbc>)
 800c08c:	4798      	blx	r3
            if(hal.driver_feedback_message)
                hal.driver_feedback_message(hal.stream.write_all);
            break;
    }

    hal.stream.write_all("]\r\n");
 800c08e:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c090:	4824      	ldr	r0, [pc, #144]	; (800c124 <report_feedback_message+0xc0>)
 800c092:	4798      	blx	r3

    return message_code;
}
 800c094:	4620      	mov	r0, r4
 800c096:	bd38      	pop	{r3, r4, r5, pc}
            hal.stream.write_all("");
 800c098:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c09a:	4823      	ldr	r0, [pc, #140]	; (800c128 <report_feedback_message+0xc4>)
 800c09c:	4798      	blx	r3
            break;
 800c09e:	e7f6      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Reset to continue");
 800c0a0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0a2:	4822      	ldr	r0, [pc, #136]	; (800c12c <report_feedback_message+0xc8>)
 800c0a4:	4798      	blx	r3
            break;
 800c0a6:	e7f2      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("'$H'|'$X' to unlock");
 800c0a8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0aa:	4821      	ldr	r0, [pc, #132]	; (800c130 <report_feedback_message+0xcc>)
 800c0ac:	4798      	blx	r3
            break;
 800c0ae:	e7ee      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Caution: Unlocked");
 800c0b0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0b2:	4820      	ldr	r0, [pc, #128]	; (800c134 <report_feedback_message+0xd0>)
 800c0b4:	4798      	blx	r3
            break;
 800c0b6:	e7ea      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Enabled");
 800c0b8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0ba:	481f      	ldr	r0, [pc, #124]	; (800c138 <report_feedback_message+0xd4>)
 800c0bc:	4798      	blx	r3
            break;
 800c0be:	e7e6      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Disabled");
 800c0c0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0c2:	481e      	ldr	r0, [pc, #120]	; (800c13c <report_feedback_message+0xd8>)
 800c0c4:	4798      	blx	r3
            break;
 800c0c6:	e7e2      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Check Door");
 800c0c8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0ca:	481d      	ldr	r0, [pc, #116]	; (800c140 <report_feedback_message+0xdc>)
 800c0cc:	4798      	blx	r3
            break;
 800c0ce:	e7de      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Check Limits");
 800c0d0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0d2:	481c      	ldr	r0, [pc, #112]	; (800c144 <report_feedback_message+0xe0>)
 800c0d4:	4798      	blx	r3
            break;
 800c0d6:	e7da      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Pgm End");
 800c0d8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0da:	481b      	ldr	r0, [pc, #108]	; (800c148 <report_feedback_message+0xe4>)
 800c0dc:	4798      	blx	r3
            break;
 800c0de:	e7d6      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Restoring defaults");
 800c0e0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0e2:	481a      	ldr	r0, [pc, #104]	; (800c14c <report_feedback_message+0xe8>)
 800c0e4:	4798      	blx	r3
            break;
 800c0e6:	e7d2      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Restoring spindle");
 800c0e8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0ea:	4819      	ldr	r0, [pc, #100]	; (800c150 <report_feedback_message+0xec>)
 800c0ec:	4798      	blx	r3
            break;
 800c0ee:	e7ce      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Sleeping");
 800c0f0:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0f2:	4818      	ldr	r0, [pc, #96]	; (800c154 <report_feedback_message+0xf0>)
 800c0f4:	4798      	blx	r3
            break;
 800c0f6:	e7ca      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Emergency stop");
 800c0f8:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c0fa:	4817      	ldr	r0, [pc, #92]	; (800c158 <report_feedback_message+0xf4>)
 800c0fc:	4798      	blx	r3
            break;
 800c0fe:	e7c6      	b.n	800c08e <report_feedback_message+0x2a>
            hal.stream.write_all("Homing cycle required");
 800c100:	6eab      	ldr	r3, [r5, #104]	; 0x68
 800c102:	4816      	ldr	r0, [pc, #88]	; (800c15c <report_feedback_message+0xf8>)
 800c104:	4798      	blx	r3
            break;
 800c106:	e7c2      	b.n	800c08e <report_feedback_message+0x2a>
            if(hal.driver_feedback_message)
 800c108:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d0be      	beq.n	800c08e <report_feedback_message+0x2a>
                hal.driver_feedback_message(hal.stream.write_all);
 800c110:	6ea8      	ldr	r0, [r5, #104]	; 0x68
 800c112:	4798      	blx	r3
 800c114:	e7bb      	b.n	800c08e <report_feedback_message+0x2a>
 800c116:	bf00      	nop
 800c118:	200024bc 	.word	0x200024bc
 800c11c:	080149c0 	.word	0x080149c0
 800c120:	08014a98 	.word	0x08014a98
 800c124:	08014ad0 	.word	0x08014ad0
 800c128:	08014b20 	.word	0x08014b20
 800c12c:	080149c8 	.word	0x080149c8
 800c130:	080149dc 	.word	0x080149dc
 800c134:	080149f0 	.word	0x080149f0
 800c138:	08014a04 	.word	0x08014a04
 800c13c:	08014a0c 	.word	0x08014a0c
 800c140:	08014a18 	.word	0x08014a18
 800c144:	08014a24 	.word	0x08014a24
 800c148:	08014a34 	.word	0x08014a34
 800c14c:	08014a3c 	.word	0x08014a3c
 800c150:	08014a50 	.word	0x08014a50
 800c154:	08014a64 	.word	0x08014a64
 800c158:	08014a70 	.word	0x08014a70
 800c15c:	08014a80 	.word	0x08014a80

0800c160 <report_init_message>:


// Welcome message
void report_init_message (void)
{
    override_counter = wco_counter = 0;
 800c160:	2300      	movs	r3, #0
 800c162:	4905      	ldr	r1, [pc, #20]	; (800c178 <report_init_message+0x18>)
{
 800c164:	b410      	push	{r4}
#if COMPATIBILITY_LEVEL == 0
    hal.stream.write_all("\r\nGrblHAL " GRBL_VERSION " ['$' for help]\r\n");
 800c166:	4a05      	ldr	r2, [pc, #20]	; (800c17c <report_init_message+0x1c>)
    override_counter = wco_counter = 0;
 800c168:	4c05      	ldr	r4, [pc, #20]	; (800c180 <report_init_message+0x20>)
 800c16a:	700b      	strb	r3, [r1, #0]
 800c16c:	7023      	strb	r3, [r4, #0]
    hal.stream.write_all("\r\nGrblHAL " GRBL_VERSION " ['$' for help]\r\n");
 800c16e:	6e92      	ldr	r2, [r2, #104]	; 0x68
 800c170:	4804      	ldr	r0, [pc, #16]	; (800c184 <report_init_message+0x24>)
#else
    hal.stream.write_all("\r\nGrbl " GRBL_VERSION " ['$' for help]\r\n");
#endif
}
 800c172:	bc10      	pop	{r4}
    hal.stream.write_all("\r\nGrblHAL " GRBL_VERSION " ['$' for help]\r\n");
 800c174:	4710      	bx	r2
 800c176:	bf00      	nop
 800c178:	20001ac8 	.word	0x20001ac8
 800c17c:	200024bc 	.word	0x200024bc
 800c180:	20001ad1 	.word	0x20001ad1
 800c184:	08014ab4 	.word	0x08014ab4

0800c188 <report_grbl_help>:

// Grbl help message
void report_grbl_help (void)
{
    hal.stream.write("[HLP:$$ $# $G $I $N $x=val $Nx=line $J=line $SLP $C $X $H $B ~ ! ? ctrl-x]\r\n");
 800c188:	4b01      	ldr	r3, [pc, #4]	; (800c190 <report_grbl_help+0x8>)
 800c18a:	4802      	ldr	r0, [pc, #8]	; (800c194 <report_grbl_help+0xc>)
 800c18c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800c18e:	4718      	bx	r3
 800c190:	200024bc 	.word	0x200024bc
 800c194:	08014ad4 	.word	0x08014ad4

0800c198 <report_grbl_settings>:
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
    hal.stream.write(appendbuf(2, val, "\r\n"));
}

void report_grbl_settings (void)
{
 800c198:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c19c:	4cc1      	ldr	r4, [pc, #772]	; (800c4a4 <report_grbl_settings+0x30c>)
    uint_fast8_t idx;

    // Print Grbl settings.
    report_uint_setting(Setting_PulseMicroseconds, settings.steppers.pulse_microseconds);
 800c19e:	4dc2      	ldr	r5, [pc, #776]	; (800c4a8 <report_grbl_settings+0x310>)
{
 800c1a0:	b085      	sub	sp, #20
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c1a2:	2000      	movs	r0, #0
    report_uint_setting(Setting_PulseMicroseconds, settings.steppers.pulse_microseconds);
 800c1a4:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c1a8:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c1aa:	f7fd ff63 	bl	800a074 <uitoa>
 800c1ae:	4bbf      	ldr	r3, [pc, #764]	; (800c4ac <report_grbl_settings+0x314>)
 800c1b0:	4602      	mov	r2, r0
 800c1b2:	49bf      	ldr	r1, [pc, #764]	; (800c4b0 <report_grbl_settings+0x318>)
 800c1b4:	2003      	movs	r0, #3
 800c1b6:	f7ff feb5 	bl	800bf24 <appendbuf.constprop.0>
 800c1ba:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c1bc:	4630      	mov	r0, r6
 800c1be:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c1c0:	f7fd ff58 	bl	800a074 <uitoa>
 800c1c4:	4abb      	ldr	r2, [pc, #748]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c1c6:	4601      	mov	r1, r0
 800c1c8:	2002      	movs	r0, #2
 800c1ca:	f7ff fec7 	bl	800bf5c <appendbuf.constprop.1>
 800c1ce:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c1d0:	2001      	movs	r0, #1
    report_uint_setting(Setting_StepperIdleLockTime, settings.steppers.idle_lock_time);
 800c1d2:	f895 60ba 	ldrb.w	r6, [r5, #186]	; 0xba
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c1d6:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c1d8:	f7fd ff4c 	bl	800a074 <uitoa>
 800c1dc:	4bb3      	ldr	r3, [pc, #716]	; (800c4ac <report_grbl_settings+0x314>)
 800c1de:	4602      	mov	r2, r0
 800c1e0:	49b3      	ldr	r1, [pc, #716]	; (800c4b0 <report_grbl_settings+0x318>)
 800c1e2:	2003      	movs	r0, #3
 800c1e4:	f7ff fe9e 	bl	800bf24 <appendbuf.constprop.0>
 800c1e8:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c1ea:	4630      	mov	r0, r6
 800c1ec:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c1ee:	f7fd ff41 	bl	800a074 <uitoa>
 800c1f2:	4ab0      	ldr	r2, [pc, #704]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c1f4:	4601      	mov	r1, r0
 800c1f6:	2002      	movs	r0, #2
 800c1f8:	f7ff feb0 	bl	800bf5c <appendbuf.constprop.1>
 800c1fc:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c1fe:	2002      	movs	r0, #2
    report_uint_setting(Setting_StepInvertMask, settings.steppers.step_invert.mask);
 800c200:	f895 60b4 	ldrb.w	r6, [r5, #180]	; 0xb4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c204:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c206:	f7fd ff35 	bl	800a074 <uitoa>
 800c20a:	4ba8      	ldr	r3, [pc, #672]	; (800c4ac <report_grbl_settings+0x314>)
 800c20c:	4602      	mov	r2, r0
 800c20e:	49a8      	ldr	r1, [pc, #672]	; (800c4b0 <report_grbl_settings+0x318>)
 800c210:	2003      	movs	r0, #3
 800c212:	f7ff fe87 	bl	800bf24 <appendbuf.constprop.0>
 800c216:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c218:	4630      	mov	r0, r6
 800c21a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c21c:	f7fd ff2a 	bl	800a074 <uitoa>
 800c220:	4aa4      	ldr	r2, [pc, #656]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c222:	4601      	mov	r1, r0
 800c224:	2002      	movs	r0, #2
 800c226:	f7ff fe99 	bl	800bf5c <appendbuf.constprop.1>
 800c22a:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c22c:	2003      	movs	r0, #3
    report_uint_setting(Setting_DirInvertMask, settings.steppers.dir_invert.mask);
 800c22e:	f895 60b5 	ldrb.w	r6, [r5, #181]	; 0xb5
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c232:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c234:	f7fd ff1e 	bl	800a074 <uitoa>
 800c238:	4b9c      	ldr	r3, [pc, #624]	; (800c4ac <report_grbl_settings+0x314>)
 800c23a:	4602      	mov	r2, r0
 800c23c:	499c      	ldr	r1, [pc, #624]	; (800c4b0 <report_grbl_settings+0x318>)
 800c23e:	2003      	movs	r0, #3
 800c240:	f7ff fe70 	bl	800bf24 <appendbuf.constprop.0>
 800c244:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c246:	4630      	mov	r0, r6
 800c248:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c24a:	f7fd ff13 	bl	800a074 <uitoa>
 800c24e:	4a99      	ldr	r2, [pc, #612]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c250:	4601      	mov	r1, r0
 800c252:	2002      	movs	r0, #2
 800c254:	f7ff fe82 	bl	800bf5c <appendbuf.constprop.1>
 800c258:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c25a:	2004      	movs	r0, #4
    report_uint_setting(Setting_InvertStepperEnable, settings.steppers.enable_invert.mask);
 800c25c:	f895 60b6 	ldrb.w	r6, [r5, #182]	; 0xb6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c260:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c262:	f7fd ff07 	bl	800a074 <uitoa>
 800c266:	4b91      	ldr	r3, [pc, #580]	; (800c4ac <report_grbl_settings+0x314>)
 800c268:	4602      	mov	r2, r0
 800c26a:	4991      	ldr	r1, [pc, #580]	; (800c4b0 <report_grbl_settings+0x318>)
 800c26c:	2003      	movs	r0, #3
 800c26e:	f7ff fe59 	bl	800bf24 <appendbuf.constprop.0>
 800c272:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c274:	4630      	mov	r0, r6
 800c276:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c278:	f7fd fefc 	bl	800a074 <uitoa>
 800c27c:	4a8d      	ldr	r2, [pc, #564]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c27e:	4601      	mov	r1, r0
 800c280:	2002      	movs	r0, #2
 800c282:	f7ff fe6b 	bl	800bf5c <appendbuf.constprop.1>
 800c286:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c288:	2005      	movs	r0, #5
    report_uint_setting(Setting_LimitPinsInvertMask, settings.limits.invert.mask);
 800c28a:	f895 60d5 	ldrb.w	r6, [r5, #213]	; 0xd5
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c28e:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c290:	f7fd fef0 	bl	800a074 <uitoa>
 800c294:	4b85      	ldr	r3, [pc, #532]	; (800c4ac <report_grbl_settings+0x314>)
 800c296:	4602      	mov	r2, r0
 800c298:	4985      	ldr	r1, [pc, #532]	; (800c4b0 <report_grbl_settings+0x318>)
 800c29a:	2003      	movs	r0, #3
 800c29c:	f7ff fe42 	bl	800bf24 <appendbuf.constprop.0>
 800c2a0:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c2a2:	4630      	mov	r0, r6
 800c2a4:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c2a6:	f7fd fee5 	bl	800a074 <uitoa>
 800c2aa:	4a82      	ldr	r2, [pc, #520]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c2ac:	4601      	mov	r1, r0
 800c2ae:	2002      	movs	r0, #2
 800c2b0:	f7ff fe54 	bl	800bf5c <appendbuf.constprop.1>
 800c2b4:	47b0      	blx	r6
    if(hal.probe_configure_invert_mask)
 800c2b6:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800c2ba:	b1c3      	cbz	r3, 800c2ee <report_grbl_settings+0x156>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c2bc:	2006      	movs	r0, #6
        report_uint_setting(Setting_InvertProbePin, settings.flags.invert_probe_pin);
 800c2be:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c2c2:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c2c4:	f7fd fed6 	bl	800a074 <uitoa>
 800c2c8:	4b78      	ldr	r3, [pc, #480]	; (800c4ac <report_grbl_settings+0x314>)
 800c2ca:	4602      	mov	r2, r0
 800c2cc:	4978      	ldr	r1, [pc, #480]	; (800c4b0 <report_grbl_settings+0x318>)
 800c2ce:	2003      	movs	r0, #3
 800c2d0:	f7ff fe28 	bl	800bf24 <appendbuf.constprop.0>
        report_uint_setting(Setting_InvertProbePin, settings.flags.invert_probe_pin);
 800c2d4:	f3c6 0680 	ubfx	r6, r6, #2, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c2d8:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c2da:	4630      	mov	r0, r6
 800c2dc:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c2de:	f7fd fec9 	bl	800a074 <uitoa>
 800c2e2:	4a74      	ldr	r2, [pc, #464]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c2e4:	4601      	mov	r1, r0
 800c2e6:	2002      	movs	r0, #2
 800c2e8:	f7ff fe38 	bl	800bf5c <appendbuf.constprop.1>
 800c2ec:	47b0      	blx	r6
#if COMPATIBILITY_LEVEL <= 1
    report_uint_setting(Setting_StatusReportMask, (uint32_t)settings.status_report.mask |
                                                   (settings.flags.force_buffer_sync_on_wco_change ? bit(8) : 0) |
 800c2ee:	f895 30bd 	ldrb.w	r3, [r5, #189]	; 0xbd
    report_uint_setting(Setting_StatusReportMask, (uint32_t)settings.status_report.mask |
 800c2f2:	f895 10bb 	ldrb.w	r1, [r5, #187]	; 0xbb
                                                   (settings.flags.force_buffer_sync_on_wco_change ? bit(8) : 0) |
 800c2f6:	009e      	lsls	r6, r3, #2
                                                    (settings.flags.report_alarm_substate ? bit(9) : 0) |
 800c2f8:	019a      	lsls	r2, r3, #6
 800c2fa:	f402 7200 	and.w	r2, r2, #512	; 0x200
                                                   (settings.flags.force_buffer_sync_on_wco_change ? bit(8) : 0) |
 800c2fe:	f406 7680 	and.w	r6, r6, #256	; 0x100
 800c302:	4316      	orrs	r6, r2
                                                     (settings.flags.report_parser_state ? bit(10) : 0));
 800c304:	025b      	lsls	r3, r3, #9
 800c306:	f403 6380 	and.w	r3, r3, #1024	; 0x400
                                                   (settings.flags.force_buffer_sync_on_wco_change ? bit(8) : 0) |
 800c30a:	430e      	orrs	r6, r1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c30c:	200a      	movs	r0, #10
    report_uint_setting(Setting_StatusReportMask, (uint32_t)settings.status_report.mask |
 800c30e:	431e      	orrs	r6, r3
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c310:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c312:	f7fd feaf 	bl	800a074 <uitoa>
 800c316:	4b65      	ldr	r3, [pc, #404]	; (800c4ac <report_grbl_settings+0x314>)
 800c318:	4602      	mov	r2, r0
 800c31a:	4965      	ldr	r1, [pc, #404]	; (800c4b0 <report_grbl_settings+0x318>)
 800c31c:	2003      	movs	r0, #3
 800c31e:	f7ff fe01 	bl	800bf24 <appendbuf.constprop.0>
 800c322:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c324:	4630      	mov	r0, r6
 800c326:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c328:	f7fd fea4 	bl	800a074 <uitoa>
 800c32c:	4a61      	ldr	r2, [pc, #388]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c32e:	4601      	mov	r1, r0
 800c330:	2002      	movs	r0, #2
 800c332:	f7ff fe13 	bl	800bf5c <appendbuf.constprop.1>
 800c336:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c338:	200b      	movs	r0, #11
#else
    report_uint_setting(Setting_StatusReportMask, settings.status_report.mask & 0x3);
#endif
    report_float_setting(Setting_JunctionDeviation, settings.junction_deviation, N_DECIMAL_SETTINGVALUE);
 800c33a:	6b6e      	ldr	r6, [r5, #52]	; 0x34
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c33c:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c33e:	f7fd fe99 	bl	800a074 <uitoa>
 800c342:	4b5a      	ldr	r3, [pc, #360]	; (800c4ac <report_grbl_settings+0x314>)
 800c344:	4602      	mov	r2, r0
 800c346:	495a      	ldr	r1, [pc, #360]	; (800c4b0 <report_grbl_settings+0x318>)
 800c348:	2003      	movs	r0, #3
 800c34a:	f7ff fdeb 	bl	800bf24 <appendbuf.constprop.0>
 800c34e:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c350:	4630      	mov	r0, r6
 800c352:	2103      	movs	r1, #3
 800c354:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c356:	f7fd feaf 	bl	800a0b8 <ftoa>
 800c35a:	4a56      	ldr	r2, [pc, #344]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c35c:	4601      	mov	r1, r0
 800c35e:	2002      	movs	r0, #2
 800c360:	f7ff fdfc 	bl	800bf5c <appendbuf.constprop.1>
 800c364:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c366:	200c      	movs	r0, #12
    report_float_setting(Setting_ArcTolerance, settings.arc_tolerance, N_DECIMAL_SETTINGVALUE);
 800c368:	6bae      	ldr	r6, [r5, #56]	; 0x38
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c36a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c36c:	f7fd fe82 	bl	800a074 <uitoa>
 800c370:	4b4e      	ldr	r3, [pc, #312]	; (800c4ac <report_grbl_settings+0x314>)
 800c372:	4602      	mov	r2, r0
 800c374:	494e      	ldr	r1, [pc, #312]	; (800c4b0 <report_grbl_settings+0x318>)
 800c376:	2003      	movs	r0, #3
 800c378:	f7ff fdd4 	bl	800bf24 <appendbuf.constprop.0>
 800c37c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c37e:	4630      	mov	r0, r6
 800c380:	2103      	movs	r1, #3
 800c382:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c384:	f7fd fe98 	bl	800a0b8 <ftoa>
 800c388:	4a4a      	ldr	r2, [pc, #296]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c38a:	4601      	mov	r1, r0
 800c38c:	2002      	movs	r0, #2
 800c38e:	f7ff fde5 	bl	800bf5c <appendbuf.constprop.1>
 800c392:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c394:	200d      	movs	r0, #13
 800c396:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_ReportInches, settings.flags.report_inches);
 800c398:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c39c:	f7fd fe6a 	bl	800a074 <uitoa>
 800c3a0:	4b42      	ldr	r3, [pc, #264]	; (800c4ac <report_grbl_settings+0x314>)
 800c3a2:	4602      	mov	r2, r0
 800c3a4:	4942      	ldr	r1, [pc, #264]	; (800c4b0 <report_grbl_settings+0x318>)
 800c3a6:	2003      	movs	r0, #3
 800c3a8:	f7ff fdbc 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_ReportInches, settings.flags.report_inches);
 800c3ac:	f006 0601 	and.w	r6, r6, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c3b0:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c3b2:	4630      	mov	r0, r6
 800c3b4:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c3b6:	f7fd fe5d 	bl	800a074 <uitoa>
 800c3ba:	4a3e      	ldr	r2, [pc, #248]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c3bc:	4601      	mov	r1, r0
 800c3be:	2002      	movs	r0, #2
 800c3c0:	f7ff fdcc 	bl	800bf5c <appendbuf.constprop.1>
 800c3c4:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c3c6:	200e      	movs	r0, #14

#if COMPATIBILITY_LEVEL <= 1

    report_uint_setting(Setting_ControlInvertMask, settings.control_invert.mask);
 800c3c8:	f895 6041 	ldrb.w	r6, [r5, #65]	; 0x41
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c3cc:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c3ce:	f7fd fe51 	bl	800a074 <uitoa>
 800c3d2:	4b36      	ldr	r3, [pc, #216]	; (800c4ac <report_grbl_settings+0x314>)
 800c3d4:	4602      	mov	r2, r0
 800c3d6:	4936      	ldr	r1, [pc, #216]	; (800c4b0 <report_grbl_settings+0x318>)
 800c3d8:	2003      	movs	r0, #3
 800c3da:	f7ff fda3 	bl	800bf24 <appendbuf.constprop.0>
 800c3de:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c3e0:	4630      	mov	r0, r6
 800c3e2:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c3e4:	f7fd fe46 	bl	800a074 <uitoa>
 800c3e8:	4a32      	ldr	r2, [pc, #200]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c3ea:	4601      	mov	r1, r0
 800c3ec:	2002      	movs	r0, #2
 800c3ee:	f7ff fdb5 	bl	800bf5c <appendbuf.constprop.1>
 800c3f2:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c3f4:	200f      	movs	r0, #15
    report_uint_setting(Setting_CoolantInvertMask, settings.coolant_invert.mask);
 800c3f6:	f895 6043 	ldrb.w	r6, [r5, #67]	; 0x43
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c3fa:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c3fc:	f7fd fe3a 	bl	800a074 <uitoa>
 800c400:	4b2a      	ldr	r3, [pc, #168]	; (800c4ac <report_grbl_settings+0x314>)
 800c402:	4602      	mov	r2, r0
 800c404:	492a      	ldr	r1, [pc, #168]	; (800c4b0 <report_grbl_settings+0x318>)
 800c406:	2003      	movs	r0, #3
 800c408:	f7ff fd8c 	bl	800bf24 <appendbuf.constprop.0>
 800c40c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c40e:	4630      	mov	r0, r6
 800c410:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c412:	f7fd fe2f 	bl	800a074 <uitoa>
 800c416:	4a27      	ldr	r2, [pc, #156]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c418:	4601      	mov	r1, r0
 800c41a:	2002      	movs	r0, #2
 800c41c:	f7ff fd9e 	bl	800bf5c <appendbuf.constprop.1>
 800c420:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c422:	2010      	movs	r0, #16
    report_uint_setting(Setting_SpindleInvertMask, settings.spindle.invert.mask);
 800c424:	f895 60b2 	ldrb.w	r6, [r5, #178]	; 0xb2
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c428:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c42a:	f7fd fe23 	bl	800a074 <uitoa>
 800c42e:	4b1f      	ldr	r3, [pc, #124]	; (800c4ac <report_grbl_settings+0x314>)
 800c430:	4602      	mov	r2, r0
 800c432:	491f      	ldr	r1, [pc, #124]	; (800c4b0 <report_grbl_settings+0x318>)
 800c434:	2003      	movs	r0, #3
 800c436:	f7ff fd75 	bl	800bf24 <appendbuf.constprop.0>
 800c43a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c43c:	4630      	mov	r0, r6
 800c43e:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c440:	f7fd fe18 	bl	800a074 <uitoa>
 800c444:	4a1b      	ldr	r2, [pc, #108]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c446:	4601      	mov	r1, r0
 800c448:	2002      	movs	r0, #2
 800c44a:	f7ff fd87 	bl	800bf5c <appendbuf.constprop.1>
 800c44e:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c450:	2011      	movs	r0, #17
    report_uint_setting(Setting_ControlPullUpDisableMask, settings.control_disable_pullup.mask);
 800c452:	f895 6042 	ldrb.w	r6, [r5, #66]	; 0x42
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c456:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c458:	f7fd fe0c 	bl	800a074 <uitoa>
 800c45c:	4b13      	ldr	r3, [pc, #76]	; (800c4ac <report_grbl_settings+0x314>)
 800c45e:	4602      	mov	r2, r0
 800c460:	4913      	ldr	r1, [pc, #76]	; (800c4b0 <report_grbl_settings+0x318>)
 800c462:	2003      	movs	r0, #3
 800c464:	f7ff fd5e 	bl	800bf24 <appendbuf.constprop.0>
 800c468:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c46a:	4630      	mov	r0, r6
 800c46c:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c46e:	f7fd fe01 	bl	800a074 <uitoa>
 800c472:	4a10      	ldr	r2, [pc, #64]	; (800c4b4 <report_grbl_settings+0x31c>)
 800c474:	4601      	mov	r1, r0
 800c476:	2002      	movs	r0, #2
 800c478:	f7ff fd70 	bl	800bf5c <appendbuf.constprop.1>
 800c47c:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c47e:	2012      	movs	r0, #18
    report_uint_setting(Setting_LimitPullUpDisableMask, settings.limits.disable_pullup.mask);
 800c480:	f895 60d6 	ldrb.w	r6, [r5, #214]	; 0xd6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c484:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c486:	f7fd fdf5 	bl	800a074 <uitoa>
 800c48a:	4b08      	ldr	r3, [pc, #32]	; (800c4ac <report_grbl_settings+0x314>)
 800c48c:	4602      	mov	r2, r0
 800c48e:	4908      	ldr	r1, [pc, #32]	; (800c4b0 <report_grbl_settings+0x318>)
 800c490:	2003      	movs	r0, #3
 800c492:	f7ff fd47 	bl	800bf24 <appendbuf.constprop.0>
 800c496:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c498:	4630      	mov	r0, r6
 800c49a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c49c:	f7fd fdea 	bl	800a074 <uitoa>
 800c4a0:	e00a      	b.n	800c4b8 <report_grbl_settings+0x320>
 800c4a2:	bf00      	nop
 800c4a4:	200024bc 	.word	0x200024bc
 800c4a8:	20002620 	.word	0x20002620
 800c4ac:	08014b24 	.word	0x08014b24
 800c4b0:	08014b28 	.word	0x08014b28
 800c4b4:	08014968 	.word	0x08014968
 800c4b8:	4abf      	ldr	r2, [pc, #764]	; (800c7b8 <report_grbl_settings+0x620>)
 800c4ba:	4601      	mov	r1, r0
 800c4bc:	2002      	movs	r0, #2
 800c4be:	f7ff fd4d 	bl	800bf5c <appendbuf.constprop.1>
 800c4c2:	47b0      	blx	r6
    if(hal.probe_configure_invert_mask)
 800c4c4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800c4c8:	b1c3      	cbz	r3, 800c4fc <report_grbl_settings+0x364>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c4ca:	2013      	movs	r0, #19
        report_uint_setting(Setting_ProbePullUpDisable, settings.flags.disable_probe_pullup);
 800c4cc:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c4d0:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c4d2:	f7fd fdcf 	bl	800a074 <uitoa>
 800c4d6:	4bb9      	ldr	r3, [pc, #740]	; (800c7bc <report_grbl_settings+0x624>)
 800c4d8:	4602      	mov	r2, r0
 800c4da:	49b9      	ldr	r1, [pc, #740]	; (800c7c0 <report_grbl_settings+0x628>)
 800c4dc:	2003      	movs	r0, #3
 800c4de:	f7ff fd21 	bl	800bf24 <appendbuf.constprop.0>
        report_uint_setting(Setting_ProbePullUpDisable, settings.flags.disable_probe_pullup);
 800c4e2:	f3c6 06c0 	ubfx	r6, r6, #3, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c4e6:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c4e8:	4630      	mov	r0, r6
 800c4ea:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c4ec:	f7fd fdc2 	bl	800a074 <uitoa>
 800c4f0:	4ab1      	ldr	r2, [pc, #708]	; (800c7b8 <report_grbl_settings+0x620>)
 800c4f2:	4601      	mov	r1, r0
 800c4f4:	2002      	movs	r0, #2
 800c4f6:	f7ff fd31 	bl	800bf5c <appendbuf.constprop.1>
 800c4fa:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c4fc:	2014      	movs	r0, #20

#endif

    report_uint_setting(Setting_SoftLimitsEnable, settings.limits.flags.soft_enabled);
 800c4fe:	f895 60d4 	ldrb.w	r6, [r5, #212]	; 0xd4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c502:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c504:	f7fd fdb6 	bl	800a074 <uitoa>
 800c508:	4bac      	ldr	r3, [pc, #688]	; (800c7bc <report_grbl_settings+0x624>)
 800c50a:	4602      	mov	r2, r0
 800c50c:	49ac      	ldr	r1, [pc, #688]	; (800c7c0 <report_grbl_settings+0x628>)
 800c50e:	2003      	movs	r0, #3
 800c510:	f7ff fd08 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_SoftLimitsEnable, settings.limits.flags.soft_enabled);
 800c514:	f3c6 0640 	ubfx	r6, r6, #1, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c518:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c51a:	4630      	mov	r0, r6
 800c51c:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c51e:	f7fd fda9 	bl	800a074 <uitoa>
 800c522:	4aa5      	ldr	r2, [pc, #660]	; (800c7b8 <report_grbl_settings+0x620>)
 800c524:	4601      	mov	r1, r0
 800c526:	2002      	movs	r0, #2
 800c528:	f7ff fd18 	bl	800bf5c <appendbuf.constprop.1>
 800c52c:	47b0      	blx	r6
    report_uint_setting(Setting_HardLimitsEnable, ((settings.limits.flags.hard_enabled & bit(0)) ? bit(0) | (settings.limits.flags.check_at_init ? bit(1) : 0) : 0));
 800c52e:	f895 30d4 	ldrb.w	r3, [r5, #212]	; 0xd4
 800c532:	f013 0601 	ands.w	r6, r3, #1
 800c536:	d004      	beq.n	800c542 <report_grbl_settings+0x3aa>
 800c538:	085b      	lsrs	r3, r3, #1
 800c53a:	f003 0302 	and.w	r3, r3, #2
 800c53e:	f043 0601 	orr.w	r6, r3, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c542:	2015      	movs	r0, #21
 800c544:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c546:	f7fd fd95 	bl	800a074 <uitoa>
 800c54a:	4b9c      	ldr	r3, [pc, #624]	; (800c7bc <report_grbl_settings+0x624>)
 800c54c:	4602      	mov	r2, r0
 800c54e:	499c      	ldr	r1, [pc, #624]	; (800c7c0 <report_grbl_settings+0x628>)
 800c550:	2003      	movs	r0, #3
 800c552:	f7ff fce7 	bl	800bf24 <appendbuf.constprop.0>
 800c556:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c558:	4630      	mov	r0, r6
 800c55a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c55c:	f7fd fd8a 	bl	800a074 <uitoa>
 800c560:	4a95      	ldr	r2, [pc, #596]	; (800c7b8 <report_grbl_settings+0x620>)
 800c562:	4601      	mov	r1, r0
 800c564:	2002      	movs	r0, #2
 800c566:	f7ff fcf9 	bl	800bf5c <appendbuf.constprop.1>
 800c56a:	47b0      	blx	r6
    report_uint_setting(Setting_HomingEnable, (settings.homing.flags.value & 0x0F) |
 800c56c:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 800c570:	f895 60d4 	ldrb.w	r6, [r5, #212]	; 0xd4
 800c574:	f003 020f 	and.w	r2, r3, #15
 800c578:	f006 0610 	and.w	r6, r6, #16
                                               (settings.limits.flags.two_switches ? bit(4) : 0) |
                                                (settings.homing.flags.manual ? bit(5) : 0));
 800c57c:	005b      	lsls	r3, r3, #1
 800c57e:	f003 0320 	and.w	r3, r3, #32
    report_uint_setting(Setting_HomingEnable, (settings.homing.flags.value & 0x0F) |
 800c582:	4316      	orrs	r6, r2
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c584:	2016      	movs	r0, #22
    report_uint_setting(Setting_HomingEnable, (settings.homing.flags.value & 0x0F) |
 800c586:	431e      	orrs	r6, r3
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c588:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c58a:	f7fd fd73 	bl	800a074 <uitoa>
 800c58e:	4b8b      	ldr	r3, [pc, #556]	; (800c7bc <report_grbl_settings+0x624>)
 800c590:	4602      	mov	r2, r0
 800c592:	498b      	ldr	r1, [pc, #556]	; (800c7c0 <report_grbl_settings+0x628>)
 800c594:	2003      	movs	r0, #3
 800c596:	f7ff fcc5 	bl	800bf24 <appendbuf.constprop.0>
 800c59a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c59c:	4630      	mov	r0, r6
 800c59e:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c5a0:	f7fd fd68 	bl	800a074 <uitoa>
 800c5a4:	4a84      	ldr	r2, [pc, #528]	; (800c7b8 <report_grbl_settings+0x620>)
 800c5a6:	4601      	mov	r1, r0
 800c5a8:	2002      	movs	r0, #2
 800c5aa:	f7ff fcd7 	bl	800bf5c <appendbuf.constprop.1>
 800c5ae:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c5b0:	2017      	movs	r0, #23
    report_uint_setting(Setting_HomingDirMask, settings.homing.dir_mask.value);
 800c5b2:	f895 60cc 	ldrb.w	r6, [r5, #204]	; 0xcc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c5b6:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c5b8:	f7fd fd5c 	bl	800a074 <uitoa>
 800c5bc:	4b7f      	ldr	r3, [pc, #508]	; (800c7bc <report_grbl_settings+0x624>)
 800c5be:	4602      	mov	r2, r0
 800c5c0:	497f      	ldr	r1, [pc, #508]	; (800c7c0 <report_grbl_settings+0x628>)
 800c5c2:	2003      	movs	r0, #3
 800c5c4:	f7ff fcae 	bl	800bf24 <appendbuf.constprop.0>
 800c5c8:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c5ca:	4630      	mov	r0, r6
 800c5cc:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c5ce:	f7fd fd51 	bl	800a074 <uitoa>
 800c5d2:	4a79      	ldr	r2, [pc, #484]	; (800c7b8 <report_grbl_settings+0x620>)
 800c5d4:	4601      	mov	r1, r0
 800c5d6:	2002      	movs	r0, #2
 800c5d8:	f7ff fcc0 	bl	800bf5c <appendbuf.constprop.1>
 800c5dc:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c5de:	2018      	movs	r0, #24
    report_float_setting(Setting_HomingFeedRate, settings.homing.feed_rate, N_DECIMAL_SETTINGVALUE);
 800c5e0:	f8d5 60c0 	ldr.w	r6, [r5, #192]	; 0xc0
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c5e4:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c5e6:	f7fd fd45 	bl	800a074 <uitoa>
 800c5ea:	4b74      	ldr	r3, [pc, #464]	; (800c7bc <report_grbl_settings+0x624>)
 800c5ec:	4602      	mov	r2, r0
 800c5ee:	4974      	ldr	r1, [pc, #464]	; (800c7c0 <report_grbl_settings+0x628>)
 800c5f0:	2003      	movs	r0, #3
 800c5f2:	f7ff fc97 	bl	800bf24 <appendbuf.constprop.0>
 800c5f6:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c5f8:	4630      	mov	r0, r6
 800c5fa:	2103      	movs	r1, #3
 800c5fc:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c5fe:	f7fd fd5b 	bl	800a0b8 <ftoa>
 800c602:	4a6d      	ldr	r2, [pc, #436]	; (800c7b8 <report_grbl_settings+0x620>)
 800c604:	4601      	mov	r1, r0
 800c606:	2002      	movs	r0, #2
 800c608:	f7ff fca8 	bl	800bf5c <appendbuf.constprop.1>
 800c60c:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c60e:	2019      	movs	r0, #25
    report_float_setting(Setting_HomingSeekRate, settings.homing.seek_rate, N_DECIMAL_SETTINGVALUE);
 800c610:	f8d5 60c4 	ldr.w	r6, [r5, #196]	; 0xc4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c614:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c616:	f7fd fd2d 	bl	800a074 <uitoa>
 800c61a:	4b68      	ldr	r3, [pc, #416]	; (800c7bc <report_grbl_settings+0x624>)
 800c61c:	4602      	mov	r2, r0
 800c61e:	4968      	ldr	r1, [pc, #416]	; (800c7c0 <report_grbl_settings+0x628>)
 800c620:	2003      	movs	r0, #3
 800c622:	f7ff fc7f 	bl	800bf24 <appendbuf.constprop.0>
 800c626:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c628:	4630      	mov	r0, r6
 800c62a:	2103      	movs	r1, #3
 800c62c:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c62e:	f7fd fd43 	bl	800a0b8 <ftoa>
 800c632:	4a61      	ldr	r2, [pc, #388]	; (800c7b8 <report_grbl_settings+0x620>)
 800c634:	4601      	mov	r1, r0
 800c636:	2002      	movs	r0, #2
 800c638:	f7ff fc90 	bl	800bf5c <appendbuf.constprop.1>
 800c63c:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c63e:	201a      	movs	r0, #26
    report_uint_setting(Setting_HomingDebounceDelay, settings.homing.debounce_delay);
 800c640:	f8b5 60ce 	ldrh.w	r6, [r5, #206]	; 0xce
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c644:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c646:	f7fd fd15 	bl	800a074 <uitoa>
 800c64a:	4b5c      	ldr	r3, [pc, #368]	; (800c7bc <report_grbl_settings+0x624>)
 800c64c:	4602      	mov	r2, r0
 800c64e:	495c      	ldr	r1, [pc, #368]	; (800c7c0 <report_grbl_settings+0x628>)
 800c650:	2003      	movs	r0, #3
 800c652:	f7ff fc67 	bl	800bf24 <appendbuf.constprop.0>
 800c656:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c658:	4630      	mov	r0, r6
 800c65a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c65c:	f7fd fd0a 	bl	800a074 <uitoa>
 800c660:	4a55      	ldr	r2, [pc, #340]	; (800c7b8 <report_grbl_settings+0x620>)
 800c662:	4601      	mov	r1, r0
 800c664:	2002      	movs	r0, #2
 800c666:	f7ff fc79 	bl	800bf5c <appendbuf.constprop.1>
 800c66a:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c66c:	201b      	movs	r0, #27
    report_float_setting(Setting_HomingPulloff, settings.homing.pulloff, N_DECIMAL_SETTINGVALUE);
 800c66e:	f8d5 60c8 	ldr.w	r6, [r5, #200]	; 0xc8
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c672:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c674:	f7fd fcfe 	bl	800a074 <uitoa>
 800c678:	4b50      	ldr	r3, [pc, #320]	; (800c7bc <report_grbl_settings+0x624>)
 800c67a:	4602      	mov	r2, r0
 800c67c:	4950      	ldr	r1, [pc, #320]	; (800c7c0 <report_grbl_settings+0x628>)
 800c67e:	2003      	movs	r0, #3
 800c680:	f7ff fc50 	bl	800bf24 <appendbuf.constprop.0>
 800c684:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c686:	4630      	mov	r0, r6
 800c688:	2103      	movs	r1, #3
 800c68a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c68c:	f7fd fd14 	bl	800a0b8 <ftoa>
 800c690:	4a49      	ldr	r2, [pc, #292]	; (800c7b8 <report_grbl_settings+0x620>)
 800c692:	4601      	mov	r1, r0
 800c694:	2002      	movs	r0, #2
 800c696:	f7ff fc61 	bl	800bf5c <appendbuf.constprop.1>
 800c69a:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c69c:	201c      	movs	r0, #28

#if COMPATIBILITY_LEVEL <= 1

    report_float_setting(Setting_G73Retract, settings.g73_retract, N_DECIMAL_SETTINGVALUE);
 800c69e:	6bee      	ldr	r6, [r5, #60]	; 0x3c
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c6a0:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c6a2:	f7fd fce7 	bl	800a074 <uitoa>
 800c6a6:	4b45      	ldr	r3, [pc, #276]	; (800c7bc <report_grbl_settings+0x624>)
 800c6a8:	4602      	mov	r2, r0
 800c6aa:	4945      	ldr	r1, [pc, #276]	; (800c7c0 <report_grbl_settings+0x628>)
 800c6ac:	2003      	movs	r0, #3
 800c6ae:	f7ff fc39 	bl	800bf24 <appendbuf.constprop.0>
 800c6b2:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c6b4:	4630      	mov	r0, r6
 800c6b6:	2103      	movs	r1, #3
 800c6b8:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c6ba:	f7fd fcfd 	bl	800a0b8 <ftoa>
 800c6be:	4a3e      	ldr	r2, [pc, #248]	; (800c7b8 <report_grbl_settings+0x620>)
 800c6c0:	4601      	mov	r1, r0
 800c6c2:	2002      	movs	r0, #2
 800c6c4:	f7ff fc4a 	bl	800bf5c <appendbuf.constprop.1>
 800c6c8:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c6ca:	201d      	movs	r0, #29
    report_uint_setting(Setting_PulseDelayMicroseconds, settings.steppers.pulse_delay_microseconds);
 800c6cc:	f895 60b9 	ldrb.w	r6, [r5, #185]	; 0xb9
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c6d0:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c6d2:	f7fd fccf 	bl	800a074 <uitoa>
 800c6d6:	4b39      	ldr	r3, [pc, #228]	; (800c7bc <report_grbl_settings+0x624>)
 800c6d8:	4602      	mov	r2, r0
 800c6da:	4939      	ldr	r1, [pc, #228]	; (800c7c0 <report_grbl_settings+0x628>)
 800c6dc:	2003      	movs	r0, #3
 800c6de:	f7ff fc21 	bl	800bf24 <appendbuf.constprop.0>
 800c6e2:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c6e4:	4630      	mov	r0, r6
 800c6e6:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c6e8:	f7fd fcc4 	bl	800a074 <uitoa>
 800c6ec:	4a32      	ldr	r2, [pc, #200]	; (800c7b8 <report_grbl_settings+0x620>)
 800c6ee:	4601      	mov	r1, r0
 800c6f0:	2002      	movs	r0, #2
 800c6f2:	f7ff fc33 	bl	800bf5c <appendbuf.constprop.1>
 800c6f6:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c6f8:	201e      	movs	r0, #30

#endif

    report_float_setting(Setting_RpmMax, settings.spindle.rpm_max, N_DECIMAL_RPMVALUE);
 800c6fa:	6c6e      	ldr	r6, [r5, #68]	; 0x44
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c6fc:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c6fe:	f7fd fcb9 	bl	800a074 <uitoa>
 800c702:	4b2e      	ldr	r3, [pc, #184]	; (800c7bc <report_grbl_settings+0x624>)
 800c704:	4602      	mov	r2, r0
 800c706:	492e      	ldr	r1, [pc, #184]	; (800c7c0 <report_grbl_settings+0x628>)
 800c708:	2003      	movs	r0, #3
 800c70a:	f7ff fc0b 	bl	800bf24 <appendbuf.constprop.0>
 800c70e:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c710:	4630      	mov	r0, r6
 800c712:	2100      	movs	r1, #0
 800c714:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c716:	f7fd fccf 	bl	800a0b8 <ftoa>
 800c71a:	4a27      	ldr	r2, [pc, #156]	; (800c7b8 <report_grbl_settings+0x620>)
 800c71c:	4601      	mov	r1, r0
 800c71e:	2002      	movs	r0, #2
 800c720:	f7ff fc1c 	bl	800bf5c <appendbuf.constprop.1>
 800c724:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c726:	201f      	movs	r0, #31
    report_float_setting(Setting_RpmMin, settings.spindle.rpm_min, N_DECIMAL_RPMVALUE);
 800c728:	6cae      	ldr	r6, [r5, #72]	; 0x48
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c72a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c72c:	f7fd fca2 	bl	800a074 <uitoa>
 800c730:	4b22      	ldr	r3, [pc, #136]	; (800c7bc <report_grbl_settings+0x624>)
 800c732:	4602      	mov	r2, r0
 800c734:	4922      	ldr	r1, [pc, #136]	; (800c7c0 <report_grbl_settings+0x628>)
 800c736:	2003      	movs	r0, #3
 800c738:	f7ff fbf4 	bl	800bf24 <appendbuf.constprop.0>
 800c73c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c73e:	4630      	mov	r0, r6
 800c740:	2100      	movs	r1, #0
 800c742:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c744:	f7fd fcb8 	bl	800a0b8 <ftoa>
 800c748:	4a1b      	ldr	r2, [pc, #108]	; (800c7b8 <report_grbl_settings+0x620>)
 800c74a:	4601      	mov	r1, r0
 800c74c:	2002      	movs	r0, #2
 800c74e:	f7ff fc05 	bl	800bf5c <appendbuf.constprop.1>
 800c752:	47b0      	blx	r6
    report_uint_setting(Setting_Mode, settings.flags.laser_mode ? 1 : (settings.flags.lathe_mode ? 2 : 0));
 800c754:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c758:	2020      	movs	r0, #32
    report_uint_setting(Setting_Mode, settings.flags.laser_mode ? 1 : (settings.flags.lathe_mode ? 2 : 0));
 800c75a:	079a      	lsls	r2, r3, #30
 800c75c:	bf57      	itett	pl
 800c75e:	f895 60bd 	ldrbpl.w	r6, [r5, #189]	; 0xbd
 800c762:	2601      	movmi	r6, #1
 800c764:	09b6      	lsrpl	r6, r6, #6
 800c766:	f006 0602 	andpl.w	r6, r6, #2
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c76a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c76c:	f7fd fc82 	bl	800a074 <uitoa>
 800c770:	4b12      	ldr	r3, [pc, #72]	; (800c7bc <report_grbl_settings+0x624>)
 800c772:	4602      	mov	r2, r0
 800c774:	4912      	ldr	r1, [pc, #72]	; (800c7c0 <report_grbl_settings+0x628>)
 800c776:	2003      	movs	r0, #3
 800c778:	f7ff fbd4 	bl	800bf24 <appendbuf.constprop.0>
 800c77c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c77e:	4630      	mov	r0, r6
 800c780:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c782:	f7fd fc77 	bl	800a074 <uitoa>
 800c786:	4a0c      	ldr	r2, [pc, #48]	; (800c7b8 <report_grbl_settings+0x620>)
 800c788:	4601      	mov	r1, r0
 800c78a:	2002      	movs	r0, #2
 800c78c:	f7ff fbe6 	bl	800bf5c <appendbuf.constprop.1>
 800c790:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c792:	2021      	movs	r0, #33	; 0x21

#if COMPATIBILITY_LEVEL <= 1

    report_float_setting(Setting_PWMFreq, settings.spindle.pwm_freq, N_DECIMAL_SETTINGVALUE);
 800c794:	6cee      	ldr	r6, [r5, #76]	; 0x4c
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c796:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c798:	f7fd fc6c 	bl	800a074 <uitoa>
 800c79c:	4b07      	ldr	r3, [pc, #28]	; (800c7bc <report_grbl_settings+0x624>)
 800c79e:	4602      	mov	r2, r0
 800c7a0:	4907      	ldr	r1, [pc, #28]	; (800c7c0 <report_grbl_settings+0x628>)
 800c7a2:	2003      	movs	r0, #3
 800c7a4:	f7ff fbbe 	bl	800bf24 <appendbuf.constprop.0>
 800c7a8:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c7aa:	4630      	mov	r0, r6
 800c7ac:	2103      	movs	r1, #3
 800c7ae:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c7b0:	f7fd fc82 	bl	800a0b8 <ftoa>
 800c7b4:	e006      	b.n	800c7c4 <report_grbl_settings+0x62c>
 800c7b6:	bf00      	nop
 800c7b8:	08014968 	.word	0x08014968
 800c7bc:	08014b24 	.word	0x08014b24
 800c7c0:	08014b28 	.word	0x08014b28
 800c7c4:	4a83      	ldr	r2, [pc, #524]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c7c6:	4601      	mov	r1, r0
 800c7c8:	2002      	movs	r0, #2
 800c7ca:	f7ff fbc7 	bl	800bf5c <appendbuf.constprop.1>
 800c7ce:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c7d0:	2022      	movs	r0, #34	; 0x22
    report_float_setting(Setting_PWMOffValue, settings.spindle.pwm_off_value, N_DECIMAL_SETTINGVALUE);
 800c7d2:	6d6e      	ldr	r6, [r5, #84]	; 0x54
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c7d4:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c7d6:	f7fd fc4d 	bl	800a074 <uitoa>
 800c7da:	4b7f      	ldr	r3, [pc, #508]	; (800c9d8 <report_grbl_settings+0x840>)
 800c7dc:	4602      	mov	r2, r0
 800c7de:	497f      	ldr	r1, [pc, #508]	; (800c9dc <report_grbl_settings+0x844>)
 800c7e0:	2003      	movs	r0, #3
 800c7e2:	f7ff fb9f 	bl	800bf24 <appendbuf.constprop.0>
 800c7e6:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c7e8:	4630      	mov	r0, r6
 800c7ea:	2103      	movs	r1, #3
 800c7ec:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c7ee:	f7fd fc63 	bl	800a0b8 <ftoa>
 800c7f2:	4a78      	ldr	r2, [pc, #480]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c7f4:	4601      	mov	r1, r0
 800c7f6:	2002      	movs	r0, #2
 800c7f8:	f7ff fbb0 	bl	800bf5c <appendbuf.constprop.1>
 800c7fc:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c7fe:	2023      	movs	r0, #35	; 0x23
    report_float_setting(Setting_PWMMinValue, settings.spindle.pwm_min_value, N_DECIMAL_SETTINGVALUE);
 800c800:	6dae      	ldr	r6, [r5, #88]	; 0x58
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c802:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c804:	f7fd fc36 	bl	800a074 <uitoa>
 800c808:	4b73      	ldr	r3, [pc, #460]	; (800c9d8 <report_grbl_settings+0x840>)
 800c80a:	4602      	mov	r2, r0
 800c80c:	4973      	ldr	r1, [pc, #460]	; (800c9dc <report_grbl_settings+0x844>)
 800c80e:	2003      	movs	r0, #3
 800c810:	f7ff fb88 	bl	800bf24 <appendbuf.constprop.0>
 800c814:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c816:	4630      	mov	r0, r6
 800c818:	2103      	movs	r1, #3
 800c81a:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c81c:	f7fd fc4c 	bl	800a0b8 <ftoa>
 800c820:	4a6c      	ldr	r2, [pc, #432]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c822:	4601      	mov	r1, r0
 800c824:	2002      	movs	r0, #2
 800c826:	f7ff fb99 	bl	800bf5c <appendbuf.constprop.1>
 800c82a:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c82c:	2024      	movs	r0, #36	; 0x24
    report_float_setting(Setting_PWMMaxValue, settings.spindle.pwm_max_value, N_DECIMAL_SETTINGVALUE);
 800c82e:	6dee      	ldr	r6, [r5, #92]	; 0x5c
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c830:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c832:	f7fd fc1f 	bl	800a074 <uitoa>
 800c836:	4b68      	ldr	r3, [pc, #416]	; (800c9d8 <report_grbl_settings+0x840>)
 800c838:	4602      	mov	r2, r0
 800c83a:	4968      	ldr	r1, [pc, #416]	; (800c9dc <report_grbl_settings+0x844>)
 800c83c:	2003      	movs	r0, #3
 800c83e:	f7ff fb71 	bl	800bf24 <appendbuf.constprop.0>
 800c842:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800c844:	4630      	mov	r0, r6
 800c846:	2103      	movs	r1, #3
 800c848:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c84a:	f7fd fc35 	bl	800a0b8 <ftoa>
 800c84e:	4a61      	ldr	r2, [pc, #388]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c850:	4601      	mov	r1, r0
 800c852:	2002      	movs	r0, #2
 800c854:	f7ff fb82 	bl	800bf5c <appendbuf.constprop.1>
 800c858:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c85a:	2025      	movs	r0, #37	; 0x25
    report_uint_setting(Setting_StepperDeenergizeMask, settings.steppers.deenergize.mask);
 800c85c:	f895 60b7 	ldrb.w	r6, [r5, #183]	; 0xb7
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c860:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c862:	f7fd fc07 	bl	800a074 <uitoa>
 800c866:	4b5c      	ldr	r3, [pc, #368]	; (800c9d8 <report_grbl_settings+0x840>)
 800c868:	4602      	mov	r2, r0
 800c86a:	495c      	ldr	r1, [pc, #368]	; (800c9dc <report_grbl_settings+0x844>)
 800c86c:	2003      	movs	r0, #3
 800c86e:	f7ff fb59 	bl	800bf24 <appendbuf.constprop.0>
 800c872:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c874:	4630      	mov	r0, r6
 800c876:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c878:	f7fd fbfc 	bl	800a074 <uitoa>
 800c87c:	4a55      	ldr	r2, [pc, #340]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c87e:	4601      	mov	r1, r0
 800c880:	2002      	movs	r0, #2
 800c882:	f7ff fb6b 	bl	800bf5c <appendbuf.constprop.1>
 800c886:	47b0      	blx	r6
    if(hal.driver_cap.spindle_sync || hal.driver_cap.spindle_pid)
 800c888:	f894 3146 	ldrb.w	r3, [r4, #326]	; 0x146
 800c88c:	f013 0f41 	tst.w	r3, #65	; 0x41
 800c890:	f040 8230 	bne.w	800ccf4 <report_grbl_settings+0xb5c>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c894:	2027      	movs	r0, #39	; 0x27
        report_uint_setting(Setting_SpindlePPR, settings.spindle.ppr);

    report_uint_setting(Setting_EnableLegacyRTCommands, settings.legacy_rt_commands ? 1 : 0);
 800c896:	f895 6040 	ldrb.w	r6, [r5, #64]	; 0x40
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c89a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c89c:	f7fd fbea 	bl	800a074 <uitoa>
 800c8a0:	4b4d      	ldr	r3, [pc, #308]	; (800c9d8 <report_grbl_settings+0x840>)
 800c8a2:	4602      	mov	r2, r0
 800c8a4:	494d      	ldr	r1, [pc, #308]	; (800c9dc <report_grbl_settings+0x844>)
 800c8a6:	2003      	movs	r0, #3
 800c8a8:	f7ff fb3c 	bl	800bf24 <appendbuf.constprop.0>
 800c8ac:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c8ae:	4630      	mov	r0, r6
 800c8b0:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c8b2:	f7fd fbdf 	bl	800a074 <uitoa>
 800c8b6:	4a47      	ldr	r2, [pc, #284]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c8b8:	4601      	mov	r1, r0
 800c8ba:	2002      	movs	r0, #2
 800c8bc:	f7ff fb4e 	bl	800bf5c <appendbuf.constprop.1>
 800c8c0:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c8c2:	2028      	movs	r0, #40	; 0x28
 800c8c4:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_JogSoftLimited, settings.limits.flags.jog_soft_limited);
 800c8c6:	f895 60d4 	ldrb.w	r6, [r5, #212]	; 0xd4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c8ca:	f7fd fbd3 	bl	800a074 <uitoa>
 800c8ce:	4b42      	ldr	r3, [pc, #264]	; (800c9d8 <report_grbl_settings+0x840>)
 800c8d0:	4602      	mov	r2, r0
 800c8d2:	4942      	ldr	r1, [pc, #264]	; (800c9dc <report_grbl_settings+0x844>)
 800c8d4:	2003      	movs	r0, #3
 800c8d6:	f7ff fb25 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_JogSoftLimited, settings.limits.flags.jog_soft_limited);
 800c8da:	f3c6 06c0 	ubfx	r6, r6, #3, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c8de:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c8e0:	4630      	mov	r0, r6
 800c8e2:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c8e4:	f7fd fbc6 	bl	800a074 <uitoa>
 800c8e8:	4a3a      	ldr	r2, [pc, #232]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c8ea:	4601      	mov	r1, r0
 800c8ec:	2002      	movs	r0, #2
 800c8ee:	f7ff fb35 	bl	800bf5c <appendbuf.constprop.1>
 800c8f2:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c8f4:	2029      	movs	r0, #41	; 0x29
    report_uint_setting(Setting_ParkingEnable, settings.parking.flags.value);
 800c8f6:	f895 60d8 	ldrb.w	r6, [r5, #216]	; 0xd8
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c8fa:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c8fc:	f7fd fbba 	bl	800a074 <uitoa>
 800c900:	4b35      	ldr	r3, [pc, #212]	; (800c9d8 <report_grbl_settings+0x840>)
 800c902:	4602      	mov	r2, r0
 800c904:	4935      	ldr	r1, [pc, #212]	; (800c9dc <report_grbl_settings+0x844>)
 800c906:	2003      	movs	r0, #3
 800c908:	f7ff fb0c 	bl	800bf24 <appendbuf.constprop.0>
 800c90c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c90e:	4630      	mov	r0, r6
 800c910:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c912:	f7fd fbaf 	bl	800a074 <uitoa>
 800c916:	4a2f      	ldr	r2, [pc, #188]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c918:	4601      	mov	r1, r0
 800c91a:	2002      	movs	r0, #2
 800c91c:	f7ff fb1e 	bl	800bf5c <appendbuf.constprop.1>
 800c920:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c922:	202a      	movs	r0, #42	; 0x2a
    report_uint_setting(Setting_ParkingAxis, settings.parking.axis);
 800c924:	f895 60d9 	ldrb.w	r6, [r5, #217]	; 0xd9
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c928:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c92a:	f7fd fba3 	bl	800a074 <uitoa>
 800c92e:	4b2a      	ldr	r3, [pc, #168]	; (800c9d8 <report_grbl_settings+0x840>)
 800c930:	4602      	mov	r2, r0
 800c932:	492a      	ldr	r1, [pc, #168]	; (800c9dc <report_grbl_settings+0x844>)
 800c934:	2003      	movs	r0, #3
 800c936:	f7ff faf5 	bl	800bf24 <appendbuf.constprop.0>
 800c93a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c93c:	4630      	mov	r0, r6
 800c93e:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c940:	f7fd fb98 	bl	800a074 <uitoa>
 800c944:	4a23      	ldr	r2, [pc, #140]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c946:	4601      	mov	r1, r0
 800c948:	2002      	movs	r0, #2
 800c94a:	f7ff fb07 	bl	800bf5c <appendbuf.constprop.1>
 800c94e:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c950:	202b      	movs	r0, #43	; 0x2b

    report_uint_setting(Setting_HomingLocateCycles, settings.homing.locate_cycles);
 800c952:	f895 60cd 	ldrb.w	r6, [r5, #205]	; 0xcd
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c956:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c958:	f7fd fb8c 	bl	800a074 <uitoa>
 800c95c:	4b1e      	ldr	r3, [pc, #120]	; (800c9d8 <report_grbl_settings+0x840>)
 800c95e:	4602      	mov	r2, r0
 800c960:	491e      	ldr	r1, [pc, #120]	; (800c9dc <report_grbl_settings+0x844>)
 800c962:	2003      	movs	r0, #3
 800c964:	f7ff fade 	bl	800bf24 <appendbuf.constprop.0>
 800c968:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c96a:	4630      	mov	r0, r6
 800c96c:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800c96e:	f7fd fb81 	bl	800a074 <uitoa>
 800c972:	4f1b      	ldr	r7, [pc, #108]	; (800c9e0 <report_grbl_settings+0x848>)
 800c974:	4601      	mov	r1, r0
 800c976:	4a17      	ldr	r2, [pc, #92]	; (800c9d4 <report_grbl_settings+0x83c>)
 800c978:	2002      	movs	r0, #2
 800c97a:	f7ff faef 	bl	800bf5c <appendbuf.constprop.1>
 800c97e:	47b0      	blx	r6
 800c980:	46b8      	mov	r8, r7
 800c982:	262c      	movs	r6, #44	; 0x2c
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c984:	f8df b050 	ldr.w	fp, [pc, #80]	; 800c9d8 <report_grbl_settings+0x840>
 800c988:	f8df a050 	ldr.w	sl, [pc, #80]	; 800c9dc <report_grbl_settings+0x844>
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c98c:	f8df 9044 	ldr.w	r9, [pc, #68]	; 800c9d4 <report_grbl_settings+0x83c>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c990:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c992:	4630      	mov	r0, r6

    for(idx = 0 ; idx < N_AXIS ; idx++)
        report_uint_setting((setting_type_t)(Setting_HomingCycle_1 + idx), settings.homing.cycle[idx].mask);
 800c994:	f818 7b01 	ldrb.w	r7, [r8], #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c998:	9301      	str	r3, [sp, #4]
 800c99a:	f7fd fb6b 	bl	800a074 <uitoa>
 800c99e:	4651      	mov	r1, sl
 800c9a0:	4602      	mov	r2, r0
 800c9a2:	465b      	mov	r3, fp
 800c9a4:	2003      	movs	r0, #3
 800c9a6:	f7ff fabd 	bl	800bf24 <appendbuf.constprop.0>
 800c9aa:	9b01      	ldr	r3, [sp, #4]
 800c9ac:	4798      	blx	r3
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800c9ae:	4638      	mov	r0, r7
 800c9b0:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c9b2:	f7fd fb5f 	bl	800a074 <uitoa>
 800c9b6:	464a      	mov	r2, r9
 800c9b8:	4601      	mov	r1, r0
 800c9ba:	2002      	movs	r0, #2
 800c9bc:	f7ff face 	bl	800bf5c <appendbuf.constprop.1>
 800c9c0:	3601      	adds	r6, #1
 800c9c2:	47b8      	blx	r7
    for(idx = 0 ; idx < N_AXIS ; idx++)
 800c9c4:	2e2f      	cmp	r6, #47	; 0x2f
 800c9c6:	d1e3      	bne.n	800c990 <report_grbl_settings+0x7f8>

    if(hal.driver_settings_report) {
 800c9c8:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800c9cc:	b18b      	cbz	r3, 800c9f2 <report_grbl_settings+0x85a>
        for(idx = Setting_JogStepSpeed; idx < Setting_ParkingPulloutIncrement; idx++)
 800c9ce:	2632      	movs	r6, #50	; 0x32
 800c9d0:	e00a      	b.n	800c9e8 <report_grbl_settings+0x850>
 800c9d2:	bf00      	nop
 800c9d4:	08014968 	.word	0x08014968
 800c9d8:	08014b24 	.word	0x08014b24
 800c9dc:	08014b28 	.word	0x08014b28
 800c9e0:	200026f1 	.word	0x200026f1
 800c9e4:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
            hal.driver_settings_report((setting_type_t)idx);
 800c9e8:	b2b0      	uxth	r0, r6
        for(idx = Setting_JogStepSpeed; idx < Setting_ParkingPulloutIncrement; idx++)
 800c9ea:	3601      	adds	r6, #1
            hal.driver_settings_report((setting_type_t)idx);
 800c9ec:	4798      	blx	r3
        for(idx = Setting_JogStepSpeed; idx < Setting_ParkingPulloutIncrement; idx++)
 800c9ee:	2e38      	cmp	r6, #56	; 0x38
 800c9f0:	d1f8      	bne.n	800c9e4 <report_grbl_settings+0x84c>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c9f2:	2038      	movs	r0, #56	; 0x38
    }

    report_float_setting(Setting_ParkingPulloutIncrement, settings.parking.pullout_increment, N_DECIMAL_SETTINGVALUE);
 800c9f4:	f8d5 60e8 	ldr.w	r6, [r5, #232]	; 0xe8
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800c9f8:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800c9fa:	f7fd fb3b 	bl	800a074 <uitoa>
 800c9fe:	4bb8      	ldr	r3, [pc, #736]	; (800cce0 <report_grbl_settings+0xb48>)
 800ca00:	4602      	mov	r2, r0
 800ca02:	49b8      	ldr	r1, [pc, #736]	; (800cce4 <report_grbl_settings+0xb4c>)
 800ca04:	2003      	movs	r0, #3
 800ca06:	f7ff fa8d 	bl	800bf24 <appendbuf.constprop.0>
 800ca0a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800ca0c:	4630      	mov	r0, r6
 800ca0e:	2103      	movs	r1, #3
 800ca10:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800ca12:	f7fd fb51 	bl	800a0b8 <ftoa>
 800ca16:	4ab4      	ldr	r2, [pc, #720]	; (800cce8 <report_grbl_settings+0xb50>)
 800ca18:	4601      	mov	r1, r0
 800ca1a:	2002      	movs	r0, #2
 800ca1c:	f7ff fa9e 	bl	800bf5c <appendbuf.constprop.1>
 800ca20:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca22:	2039      	movs	r0, #57	; 0x39
    report_float_setting(Setting_ParkingPulloutRate, settings.parking.pullout_rate, N_DECIMAL_SETTINGVALUE);
 800ca24:	f8d5 60e4 	ldr.w	r6, [r5, #228]	; 0xe4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca28:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800ca2a:	f7fd fb23 	bl	800a074 <uitoa>
 800ca2e:	4bac      	ldr	r3, [pc, #688]	; (800cce0 <report_grbl_settings+0xb48>)
 800ca30:	4602      	mov	r2, r0
 800ca32:	49ac      	ldr	r1, [pc, #688]	; (800cce4 <report_grbl_settings+0xb4c>)
 800ca34:	2003      	movs	r0, #3
 800ca36:	f7ff fa75 	bl	800bf24 <appendbuf.constprop.0>
 800ca3a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800ca3c:	4630      	mov	r0, r6
 800ca3e:	2103      	movs	r1, #3
 800ca40:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800ca42:	f7fd fb39 	bl	800a0b8 <ftoa>
 800ca46:	4aa8      	ldr	r2, [pc, #672]	; (800cce8 <report_grbl_settings+0xb50>)
 800ca48:	4601      	mov	r1, r0
 800ca4a:	2002      	movs	r0, #2
 800ca4c:	f7ff fa86 	bl	800bf5c <appendbuf.constprop.1>
 800ca50:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca52:	203a      	movs	r0, #58	; 0x3a
    report_float_setting(Setting_ParkingTarget, settings.parking.target, N_DECIMAL_SETTINGVALUE);
 800ca54:	f8d5 60dc 	ldr.w	r6, [r5, #220]	; 0xdc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca58:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800ca5a:	f7fd fb0b 	bl	800a074 <uitoa>
 800ca5e:	4ba0      	ldr	r3, [pc, #640]	; (800cce0 <report_grbl_settings+0xb48>)
 800ca60:	4602      	mov	r2, r0
 800ca62:	49a0      	ldr	r1, [pc, #640]	; (800cce4 <report_grbl_settings+0xb4c>)
 800ca64:	2003      	movs	r0, #3
 800ca66:	f7ff fa5d 	bl	800bf24 <appendbuf.constprop.0>
 800ca6a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800ca6c:	4630      	mov	r0, r6
 800ca6e:	2103      	movs	r1, #3
 800ca70:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800ca72:	f7fd fb21 	bl	800a0b8 <ftoa>
 800ca76:	4a9c      	ldr	r2, [pc, #624]	; (800cce8 <report_grbl_settings+0xb50>)
 800ca78:	4601      	mov	r1, r0
 800ca7a:	2002      	movs	r0, #2
 800ca7c:	f7ff fa6e 	bl	800bf5c <appendbuf.constprop.1>
 800ca80:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca82:	203b      	movs	r0, #59	; 0x3b
    report_float_setting(Setting_ParkingFastRate, settings.parking.rate, N_DECIMAL_SETTINGVALUE);
 800ca84:	f8d5 60e0 	ldr.w	r6, [r5, #224]	; 0xe0
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ca88:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800ca8a:	f7fd faf3 	bl	800a074 <uitoa>
 800ca8e:	4b94      	ldr	r3, [pc, #592]	; (800cce0 <report_grbl_settings+0xb48>)
 800ca90:	4602      	mov	r2, r0
 800ca92:	4994      	ldr	r1, [pc, #592]	; (800cce4 <report_grbl_settings+0xb4c>)
 800ca94:	2003      	movs	r0, #3
 800ca96:	f7ff fa45 	bl	800bf24 <appendbuf.constprop.0>
 800ca9a:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800ca9c:	4630      	mov	r0, r6
 800ca9e:	2103      	movs	r1, #3
 800caa0:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800caa2:	f7fd fb09 	bl	800a0b8 <ftoa>
 800caa6:	4a90      	ldr	r2, [pc, #576]	; (800cce8 <report_grbl_settings+0xb50>)
 800caa8:	4601      	mov	r1, r0
 800caaa:	2002      	movs	r0, #2
 800caac:	f7ff fa56 	bl	800bf5c <appendbuf.constprop.1>
 800cab0:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cab2:	203c      	movs	r0, #60	; 0x3c
 800cab4:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_RestoreOverrides, settings.flags.restore_overrides);
 800cab6:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800caba:	f7fd fadb 	bl	800a074 <uitoa>
 800cabe:	4b88      	ldr	r3, [pc, #544]	; (800cce0 <report_grbl_settings+0xb48>)
 800cac0:	4602      	mov	r2, r0
 800cac2:	4988      	ldr	r1, [pc, #544]	; (800cce4 <report_grbl_settings+0xb4c>)
 800cac4:	2003      	movs	r0, #3
 800cac6:	f7ff fa2d 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_RestoreOverrides, settings.flags.restore_overrides);
 800caca:	f3c6 1600 	ubfx	r6, r6, #4, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cace:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cad0:	4630      	mov	r0, r6
 800cad2:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cad4:	f7fd face 	bl	800a074 <uitoa>
 800cad8:	4a83      	ldr	r2, [pc, #524]	; (800cce8 <report_grbl_settings+0xb50>)
 800cada:	4601      	mov	r1, r0
 800cadc:	2002      	movs	r0, #2
 800cade:	f7ff fa3d 	bl	800bf5c <appendbuf.constprop.1>
 800cae2:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cae4:	203d      	movs	r0, #61	; 0x3d
 800cae6:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_IgnoreDoorWhenIdle, settings.flags.safety_door_ignore_when_idle);
 800cae8:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800caec:	f7fd fac2 	bl	800a074 <uitoa>
 800caf0:	4b7b      	ldr	r3, [pc, #492]	; (800cce0 <report_grbl_settings+0xb48>)
 800caf2:	4602      	mov	r2, r0
 800caf4:	497b      	ldr	r1, [pc, #492]	; (800cce4 <report_grbl_settings+0xb4c>)
 800caf6:	2003      	movs	r0, #3
 800caf8:	f7ff fa14 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_IgnoreDoorWhenIdle, settings.flags.safety_door_ignore_when_idle);
 800cafc:	f3c6 1640 	ubfx	r6, r6, #5, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb00:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cb02:	4630      	mov	r0, r6
 800cb04:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cb06:	f7fd fab5 	bl	800a074 <uitoa>
 800cb0a:	4a77      	ldr	r2, [pc, #476]	; (800cce8 <report_grbl_settings+0xb50>)
 800cb0c:	4601      	mov	r1, r0
 800cb0e:	2002      	movs	r0, #2
 800cb10:	f7ff fa24 	bl	800bf5c <appendbuf.constprop.1>
 800cb14:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb16:	203e      	movs	r0, #62	; 0x3e
 800cb18:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_SleepEnable, settings.flags.sleep_enable);
 800cb1a:	f895 60bc 	ldrb.w	r6, [r5, #188]	; 0xbc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb1e:	f7fd faa9 	bl	800a074 <uitoa>
 800cb22:	4b6f      	ldr	r3, [pc, #444]	; (800cce0 <report_grbl_settings+0xb48>)
 800cb24:	4602      	mov	r2, r0
 800cb26:	496f      	ldr	r1, [pc, #444]	; (800cce4 <report_grbl_settings+0xb4c>)
 800cb28:	2003      	movs	r0, #3
 800cb2a:	f7ff f9fb 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_SleepEnable, settings.flags.sleep_enable);
 800cb2e:	f3c6 1680 	ubfx	r6, r6, #6, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb32:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cb34:	4630      	mov	r0, r6
 800cb36:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cb38:	f7fd fa9c 	bl	800a074 <uitoa>
 800cb3c:	4a6a      	ldr	r2, [pc, #424]	; (800cce8 <report_grbl_settings+0xb50>)
 800cb3e:	4601      	mov	r1, r0
 800cb40:	2002      	movs	r0, #2
 800cb42:	f7ff fa0b 	bl	800bf5c <appendbuf.constprop.1>
 800cb46:	47b0      	blx	r6
    report_uint_setting(Setting_HoldActions, (settings.flags.disable_laser_during_hold ? bit(0) : 0) | (settings.flags.restore_after_feed_hold ? bit(1) : 0));
 800cb48:	f895 60bd 	ldrb.w	r6, [r5, #189]	; 0xbd
 800cb4c:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
 800cb50:	08f6      	lsrs	r6, r6, #3
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb52:	203f      	movs	r0, #63	; 0x3f
    report_uint_setting(Setting_HoldActions, (settings.flags.disable_laser_during_hold ? bit(0) : 0) | (settings.flags.restore_after_feed_hold ? bit(1) : 0));
 800cb54:	f006 0602 	and.w	r6, r6, #2
 800cb58:	ea46 16d3 	orr.w	r6, r6, r3, lsr #7
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb5c:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800cb5e:	f7fd fa89 	bl	800a074 <uitoa>
 800cb62:	4b5f      	ldr	r3, [pc, #380]	; (800cce0 <report_grbl_settings+0xb48>)
 800cb64:	4602      	mov	r2, r0
 800cb66:	495f      	ldr	r1, [pc, #380]	; (800cce4 <report_grbl_settings+0xb4c>)
 800cb68:	2003      	movs	r0, #3
 800cb6a:	f7ff f9db 	bl	800bf24 <appendbuf.constprop.0>
 800cb6e:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cb70:	4630      	mov	r0, r6
 800cb72:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cb74:	f7fd fa7e 	bl	800a074 <uitoa>
 800cb78:	4a5b      	ldr	r2, [pc, #364]	; (800cce8 <report_grbl_settings+0xb50>)
 800cb7a:	4601      	mov	r1, r0
 800cb7c:	2002      	movs	r0, #2
 800cb7e:	f7ff f9ed 	bl	800bf5c <appendbuf.constprop.1>
 800cb82:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb84:	2040      	movs	r0, #64	; 0x40
 800cb86:	6e67      	ldr	r7, [r4, #100]	; 0x64
    report_uint_setting(Setting_ForceInitAlarm, settings.flags.force_initialization_alarm);
 800cb88:	f895 60bd 	ldrb.w	r6, [r5, #189]	; 0xbd
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cb8c:	f7fd fa72 	bl	800a074 <uitoa>
 800cb90:	4b53      	ldr	r3, [pc, #332]	; (800cce0 <report_grbl_settings+0xb48>)
 800cb92:	4602      	mov	r2, r0
 800cb94:	4953      	ldr	r1, [pc, #332]	; (800cce4 <report_grbl_settings+0xb4c>)
 800cb96:	2003      	movs	r0, #3
 800cb98:	f7ff f9c4 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_ForceInitAlarm, settings.flags.force_initialization_alarm);
 800cb9c:	f006 0601 	and.w	r6, r6, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cba0:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cba2:	4630      	mov	r0, r6
 800cba4:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cba6:	f7fd fa65 	bl	800a074 <uitoa>
 800cbaa:	4a4f      	ldr	r2, [pc, #316]	; (800cce8 <report_grbl_settings+0xb50>)
 800cbac:	4601      	mov	r1, r0
 800cbae:	2002      	movs	r0, #2
 800cbb0:	f7ff f9d4 	bl	800bf5c <appendbuf.constprop.1>
 800cbb4:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cbb6:	2041      	movs	r0, #65	; 0x41
    report_uint_setting(Setting_ProbingFeedOverride, settings.flags.allow_probing_feed_override);
 800cbb8:	f895 60bd 	ldrb.w	r6, [r5, #189]	; 0xbd
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cbbc:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800cbbe:	f7fd fa59 	bl	800a074 <uitoa>
 800cbc2:	4b47      	ldr	r3, [pc, #284]	; (800cce0 <report_grbl_settings+0xb48>)
 800cbc4:	4602      	mov	r2, r0
 800cbc6:	4947      	ldr	r1, [pc, #284]	; (800cce4 <report_grbl_settings+0xb4c>)
 800cbc8:	2003      	movs	r0, #3
 800cbca:	f7ff f9ab 	bl	800bf24 <appendbuf.constprop.0>
    report_uint_setting(Setting_ProbingFeedOverride, settings.flags.allow_probing_feed_override);
 800cbce:	f3c6 0680 	ubfx	r6, r6, #2, #1
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cbd2:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cbd4:	4630      	mov	r0, r6
 800cbd6:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cbd8:	f7fd fa4c 	bl	800a074 <uitoa>
 800cbdc:	4a42      	ldr	r2, [pc, #264]	; (800cce8 <report_grbl_settings+0xb50>)
 800cbde:	4601      	mov	r1, r0
 800cbe0:	2002      	movs	r0, #2
 800cbe2:	f7ff f9bb 	bl	800bf5c <appendbuf.constprop.1>
 800cbe6:	47b0      	blx	r6
    }
  #endif

#endif

    if(hal.driver_settings_report) {
 800cbe8:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800cbec:	b143      	cbz	r3, 800cc00 <report_grbl_settings+0xa68>
        for(idx = Setting_NetworkServices; idx < Setting_SpindlePGain; idx++)
 800cbee:	2646      	movs	r6, #70	; 0x46
 800cbf0:	e001      	b.n	800cbf6 <report_grbl_settings+0xa5e>
 800cbf2:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
            hal.driver_settings_report((setting_type_t)idx);
 800cbf6:	b2b0      	uxth	r0, r6
        for(idx = Setting_NetworkServices; idx < Setting_SpindlePGain; idx++)
 800cbf8:	3601      	adds	r6, #1
            hal.driver_settings_report((setting_type_t)idx);
 800cbfa:	4798      	blx	r3
        for(idx = Setting_NetworkServices; idx < Setting_SpindlePGain; idx++)
 800cbfc:	2e50      	cmp	r6, #80	; 0x50
 800cbfe:	d1f8      	bne.n	800cbf2 <report_grbl_settings+0xa5a>
        report_float_setting(Setting_SpindleIMaxError, settings.spindle.pid.i_max_error, N_DECIMAL_SETTINGVALUE);
    }

#endif

    if(hal.driver_cap.spindle_sync) {
 800cc00:	f894 3146 	ldrb.w	r3, [r4, #326]	; 0x146
 800cc04:	07db      	lsls	r3, r3, #31
 800cc06:	f100 808d 	bmi.w	800cd24 <report_grbl_settings+0xb8c>
        report_float_setting(Setting_PositionDGain, settings.position.pid.d_gain, N_DECIMAL_SETTINGVALUE);
        report_float_setting(Setting_PositionIMaxError, settings.position.pid.i_max_error, N_DECIMAL_SETTINGVALUE);
    }

    // Print axis settings
    uint_fast8_t set_idx, val = (uint_fast8_t)Setting_AxisSettingsBase;
 800cc0a:	f04f 0864 	mov.w	r8, #100	; 0x64
    uint_fast8_t max_set = hal.driver_settings_report ? AXIS_SETTINGS_INCREMENT : AXIS_N_SETTINGS;
 800cc0e:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    for (set_idx = 0; set_idx < max_set; set_idx++) {
 800cc12:	2600      	movs	r6, #0
    uint_fast8_t max_set = hal.driver_settings_report ? AXIS_SETTINGS_INCREMENT : AXIS_N_SETTINGS;
 800cc14:	2b00      	cmp	r3, #0
 800cc16:	bf14      	ite	ne
 800cc18:	230a      	movne	r3, #10
 800cc1a:	2304      	moveq	r3, #4
 800cc1c:	46c1      	mov	r9, r8
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cc1e:	f8df b0c0 	ldr.w	fp, [pc, #192]	; 800cce0 <report_grbl_settings+0xb48>
 800cc22:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 800cce4 <report_grbl_settings+0xb4c>
    uint_fast8_t max_set = hal.driver_settings_report ? AXIS_SETTINGS_INCREMENT : AXIS_N_SETTINGS;
 800cc26:	9302      	str	r3, [sp, #8]

        for (idx = 0; idx < N_AXIS; idx++) {
 800cc28:	2500      	movs	r5, #0
 800cc2a:	b2f3      	uxtb	r3, r6
 800cc2c:	4f2f      	ldr	r7, [pc, #188]	; (800ccec <report_grbl_settings+0xb54>)
 800cc2e:	9303      	str	r3, [sp, #12]

            switch ((axis_setting_type_t)set_idx) {
 800cc30:	2e03      	cmp	r6, #3
 800cc32:	f200 80d8 	bhi.w	800cde6 <report_grbl_settings+0xc4e>
 800cc36:	e8df f006 	tbb	[pc, r6]
 800cc3a:	464c      	.short	0x464c
 800cc3c:	023d      	.short	0x023d
                case AxisSetting_Acceleration:
                    report_float_setting((setting_type_t)(val + idx), settings.acceleration[idx] / (60.0f * 60.0f), N_DECIMAL_SETTINGVALUE);
                    break;

                case AxisSetting_MaxTravel:
                    report_float_setting((setting_type_t)(val + idx), -settings.max_travel[idx], N_DECIMAL_SETTINGVALUE);
 800cc3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc40:	eb09 0005 	add.w	r0, r9, r5
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cc44:	b280      	uxth	r0, r0
                    report_float_setting((setting_type_t)(val + idx), -settings.max_travel[idx], N_DECIMAL_SETTINGVALUE);
 800cc46:	f103 4800 	add.w	r8, r3, #2147483648	; 0x80000000
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cc4a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cc4c:	9301      	str	r3, [sp, #4]
 800cc4e:	f7fd fa11 	bl	800a074 <uitoa>
 800cc52:	4651      	mov	r1, sl
 800cc54:	4602      	mov	r2, r0
 800cc56:	465b      	mov	r3, fp
 800cc58:	2003      	movs	r0, #3
 800cc5a:	f7ff f963 	bl	800bf24 <appendbuf.constprop.0>
 800cc5e:	9b01      	ldr	r3, [sp, #4]
 800cc60:	4798      	blx	r3
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800cc62:	4640      	mov	r0, r8
 800cc64:	2103      	movs	r1, #3
 800cc66:	f8d4 8064 	ldr.w	r8, [r4, #100]	; 0x64
 800cc6a:	f7fd fa25 	bl	800a0b8 <ftoa>
 800cc6e:	4a1e      	ldr	r2, [pc, #120]	; (800cce8 <report_grbl_settings+0xb50>)
 800cc70:	4601      	mov	r1, r0
 800cc72:	2002      	movs	r0, #2
 800cc74:	f7ff f972 	bl	800bf5c <appendbuf.constprop.1>
 800cc78:	47c0      	blx	r8
        for (idx = 0; idx < N_AXIS; idx++) {
 800cc7a:	3501      	adds	r5, #1
 800cc7c:	2d03      	cmp	r5, #3
 800cc7e:	f107 0704 	add.w	r7, r7, #4
 800cc82:	d1d5      	bne.n	800cc30 <report_grbl_settings+0xa98>
    for (set_idx = 0; set_idx < max_set; set_idx++) {
 800cc84:	9b02      	ldr	r3, [sp, #8]
 800cc86:	3601      	adds	r6, #1
 800cc88:	42b3      	cmp	r3, r6
                    if(hal.driver_axis_settings_report)
                        hal.driver_axis_settings_report((axis_setting_type_t)set_idx, idx);
                    break;
            }
        }
        val += AXIS_SETTINGS_INCREMENT;
 800cc8a:	f109 090a 	add.w	r9, r9, #10
    for (set_idx = 0; set_idx < max_set; set_idx++) {
 800cc8e:	d1cb      	bne.n	800cc28 <report_grbl_settings+0xa90>
    }

    if(hal.driver_settings_report) {
 800cc90:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 800cc94:	b15b      	cbz	r3, 800ccae <report_grbl_settings+0xb16>
        for(idx = Setting_AxisSettingsMax + 1; idx <= Setting_SettingsMax; idx++)
 800cc96:	f44f 7580 	mov.w	r5, #256	; 0x100
 800cc9a:	f240 164d 	movw	r6, #333	; 0x14d
 800cc9e:	e001      	b.n	800cca4 <report_grbl_settings+0xb0c>
 800cca0:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
            hal.driver_settings_report((setting_type_t)idx);
 800cca4:	b2a8      	uxth	r0, r5
        for(idx = Setting_AxisSettingsMax + 1; idx <= Setting_SettingsMax; idx++)
 800cca6:	3501      	adds	r5, #1
            hal.driver_settings_report((setting_type_t)idx);
 800cca8:	4798      	blx	r3
        for(idx = Setting_AxisSettingsMax + 1; idx <= Setting_SettingsMax; idx++)
 800ccaa:	42b5      	cmp	r5, r6
 800ccac:	d1f8      	bne.n	800cca0 <report_grbl_settings+0xb08>
    }
}
 800ccae:	b005      	add	sp, #20
 800ccb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    report_float_setting((setting_type_t)(val + idx), settings.acceleration[idx] / (60.0f * 60.0f), N_DECIMAL_SETTINGVALUE);
 800ccb4:	490e      	ldr	r1, [pc, #56]	; (800ccf0 <report_grbl_settings+0xb58>)
 800ccb6:	69f8      	ldr	r0, [r7, #28]
 800ccb8:	f7f3 fd6c 	bl	8000794 <__aeabi_fmul>
 800ccbc:	4680      	mov	r8, r0
 800ccbe:	eb09 0005 	add.w	r0, r9, r5
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ccc2:	b280      	uxth	r0, r0
 800ccc4:	e7c1      	b.n	800cc4a <report_grbl_settings+0xab2>
                    report_float_setting((setting_type_t)(val + idx), settings.max_rate[idx], N_DECIMAL_SETTINGVALUE);
 800ccc6:	eb09 0005 	add.w	r0, r9, r5
 800ccca:	f8d7 8010 	ldr.w	r8, [r7, #16]
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ccce:	b280      	uxth	r0, r0
 800ccd0:	e7bb      	b.n	800cc4a <report_grbl_settings+0xab2>
                    report_float_setting((setting_type_t)(val + idx), settings.steps_per_mm[idx], N_DECIMAL_SETTINGVALUE);
 800ccd2:	eb09 0005 	add.w	r0, r9, r5
 800ccd6:	f8d7 8004 	ldr.w	r8, [r7, #4]
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ccda:	b280      	uxth	r0, r0
 800ccdc:	e7b5      	b.n	800cc4a <report_grbl_settings+0xab2>
 800ccde:	bf00      	nop
 800cce0:	08014b24 	.word	0x08014b24
 800cce4:	08014b28 	.word	0x08014b28
 800cce8:	08014968 	.word	0x08014968
 800ccec:	20002620 	.word	0x20002620
 800ccf0:	3991a2b4 	.word	0x3991a2b4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ccf4:	2026      	movs	r0, #38	; 0x26
        report_uint_setting(Setting_SpindlePPR, settings.spindle.ppr);
 800ccf6:	f8b5 60b0 	ldrh.w	r6, [r5, #176]	; 0xb0
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800ccfa:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800ccfc:	f7fd f9ba 	bl	800a074 <uitoa>
 800cd00:	4b3d      	ldr	r3, [pc, #244]	; (800cdf8 <report_grbl_settings+0xc60>)
 800cd02:	4602      	mov	r2, r0
 800cd04:	493d      	ldr	r1, [pc, #244]	; (800cdfc <report_grbl_settings+0xc64>)
 800cd06:	2003      	movs	r0, #3
 800cd08:	f7ff f90c 	bl	800bf24 <appendbuf.constprop.0>
 800cd0c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, uitoa(val), "\r\n"));
 800cd0e:	4630      	mov	r0, r6
 800cd10:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cd12:	f7fd f9af 	bl	800a074 <uitoa>
 800cd16:	4a3a      	ldr	r2, [pc, #232]	; (800ce00 <report_grbl_settings+0xc68>)
 800cd18:	4601      	mov	r1, r0
 800cd1a:	2002      	movs	r0, #2
 800cd1c:	f7ff f91e 	bl	800bf5c <appendbuf.constprop.1>
 800cd20:	47b0      	blx	r6
}
 800cd22:	e5b7      	b.n	800c894 <report_grbl_settings+0x6fc>
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd24:	205a      	movs	r0, #90	; 0x5a
        report_float_setting(Setting_PositionPGain, settings.position.pid.p_gain, N_DECIMAL_SETTINGVALUE);
 800cd26:	f8d5 60ec 	ldr.w	r6, [r5, #236]	; 0xec
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd2a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800cd2c:	f7fd f9a2 	bl	800a074 <uitoa>
 800cd30:	4b31      	ldr	r3, [pc, #196]	; (800cdf8 <report_grbl_settings+0xc60>)
 800cd32:	4602      	mov	r2, r0
 800cd34:	4931      	ldr	r1, [pc, #196]	; (800cdfc <report_grbl_settings+0xc64>)
 800cd36:	2003      	movs	r0, #3
 800cd38:	f7ff f8f4 	bl	800bf24 <appendbuf.constprop.0>
 800cd3c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800cd3e:	4630      	mov	r0, r6
 800cd40:	2103      	movs	r1, #3
 800cd42:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cd44:	f7fd f9b8 	bl	800a0b8 <ftoa>
 800cd48:	4a2d      	ldr	r2, [pc, #180]	; (800ce00 <report_grbl_settings+0xc68>)
 800cd4a:	4601      	mov	r1, r0
 800cd4c:	2002      	movs	r0, #2
 800cd4e:	f7ff f905 	bl	800bf5c <appendbuf.constprop.1>
 800cd52:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd54:	205b      	movs	r0, #91	; 0x5b
        report_float_setting(Setting_PositionIGain, settings.position.pid.i_gain, N_DECIMAL_SETTINGVALUE);
 800cd56:	f8d5 60f0 	ldr.w	r6, [r5, #240]	; 0xf0
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd5a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800cd5c:	f7fd f98a 	bl	800a074 <uitoa>
 800cd60:	4b25      	ldr	r3, [pc, #148]	; (800cdf8 <report_grbl_settings+0xc60>)
 800cd62:	4602      	mov	r2, r0
 800cd64:	4925      	ldr	r1, [pc, #148]	; (800cdfc <report_grbl_settings+0xc64>)
 800cd66:	2003      	movs	r0, #3
 800cd68:	f7ff f8dc 	bl	800bf24 <appendbuf.constprop.0>
 800cd6c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800cd6e:	4630      	mov	r0, r6
 800cd70:	2103      	movs	r1, #3
 800cd72:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cd74:	f7fd f9a0 	bl	800a0b8 <ftoa>
 800cd78:	4a21      	ldr	r2, [pc, #132]	; (800ce00 <report_grbl_settings+0xc68>)
 800cd7a:	4601      	mov	r1, r0
 800cd7c:	2002      	movs	r0, #2
 800cd7e:	f7ff f8ed 	bl	800bf5c <appendbuf.constprop.1>
 800cd82:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd84:	205c      	movs	r0, #92	; 0x5c
        report_float_setting(Setting_PositionDGain, settings.position.pid.d_gain, N_DECIMAL_SETTINGVALUE);
 800cd86:	f8d5 60f4 	ldr.w	r6, [r5, #244]	; 0xf4
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cd8a:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800cd8c:	f7fd f972 	bl	800a074 <uitoa>
 800cd90:	4b19      	ldr	r3, [pc, #100]	; (800cdf8 <report_grbl_settings+0xc60>)
 800cd92:	4602      	mov	r2, r0
 800cd94:	4919      	ldr	r1, [pc, #100]	; (800cdfc <report_grbl_settings+0xc64>)
 800cd96:	2003      	movs	r0, #3
 800cd98:	f7ff f8c4 	bl	800bf24 <appendbuf.constprop.0>
 800cd9c:	47b8      	blx	r7
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800cd9e:	4630      	mov	r0, r6
 800cda0:	2103      	movs	r1, #3
 800cda2:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cda4:	f7fd f988 	bl	800a0b8 <ftoa>
 800cda8:	4a15      	ldr	r2, [pc, #84]	; (800ce00 <report_grbl_settings+0xc68>)
 800cdaa:	4601      	mov	r1, r0
 800cdac:	2002      	movs	r0, #2
 800cdae:	f7ff f8d5 	bl	800bf5c <appendbuf.constprop.1>
 800cdb2:	47b0      	blx	r6
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cdb4:	205f      	movs	r0, #95	; 0x5f
        report_float_setting(Setting_PositionIMaxError, settings.position.pid.i_max_error, N_DECIMAL_SETTINGVALUE);
 800cdb6:	f8d5 50fc 	ldr.w	r5, [r5, #252]	; 0xfc
    hal.stream.write(appendbuf(3, "$", uitoa((uint32_t)n), "="));
 800cdba:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cdbc:	f7fd f95a 	bl	800a074 <uitoa>
 800cdc0:	4b0d      	ldr	r3, [pc, #52]	; (800cdf8 <report_grbl_settings+0xc60>)
 800cdc2:	4602      	mov	r2, r0
 800cdc4:	490d      	ldr	r1, [pc, #52]	; (800cdfc <report_grbl_settings+0xc64>)
 800cdc6:	2003      	movs	r0, #3
 800cdc8:	f7ff f8ac 	bl	800bf24 <appendbuf.constprop.0>
 800cdcc:	47b0      	blx	r6
    hal.stream.write(appendbuf(2, ftoa(val, n_decimal), "\r\n"));
 800cdce:	4628      	mov	r0, r5
 800cdd0:	2103      	movs	r1, #3
 800cdd2:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800cdd4:	f7fd f970 	bl	800a0b8 <ftoa>
 800cdd8:	4a09      	ldr	r2, [pc, #36]	; (800ce00 <report_grbl_settings+0xc68>)
 800cdda:	4601      	mov	r1, r0
 800cddc:	2002      	movs	r0, #2
 800cdde:	f7ff f8bd 	bl	800bf5c <appendbuf.constprop.1>
 800cde2:	47a8      	blx	r5
}
 800cde4:	e711      	b.n	800cc0a <report_grbl_settings+0xa72>
                    if(hal.driver_axis_settings_report)
 800cde6:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 800cdea:	2b00      	cmp	r3, #0
 800cdec:	f43f af45 	beq.w	800cc7a <report_grbl_settings+0xae2>
                        hal.driver_axis_settings_report((axis_setting_type_t)set_idx, idx);
 800cdf0:	9803      	ldr	r0, [sp, #12]
 800cdf2:	b2e9      	uxtb	r1, r5
 800cdf4:	4798      	blx	r3
 800cdf6:	e740      	b.n	800cc7a <report_grbl_settings+0xae2>
 800cdf8:	08014b24 	.word	0x08014b24
 800cdfc:	08014b28 	.word	0x08014b28
 800ce00:	08014968 	.word	0x08014968

0800ce04 <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported).
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters (void)
{
 800ce04:	b530      	push	{r4, r5, lr}
    // Report in terms of machine position.
    float print_position[N_AXIS];
    system_convert_array_steps_to_mpos(print_position, sys_probe_position);
    hal.stream.write("[PRB:");
 800ce06:	4c0f      	ldr	r4, [pc, #60]	; (800ce44 <report_probe_parameters+0x40>)
{
 800ce08:	b085      	sub	sp, #20
    system_convert_array_steps_to_mpos(print_position, sys_probe_position);
 800ce0a:	490f      	ldr	r1, [pc, #60]	; (800ce48 <report_probe_parameters+0x44>)
 800ce0c:	a801      	add	r0, sp, #4
 800ce0e:	f004 fc8b 	bl	8011728 <system_convert_array_steps_to_mpos>
    hal.stream.write("[PRB:");
 800ce12:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ce14:	480d      	ldr	r0, [pc, #52]	; (800ce4c <report_probe_parameters+0x48>)
 800ce16:	4798      	blx	r3
    hal.stream.write(get_axis_values(print_position));
 800ce18:	4b0d      	ldr	r3, [pc, #52]	; (800ce50 <report_probe_parameters+0x4c>)
 800ce1a:	a801      	add	r0, sp, #4
 800ce1c:	681b      	ldr	r3, [r3, #0]
 800ce1e:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800ce20:	4798      	blx	r3
 800ce22:	47a8      	blx	r5
    hal.stream.write(sys.flags.probe_succeeded ? ":1" : ":0");
 800ce24:	4b0b      	ldr	r3, [pc, #44]	; (800ce54 <report_probe_parameters+0x50>)
 800ce26:	480c      	ldr	r0, [pc, #48]	; (800ce58 <report_probe_parameters+0x54>)
 800ce28:	7a5a      	ldrb	r2, [r3, #9]
 800ce2a:	4b0c      	ldr	r3, [pc, #48]	; (800ce5c <report_probe_parameters+0x58>)
 800ce2c:	f012 0f02 	tst.w	r2, #2
 800ce30:	bf08      	it	eq
 800ce32:	4618      	moveq	r0, r3
 800ce34:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ce36:	4798      	blx	r3
    hal.stream.write("]\r\n");
 800ce38:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ce3a:	4809      	ldr	r0, [pc, #36]	; (800ce60 <report_probe_parameters+0x5c>)
 800ce3c:	4798      	blx	r3
}
 800ce3e:	b005      	add	sp, #20
 800ce40:	bd30      	pop	{r4, r5, pc}
 800ce42:	bf00      	nop
 800ce44:	200024bc 	.word	0x200024bc
 800ce48:	20002604 	.word	0x20002604
 800ce4c:	08014b2c 	.word	0x08014b2c
 800ce50:	20001a98 	.word	0x20001a98
 800ce54:	20002494 	.word	0x20002494
 800ce58:	08014ce8 	.word	0x08014ce8
 800ce5c:	08014cf0 	.word	0x08014cf0
 800ce60:	08014ad0 	.word	0x08014ad0

0800ce64 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing, tool table)
void report_ngc_parameters (void)
{
 800ce64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint_fast8_t idx;
    float coord_data[N_AXIS];

    if(gc_state.modal.scaling_active) {
 800ce68:	4b4a      	ldr	r3, [pc, #296]	; (800cf94 <report_ngc_parameters+0x130>)
        hal.stream.write("[G51:");
 800ce6a:	4c4b      	ldr	r4, [pc, #300]	; (800cf98 <report_ngc_parameters+0x134>)
    if(gc_state.modal.scaling_active) {
 800ce6c:	7f9b      	ldrb	r3, [r3, #30]
{
 800ce6e:	b085      	sub	sp, #20
    if(gc_state.modal.scaling_active) {
 800ce70:	b163      	cbz	r3, 800ce8c <report_ngc_parameters+0x28>
        hal.stream.write("[G51:");
 800ce72:	484a      	ldr	r0, [pc, #296]	; (800cf9c <report_ngc_parameters+0x138>)
 800ce74:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ce76:	4798      	blx	r3
        hal.stream.write(get_axis_values(gc_get_scaling()));
 800ce78:	4b49      	ldr	r3, [pc, #292]	; (800cfa0 <report_ngc_parameters+0x13c>)
 800ce7a:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800ce7c:	681e      	ldr	r6, [r3, #0]
 800ce7e:	f7f8 fb23 	bl	80054c8 <gc_get_scaling>
 800ce82:	47b0      	blx	r6
 800ce84:	47a8      	blx	r5
        hal.stream.write("]\r\n");
 800ce86:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ce88:	4846      	ldr	r0, [pc, #280]	; (800cfa4 <report_ngc_parameters+0x140>)
 800ce8a:	4798      	blx	r3
{
 800ce8c:	2500      	movs	r5, #0
        if (!(settings_read_coord_data(idx, &coord_data))) {
            hal.report.status_message(Status_SettingReadFail);
            return;
        }

        hal.stream.write("[G");
 800ce8e:	f8df 8138 	ldr.w	r8, [pc, #312]	; 800cfc8 <report_ngc_parameters+0x164>

        switch (idx) {

            case SETTING_INDEX_G28:
                hal.stream.write("28");
 800ce92:	f8df a138 	ldr.w	sl, [pc, #312]	; 800cfcc <report_ngc_parameters+0x168>

            default: // G54-G59
                hal.stream.write(map_coord_system(idx));
                break;
        }
        hal.stream.write(":");
 800ce96:	f8df 9118 	ldr.w	r9, [pc, #280]	; 800cfb0 <report_ngc_parameters+0x14c>
 800ce9a:	e021      	b.n	800cee0 <report_ngc_parameters+0x7c>
                hal.stream.write(map_coord_system(idx));
 800ce9c:	3636      	adds	r6, #54	; 0x36
 800ce9e:	b2f6      	uxtb	r6, r6
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800cea0:	2e3b      	cmp	r6, #59	; 0x3b
 800cea2:	4630      	mov	r0, r6
 800cea4:	bf28      	it	cs
 800cea6:	203b      	movcs	r0, #59	; 0x3b
                hal.stream.write(map_coord_system(idx));
 800cea8:	f8d4 b064 	ldr.w	fp, [r4, #100]	; 0x64
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800ceac:	f7fd f8e2 	bl	800a074 <uitoa>
 800ceb0:	4601      	mov	r1, r0
 800ceb2:	483d      	ldr	r0, [pc, #244]	; (800cfa8 <report_ngc_parameters+0x144>)
 800ceb4:	f005 fa92 	bl	80123dc <stpcpy>
    if(g5x > 59) {
 800ceb8:	2e3b      	cmp	r6, #59	; 0x3b
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800ceba:	4603      	mov	r3, r0
        hal.stream.write(get_axis_values(coord_data));
 800cebc:	4f38      	ldr	r7, [pc, #224]	; (800cfa0 <report_ngc_parameters+0x13c>)
    if(g5x > 59) {
 800cebe:	d857      	bhi.n	800cf70 <report_ngc_parameters+0x10c>
                hal.stream.write(map_coord_system(idx));
 800cec0:	4839      	ldr	r0, [pc, #228]	; (800cfa8 <report_ngc_parameters+0x144>)
 800cec2:	47d8      	blx	fp
        hal.stream.write(":");
 800cec4:	4648      	mov	r0, r9
 800cec6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cec8:	4798      	blx	r3
        hal.stream.write(get_axis_values(coord_data));
 800ceca:	683b      	ldr	r3, [r7, #0]
 800cecc:	a801      	add	r0, sp, #4
 800cece:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800ced0:	4798      	blx	r3
 800ced2:	47b0      	blx	r6
        hal.stream.write("]\r\n");
 800ced4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800ced6:	4833      	ldr	r0, [pc, #204]	; (800cfa4 <report_ngc_parameters+0x140>)
 800ced8:	4798      	blx	r3
    for (idx = 0; idx < SETTING_INDEX_NCOORD; idx++) {
 800ceda:	2d0a      	cmp	r5, #10
 800cedc:	d01d      	beq.n	800cf1a <report_ngc_parameters+0xb6>
 800cede:	3501      	adds	r5, #1
        if (!(settings_read_coord_data(idx, &coord_data))) {
 800cee0:	b2ee      	uxtb	r6, r5
 800cee2:	4630      	mov	r0, r6
 800cee4:	a901      	add	r1, sp, #4
 800cee6:	f001 f923 	bl	800e130 <settings_read_coord_data>
 800ceea:	2800      	cmp	r0, #0
 800ceec:	d04b      	beq.n	800cf86 <report_ngc_parameters+0x122>
        hal.stream.write("[G");
 800ceee:	4640      	mov	r0, r8
 800cef0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cef2:	4798      	blx	r3
        switch (idx) {
 800cef4:	2d09      	cmp	r5, #9
 800cef6:	d02b      	beq.n	800cf50 <report_ngc_parameters+0xec>
 800cef8:	2d0a      	cmp	r5, #10
 800cefa:	d1cf      	bne.n	800ce9c <report_ngc_parameters+0x38>
                hal.stream.write("30");
 800cefc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cefe:	482b      	ldr	r0, [pc, #172]	; (800cfac <report_ngc_parameters+0x148>)
        hal.stream.write(get_axis_values(coord_data));
 800cf00:	4f27      	ldr	r7, [pc, #156]	; (800cfa0 <report_ngc_parameters+0x13c>)
                hal.stream.write("30");
 800cf02:	4798      	blx	r3
        hal.stream.write(":");
 800cf04:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf06:	482a      	ldr	r0, [pc, #168]	; (800cfb0 <report_ngc_parameters+0x14c>)
 800cf08:	4798      	blx	r3
        hal.stream.write(get_axis_values(coord_data));
 800cf0a:	683b      	ldr	r3, [r7, #0]
 800cf0c:	a801      	add	r0, sp, #4
 800cf0e:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800cf10:	4798      	blx	r3
 800cf12:	47a8      	blx	r5
        hal.stream.write("]\r\n");
 800cf14:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf16:	4823      	ldr	r0, [pc, #140]	; (800cfa4 <report_ngc_parameters+0x140>)
 800cf18:	4798      	blx	r3
    }

    // Print G92,G92.1 which are not persistent in memory
    hal.stream.write("[G92:");
 800cf1a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf1c:	4825      	ldr	r0, [pc, #148]	; (800cfb4 <report_ngc_parameters+0x150>)
 800cf1e:	4798      	blx	r3
    hal.stream.write(get_axis_values(gc_state.g92_coord_offset));
 800cf20:	683b      	ldr	r3, [r7, #0]
 800cf22:	4825      	ldr	r0, [pc, #148]	; (800cfb8 <report_ngc_parameters+0x154>)
 800cf24:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800cf26:	4798      	blx	r3
 800cf28:	47a8      	blx	r5
    hal.stream.write("]\r\n");
 800cf2a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf2c:	481d      	ldr	r0, [pc, #116]	; (800cfa4 <report_ngc_parameters+0x140>)
 800cf2e:	4798      	blx	r3
            hal.stream.write(ftoa(tool_table[idx].radius, N_DECIMAL_COORDVALUE_MM));
        hal.stream.write("]\r\n");
    }
#endif
    // Print tool length offset value
    hal.stream.write("[TLO:");
 800cf30:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf32:	4822      	ldr	r0, [pc, #136]	; (800cfbc <report_ngc_parameters+0x158>)
 800cf34:	4798      	blx	r3
    hal.stream.write(get_axis_values(gc_state.tool_length_offset));
 800cf36:	683b      	ldr	r3, [r7, #0]
 800cf38:	4821      	ldr	r0, [pc, #132]	; (800cfc0 <report_ngc_parameters+0x15c>)
 800cf3a:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800cf3c:	4798      	blx	r3
 800cf3e:	47a8      	blx	r5
    hal.stream.write("]\r\n");
 800cf40:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf42:	4818      	ldr	r0, [pc, #96]	; (800cfa4 <report_ngc_parameters+0x140>)
 800cf44:	4798      	blx	r3

    report_probe_parameters(); // Print probe parameters. Not persistent in memory.
 800cf46:	f7ff ff5d 	bl	800ce04 <report_probe_parameters>
}
 800cf4a:	b005      	add	sp, #20
 800cf4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                hal.stream.write("28");
 800cf50:	4650      	mov	r0, sl
 800cf52:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf54:	4798      	blx	r3
        hal.stream.write(":");
 800cf56:	4648      	mov	r0, r9
 800cf58:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf5a:	4798      	blx	r3
        hal.stream.write(get_axis_values(coord_data));
 800cf5c:	4b10      	ldr	r3, [pc, #64]	; (800cfa0 <report_ngc_parameters+0x13c>)
 800cf5e:	a801      	add	r0, sp, #4
 800cf60:	681b      	ldr	r3, [r3, #0]
 800cf62:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cf64:	4798      	blx	r3
 800cf66:	47b0      	blx	r6
        hal.stream.write("]\r\n");
 800cf68:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cf6a:	480e      	ldr	r0, [pc, #56]	; (800cfa4 <report_ngc_parameters+0x140>)
 800cf6c:	4798      	blx	r3
    for (idx = 0; idx < SETTING_INDEX_NCOORD; idx++) {
 800cf6e:	e7b6      	b.n	800cede <report_ngc_parameters+0x7a>
        strcat(buf, ".");
 800cf70:	4a14      	ldr	r2, [pc, #80]	; (800cfc4 <report_ngc_parameters+0x160>)
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800cf72:	1f68      	subs	r0, r5, #5
        strcat(buf, ".");
 800cf74:	8812      	ldrh	r2, [r2, #0]
 800cf76:	801a      	strh	r2, [r3, #0]
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800cf78:	f7fd f87c 	bl	800a074 <uitoa>
 800cf7c:	4601      	mov	r1, r0
 800cf7e:	480a      	ldr	r0, [pc, #40]	; (800cfa8 <report_ngc_parameters+0x144>)
 800cf80:	f005 fa35 	bl	80123ee <strcat>
 800cf84:	e79c      	b.n	800cec0 <report_ngc_parameters+0x5c>
            hal.report.status_message(Status_SettingReadFail);
 800cf86:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 800cf8a:	2007      	movs	r0, #7
 800cf8c:	4798      	blx	r3
}
 800cf8e:	b005      	add	sp, #20
 800cf90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cf94:	200023dc 	.word	0x200023dc
 800cf98:	200024bc 	.word	0x200024bc
 800cf9c:	08014b34 	.word	0x08014b34
 800cfa0:	20001a98 	.word	0x20001a98
 800cfa4:	08014ad0 	.word	0x08014ad0
 800cfa8:	20001a68 	.word	0x20001a68
 800cfac:	08014b44 	.word	0x08014b44
 800cfb0:	08014b38 	.word	0x08014b38
 800cfb4:	08014b4c 	.word	0x08014b4c
 800cfb8:	20002460 	.word	0x20002460
 800cfbc:	08014b54 	.word	0x08014b54
 800cfc0:	2000246c 	.word	0x2000246c
 800cfc4:	08014b48 	.word	0x08014b48
 800cfc8:	08014b3c 	.word	0x08014b3c
 800cfcc:	08014b40 	.word	0x08014b40

0800cfd0 <report_gcode_modes>:

// Print current gcode parser mode state
void report_gcode_modes (void)
{
 800cfd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    hal.stream.write("[GC:G");
 800cfd4:	4c9d      	ldr	r4, [pc, #628]	; (800d24c <report_gcode_modes+0x27c>)
    if (gc_state.modal.motion >= MotionMode_ProbeToward) {
 800cfd6:	4d9e      	ldr	r5, [pc, #632]	; (800d250 <report_gcode_modes+0x280>)
    hal.stream.write("[GC:G");
 800cfd8:	489e      	ldr	r0, [pc, #632]	; (800d254 <report_gcode_modes+0x284>)
 800cfda:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cfdc:	4798      	blx	r3
    if (gc_state.modal.motion >= MotionMode_ProbeToward) {
 800cfde:	7828      	ldrb	r0, [r5, #0]
 800cfe0:	288b      	cmp	r0, #139	; 0x8b
 800cfe2:	f240 81c6 	bls.w	800d372 <report_gcode_modes+0x3a2>
        hal.stream.write("38.");
 800cfe6:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cfe8:	489b      	ldr	r0, [pc, #620]	; (800d258 <report_gcode_modes+0x288>)
 800cfea:	4798      	blx	r3
        hal.stream.write(uitoa((uint32_t)(gc_state.modal.motion - (MotionMode_ProbeToward - 2))));
 800cfec:	7828      	ldrb	r0, [r5, #0]
 800cfee:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800cff0:	388a      	subs	r0, #138	; 0x8a
 800cff2:	f7fd f83f 	bl	800a074 <uitoa>
 800cff6:	47b0      	blx	r6
    } else
        hal.stream.write(uitoa((uint32_t)gc_state.modal.motion));

    hal.stream.write(" G");
 800cff8:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800cffa:	4898      	ldr	r0, [pc, #608]	; (800d25c <report_gcode_modes+0x28c>)
 800cffc:	4798      	blx	r3
    uint8_t g5x = idx + 54;
 800cffe:	7d2e      	ldrb	r6, [r5, #20]
    hal.stream.write(map_coord_system(gc_state.modal.coord_system.idx));
 800d000:	6e67      	ldr	r7, [r4, #100]	; 0x64
    uint8_t g5x = idx + 54;
 800d002:	3636      	adds	r6, #54	; 0x36
 800d004:	b2f6      	uxtb	r6, r6
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800d006:	2e3b      	cmp	r6, #59	; 0x3b
 800d008:	4630      	mov	r0, r6
 800d00a:	bf28      	it	cs
 800d00c:	203b      	movcs	r0, #59	; 0x3b
 800d00e:	f7fd f831 	bl	800a074 <uitoa>
 800d012:	f8df 8250 	ldr.w	r8, [pc, #592]	; 800d264 <report_gcode_modes+0x294>
 800d016:	4601      	mov	r1, r0
 800d018:	4640      	mov	r0, r8
 800d01a:	f005 f9df 	bl	80123dc <stpcpy>
    if(g5x > 59) {
 800d01e:	2e3b      	cmp	r6, #59	; 0x3b
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800d020:	4603      	mov	r3, r0
    if(g5x > 59) {
 800d022:	f200 819a 	bhi.w	800d35a <report_gcode_modes+0x38a>

    if(settings.flags.lathe_mode)
 800d026:	4e8e      	ldr	r6, [pc, #568]	; (800d260 <report_gcode_modes+0x290>)
    hal.stream.write(map_coord_system(gc_state.modal.coord_system.idx));
 800d028:	488e      	ldr	r0, [pc, #568]	; (800d264 <report_gcode_modes+0x294>)
 800d02a:	47b8      	blx	r7
    if(settings.flags.lathe_mode)
 800d02c:	f996 30bd 	ldrsb.w	r3, [r6, #189]	; 0xbd
 800d030:	2b00      	cmp	r3, #0
 800d032:	da08      	bge.n	800d046 <report_gcode_modes+0x76>
        hal.stream.write(gc_state.modal.diameter_mode ? " G7" : " G8");
 800d034:	7928      	ldrb	r0, [r5, #4]
 800d036:	498c      	ldr	r1, [pc, #560]	; (800d268 <report_gcode_modes+0x298>)
 800d038:	4a8c      	ldr	r2, [pc, #560]	; (800d26c <report_gcode_modes+0x29c>)
 800d03a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d03c:	2800      	cmp	r0, #0
 800d03e:	bf14      	ite	ne
 800d040:	4608      	movne	r0, r1
 800d042:	4610      	moveq	r0, r2
 800d044:	4798      	blx	r3

    hal.stream.write(" G");
 800d046:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d048:	4884      	ldr	r0, [pc, #528]	; (800d25c <report_gcode_modes+0x28c>)
 800d04a:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(gc_state.modal.plane_select + 17)));
 800d04c:	7968      	ldrb	r0, [r5, #5]
 800d04e:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800d050:	3011      	adds	r0, #17
 800d052:	f7fd f80f 	bl	800a074 <uitoa>
 800d056:	47b8      	blx	r7

    hal.stream.write(gc_state.modal.units_imperial ? " G20" : " G21");
 800d058:	4985      	ldr	r1, [pc, #532]	; (800d270 <report_gcode_modes+0x2a0>)
 800d05a:	4a86      	ldr	r2, [pc, #536]	; (800d274 <report_gcode_modes+0x2a4>)
 800d05c:	78a8      	ldrb	r0, [r5, #2]
 800d05e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d060:	2800      	cmp	r0, #0
 800d062:	bf14      	ite	ne
 800d064:	4608      	movne	r0, r1
 800d066:	4610      	moveq	r0, r2
 800d068:	4798      	blx	r3

    hal.stream.write(gc_state.modal.distance_incremental ? " G91" : " G90");
 800d06a:	4983      	ldr	r1, [pc, #524]	; (800d278 <report_gcode_modes+0x2a8>)
 800d06c:	4a83      	ldr	r2, [pc, #524]	; (800d27c <report_gcode_modes+0x2ac>)
 800d06e:	78e8      	ldrb	r0, [r5, #3]
 800d070:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d072:	2800      	cmp	r0, #0
 800d074:	bf14      	ite	ne
 800d076:	4608      	movne	r0, r1
 800d078:	4610      	moveq	r0, r2
 800d07a:	4798      	blx	r3

    hal.stream.write(" G");
 800d07c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d07e:	4877      	ldr	r0, [pc, #476]	; (800d25c <report_gcode_modes+0x28c>)
 800d080:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)(94 - gc_state.modal.feed_mode)));
 800d082:	7868      	ldrb	r0, [r5, #1]
 800d084:	6e67      	ldr	r7, [r4, #100]	; 0x64
 800d086:	f1c0 005e 	rsb	r0, r0, #94	; 0x5e
 800d08a:	f7fc fff3 	bl	800a074 <uitoa>
 800d08e:	47b8      	blx	r7

    if(settings.flags.lathe_mode && hal.driver_cap.variable_spindle)
 800d090:	f996 30bd 	ldrsb.w	r3, [r6, #189]	; 0xbd
 800d094:	2b00      	cmp	r3, #0
 800d096:	f2c0 8123 	blt.w	800d2e0 <report_gcode_modes+0x310>
        hal.stream.write(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_RPM ? " G97" : " G96");

#if COMPATIBILITY_LEVEL < 10

    if(gc_state.modal.tool_offset_mode == ToolLengthOffset_Cancel)
 800d09a:	79ab      	ldrb	r3, [r5, #6]
 800d09c:	2b00      	cmp	r3, #0
 800d09e:	f040 80bd 	bne.w	800d21c <report_gcode_modes+0x24c>
        hal.stream.write(" G49");
 800d0a2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d0a4:	4876      	ldr	r0, [pc, #472]	; (800d280 <report_gcode_modes+0x2b0>)
 800d0a6:	4798      	blx	r3
        hal.stream.write(" G43");
        if(gc_state.modal.tool_offset_mode != ToolLengthOffset_Enable)
            hal.stream.write(gc_state.modal.tool_offset_mode == ToolLengthOffset_EnableDynamic ? ".1" : ".2");
    }

    hal.stream.write(gc_state.canned.retract_mode == CCRetractMode_RPos ? " G99" : " G98");
 800d0a8:	4976      	ldr	r1, [pc, #472]	; (800d284 <report_gcode_modes+0x2b4>)
 800d0aa:	4a77      	ldr	r2, [pc, #476]	; (800d288 <report_gcode_modes+0x2b8>)
 800d0ac:	f895 0046 	ldrb.w	r0, [r5, #70]	; 0x46
 800d0b0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d0b2:	2801      	cmp	r0, #1
 800d0b4:	bf0c      	ite	eq
 800d0b6:	4608      	moveq	r0, r1
 800d0b8:	4610      	movne	r0, r2
 800d0ba:	4798      	blx	r3

    hal.stream.write(gc_state.modal.scaling_active ? " G51" : " G50");
 800d0bc:	7fa8      	ldrb	r0, [r5, #30]
 800d0be:	4973      	ldr	r1, [pc, #460]	; (800d28c <report_gcode_modes+0x2bc>)
 800d0c0:	4a73      	ldr	r2, [pc, #460]	; (800d290 <report_gcode_modes+0x2c0>)
 800d0c2:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d0c4:	2800      	cmp	r0, #0
 800d0c6:	bf14      	ite	ne
 800d0c8:	4608      	movne	r0, r1
 800d0ca:	4610      	moveq	r0, r2
 800d0cc:	4798      	blx	r3

    if(gc_state.modal.scaling_active) {
 800d0ce:	7fab      	ldrb	r3, [r5, #30]
 800d0d0:	2b00      	cmp	r3, #0
 800d0d2:	f040 8124 	bne.w	800d31e <report_gcode_modes+0x34e>
        hal.stream.write(buf);
    }

#endif

    if (gc_state.modal.program_flow) {
 800d0d6:	7e2b      	ldrb	r3, [r5, #24]
 800d0d8:	2b00      	cmp	r3, #0
 800d0da:	d15b      	bne.n	800d194 <report_gcode_modes+0x1c4>
            default:
                break;
        }
    }

    hal.stream.write(gc_state.modal.spindle.on ? (gc_state.modal.spindle.ccw ? " M4" : " M3") : " M5");
 800d0dc:	7eab      	ldrb	r3, [r5, #26]
 800d0de:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800d0e0:	07d9      	lsls	r1, r3, #31
 800d0e2:	f140 8099 	bpl.w	800d218 <report_gcode_modes+0x248>
 800d0e6:	496b      	ldr	r1, [pc, #428]	; (800d294 <report_gcode_modes+0x2c4>)
 800d0e8:	f013 0f02 	tst.w	r3, #2
 800d0ec:	486a      	ldr	r0, [pc, #424]	; (800d298 <report_gcode_modes+0x2c8>)
 800d0ee:	bf08      	it	eq
 800d0f0:	4608      	moveq	r0, r1
 800d0f2:	4790      	blx	r2

    if(gc_state.tool_change)
 800d0f4:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
 800d0f8:	b113      	cbz	r3, 800d100 <report_gcode_modes+0x130>
        hal.stream.write(" M6");
 800d0fa:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d0fc:	4867      	ldr	r0, [pc, #412]	; (800d29c <report_gcode_modes+0x2cc>)
 800d0fe:	4798      	blx	r3

    if (gc_state.modal.coolant.value) {
 800d100:	7e6b      	ldrb	r3, [r5, #25]
 800d102:	2b00      	cmp	r3, #0
 800d104:	f000 809e 	beq.w	800d244 <report_gcode_modes+0x274>

        if (gc_state.modal.coolant.mist)
 800d108:	079f      	lsls	r7, r3, #30
 800d10a:	f100 8096 	bmi.w	800d23a <report_gcode_modes+0x26a>
             hal.stream.write(" M7");

        if (gc_state.modal.coolant.flood)
 800d10e:	07d8      	lsls	r0, r3, #31
 800d110:	d502      	bpl.n	800d118 <report_gcode_modes+0x148>
            hal.stream.write(" M8");
 800d112:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d114:	4862      	ldr	r0, [pc, #392]	; (800d2a0 <report_gcode_modes+0x2d0>)
 800d116:	4798      	blx	r3

    } else
        hal.stream.write(" M9");

    if (sys.override.control.feed_rate_disable)
 800d118:	4f62      	ldr	r7, [pc, #392]	; (800d2a4 <report_gcode_modes+0x2d4>)
 800d11a:	7cbb      	ldrb	r3, [r7, #18]
 800d11c:	07d9      	lsls	r1, r3, #31
 800d11e:	d503      	bpl.n	800d128 <report_gcode_modes+0x158>
        hal.stream.write(" M50");
 800d120:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d122:	4861      	ldr	r0, [pc, #388]	; (800d2a8 <report_gcode_modes+0x2d8>)
 800d124:	4798      	blx	r3
 800d126:	7cbb      	ldrb	r3, [r7, #18]

    if (sys.override.control.spindle_rpm_disable)
 800d128:	075a      	lsls	r2, r3, #29
 800d12a:	d503      	bpl.n	800d134 <report_gcode_modes+0x164>
        hal.stream.write(" M51");
 800d12c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d12e:	485f      	ldr	r0, [pc, #380]	; (800d2ac <report_gcode_modes+0x2dc>)
 800d130:	4798      	blx	r3
 800d132:	7cbb      	ldrb	r3, [r7, #18]

    if (sys.override.control.feed_hold_disable)
 800d134:	0798      	lsls	r0, r3, #30
 800d136:	d502      	bpl.n	800d13e <report_gcode_modes+0x16e>
        hal.stream.write(" M53");
 800d138:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d13a:	485d      	ldr	r0, [pc, #372]	; (800d2b0 <report_gcode_modes+0x2e0>)
 800d13c:	4798      	blx	r3

    if (settings.parking.flags.enable_override_control && sys.override.control.parking_disable)
 800d13e:	f896 30d8 	ldrb.w	r3, [r6, #216]	; 0xd8
 800d142:	0759      	lsls	r1, r3, #29
 800d144:	d505      	bpl.n	800d152 <report_gcode_modes+0x182>
 800d146:	7cbb      	ldrb	r3, [r7, #18]
 800d148:	071a      	lsls	r2, r3, #28
 800d14a:	d502      	bpl.n	800d152 <report_gcode_modes+0x182>
        hal.stream.write(" M56");
 800d14c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d14e:	4859      	ldr	r0, [pc, #356]	; (800d2b4 <report_gcode_modes+0x2e4>)
 800d150:	4798      	blx	r3

    hal.stream.write(appendbuf(2, " T", uitoa((uint32_t)gc_state.tool->tool)));
 800d152:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
 800d156:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800d158:	7c18      	ldrb	r0, [r3, #16]
 800d15a:	f7fc ff8b 	bl	800a074 <uitoa>
 800d15e:	4956      	ldr	r1, [pc, #344]	; (800d2b8 <report_gcode_modes+0x2e8>)
 800d160:	4602      	mov	r2, r0
 800d162:	2002      	movs	r0, #2
 800d164:	f7fe fefa 	bl	800bf5c <appendbuf.constprop.1>
 800d168:	47b0      	blx	r6

    hal.stream.write(appendbuf(2, " F", get_rate_value(gc_state.feed_rate)));
 800d16a:	4b54      	ldr	r3, [pc, #336]	; (800d2bc <report_gcode_modes+0x2ec>)
 800d16c:	6e68      	ldr	r0, [r5, #100]	; 0x64
 800d16e:	681b      	ldr	r3, [r3, #0]
 800d170:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800d172:	4798      	blx	r3
 800d174:	4952      	ldr	r1, [pc, #328]	; (800d2c0 <report_gcode_modes+0x2f0>)
 800d176:	4602      	mov	r2, r0
 800d178:	2002      	movs	r0, #2
 800d17a:	f7fe feef 	bl	800bf5c <appendbuf.constprop.1>
 800d17e:	47b0      	blx	r6

    if(hal.driver_cap.variable_spindle)
 800d180:	f894 3144 	ldrb.w	r3, [r4, #324]	; 0x144
 800d184:	079b      	lsls	r3, r3, #30
 800d186:	f100 80ba 	bmi.w	800d2fe <report_gcode_modes+0x32e>
        hal.stream.write(appendbuf(2, " S", ftoa(gc_state.spindle.rpm, N_DECIMAL_RPMVALUE)));

    hal.stream.write("]\r\n");
 800d18a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d18c:	484d      	ldr	r0, [pc, #308]	; (800d2c4 <report_gcode_modes+0x2f4>)
}
 800d18e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    hal.stream.write("]\r\n");
 800d192:	4718      	bx	r3
        switch (gc_state.modal.program_flow) {
 800d194:	3b01      	subs	r3, #1
 800d196:	2b1d      	cmp	r3, #29
 800d198:	d8a0      	bhi.n	800d0dc <report_gcode_modes+0x10c>
 800d19a:	a201      	add	r2, pc, #4	; (adr r2, 800d1a0 <report_gcode_modes+0x1d0>)
 800d19c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d1a0:	0800d385 	.word	0x0800d385
 800d1a4:	0800d38d 	.word	0x0800d38d
 800d1a8:	0800d395 	.word	0x0800d395
 800d1ac:	0800d0dd 	.word	0x0800d0dd
 800d1b0:	0800d0dd 	.word	0x0800d0dd
 800d1b4:	0800d0dd 	.word	0x0800d0dd
 800d1b8:	0800d0dd 	.word	0x0800d0dd
 800d1bc:	0800d0dd 	.word	0x0800d0dd
 800d1c0:	0800d0dd 	.word	0x0800d0dd
 800d1c4:	0800d0dd 	.word	0x0800d0dd
 800d1c8:	0800d0dd 	.word	0x0800d0dd
 800d1cc:	0800d0dd 	.word	0x0800d0dd
 800d1d0:	0800d0dd 	.word	0x0800d0dd
 800d1d4:	0800d0dd 	.word	0x0800d0dd
 800d1d8:	0800d0dd 	.word	0x0800d0dd
 800d1dc:	0800d0dd 	.word	0x0800d0dd
 800d1e0:	0800d0dd 	.word	0x0800d0dd
 800d1e4:	0800d0dd 	.word	0x0800d0dd
 800d1e8:	0800d0dd 	.word	0x0800d0dd
 800d1ec:	0800d0dd 	.word	0x0800d0dd
 800d1f0:	0800d0dd 	.word	0x0800d0dd
 800d1f4:	0800d0dd 	.word	0x0800d0dd
 800d1f8:	0800d0dd 	.word	0x0800d0dd
 800d1fc:	0800d0dd 	.word	0x0800d0dd
 800d200:	0800d0dd 	.word	0x0800d0dd
 800d204:	0800d0dd 	.word	0x0800d0dd
 800d208:	0800d0dd 	.word	0x0800d0dd
 800d20c:	0800d0dd 	.word	0x0800d0dd
 800d210:	0800d0dd 	.word	0x0800d0dd
 800d214:	0800d37d 	.word	0x0800d37d
    hal.stream.write(gc_state.modal.spindle.on ? (gc_state.modal.spindle.ccw ? " M4" : " M3") : " M5");
 800d218:	482b      	ldr	r0, [pc, #172]	; (800d2c8 <report_gcode_modes+0x2f8>)
 800d21a:	e76a      	b.n	800d0f2 <report_gcode_modes+0x122>
        hal.stream.write(" G43");
 800d21c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d21e:	482b      	ldr	r0, [pc, #172]	; (800d2cc <report_gcode_modes+0x2fc>)
 800d220:	4798      	blx	r3
        if(gc_state.modal.tool_offset_mode != ToolLengthOffset_Enable)
 800d222:	79ab      	ldrb	r3, [r5, #6]
 800d224:	2b01      	cmp	r3, #1
 800d226:	f43f af3f 	beq.w	800d0a8 <report_gcode_modes+0xd8>
            hal.stream.write(gc_state.modal.tool_offset_mode == ToolLengthOffset_EnableDynamic ? ".1" : ".2");
 800d22a:	4929      	ldr	r1, [pc, #164]	; (800d2d0 <report_gcode_modes+0x300>)
 800d22c:	4829      	ldr	r0, [pc, #164]	; (800d2d4 <report_gcode_modes+0x304>)
 800d22e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800d230:	2b02      	cmp	r3, #2
 800d232:	bf18      	it	ne
 800d234:	4608      	movne	r0, r1
 800d236:	4790      	blx	r2
 800d238:	e736      	b.n	800d0a8 <report_gcode_modes+0xd8>
             hal.stream.write(" M7");
 800d23a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d23c:	4826      	ldr	r0, [pc, #152]	; (800d2d8 <report_gcode_modes+0x308>)
 800d23e:	4798      	blx	r3
 800d240:	7e6b      	ldrb	r3, [r5, #25]
 800d242:	e764      	b.n	800d10e <report_gcode_modes+0x13e>
        hal.stream.write(" M9");
 800d244:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d246:	4825      	ldr	r0, [pc, #148]	; (800d2dc <report_gcode_modes+0x30c>)
 800d248:	4798      	blx	r3
 800d24a:	e765      	b.n	800d118 <report_gcode_modes+0x148>
 800d24c:	200024bc 	.word	0x200024bc
 800d250:	200023dc 	.word	0x200023dc
 800d254:	08014bc8 	.word	0x08014bc8
 800d258:	08014bd0 	.word	0x08014bd0
 800d25c:	08014bd4 	.word	0x08014bd4
 800d260:	20002620 	.word	0x20002620
 800d264:	20001a68 	.word	0x20001a68
 800d268:	08014b5c 	.word	0x08014b5c
 800d26c:	08014b60 	.word	0x08014b60
 800d270:	08014b64 	.word	0x08014b64
 800d274:	08014b6c 	.word	0x08014b6c
 800d278:	08014b74 	.word	0x08014b74
 800d27c:	08014b7c 	.word	0x08014b7c
 800d280:	08014bd8 	.word	0x08014bd8
 800d284:	08014b9c 	.word	0x08014b9c
 800d288:	08014ba4 	.word	0x08014ba4
 800d28c:	08014bac 	.word	0x08014bac
 800d290:	08014bb4 	.word	0x08014bb4
 800d294:	08014bc4 	.word	0x08014bc4
 800d298:	08014bc0 	.word	0x08014bc0
 800d29c:	08014bfc 	.word	0x08014bfc
 800d2a0:	08014c04 	.word	0x08014c04
 800d2a4:	20002494 	.word	0x20002494
 800d2a8:	08014c0c 	.word	0x08014c0c
 800d2ac:	08014c14 	.word	0x08014c14
 800d2b0:	08014c1c 	.word	0x08014c1c
 800d2b4:	08014c24 	.word	0x08014c24
 800d2b8:	08014c2c 	.word	0x08014c2c
 800d2bc:	20001a9c 	.word	0x20001a9c
 800d2c0:	08014c30 	.word	0x08014c30
 800d2c4:	08014ad0 	.word	0x08014ad0
 800d2c8:	08014bbc 	.word	0x08014bbc
 800d2cc:	08014be0 	.word	0x08014be0
 800d2d0:	08014b98 	.word	0x08014b98
 800d2d4:	08014b94 	.word	0x08014b94
 800d2d8:	08014c00 	.word	0x08014c00
 800d2dc:	08014c08 	.word	0x08014c08
    if(settings.flags.lathe_mode && hal.driver_cap.variable_spindle)
 800d2e0:	f894 3144 	ldrb.w	r3, [r4, #324]	; 0x144
 800d2e4:	079a      	lsls	r2, r3, #30
 800d2e6:	f57f aed8 	bpl.w	800d09a <report_gcode_modes+0xca>
        hal.stream.write(gc_state.modal.spindle_rpm_mode == SpindleSpeedMode_RPM ? " G97" : " G96");
 800d2ea:	7f28      	ldrb	r0, [r5, #28]
 800d2ec:	492b      	ldr	r1, [pc, #172]	; (800d39c <report_gcode_modes+0x3cc>)
 800d2ee:	4a2c      	ldr	r2, [pc, #176]	; (800d3a0 <report_gcode_modes+0x3d0>)
 800d2f0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d2f2:	2800      	cmp	r0, #0
 800d2f4:	bf0c      	ite	eq
 800d2f6:	4608      	moveq	r0, r1
 800d2f8:	4610      	movne	r0, r2
 800d2fa:	4798      	blx	r3
 800d2fc:	e6cd      	b.n	800d09a <report_gcode_modes+0xca>
        hal.stream.write(appendbuf(2, " S", ftoa(gc_state.spindle.rpm, N_DECIMAL_RPMVALUE)));
 800d2fe:	2100      	movs	r1, #0
 800d300:	6ca8      	ldr	r0, [r5, #72]	; 0x48
 800d302:	6e65      	ldr	r5, [r4, #100]	; 0x64
 800d304:	f7fc fed8 	bl	800a0b8 <ftoa>
 800d308:	4926      	ldr	r1, [pc, #152]	; (800d3a4 <report_gcode_modes+0x3d4>)
 800d30a:	4602      	mov	r2, r0
 800d30c:	2002      	movs	r0, #2
 800d30e:	f7fe fe25 	bl	800bf5c <appendbuf.constprop.1>
 800d312:	47a8      	blx	r5
    hal.stream.write("]\r\n");
 800d314:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d316:	4824      	ldr	r0, [pc, #144]	; (800d3a8 <report_gcode_modes+0x3d8>)
}
 800d318:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    hal.stream.write("]\r\n");
 800d31c:	4718      	bx	r3
        axis_signals_tostring(buf, gc_get_g51_state());
 800d31e:	f7f8 f8d7 	bl	80054d0 <gc_get_g51_state>
    if(signals.x)
 800d322:	07c3      	lsls	r3, r0, #31
        *buf++ = 'X';
 800d324:	bf48      	it	mi
 800d326:	2358      	movmi	r3, #88	; 0x58
    if(signals.x)
 800d328:	b2c2      	uxtb	r2, r0
        *buf++ = 'X';
 800d32a:	bf4a      	itet	mi
 800d32c:	f888 3000 	strbmi.w	r3, [r8]
 800d330:	4b1e      	ldrpl	r3, [pc, #120]	; (800d3ac <report_gcode_modes+0x3dc>)
 800d332:	4b1f      	ldrmi	r3, [pc, #124]	; (800d3b0 <report_gcode_modes+0x3e0>)
    if(signals.y)
 800d334:	0797      	lsls	r7, r2, #30
        *buf++ = 'Y';
 800d336:	bf44      	itt	mi
 800d338:	2159      	movmi	r1, #89	; 0x59
 800d33a:	f803 1b01 	strbmi.w	r1, [r3], #1
    if (signals.z)
 800d33e:	0750      	lsls	r0, r2, #29
        *buf++ = 'Z';
 800d340:	bf44      	itt	mi
 800d342:	225a      	movmi	r2, #90	; 0x5a
 800d344:	f803 2b01 	strbmi.w	r2, [r3], #1
    *buf = '\0';
 800d348:	2200      	movs	r2, #0
        hal.stream.write(":");
 800d34a:	481a      	ldr	r0, [pc, #104]	; (800d3b4 <report_gcode_modes+0x3e4>)
    *buf = '\0';
 800d34c:	701a      	strb	r2, [r3, #0]
        hal.stream.write(":");
 800d34e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d350:	4798      	blx	r3
        hal.stream.write(buf);
 800d352:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d354:	4815      	ldr	r0, [pc, #84]	; (800d3ac <report_gcode_modes+0x3dc>)
 800d356:	4798      	blx	r3
 800d358:	e6bd      	b.n	800d0d6 <report_gcode_modes+0x106>
        strcat(buf, ".");
 800d35a:	4a17      	ldr	r2, [pc, #92]	; (800d3b8 <report_gcode_modes+0x3e8>)
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800d35c:	f1a6 003b 	sub.w	r0, r6, #59	; 0x3b
        strcat(buf, ".");
 800d360:	8812      	ldrh	r2, [r2, #0]
 800d362:	801a      	strh	r2, [r3, #0]
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800d364:	f7fc fe86 	bl	800a074 <uitoa>
 800d368:	4601      	mov	r1, r0
 800d36a:	4640      	mov	r0, r8
 800d36c:	f005 f83f 	bl	80123ee <strcat>
 800d370:	e659      	b.n	800d026 <report_gcode_modes+0x56>
        hal.stream.write(uitoa((uint32_t)gc_state.modal.motion));
 800d372:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800d374:	f7fc fe7e 	bl	800a074 <uitoa>
 800d378:	47b0      	blx	r6
 800d37a:	e63d      	b.n	800cff8 <report_gcode_modes+0x28>
                hal.stream.write(" M30");
 800d37c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d37e:	480f      	ldr	r0, [pc, #60]	; (800d3bc <report_gcode_modes+0x3ec>)
 800d380:	4798      	blx	r3
                break;
 800d382:	e6ab      	b.n	800d0dc <report_gcode_modes+0x10c>
                hal.stream.write(" M1");
 800d384:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d386:	480e      	ldr	r0, [pc, #56]	; (800d3c0 <report_gcode_modes+0x3f0>)
 800d388:	4798      	blx	r3
                break;
 800d38a:	e6a7      	b.n	800d0dc <report_gcode_modes+0x10c>
                hal.stream.write(" M2");
 800d38c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d38e:	480d      	ldr	r0, [pc, #52]	; (800d3c4 <report_gcode_modes+0x3f4>)
 800d390:	4798      	blx	r3
                break;
 800d392:	e6a3      	b.n	800d0dc <report_gcode_modes+0x10c>
                hal.stream.write(" M0");
 800d394:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d396:	480c      	ldr	r0, [pc, #48]	; (800d3c8 <report_gcode_modes+0x3f8>)
 800d398:	4798      	blx	r3
                break;
 800d39a:	e69f      	b.n	800d0dc <report_gcode_modes+0x10c>
 800d39c:	08014b84 	.word	0x08014b84
 800d3a0:	08014b8c 	.word	0x08014b8c
 800d3a4:	08014c34 	.word	0x08014c34
 800d3a8:	08014ad0 	.word	0x08014ad0
 800d3ac:	20001a68 	.word	0x20001a68
 800d3b0:	20001a69 	.word	0x20001a69
 800d3b4:	08014b38 	.word	0x08014b38
 800d3b8:	08014b48 	.word	0x08014b48
 800d3bc:	08014bf4 	.word	0x08014bf4
 800d3c0:	08014bec 	.word	0x08014bec
 800d3c4:	08014bf0 	.word	0x08014bf0
 800d3c8:	08014be8 	.word	0x08014be8

0800d3cc <report_startup_line>:

// Prints specified startup line
void report_startup_line (uint8_t n, char *line)
{
 800d3cc:	b570      	push	{r4, r5, r6, lr}
    hal.stream.write(appendbuf(3, "$N", uitoa((uint32_t)n), "="));
 800d3ce:	4c0a      	ldr	r4, [pc, #40]	; (800d3f8 <report_startup_line+0x2c>)
{
 800d3d0:	460d      	mov	r5, r1
    hal.stream.write(appendbuf(3, "$N", uitoa((uint32_t)n), "="));
 800d3d2:	6e66      	ldr	r6, [r4, #100]	; 0x64
 800d3d4:	f7fc fe4e 	bl	800a074 <uitoa>
 800d3d8:	4b08      	ldr	r3, [pc, #32]	; (800d3fc <report_startup_line+0x30>)
 800d3da:	4602      	mov	r2, r0
 800d3dc:	4908      	ldr	r1, [pc, #32]	; (800d400 <report_startup_line+0x34>)
 800d3de:	2003      	movs	r0, #3
 800d3e0:	f7fe fda0 	bl	800bf24 <appendbuf.constprop.0>
 800d3e4:	47b0      	blx	r6
    hal.stream.write(line);
 800d3e6:	4628      	mov	r0, r5
 800d3e8:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d3ea:	4798      	blx	r3
    hal.stream.write("\r\n");
 800d3ec:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d3ee:	4805      	ldr	r0, [pc, #20]	; (800d404 <report_startup_line+0x38>)
}
 800d3f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hal.stream.write("\r\n");
 800d3f4:	4718      	bx	r3
 800d3f6:	bf00      	nop
 800d3f8:	200024bc 	.word	0x200024bc
 800d3fc:	08014b24 	.word	0x08014b24
 800d400:	08014c38 	.word	0x08014c38
 800d404:	08014968 	.word	0x08014968

0800d408 <report_execute_startup_message>:

void report_execute_startup_message (char *line, status_code_t status_code)
{
 800d408:	b570      	push	{r4, r5, r6, lr}
 800d40a:	4606      	mov	r6, r0
 800d40c:	460d      	mov	r5, r1
    hal.stream.write(">");
 800d40e:	4c08      	ldr	r4, [pc, #32]	; (800d430 <report_execute_startup_message+0x28>)
 800d410:	4808      	ldr	r0, [pc, #32]	; (800d434 <report_execute_startup_message+0x2c>)
 800d412:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d414:	4798      	blx	r3
    hal.stream.write(line);
 800d416:	4630      	mov	r0, r6
 800d418:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d41a:	4798      	blx	r3
    hal.stream.write(":");
 800d41c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800d41e:	4806      	ldr	r0, [pc, #24]	; (800d438 <report_execute_startup_message+0x30>)
 800d420:	4798      	blx	r3
    hal.report.status_message(status_code);
 800d422:	4628      	mov	r0, r5
 800d424:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
}
 800d428:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    hal.report.status_message(status_code);
 800d42c:	4718      	bx	r3
 800d42e:	bf00      	nop
 800d430:	200024bc 	.word	0x200024bc
 800d434:	08014c3c 	.word	0x08014c3c
 800d438:	08014b38 	.word	0x08014b38

0800d43c <report_build_info>:

// Prints build info line
void report_build_info (char *line)
{
 800d43c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d440:	4604      	mov	r4, r0

    hal.stream.write("[VER:" GRBL_VERSION "(");
 800d442:	4d9e      	ldr	r5, [pc, #632]	; (800d6bc <report_build_info+0x280>)
 800d444:	489e      	ldr	r0, [pc, #632]	; (800d6c0 <report_build_info+0x284>)
 800d446:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d448:	4798      	blx	r3
    hal.stream.write(hal.info ? hal.info : "HAL");
 800d44a:	4a9e      	ldr	r2, [pc, #632]	; (800d6c4 <report_build_info+0x288>)
 800d44c:	6868      	ldr	r0, [r5, #4]
 800d44e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d450:	2800      	cmp	r0, #0
 800d452:	bf08      	it	eq
 800d454:	4610      	moveq	r0, r2
 800d456:	4798      	blx	r3
    hal.stream.write(")." GRBL_VERSION_BUILD ":");
 800d458:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d45a:	489b      	ldr	r0, [pc, #620]	; (800d6c8 <report_build_info+0x28c>)
 800d45c:	4798      	blx	r3
    hal.stream.write(line);
 800d45e:	4620      	mov	r0, r4
 800d460:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d462:	4798      	blx	r3
    hal.stream.write("]\r\n");
 800d464:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d466:	4899      	ldr	r0, [pc, #612]	; (800d6cc <report_build_info+0x290>)
 800d468:	4798      	blx	r3

    char *append = &buf[5];

    strcpy(buf, "[OPT:");

    if(hal.driver_cap.variable_spindle)
 800d46a:	f895 2144 	ldrb.w	r2, [r5, #324]	; 0x144
    strcpy(buf, "[OPT:");
 800d46e:	4b98      	ldr	r3, [pc, #608]	; (800d6d0 <report_build_info+0x294>)
 800d470:	4c98      	ldr	r4, [pc, #608]	; (800d6d4 <report_build_info+0x298>)
    if(hal.driver_cap.variable_spindle)
 800d472:	0796      	lsls	r6, r2, #30
    strcpy(buf, "[OPT:");
 800d474:	e893 0003 	ldmia.w	r3, {r0, r1}
 800d478:	80a1      	strh	r1, [r4, #4]
        *append++ = 'V';
 800d47a:	bf44      	itt	mi
 800d47c:	2156      	movmi	r1, #86	; 0x56
 800d47e:	7161      	strbmi	r1, [r4, #5]

    *append++ = 'N';
 800d480:	f04f 014e 	mov.w	r1, #78	; 0x4e
    strcpy(buf, "[OPT:");
 800d484:	6020      	str	r0, [r4, #0]
        *append++ = 'V';
 800d486:	bf4c      	ite	mi
 800d488:	1da3      	addmi	r3, r4, #6
    char *append = &buf[5];
 800d48a:	1d63      	addpl	r3, r4, #5

    if(hal.driver_cap.mist_control)
 800d48c:	07d0      	lsls	r0, r2, #31
    *append++ = 'N';
 800d48e:	7019      	strb	r1, [r3, #0]
        *append++ = 'M';
 800d490:	bf48      	it	mi
 800d492:	214d      	movmi	r1, #77	; 0x4d

#ifdef COREXY
    *append++ = 'C';
#endif

    if(settings.parking.flags.enabled)
 800d494:	4e90      	ldr	r6, [pc, #576]	; (800d6d8 <report_build_info+0x29c>)
        *append++ = 'M';
 800d496:	bf48      	it	mi
 800d498:	7059      	strbmi	r1, [r3, #1]
    if(settings.parking.flags.enabled)
 800d49a:	f896 00d8 	ldrb.w	r0, [r6, #216]	; 0xd8
        *append++ = 'M';
 800d49e:	bf4c      	ite	mi
 800d4a0:	3302      	addmi	r3, #2
    *append++ = 'N';
 800d4a2:	3301      	addpl	r3, #1
    if(settings.parking.flags.enabled)
 800d4a4:	07c1      	lsls	r1, r0, #31
        *append++ = 'P';
 800d4a6:	bf44      	itt	mi
 800d4a8:	2150      	movmi	r1, #80	; 0x50
 800d4aa:	f803 1b01 	strbmi.w	r1, [r3], #1

    if(settings.homing.flags.force_set_origin)
 800d4ae:	f896 10d0 	ldrb.w	r1, [r6, #208]	; 0xd0
 800d4b2:	070f      	lsls	r7, r1, #28
        *append++ = 'Z';
 800d4b4:	bf44      	itt	mi
 800d4b6:	275a      	movmi	r7, #90	; 0x5a
 800d4b8:	f803 7b01 	strbmi.w	r7, [r3], #1

    if(settings.homing.flags.single_axis_commands)
 800d4bc:	078f      	lsls	r7, r1, #30
        *append++ = 'H';
 800d4be:	bf44      	itt	mi
 800d4c0:	2748      	movmi	r7, #72	; 0x48
 800d4c2:	f803 7b01 	strbmi.w	r7, [r3], #1

    if(settings.limits.flags.two_switches)
 800d4c6:	f896 70d4 	ldrb.w	r7, [r6, #212]	; 0xd4
 800d4ca:	06ff      	lsls	r7, r7, #27
        *append++ = 'T';
 800d4cc:	bf44      	itt	mi
 800d4ce:	2754      	movmi	r7, #84	; 0x54
 800d4d0:	f803 7b01 	strbmi.w	r7, [r3], #1

    if(settings.flags.allow_probing_feed_override)
 800d4d4:	f896 70bd 	ldrb.w	r7, [r6, #189]	; 0xbd
 800d4d8:	f017 0f04 	tst.w	r7, #4
        *append++ = 'A';
 800d4dc:	bf1c      	itt	ne
 800d4de:	f04f 0c41 	movne.w	ip, #65	; 0x41
 800d4e2:	f803 cb01 	strbne.w	ip, [r3], #1

    if(settings.spindle.disable_with_zero_speed)
 800d4e6:	f896 c0b3 	ldrb.w	ip, [r6, #179]	; 0xb3
 800d4ea:	f1bc 0f00 	cmp.w	ip, #0
 800d4ee:	d003      	beq.n	800d4f8 <report_build_info+0xbc>
        *append++ = '0';
 800d4f0:	f04f 0c30 	mov.w	ip, #48	; 0x30
 800d4f4:	f803 cb01 	strb.w	ip, [r3], #1

    if(hal.driver_cap.software_debounce)
 800d4f8:	f012 0f10 	tst.w	r2, #16
        *append++ = 'S';
 800d4fc:	bf1c      	itt	ne
 800d4fe:	f04f 0c53 	movne.w	ip, #83	; 0x53
 800d502:	f803 cb01 	strbne.w	ip, [r3], #1

    if(settings.parking.flags.enable_override_control)
 800d506:	0740      	lsls	r0, r0, #29
        *append++ = 'R';
 800d508:	bf44      	itt	mi
 800d50a:	2052      	movmi	r0, #82	; 0x52
 800d50c:	f803 0b01 	strbmi.w	r0, [r3], #1

    if(!settings.homing.flags.init_lock)
 800d510:	0749      	lsls	r1, r1, #29
        *append++ = 'L';
 800d512:	bf5c      	itt	pl
 800d514:	214c      	movpl	r1, #76	; 0x4c
 800d516:	f803 1b01 	strbpl.w	r1, [r3], #1

    if(hal.driver_cap.safety_door)
 800d51a:	0750      	lsls	r0, r2, #29
        *append++ = '+';
 800d51c:	bf44      	itt	mi
 800d51e:	222b      	movmi	r2, #43	; 0x2b
 800d520:	f803 2b01 	strbmi.w	r2, [r3], #1

  #ifndef ENABLE_BUILD_INFO_WRITE_COMMAND // NOTE: Shown when disabled.
    *append++ = 'I';
  #endif

    if(!settings.flags.force_buffer_sync_on_wco_change) // NOTE: Shown when disabled.
 800d524:	0679      	lsls	r1, r7, #25
        *append++ = 'W';
 800d526:	bf58      	it	pl
 800d528:	2257      	movpl	r2, #87	; 0x57

    *append++ = ',';
 800d52a:	f04f 012c 	mov.w	r1, #44	; 0x2c
        *append++ = 'W';
 800d52e:	bf58      	it	pl
 800d530:	f803 2b01 	strbpl.w	r2, [r3], #1
    *append = '\0';
 800d534:	2200      	movs	r2, #0
    *append++ = ',';
 800d536:	7019      	strb	r1, [r3, #0]
    *append = '\0';
 800d538:	705a      	strb	r2, [r3, #1]
    hal.stream.write(buf);
 800d53a:	4866      	ldr	r0, [pc, #408]	; (800d6d4 <report_build_info+0x298>)
 800d53c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d53e:	4798      	blx	r3

    // NOTE: Compiled values, like override increments/max/min values, may be added at some point later.
    hal.stream.write(uitoa((uint32_t)(BLOCK_BUFFER_SIZE - 1)));
 800d540:	2023      	movs	r0, #35	; 0x23
 800d542:	6e6f      	ldr	r7, [r5, #100]	; 0x64
 800d544:	f7fc fd96 	bl	800a074 <uitoa>
 800d548:	47b8      	blx	r7
    hal.stream.write(",");
 800d54a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d54c:	4863      	ldr	r0, [pc, #396]	; (800d6dc <report_build_info+0x2a0>)
 800d54e:	4798      	blx	r3
    hal.stream.write(uitoa(hal.rx_buffer_size));
 800d550:	6968      	ldr	r0, [r5, #20]
 800d552:	6e6f      	ldr	r7, [r5, #100]	; 0x64
 800d554:	f7fc fd8e 	bl	800a074 <uitoa>
 800d558:	47b8      	blx	r7
    hal.stream.write(",");
 800d55a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d55c:	485f      	ldr	r0, [pc, #380]	; (800d6dc <report_build_info+0x2a0>)
 800d55e:	4798      	blx	r3
    hal.stream.write(uitoa((uint32_t)N_AXIS));
 800d560:	2003      	movs	r0, #3
 800d562:	6e6f      	ldr	r7, [r5, #100]	; 0x64
 800d564:	f7fc fd86 	bl	800a074 <uitoa>
 800d568:	47b8      	blx	r7
#if COMPATIBILITY_LEVEL == 0
    hal.stream.write(",");
 800d56a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d56c:	485b      	ldr	r0, [pc, #364]	; (800d6dc <report_build_info+0x2a0>)
 800d56e:	4798      	blx	r3
  #ifdef N_TOOLS
    hal.stream.write(uitoa((uint32_t)N_TOOLS));
  #else
    hal.stream.write("0");
 800d570:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d572:	485b      	ldr	r0, [pc, #364]	; (800d6e0 <report_build_info+0x2a4>)
 800d574:	4798      	blx	r3
  #endif
#endif
    hal.stream.write("]\r\n");
 800d576:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d578:	4854      	ldr	r0, [pc, #336]	; (800d6cc <report_build_info+0x290>)
 800d57a:	4798      	blx	r3

#if COMPATIBILITY_LEVEL == 0

    strcpy(buf, "[NEWOPT:");
 800d57c:	4a59      	ldr	r2, [pc, #356]	; (800d6e4 <report_build_info+0x2a8>)
 800d57e:	4b55      	ldr	r3, [pc, #340]	; (800d6d4 <report_build_info+0x298>)
 800d580:	ca07      	ldmia	r2, {r0, r1, r2}
 800d582:	c303      	stmia	r3!, {r0, r1}

    if(hal.driver_cap.program_stop)
 800d584:	f895 7145 	ldrb.w	r7, [r5, #325]	; 0x145
    strcpy(buf, "[NEWOPT:");
 800d588:	701a      	strb	r2, [r3, #0]
    if(hal.driver_cap.program_stop)
 800d58a:	073a      	lsls	r2, r7, #28
        strcat(buf, "OS,");
 800d58c:	bf44      	itt	mi
 800d58e:	4a56      	ldrmi	r2, [pc, #344]	; (800d6e8 <report_build_info+0x2ac>)
 800d590:	601a      	strmi	r2, [r3, #0]

    if(hal.driver_cap.block_delete)
 800d592:	06f8      	lsls	r0, r7, #27
 800d594:	f100 80cc 	bmi.w	800d730 <report_build_info+0x2f4>
        strcat(buf, "BD,");

    if(hal.driver_cap.e_stop)
 800d598:	06b9      	lsls	r1, r7, #26
 800d59a:	f100 80c1 	bmi.w	800d720 <report_build_info+0x2e4>
        strcat(buf, "ES,");

    if(hal.driver_cap.sd_card)
 800d59e:	f895 7146 	ldrb.w	r7, [r5, #326]	; 0x146
 800d5a2:	07ba      	lsls	r2, r7, #30
 800d5a4:	f100 80b4 	bmi.w	800d710 <report_build_info+0x2d4>
        strcat(buf, "SD,");

    if(hal.driver_cap.bluetooth)
 800d5a8:	077b      	lsls	r3, r7, #29
 800d5aa:	d47f      	bmi.n	800d6ac <report_build_info+0x270>
        strcat(buf, "BT,");

    if(hal.driver_cap.ethernet)
 800d5ac:	0738      	lsls	r0, r7, #28
 800d5ae:	d472      	bmi.n	800d696 <report_build_info+0x25a>
        strcat(buf, "ETH,");

    if(hal.driver_cap.mpg_mode)
 800d5b0:	f895 3147 	ldrb.w	r3, [r5, #327]	; 0x147
 800d5b4:	0759      	lsls	r1, r3, #29
 800d5b6:	d463      	bmi.n	800d680 <report_build_info+0x244>
        strcat(buf, "MPG,");

    if(hal.driver_cap.wifi)
 800d5b8:	06fa      	lsls	r2, r7, #27
 800d5ba:	d446      	bmi.n	800d64a <report_build_info+0x20e>
        strcat(buf, "WIFI,");

    if(settings.flags.lathe_mode)
 800d5bc:	f996 30bd 	ldrsb.w	r3, [r6, #189]	; 0xbd
 800d5c0:	2b00      	cmp	r3, #0
 800d5c2:	db50      	blt.n	800d666 <report_build_info+0x22a>
#ifdef N_TOOLS
    if(hal.tool_change)
        strcat(buf, "ATC,");
    else
#endif
    if(hal.stream.suspend_read)
 800d5c4:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800d5c6:	b133      	cbz	r3, 800d5d6 <report_build_info+0x19a>
        strcat(buf, "TC,"); // Manual tool change supported (M6)
 800d5c8:	4842      	ldr	r0, [pc, #264]	; (800d6d4 <report_build_info+0x298>)
 800d5ca:	f7f2 fdc1 	bl	8000150 <strlen>
 800d5ce:	4603      	mov	r3, r0
 800d5d0:	4a46      	ldr	r2, [pc, #280]	; (800d6ec <report_build_info+0x2b0>)
 800d5d2:	6810      	ldr	r0, [r2, #0]
 800d5d4:	50e0      	str	r0, [r4, r3]

    if(hal.driver_cap.spindle_sync)
 800d5d6:	07fb      	lsls	r3, r7, #31
 800d5d8:	d42f      	bmi.n	800d63a <report_build_info+0x1fe>

#ifdef PID_LOG
    strcat(buf, "PID,");
#endif

    append = &buf[strlen(buf) - 1];
 800d5da:	483e      	ldr	r0, [pc, #248]	; (800d6d4 <report_build_info+0x298>)
 800d5dc:	f7f2 fdb8 	bl	8000150 <strlen>
 800d5e0:	3801      	subs	r0, #1
    if(*append == ',')
 800d5e2:	5c23      	ldrb	r3, [r4, r0]
 800d5e4:	2b2c      	cmp	r3, #44	; 0x2c
 800d5e6:	d01f      	beq.n	800d628 <report_build_info+0x1ec>
        *append = '\0';

    if(*append != ':') {
 800d5e8:	2b3a      	cmp	r3, #58	; 0x3a
 800d5ea:	d11f      	bne.n	800d62c <report_build_info+0x1f0>
        hal.stream.write(buf);
        hal.stream.write("]" ASCII_EOL);
    }

    if(hal.driver_version) {
 800d5ec:	68ab      	ldr	r3, [r5, #8]
 800d5ee:	b143      	cbz	r3, 800d602 <report_build_info+0x1c6>
        hal.stream.write("[DRIVER VERSION:");
 800d5f0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d5f2:	483f      	ldr	r0, [pc, #252]	; (800d6f0 <report_build_info+0x2b4>)
 800d5f4:	4798      	blx	r3
        hal.stream.write(hal.driver_version);
 800d5f6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d5f8:	68a8      	ldr	r0, [r5, #8]
 800d5fa:	4798      	blx	r3
        hal.stream.write("]"  ASCII_EOL);
 800d5fc:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d5fe:	4833      	ldr	r0, [pc, #204]	; (800d6cc <report_build_info+0x290>)
 800d600:	4798      	blx	r3
    }

    if(hal.driver_options) {
 800d602:	68eb      	ldr	r3, [r5, #12]
 800d604:	b143      	cbz	r3, 800d618 <report_build_info+0x1dc>
        hal.stream.write("[DRIVER OPTIONS:");
 800d606:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d608:	483a      	ldr	r0, [pc, #232]	; (800d6f4 <report_build_info+0x2b8>)
 800d60a:	4798      	blx	r3
        hal.stream.write(hal.driver_options);
 800d60c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d60e:	68e8      	ldr	r0, [r5, #12]
 800d610:	4798      	blx	r3
        hal.stream.write("]"  ASCII_EOL);
 800d612:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d614:	482d      	ldr	r0, [pc, #180]	; (800d6cc <report_build_info+0x290>)
 800d616:	4798      	blx	r3
    }

    if(hal.report_options)
 800d618:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 800d61c:	2b00      	cmp	r3, #0
 800d61e:	f000 808f 	beq.w	800d740 <report_build_info+0x304>
        hal.report_options();
#endif

}
 800d622:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hal.report_options();
 800d626:	4718      	bx	r3
        *append = '\0';
 800d628:	2300      	movs	r3, #0
 800d62a:	5423      	strb	r3, [r4, r0]
        hal.stream.write(buf);
 800d62c:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d62e:	4829      	ldr	r0, [pc, #164]	; (800d6d4 <report_build_info+0x298>)
 800d630:	4798      	blx	r3
        hal.stream.write("]" ASCII_EOL);
 800d632:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 800d634:	4825      	ldr	r0, [pc, #148]	; (800d6cc <report_build_info+0x290>)
 800d636:	4798      	blx	r3
 800d638:	e7d8      	b.n	800d5ec <report_build_info+0x1b0>
        strcat(buf, "SS,");
 800d63a:	4826      	ldr	r0, [pc, #152]	; (800d6d4 <report_build_info+0x298>)
 800d63c:	f7f2 fd88 	bl	8000150 <strlen>
 800d640:	4603      	mov	r3, r0
 800d642:	4a2d      	ldr	r2, [pc, #180]	; (800d6f8 <report_build_info+0x2bc>)
 800d644:	6810      	ldr	r0, [r2, #0]
 800d646:	50e0      	str	r0, [r4, r3]
 800d648:	e7c7      	b.n	800d5da <report_build_info+0x19e>
        strcat(buf, "WIFI,");
 800d64a:	4822      	ldr	r0, [pc, #136]	; (800d6d4 <report_build_info+0x298>)
 800d64c:	f7f2 fd80 	bl	8000150 <strlen>
 800d650:	4603      	mov	r3, r0
 800d652:	4a2a      	ldr	r2, [pc, #168]	; (800d6fc <report_build_info+0x2c0>)
 800d654:	1821      	adds	r1, r4, r0
 800d656:	6810      	ldr	r0, [r2, #0]
 800d658:	8892      	ldrh	r2, [r2, #4]
 800d65a:	50e0      	str	r0, [r4, r3]
    if(settings.flags.lathe_mode)
 800d65c:	f996 30bd 	ldrsb.w	r3, [r6, #189]	; 0xbd
        strcat(buf, "WIFI,");
 800d660:	808a      	strh	r2, [r1, #4]
    if(settings.flags.lathe_mode)
 800d662:	2b00      	cmp	r3, #0
 800d664:	daae      	bge.n	800d5c4 <report_build_info+0x188>
        strcat(buf, "LATHE,");
 800d666:	481b      	ldr	r0, [pc, #108]	; (800d6d4 <report_build_info+0x298>)
 800d668:	f7f2 fd72 	bl	8000150 <strlen>
 800d66c:	4603      	mov	r3, r0
 800d66e:	4a24      	ldr	r2, [pc, #144]	; (800d700 <report_build_info+0x2c4>)
 800d670:	1821      	adds	r1, r4, r0
 800d672:	8896      	ldrh	r6, [r2, #4]
 800d674:	6810      	ldr	r0, [r2, #0]
 800d676:	7992      	ldrb	r2, [r2, #6]
 800d678:	50e0      	str	r0, [r4, r3]
 800d67a:	808e      	strh	r6, [r1, #4]
 800d67c:	718a      	strb	r2, [r1, #6]
 800d67e:	e7a1      	b.n	800d5c4 <report_build_info+0x188>
        strcat(buf, "MPG,");
 800d680:	4814      	ldr	r0, [pc, #80]	; (800d6d4 <report_build_info+0x298>)
 800d682:	f7f2 fd65 	bl	8000150 <strlen>
 800d686:	4603      	mov	r3, r0
 800d688:	4a1e      	ldr	r2, [pc, #120]	; (800d704 <report_build_info+0x2c8>)
 800d68a:	1821      	adds	r1, r4, r0
 800d68c:	6810      	ldr	r0, [r2, #0]
 800d68e:	7912      	ldrb	r2, [r2, #4]
 800d690:	50e0      	str	r0, [r4, r3]
 800d692:	710a      	strb	r2, [r1, #4]
 800d694:	e790      	b.n	800d5b8 <report_build_info+0x17c>
        strcat(buf, "ETH,");
 800d696:	480f      	ldr	r0, [pc, #60]	; (800d6d4 <report_build_info+0x298>)
 800d698:	f7f2 fd5a 	bl	8000150 <strlen>
 800d69c:	4603      	mov	r3, r0
 800d69e:	4a1a      	ldr	r2, [pc, #104]	; (800d708 <report_build_info+0x2cc>)
 800d6a0:	1821      	adds	r1, r4, r0
 800d6a2:	6810      	ldr	r0, [r2, #0]
 800d6a4:	7912      	ldrb	r2, [r2, #4]
 800d6a6:	50e0      	str	r0, [r4, r3]
 800d6a8:	710a      	strb	r2, [r1, #4]
 800d6aa:	e781      	b.n	800d5b0 <report_build_info+0x174>
        strcat(buf, "BT,");
 800d6ac:	4809      	ldr	r0, [pc, #36]	; (800d6d4 <report_build_info+0x298>)
 800d6ae:	f7f2 fd4f 	bl	8000150 <strlen>
 800d6b2:	4603      	mov	r3, r0
 800d6b4:	4a15      	ldr	r2, [pc, #84]	; (800d70c <report_build_info+0x2d0>)
 800d6b6:	6810      	ldr	r0, [r2, #0]
 800d6b8:	50e0      	str	r0, [r4, r3]
 800d6ba:	e777      	b.n	800d5ac <report_build_info+0x170>
 800d6bc:	200024bc 	.word	0x200024bc
 800d6c0:	08014c44 	.word	0x08014c44
 800d6c4:	08014c40 	.word	0x08014c40
 800d6c8:	08014c50 	.word	0x08014c50
 800d6cc:	08014ad0 	.word	0x08014ad0
 800d6d0:	08014c5c 	.word	0x08014c5c
 800d6d4:	20001a68 	.word	0x20001a68
 800d6d8:	20002620 	.word	0x20002620
 800d6dc:	080149a4 	.word	0x080149a4
 800d6e0:	08014c64 	.word	0x08014c64
 800d6e4:	08014c68 	.word	0x08014c68
 800d6e8:	002c534f 	.word	0x002c534f
 800d6ec:	08014ca4 	.word	0x08014ca4
 800d6f0:	08014cac 	.word	0x08014cac
 800d6f4:	08014cc0 	.word	0x08014cc0
 800d6f8:	08014ca8 	.word	0x08014ca8
 800d6fc:	08014c94 	.word	0x08014c94
 800d700:	08014c9c 	.word	0x08014c9c
 800d704:	08014c8c 	.word	0x08014c8c
 800d708:	08014c84 	.word	0x08014c84
 800d70c:	08014c80 	.word	0x08014c80
        strcat(buf, "SD,");
 800d710:	480c      	ldr	r0, [pc, #48]	; (800d744 <report_build_info+0x308>)
 800d712:	f7f2 fd1d 	bl	8000150 <strlen>
 800d716:	4603      	mov	r3, r0
 800d718:	4a0b      	ldr	r2, [pc, #44]	; (800d748 <report_build_info+0x30c>)
 800d71a:	6810      	ldr	r0, [r2, #0]
 800d71c:	50e0      	str	r0, [r4, r3]
 800d71e:	e743      	b.n	800d5a8 <report_build_info+0x16c>
        strcat(buf, "ES,");
 800d720:	4808      	ldr	r0, [pc, #32]	; (800d744 <report_build_info+0x308>)
 800d722:	f7f2 fd15 	bl	8000150 <strlen>
 800d726:	4603      	mov	r3, r0
 800d728:	4a08      	ldr	r2, [pc, #32]	; (800d74c <report_build_info+0x310>)
 800d72a:	6810      	ldr	r0, [r2, #0]
 800d72c:	50e0      	str	r0, [r4, r3]
 800d72e:	e736      	b.n	800d59e <report_build_info+0x162>
        strcat(buf, "BD,");
 800d730:	4804      	ldr	r0, [pc, #16]	; (800d744 <report_build_info+0x308>)
 800d732:	f7f2 fd0d 	bl	8000150 <strlen>
 800d736:	4603      	mov	r3, r0
 800d738:	4a05      	ldr	r2, [pc, #20]	; (800d750 <report_build_info+0x314>)
 800d73a:	6810      	ldr	r0, [r2, #0]
 800d73c:	50e0      	str	r0, [r4, r3]
 800d73e:	e72b      	b.n	800d598 <report_build_info+0x15c>
}
 800d740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d744:	20001a68 	.word	0x20001a68
 800d748:	08014c7c 	.word	0x08014c7c
 800d74c:	08014c78 	.word	0x08014c78
 800d750:	08014c74 	.word	0x08014c74

0800d754 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status (void)
{
 800d754:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int32_t current_position[N_AXIS]; // Copy current state of the system position variable
    float print_position[N_AXIS];

    memcpy(current_position, sys_position, sizeof(sys_position));
 800d758:	4a7b      	ldr	r2, [pc, #492]	; (800d948 <report_realtime_status+0x1f4>)
{
 800d75a:	b093      	sub	sp, #76	; 0x4c
    memcpy(current_position, sys_position, sizeof(sys_position));
 800d75c:	ab01      	add	r3, sp, #4
    system_convert_array_steps_to_mpos(print_position, current_position);

    // Report current machine state and sub-states
    hal.stream.write_all("<");
 800d75e:	4c7b      	ldr	r4, [pc, #492]	; (800d94c <report_realtime_status+0x1f8>)
    memcpy(current_position, sys_position, sizeof(sys_position));
 800d760:	ca07      	ldmia	r2, {r0, r1, r2}

    switch (sys.state) {
 800d762:	4d7b      	ldr	r5, [pc, #492]	; (800d950 <report_realtime_status+0x1fc>)
    memcpy(current_position, sys_position, sizeof(sys_position));
 800d764:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    system_convert_array_steps_to_mpos(print_position, current_position);
 800d768:	4619      	mov	r1, r3
 800d76a:	a804      	add	r0, sp, #16
 800d76c:	f003 ffdc 	bl	8011728 <system_convert_array_steps_to_mpos>
    hal.stream.write_all("<");
 800d770:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d772:	4878      	ldr	r0, [pc, #480]	; (800d954 <report_realtime_status+0x200>)
 800d774:	4798      	blx	r3
    switch (sys.state) {
 800d776:	682b      	ldr	r3, [r5, #0]
 800d778:	2b20      	cmp	r3, #32
 800d77a:	d824      	bhi.n	800d7c6 <report_realtime_status+0x72>
 800d77c:	2b20      	cmp	r3, #32
 800d77e:	d831      	bhi.n	800d7e4 <report_realtime_status+0x90>
 800d780:	e8df f013 	tbh	[pc, r3, lsl #1]
 800d784:	031e02f6 	.word	0x031e02f6
 800d788:	00300328 	.word	0x00300328
 800d78c:	003002fb 	.word	0x003002fb
 800d790:	00300030 	.word	0x00300030
 800d794:	00300300 	.word	0x00300300
 800d798:	00300030 	.word	0x00300030
 800d79c:	00300030 	.word	0x00300030
 800d7a0:	00300030 	.word	0x00300030
 800d7a4:	0030030c 	.word	0x0030030c
 800d7a8:	00300030 	.word	0x00300030
 800d7ac:	00300030 	.word	0x00300030
 800d7b0:	00300030 	.word	0x00300030
 800d7b4:	00300030 	.word	0x00300030
 800d7b8:	00300030 	.word	0x00300030
 800d7bc:	00300030 	.word	0x00300030
 800d7c0:	00300030 	.word	0x00300030
 800d7c4:	0319      	.short	0x0319
 800d7c6:	2b80      	cmp	r3, #128	; 0x80
 800d7c8:	f000 83ae 	beq.w	800df28 <report_realtime_status+0x7d4>
 800d7cc:	f240 80ac 	bls.w	800d928 <report_realtime_status+0x1d4>
 800d7d0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d7d4:	f000 82f4 	beq.w	800ddc0 <report_realtime_status+0x66c>
 800d7d8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800d7dc:	d102      	bne.n	800d7e4 <report_realtime_status+0x90>
        case STATE_SLEEP:
            hal.stream.write_all("Sleep");
            break;

        case STATE_TOOL_CHANGE:
            hal.stream.write_all("Tool");
 800d7de:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d7e0:	485d      	ldr	r0, [pc, #372]	; (800d958 <report_realtime_status+0x204>)
 800d7e2:	4798      	blx	r3
            break;
 800d7e4:	4e5d      	ldr	r6, [pc, #372]	; (800d95c <report_realtime_status+0x208>)
    }

    uint_fast8_t idx;
    float wco[N_AXIS];
    if (!settings.status_report.machine_position || sys.report.wco) {
 800d7e6:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
 800d7ea:	07db      	lsls	r3, r3, #31
 800d7ec:	f100 81f0 	bmi.w	800dbd0 <report_realtime_status+0x47c>
{
 800d7f0:	f04f 0900 	mov.w	r9, #0
 800d7f4:	f10d 0a10 	add.w	sl, sp, #16
 800d7f8:	f10d 081c 	add.w	r8, sp, #28
        for (idx = 0; idx < N_AXIS; idx++) {
            // Apply work coordinate offsets and tool length offset to current position.
            wco[idx] = gc_get_offset(idx);
 800d7fc:	4648      	mov	r0, r9
 800d7fe:	f7f7 fe89 	bl	8005514 <gc_get_offset>
 800d802:	4601      	mov	r1, r0
            if (!settings.status_report.machine_position)
 800d804:	f896 00bb 	ldrb.w	r0, [r6, #187]	; 0xbb
        for (idx = 0; idx < N_AXIS; idx++) {
 800d808:	f109 0901 	add.w	r9, r9, #1
            if (!settings.status_report.machine_position)
 800d80c:	f010 0701 	ands.w	r7, r0, #1
            wco[idx] = gc_get_offset(idx);
 800d810:	f848 1b04 	str.w	r1, [r8], #4
            if (!settings.status_report.machine_position)
 800d814:	d105      	bne.n	800d822 <report_realtime_status+0xce>
                print_position[idx] -= wco[idx];
 800d816:	f8da 0000 	ldr.w	r0, [sl]
 800d81a:	f7f2 feb1 	bl	8000580 <__aeabi_fsub>
 800d81e:	f8ca 0000 	str.w	r0, [sl]
        for (idx = 0; idx < N_AXIS; idx++) {
 800d822:	f1b9 0f03 	cmp.w	r9, #3
 800d826:	f10a 0a04 	add.w	sl, sl, #4
 800d82a:	d1e7      	bne.n	800d7fc <report_realtime_status+0xa8>
        }
    }

    // Report position
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 800d82c:	484c      	ldr	r0, [pc, #304]	; (800d960 <report_realtime_status+0x20c>)
 800d82e:	4a4d      	ldr	r2, [pc, #308]	; (800d964 <report_realtime_status+0x210>)
 800d830:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d832:	2f00      	cmp	r7, #0
 800d834:	bf08      	it	eq
 800d836:	4610      	moveq	r0, r2
    hal.stream.write_all(get_axis_values(print_position));
 800d838:	f8df 8140 	ldr.w	r8, [pc, #320]	; 800d97c <report_realtime_status+0x228>
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 800d83c:	4798      	blx	r3
    hal.stream.write_all(get_axis_values(print_position));
 800d83e:	f8d8 3000 	ldr.w	r3, [r8]
 800d842:	a804      	add	r0, sp, #16
 800d844:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800d846:	4798      	blx	r3
 800d848:	47b8      	blx	r7

    // Returns planner and output stream buffer states.

    if (settings.status_report.buffer_state) {
 800d84a:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
 800d84e:	0798      	lsls	r0, r3, #30
 800d850:	f100 819d 	bmi.w	800db8e <report_realtime_status+0x43a>
        hal.stream.write_all(uitoa((uint32_t)plan_get_block_buffer_available()));
        hal.stream.write_all(",");
        hal.stream.write_all(uitoa(hal.stream.get_rx_buffer_available()));
    }

    if(settings.status_report.line_numbers) {
 800d854:	0759      	lsls	r1, r3, #29
 800d856:	f100 81b1 	bmi.w	800dbbc <report_realtime_status+0x468>
        if (cur_block != NULL && cur_block->line_number > 0)
            hal.stream.write_all(appendbuf(2, "|Ln:", uitoa((uint32_t)cur_block->line_number)));
    }

    // Report realtime feed speed
    if(settings.status_report.feed_speed) {
 800d85a:	071a      	lsls	r2, r3, #28
 800d85c:	d534      	bpl.n	800d8c8 <report_realtime_status+0x174>
        if(hal.driver_cap.variable_spindle) {
 800d85e:	f894 3144 	ldrb.w	r3, [r4, #324]	; 0x144
            hal.stream.write_all(appendbuf(2, "|FS:", get_rate_value(st_get_realtime_rate())));
 800d862:	6ea7      	ldr	r7, [r4, #104]	; 0x68
        if(hal.driver_cap.variable_spindle) {
 800d864:	f013 0f02 	tst.w	r3, #2
            hal.stream.write_all(appendbuf(2, "|FS:", get_rate_value(st_get_realtime_rate())));
 800d868:	4b3f      	ldr	r3, [pc, #252]	; (800d968 <report_realtime_status+0x214>)
 800d86a:	f8d3 9000 	ldr.w	r9, [r3]
        if(hal.driver_cap.variable_spindle) {
 800d86e:	f000 820b 	beq.w	800dc88 <report_realtime_status+0x534>
            hal.stream.write_all(appendbuf(2, "|FS:", get_rate_value(st_get_realtime_rate())));
 800d872:	f003 fbdf 	bl	8011034 <st_get_realtime_rate>
 800d876:	47c8      	blx	r9
 800d878:	493c      	ldr	r1, [pc, #240]	; (800d96c <report_realtime_status+0x218>)
 800d87a:	4602      	mov	r2, r0
 800d87c:	2002      	movs	r0, #2
 800d87e:	f7fe fb6d 	bl	800bf5c <appendbuf.constprop.1>
 800d882:	47b8      	blx	r7
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.spindle_rpm)));
 800d884:	69a8      	ldr	r0, [r5, #24]
 800d886:	f7f3 f987 	bl	8000b98 <__aeabi_f2uiz>
 800d88a:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800d88c:	f7fc fbf2 	bl	800a074 <uitoa>
 800d890:	4937      	ldr	r1, [pc, #220]	; (800d970 <report_realtime_status+0x21c>)
 800d892:	4602      	mov	r2, r0
 800d894:	2002      	movs	r0, #2
 800d896:	f7fe fb61 	bl	800bf5c <appendbuf.constprop.1>
 800d89a:	47b8      	blx	r7
            if(hal.spindle_get_data /* && sys.mpg_mode */)
 800d89c:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 800d8a0:	2b00      	cmp	r3, #0
 800d8a2:	f000 81fa 	beq.w	800dc9a <report_realtime_status+0x546>
                hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)hal.spindle_get_data(SpindleData_RPM).rpm)));
 800d8a6:	2101      	movs	r1, #1
 800d8a8:	a80a      	add	r0, sp, #40	; 0x28
 800d8aa:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800d8ac:	4798      	blx	r3
 800d8ae:	980c      	ldr	r0, [sp, #48]	; 0x30
 800d8b0:	f7f3 f972 	bl	8000b98 <__aeabi_f2uiz>
 800d8b4:	f7fc fbde 	bl	800a074 <uitoa>
 800d8b8:	492d      	ldr	r1, [pc, #180]	; (800d970 <report_realtime_status+0x21c>)
 800d8ba:	4602      	mov	r2, r0
 800d8bc:	2002      	movs	r0, #2
 800d8be:	f7fe fb4d 	bl	800bf5c <appendbuf.constprop.1>
 800d8c2:	47b8      	blx	r7
 800d8c4:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
        } else
            hal.stream.write_all(appendbuf(2, "|F:", get_rate_value(st_get_realtime_rate())));
    }

    if(settings.status_report.pin_state) {
 800d8c8:	06df      	lsls	r7, r3, #27
 800d8ca:	d517      	bpl.n	800d8fc <report_realtime_status+0x1a8>

        axes_signals_t lim_pin_state = (axes_signals_t)hal.limits_get_state();
 800d8cc:	6a23      	ldr	r3, [r4, #32]
 800d8ce:	4798      	blx	r3
        control_signals_t ctrl_pin_state = hal.system_control_get_state();
 800d8d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
        axes_signals_t lim_pin_state = (axes_signals_t)hal.limits_get_state();
 800d8d2:	fa5f f980 	uxtb.w	r9, r0
        control_signals_t ctrl_pin_state = hal.system_control_get_state();
 800d8d6:	4798      	blx	r3
        bool prb_pin_state = hal.probe_get_state && hal.probe_get_state();
 800d8d8:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        control_signals_t ctrl_pin_state = hal.system_control_get_state();
 800d8dc:	b2c7      	uxtb	r7, r0
        bool prb_pin_state = hal.probe_get_state && hal.probe_get_state();
 800d8de:	b11b      	cbz	r3, 800d8e8 <report_realtime_status+0x194>
 800d8e0:	4798      	blx	r3
 800d8e2:	2800      	cmp	r0, #0
 800d8e4:	f040 8290 	bne.w	800de08 <report_realtime_status+0x6b4>

        if (lim_pin_state.value | ctrl_pin_state.value | prb_pin_state | sys.flags.block_delete_enabled) {
 800d8e8:	7a6b      	ldrb	r3, [r5, #9]
 800d8ea:	ea49 0207 	orr.w	r2, r9, r7
 800d8ee:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800d8f2:	4313      	orrs	r3, r2
 800d8f4:	f040 834e 	bne.w	800df94 <report_realtime_status+0x840>
 800d8f8:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
            *append = '\0';
            hal.stream.write_all(buf);
        }
    }

    if(settings.status_report.work_coord_offset) {
 800d8fc:	f013 0220 	ands.w	r2, r3, #32
 800d900:	d13e      	bne.n	800d980 <report_realtime_status+0x22c>
        else
            wco_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
                            ? (REPORT_WCO_REFRESH_BUSY_COUNT - 1) // Reset counter for slow refresh
                            : (REPORT_WCO_REFRESH_IDLE_COUNT - 1);
    } else
        sys.report.wco = Off;
 800d902:	7d69      	ldrb	r1, [r5, #21]
 800d904:	f362 0100 	bfi	r1, r2, #0, #1
 800d908:	7569      	strb	r1, [r5, #21]

    if(settings.status_report.overrides) {
 800d90a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 800d90e:	d045      	beq.n	800d99c <report_realtime_status+0x248>

        if (override_counter > 0 && !sys.report.overrides)
 800d910:	4f18      	ldr	r7, [pc, #96]	; (800d974 <report_realtime_status+0x220>)
 800d912:	783b      	ldrb	r3, [r7, #0]
 800d914:	2b00      	cmp	r3, #0
 800d916:	f000 8162 	beq.w	800dbde <report_realtime_status+0x48a>
 800d91a:	7d2a      	ldrb	r2, [r5, #20]
 800d91c:	0651      	lsls	r1, r2, #25
 800d91e:	f100 815e 	bmi.w	800dbde <report_realtime_status+0x48a>
            override_counter--;
 800d922:	3b01      	subs	r3, #1
 800d924:	703b      	strb	r3, [r7, #0]
 800d926:	e03d      	b.n	800d9a4 <report_realtime_status+0x250>
    switch (sys.state) {
 800d928:	2b40      	cmp	r3, #64	; 0x40
 800d92a:	f47f af5b 	bne.w	800d7e4 <report_realtime_status+0x90>
            hal.stream.write_all(appendbuf(2, "Door:", uitoa((uint32_t)sys.parking_state)));
 800d92e:	7da8      	ldrb	r0, [r5, #22]
 800d930:	6ea6      	ldr	r6, [r4, #104]	; 0x68
 800d932:	f7fc fb9f 	bl	800a074 <uitoa>
 800d936:	4910      	ldr	r1, [pc, #64]	; (800d978 <report_realtime_status+0x224>)
 800d938:	4602      	mov	r2, r0
 800d93a:	2002      	movs	r0, #2
 800d93c:	f7fe fb0e 	bl	800bf5c <appendbuf.constprop.1>
 800d940:	47b0      	blx	r6
            break;
 800d942:	4e06      	ldr	r6, [pc, #24]	; (800d95c <report_realtime_status+0x208>)
 800d944:	e74f      	b.n	800d7e6 <report_realtime_status+0x92>
 800d946:	bf00      	nop
 800d948:	20002610 	.word	0x20002610
 800d94c:	200024bc 	.word	0x200024bc
 800d950:	20002494 	.word	0x20002494
 800d954:	08014d08 	.word	0x08014d08
 800d958:	08014d54 	.word	0x08014d54
 800d95c:	20002620 	.word	0x20002620
 800d960:	08014cd4 	.word	0x08014cd4
 800d964:	08014cdc 	.word	0x08014cdc
 800d968:	20001a9c 	.word	0x20001a9c
 800d96c:	08014d6c 	.word	0x08014d6c
 800d970:	080149a4 	.word	0x080149a4
 800d974:	20001ac8 	.word	0x20001ac8
 800d978:	08014d44 	.word	0x08014d44
 800d97c:	20001a98 	.word	0x20001a98
        if (wco_counter > 0 && !sys.report.wco)
 800d980:	4aa9      	ldr	r2, [pc, #676]	; (800dc28 <report_realtime_status+0x4d4>)
 800d982:	7811      	ldrb	r1, [r2, #0]
 800d984:	2900      	cmp	r1, #0
 800d986:	f000 8177 	beq.w	800dc78 <report_realtime_status+0x524>
 800d98a:	7d68      	ldrb	r0, [r5, #21]
 800d98c:	07c0      	lsls	r0, r0, #31
 800d98e:	f100 8173 	bmi.w	800dc78 <report_realtime_status+0x524>
            wco_counter--;
 800d992:	3901      	subs	r1, #1
    if(settings.status_report.overrides) {
 800d994:	f013 0340 	ands.w	r3, r3, #64	; 0x40
            wco_counter--;
 800d998:	7011      	strb	r1, [r2, #0]
    if(settings.status_report.overrides) {
 800d99a:	d1b9      	bne.n	800d910 <report_realtime_status+0x1bc>
            override_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
                                 ? (REPORT_OVERRIDE_REFRESH_BUSY_COUNT - 1) // Reset counter for slow refresh
                                 : (REPORT_OVERRIDE_REFRESH_IDLE_COUNT - 1);
        }
    } else
        sys.report.overrides = Off;
 800d99c:	7d2a      	ldrb	r2, [r5, #20]
 800d99e:	f363 1286 	bfi	r2, r3, #6, #1
 800d9a2:	752a      	strb	r2, [r5, #20]

    if(sys.report.value || gc_state.tool_change) {
 800d9a4:	8aab      	ldrh	r3, [r5, #20]
 800d9a6:	4fa1      	ldr	r7, [pc, #644]	; (800dc2c <report_realtime_status+0x4d8>)
 800d9a8:	b923      	cbnz	r3, 800d9b4 <report_realtime_status+0x260>
 800d9aa:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
 800d9ae:	2b00      	cmp	r3, #0
 800d9b0:	f000 80a2 	beq.w	800daf8 <report_realtime_status+0x3a4>

        if(sys.report.wco) {
 800d9b4:	7d6b      	ldrb	r3, [r5, #21]
 800d9b6:	07d8      	lsls	r0, r3, #31
 800d9b8:	d50a      	bpl.n	800d9d0 <report_realtime_status+0x27c>
            hal.stream.write_all("|WCO:");
 800d9ba:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d9bc:	489c      	ldr	r0, [pc, #624]	; (800dc30 <report_realtime_status+0x4dc>)
 800d9be:	4798      	blx	r3
            hal.stream.write_all(get_axis_values(wco));
 800d9c0:	f8d8 3000 	ldr.w	r3, [r8]
 800d9c4:	a807      	add	r0, sp, #28
 800d9c6:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800d9ca:	4798      	blx	r3
 800d9cc:	47c0      	blx	r8
 800d9ce:	7d6b      	ldrb	r3, [r5, #21]
        }

        if(sys.report.gwco) {
 800d9d0:	0799      	lsls	r1, r3, #30
 800d9d2:	d51b      	bpl.n	800da0c <report_realtime_status+0x2b8>
            hal.stream.write_all("|WCS:G");
 800d9d4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800d9d6:	4897      	ldr	r0, [pc, #604]	; (800dc34 <report_realtime_status+0x4e0>)
 800d9d8:	4798      	blx	r3
    uint8_t g5x = idx + 54;
 800d9da:	f897 8014 	ldrb.w	r8, [r7, #20]
            hal.stream.write_all(map_coord_system(gc_state.modal.coord_system.idx));
 800d9de:	f8d4 9068 	ldr.w	r9, [r4, #104]	; 0x68
    uint8_t g5x = idx + 54;
 800d9e2:	f108 0836 	add.w	r8, r8, #54	; 0x36
 800d9e6:	fa5f f888 	uxtb.w	r8, r8
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800d9ea:	4640      	mov	r0, r8
 800d9ec:	283b      	cmp	r0, #59	; 0x3b
 800d9ee:	bf28      	it	cs
 800d9f0:	203b      	movcs	r0, #59	; 0x3b
 800d9f2:	f7fc fb3f 	bl	800a074 <uitoa>
 800d9f6:	4601      	mov	r1, r0
 800d9f8:	488f      	ldr	r0, [pc, #572]	; (800dc38 <report_realtime_status+0x4e4>)
 800d9fa:	f004 fcef 	bl	80123dc <stpcpy>
    if(g5x > 59) {
 800d9fe:	f1b8 0f3b 	cmp.w	r8, #59	; 0x3b
    strcpy(buf, uitoa((uint32_t)(g5x > 59 ? 59 : g5x)));
 800da02:	4603      	mov	r3, r0
    if(g5x > 59) {
 800da04:	f200 8284 	bhi.w	800df10 <report_realtime_status+0x7bc>
            hal.stream.write_all(map_coord_system(gc_state.modal.coord_system.idx));
 800da08:	488b      	ldr	r0, [pc, #556]	; (800dc38 <report_realtime_status+0x4e4>)
 800da0a:	47c8      	blx	r9
        }

        if(sys.report.overrides) {
 800da0c:	7d2b      	ldrb	r3, [r5, #20]
 800da0e:	065a      	lsls	r2, r3, #25
 800da10:	f100 818b 	bmi.w	800dd2a <report_realtime_status+0x5d6>
            hal.stream.write_all(appendbuf(2, "|Ov:", uitoa((uint32_t)sys.override.feed_rate)));
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.rapid_rate)));
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.spindle_rpm)));
        }

        if(sys.report.spindle || sys.report.coolant || sys.report.tool || gc_state.tool_change) {
 800da14:	f013 0fb0 	tst.w	r3, #176	; 0xb0
 800da18:	d103      	bne.n	800da22 <report_realtime_status+0x2ce>
 800da1a:	f897 2080 	ldrb.w	r2, [r7, #128]	; 0x80
 800da1e:	2a00      	cmp	r2, #0
 800da20:	d030      	beq.n	800da84 <report_realtime_status+0x330>

            spindle_state_t sp_state = hal.spindle_get_state();
 800da22:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800da24:	4798      	blx	r3
 800da26:	4680      	mov	r8, r0
            coolant_state_t cl_state = hal.coolant_get_state();
 800da28:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800da2a:	4798      	blx	r3

            char *append = &buf[3];

            strcpy(buf, "|A:");
 800da2c:	4b82      	ldr	r3, [pc, #520]	; (800dc38 <report_realtime_status+0x4e4>)
 800da2e:	4a83      	ldr	r2, [pc, #524]	; (800dc3c <report_realtime_status+0x4e8>)

            if (sp_state.on)
 800da30:	f018 0f01 	tst.w	r8, #1
 800da34:	fa5f f188 	uxtb.w	r1, r8
            strcpy(buf, "|A:");
 800da38:	601a      	str	r2, [r3, #0]
            if (sp_state.on)
 800da3a:	f000 8134 	beq.w	800dca6 <report_realtime_status+0x552>
                *append++ = sp_state.ccw ? 'C' : 'S';
 800da3e:	f011 0f02 	tst.w	r1, #2
 800da42:	bf14      	ite	ne
 800da44:	2243      	movne	r2, #67	; 0x43
 800da46:	2253      	moveq	r2, #83	; 0x53
 800da48:	3304      	adds	r3, #4
 800da4a:	f803 2c01 	strb.w	r2, [r3, #-1]

            if (cl_state.flood)
 800da4e:	b2c2      	uxtb	r2, r0
 800da50:	07c0      	lsls	r0, r0, #31
                *append++ = 'F';
 800da52:	bf44      	itt	mi
 800da54:	2146      	movmi	r1, #70	; 0x46
 800da56:	f803 1b01 	strbmi.w	r1, [r3], #1

            if (cl_state.mist)
 800da5a:	0791      	lsls	r1, r2, #30
                *append++ = 'M';
 800da5c:	bf44      	itt	mi
 800da5e:	224d      	movmi	r2, #77	; 0x4d
 800da60:	f803 2b01 	strbmi.w	r2, [r3], #1

            if(gc_state.tool_change && !sys.report.tool)
 800da64:	f897 2080 	ldrb.w	r2, [r7, #128]	; 0x80
 800da68:	b132      	cbz	r2, 800da78 <report_realtime_status+0x324>
 800da6a:	f995 2014 	ldrsb.w	r2, [r5, #20]
 800da6e:	2a00      	cmp	r2, #0
                *append++ = 'T';
 800da70:	bfa4      	itt	ge
 800da72:	2254      	movge	r2, #84	; 0x54
 800da74:	f803 2b01 	strbge.w	r2, [r3], #1

            *append = '\0';
 800da78:	2200      	movs	r2, #0
            hal.stream.write_all(buf);
 800da7a:	486f      	ldr	r0, [pc, #444]	; (800dc38 <report_realtime_status+0x4e4>)
            *append = '\0';
 800da7c:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all(buf);
 800da7e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800da80:	4798      	blx	r3
 800da82:	7d2b      	ldrb	r3, [r5, #20]
        }

        if(sys.report.scaling) {
 800da84:	079a      	lsls	r2, r3, #30
 800da86:	f100 8132 	bmi.w	800dcee <report_realtime_status+0x59a>
            axis_signals_tostring(buf, gc_get_g51_state());
            hal.stream.write_all("|Sc:");
            hal.stream.write_all(buf);
        }

        if(sys.report.mpg_mode && hal.driver_cap.mpg_mode)
 800da8a:	07d8      	lsls	r0, r3, #31
 800da8c:	d504      	bpl.n	800da98 <report_realtime_status+0x344>
 800da8e:	f894 2147 	ldrb.w	r2, [r4, #327]	; 0x147
 800da92:	0751      	lsls	r1, r2, #29
 800da94:	f100 81a3 	bmi.w	800ddde <report_realtime_status+0x68a>
            hal.stream.write_all(sys.mpg_mode ? "|MPG:1" : "|MPG:0");

        if(sys.report.homed && (sys.homing.mask || settings.homing.flags.single_axis_commands || settings.homing.flags.manual)) {
 800da98:	075a      	lsls	r2, r3, #29
 800da9a:	d51a      	bpl.n	800dad2 <report_realtime_status+0x37e>
 800da9c:	7b29      	ldrb	r1, [r5, #12]
 800da9e:	b929      	cbnz	r1, 800daac <report_realtime_status+0x358>
 800daa0:	f896 20d0 	ldrb.w	r2, [r6, #208]	; 0xd0
 800daa4:	f012 0f12 	tst.w	r2, #18
 800daa8:	d013      	beq.n	800dad2 <report_realtime_status+0x37e>
            axes_signals_t homing = {sys.homing.mask ? sys.homing.mask : AXES_BITMASK};
 800daaa:	2107      	movs	r1, #7
            hal.stream.write_all(appendbuf(2, "|H:", (homing.mask & sys.homed.mask) == homing.mask ? "1" : "0"));
 800daac:	7b68      	ldrb	r0, [r5, #13]
 800daae:	4b64      	ldr	r3, [pc, #400]	; (800dc40 <report_realtime_status+0x4ec>)
 800dab0:	4381      	bics	r1, r0
 800dab2:	4a64      	ldr	r2, [pc, #400]	; (800dc44 <report_realtime_status+0x4f0>)
 800dab4:	4964      	ldr	r1, [pc, #400]	; (800dc48 <report_realtime_status+0x4f4>)
 800dab6:	bf18      	it	ne
 800dab8:	461a      	movne	r2, r3
 800daba:	2002      	movs	r0, #2
 800dabc:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800dac0:	f7fe fa4c 	bl	800bf5c <appendbuf.constprop.1>
 800dac4:	47c0      	blx	r8
            if(settings.homing.flags.single_axis_commands)
 800dac6:	f896 30d0 	ldrb.w	r3, [r6, #208]	; 0xd0
 800daca:	0798      	lsls	r0, r3, #30
 800dacc:	f100 8206 	bmi.w	800dedc <report_realtime_status+0x788>
 800dad0:	7d2b      	ldrb	r3, [r5, #20]
                hal.stream.write_all(appendbuf(2, ",", uitoa(sys.homed.mask)));
        }

        if(sys.report.xmode && settings.flags.lathe_mode)
 800dad2:	0719      	lsls	r1, r3, #28
 800dad4:	d50d      	bpl.n	800daf2 <report_realtime_status+0x39e>
 800dad6:	f996 20bd 	ldrsb.w	r2, [r6, #189]	; 0xbd
 800dada:	2a00      	cmp	r2, #0
 800dadc:	da09      	bge.n	800daf2 <report_realtime_status+0x39e>
            hal.stream.write_all(gc_state.modal.diameter_mode ? "|D:1" : "|D:0");
 800dade:	7938      	ldrb	r0, [r7, #4]
 800dae0:	495a      	ldr	r1, [pc, #360]	; (800dc4c <report_realtime_status+0x4f8>)
 800dae2:	4a5b      	ldr	r2, [pc, #364]	; (800dc50 <report_realtime_status+0x4fc>)
 800dae4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dae6:	2800      	cmp	r0, #0
 800dae8:	bf14      	ite	ne
 800daea:	4608      	movne	r0, r1
 800daec:	4610      	moveq	r0, r2
 800daee:	4798      	blx	r3
 800daf0:	7d2b      	ldrb	r3, [r5, #20]

        if(sys.report.tool)
 800daf2:	061a      	lsls	r2, r3, #24
 800daf4:	f100 81fe 	bmi.w	800def4 <report_realtime_status+0x7a0>
            hal.stream.write_all(appendbuf(2, "|T:", uitoa((uint32_t)gc_state.tool->tool)));
    }

    if(hal.driver_rt_report)
 800daf8:	f8d4 30b4 	ldr.w	r3, [r4, #180]	; 0xb4
 800dafc:	b113      	cbz	r3, 800db04 <report_realtime_status+0x3b0>
        hal.driver_rt_report(hal.stream.write_all, sys.report);
 800dafe:	8aa9      	ldrh	r1, [r5, #20]
 800db00:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800db02:	4798      	blx	r3

    sys.report.value = 0;
 800db04:	2200      	movs	r2, #0
    sys.report.wco = settings.status_report.work_coord_offset && wco_counter == 0; // Set to report on next request
 800db06:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
    sys.report.value = 0;
 800db0a:	82aa      	strh	r2, [r5, #20]
    sys.report.wco = settings.status_report.work_coord_offset && wco_counter == 0; // Set to report on next request
 800db0c:	f013 0320 	ands.w	r3, r3, #32
 800db10:	d004      	beq.n	800db1c <report_realtime_status+0x3c8>
 800db12:	4b45      	ldr	r3, [pc, #276]	; (800dc28 <report_realtime_status+0x4d4>)
 800db14:	781b      	ldrb	r3, [r3, #0]
 800db16:	fab3 f383 	clz	r3, r3
 800db1a:	095b      	lsrs	r3, r3, #5
 800db1c:	7d6a      	ldrb	r2, [r5, #21]

    hal.stream.write_all(">\r\n");
 800db1e:	6ea1      	ldr	r1, [r4, #104]	; 0x68
    sys.report.wco = settings.status_report.work_coord_offset && wco_counter == 0; // Set to report on next request
 800db20:	f363 0200 	bfi	r2, r3, #0, #1
    hal.stream.write_all(">\r\n");
 800db24:	484b      	ldr	r0, [pc, #300]	; (800dc54 <report_realtime_status+0x500>)
    sys.report.wco = settings.status_report.work_coord_offset && wco_counter == 0; // Set to report on next request
 800db26:	756a      	strb	r2, [r5, #21]
    hal.stream.write_all(">\r\n");
 800db28:	4788      	blx	r1

    if(settings.flags.report_parser_state) {
 800db2a:	f896 30bd 	ldrb.w	r3, [r6, #189]	; 0xbd
 800db2e:	079b      	lsls	r3, r3, #30
 800db30:	d52a      	bpl.n	800db88 <report_realtime_status+0x434>

        static uint8_t tool;
        static float feed_rate, spindle_rpm;
        static gc_modal_t last_state;

        if (memcmp(&last_state, &gc_state.modal, sizeof(gc_modal_t)) || feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool != gc_state.tool->tool) {
 800db32:	2228      	movs	r2, #40	; 0x28
 800db34:	493d      	ldr	r1, [pc, #244]	; (800dc2c <report_realtime_status+0x4d8>)
 800db36:	4848      	ldr	r0, [pc, #288]	; (800dc58 <report_realtime_status+0x504>)
 800db38:	f004 f888 	bl	8011c4c <memcmp>
 800db3c:	2800      	cmp	r0, #0
 800db3e:	f000 80b4 	beq.w	800dcaa <report_realtime_status+0x556>
 800db42:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800db46:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
 800db4a:	f8d7 b048 	ldr.w	fp, [r7, #72]	; 0x48
 800db4e:	f893 c010 	ldrb.w	ip, [r3, #16]
 800db52:	f8df 811c 	ldr.w	r8, [pc, #284]	; 800dc70 <report_realtime_status+0x51c>
 800db56:	f8df a11c 	ldr.w	sl, [pc, #284]	; 800dc74 <report_realtime_status+0x520>
 800db5a:	4f40      	ldr	r7, [pc, #256]	; (800dc5c <report_realtime_status+0x508>)
            last_state = gc_state.modal;
 800db5c:	4e33      	ldr	r6, [pc, #204]	; (800dc2c <report_realtime_status+0x4d8>)
 800db5e:	4d3e      	ldr	r5, [pc, #248]	; (800dc58 <report_realtime_status+0x504>)
 800db60:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800db62:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800db64:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800db66:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800db68:	e896 0003 	ldmia.w	r6, {r0, r1}
            feed_rate = gc_state.feed_rate;
            tool = gc_state.tool->tool;
            spindle_rpm = gc_state.spindle.rpm;
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 800db6c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
            last_state = gc_state.modal;
 800db70:	e885 0003 	stmia.w	r5, {r0, r1}
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 800db74:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800db78:	4839      	ldr	r0, [pc, #228]	; (800dc60 <report_realtime_status+0x50c>)
            feed_rate = gc_state.feed_rate;
 800db7a:	f8c8 9000 	str.w	r9, [r8]
            tool = gc_state.tool->tool;
 800db7e:	f887 c000 	strb.w	ip, [r7]
            spindle_rpm = gc_state.spindle.rpm;
 800db82:	f8ca b000 	str.w	fp, [sl]
            system_set_exec_state_flag(EXEC_GCODE_REPORT);
 800db86:	4798      	blx	r3
        }
    }
}
 800db88:	b013      	add	sp, #76	; 0x4c
 800db8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        hal.stream.write_all("|Bf:");
 800db8e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800db90:	4834      	ldr	r0, [pc, #208]	; (800dc64 <report_realtime_status+0x510>)
 800db92:	4798      	blx	r3
        hal.stream.write_all(uitoa((uint32_t)plan_get_block_buffer_available()));
 800db94:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800db96:	f7fd fa45 	bl	800b024 <plan_get_block_buffer_available>
 800db9a:	f7fc fa6b 	bl	800a074 <uitoa>
 800db9e:	47b8      	blx	r7
        hal.stream.write_all(",");
 800dba0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dba2:	4831      	ldr	r0, [pc, #196]	; (800dc68 <report_realtime_status+0x514>)
 800dba4:	4798      	blx	r3
        hal.stream.write_all(uitoa(hal.stream.get_rx_buffer_available()));
 800dba6:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800dba8:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800dbaa:	4798      	blx	r3
 800dbac:	f7fc fa62 	bl	800a074 <uitoa>
 800dbb0:	47b8      	blx	r7
 800dbb2:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
    if(settings.status_report.line_numbers) {
 800dbb6:	0759      	lsls	r1, r3, #29
 800dbb8:	f57f ae4f 	bpl.w	800d85a <report_realtime_status+0x106>
        plan_block_t *cur_block = plan_get_current_block();
 800dbbc:	f7fc fe48 	bl	800a850 <plan_get_current_block>
        if (cur_block != NULL && cur_block->line_number > 0)
 800dbc0:	b118      	cbz	r0, 800dbca <report_realtime_status+0x476>
 800dbc2:	69c0      	ldr	r0, [r0, #28]
 800dbc4:	2800      	cmp	r0, #0
 800dbc6:	f300 817f 	bgt.w	800dec8 <report_realtime_status+0x774>
 800dbca:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
 800dbce:	e644      	b.n	800d85a <report_realtime_status+0x106>
    if (!settings.status_report.machine_position || sys.report.wco) {
 800dbd0:	7d6b      	ldrb	r3, [r5, #21]
 800dbd2:	07df      	lsls	r7, r3, #31
 800dbd4:	f53f ae0c 	bmi.w	800d7f0 <report_realtime_status+0x9c>
    hal.stream.write_all(settings.status_report.machine_position ? "|MPos:" : "|WPos:");
 800dbd8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dbda:	4824      	ldr	r0, [pc, #144]	; (800dc6c <report_realtime_status+0x518>)
 800dbdc:	e62c      	b.n	800d838 <report_realtime_status+0xe4>
            sys.report.overrides = On;
 800dbde:	7d2b      	ldrb	r3, [r5, #20]
 800dbe0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
            sys.report.spindle = sys.report.spindle || hal.spindle_get_state().on;
 800dbe4:	06da      	lsls	r2, r3, #27
            sys.report.overrides = On;
 800dbe6:	752b      	strb	r3, [r5, #20]
            sys.report.spindle = sys.report.spindle || hal.spindle_get_state().on;
 800dbe8:	f100 8104 	bmi.w	800ddf4 <report_realtime_status+0x6a0>
 800dbec:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800dbee:	4798      	blx	r3
 800dbf0:	7d2b      	ldrb	r3, [r5, #20]
 800dbf2:	f000 0001 	and.w	r0, r0, #1
 800dbf6:	f360 1304 	bfi	r3, r0, #4, #1
 800dbfa:	752b      	strb	r3, [r5, #20]
            sys.report.coolant = sys.report.coolant || hal.coolant_get_state().value != 0;
 800dbfc:	069b      	lsls	r3, r3, #26
 800dbfe:	f100 8101 	bmi.w	800de04 <report_realtime_status+0x6b0>
 800dc02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800dc04:	4798      	blx	r3
 800dc06:	b2c3      	uxtb	r3, r0
 800dc08:	3b00      	subs	r3, #0
 800dc0a:	bf18      	it	ne
 800dc0c:	2301      	movne	r3, #1
            override_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 800dc0e:	6829      	ldr	r1, [r5, #0]
            sys.report.coolant = sys.report.coolant || hal.coolant_get_state().value != 0;
 800dc10:	7d2a      	ldrb	r2, [r5, #20]
            override_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 800dc12:	f011 0f7c 	tst.w	r1, #124	; 0x7c
 800dc16:	bf14      	ite	ne
 800dc18:	2113      	movne	r1, #19
 800dc1a:	2109      	moveq	r1, #9
            sys.report.coolant = sys.report.coolant || hal.coolant_get_state().value != 0;
 800dc1c:	f363 1245 	bfi	r2, r3, #5, #1
            override_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 800dc20:	7039      	strb	r1, [r7, #0]
            sys.report.coolant = sys.report.coolant || hal.coolant_get_state().value != 0;
 800dc22:	752a      	strb	r2, [r5, #20]
            override_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 800dc24:	e6be      	b.n	800d9a4 <report_realtime_status+0x250>
 800dc26:	bf00      	nop
 800dc28:	20001ad1 	.word	0x20001ad1
 800dc2c:	200023dc 	.word	0x200023dc
 800dc30:	08014d78 	.word	0x08014d78
 800dc34:	08014d80 	.word	0x08014d80
 800dc38:	20001a68 	.word	0x20001a68
 800dc3c:	003a417c 	.word	0x003a417c
 800dc40:	08014c64 	.word	0x08014c64
 800dc44:	08014cf4 	.word	0x08014cf4
 800dc48:	08014d98 	.word	0x08014d98
 800dc4c:	08014cf8 	.word	0x08014cf8
 800dc50:	08014d00 	.word	0x08014d00
 800dc54:	08014da0 	.word	0x08014da0
 800dc58:	20001aa0 	.word	0x20001aa0
 800dc5c:	20001ad0 	.word	0x20001ad0
 800dc60:	200024b4 	.word	0x200024b4
 800dc64:	08014d5c 	.word	0x08014d5c
 800dc68:	080149a4 	.word	0x080149a4
 800dc6c:	08014cd4 	.word	0x08014cd4
 800dc70:	20001a94 	.word	0x20001a94
 800dc74:	20001acc 	.word	0x20001acc
            wco_counter = sys.state & (STATE_HOMING|STATE_CYCLE|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR)
 800dc78:	6829      	ldr	r1, [r5, #0]
 800dc7a:	f011 0f7c 	tst.w	r1, #124	; 0x7c
 800dc7e:	bf14      	ite	ne
 800dc80:	211d      	movne	r1, #29
 800dc82:	2109      	moveq	r1, #9
 800dc84:	7011      	strb	r1, [r2, #0]
 800dc86:	e640      	b.n	800d90a <report_realtime_status+0x1b6>
            hal.stream.write_all(appendbuf(2, "|F:", get_rate_value(st_get_realtime_rate())));
 800dc88:	f003 f9d4 	bl	8011034 <st_get_realtime_rate>
 800dc8c:	47c8      	blx	r9
 800dc8e:	49a9      	ldr	r1, [pc, #676]	; (800df34 <report_realtime_status+0x7e0>)
 800dc90:	4602      	mov	r2, r0
 800dc92:	2002      	movs	r0, #2
 800dc94:	f7fe f962 	bl	800bf5c <appendbuf.constprop.1>
 800dc98:	47b8      	blx	r7
 800dc9a:	f896 30bb 	ldrb.w	r3, [r6, #187]	; 0xbb
    if(settings.status_report.pin_state) {
 800dc9e:	06df      	lsls	r7, r3, #27
 800dca0:	f57f ae2c 	bpl.w	800d8fc <report_realtime_status+0x1a8>
 800dca4:	e612      	b.n	800d8cc <report_realtime_status+0x178>
            char *append = &buf[3];
 800dca6:	3303      	adds	r3, #3
 800dca8:	e6d1      	b.n	800da4e <report_realtime_status+0x2fa>
        if (memcmp(&last_state, &gc_state.modal, sizeof(gc_modal_t)) || feed_rate != gc_state.feed_rate || spindle_rpm != gc_state.spindle.rpm || tool != gc_state.tool->tool) {
 800dcaa:	f8d7 9064 	ldr.w	r9, [r7, #100]	; 0x64
 800dcae:	f8df 82dc 	ldr.w	r8, [pc, #732]	; 800df8c <report_realtime_status+0x838>
 800dcb2:	4648      	mov	r0, r9
 800dcb4:	f8d8 1000 	ldr.w	r1, [r8]
 800dcb8:	f7f2 ff00 	bl	8000abc <__aeabi_fcmpeq>
 800dcbc:	2800      	cmp	r0, #0
 800dcbe:	f000 80f9 	beq.w	800deb4 <report_realtime_status+0x760>
 800dcc2:	f8d7 b048 	ldr.w	fp, [r7, #72]	; 0x48
 800dcc6:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 800df90 <report_realtime_status+0x83c>
 800dcca:	4658      	mov	r0, fp
 800dccc:	f8da 1000 	ldr.w	r1, [sl]
 800dcd0:	f7f2 fef4 	bl	8000abc <__aeabi_fcmpeq>
 800dcd4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800dcd8:	4f97      	ldr	r7, [pc, #604]	; (800df38 <report_realtime_status+0x7e4>)
 800dcda:	f893 c010 	ldrb.w	ip, [r3, #16]
 800dcde:	2800      	cmp	r0, #0
 800dce0:	f43f af3c 	beq.w	800db5c <report_realtime_status+0x408>
 800dce4:	783b      	ldrb	r3, [r7, #0]
 800dce6:	4563      	cmp	r3, ip
 800dce8:	f47f af38 	bne.w	800db5c <report_realtime_status+0x408>
 800dcec:	e74c      	b.n	800db88 <report_realtime_status+0x434>
            axis_signals_tostring(buf, gc_get_g51_state());
 800dcee:	f7f7 fbef 	bl	80054d0 <gc_get_g51_state>
    if(signals.x)
 800dcf2:	b2c2      	uxtb	r2, r0
 800dcf4:	07c0      	lsls	r0, r0, #31
        *buf++ = 'X';
 800dcf6:	bf45      	ittet	mi
 800dcf8:	2158      	movmi	r1, #88	; 0x58
 800dcfa:	4b90      	ldrmi	r3, [pc, #576]	; (800df3c <report_realtime_status+0x7e8>)
 800dcfc:	4b8f      	ldrpl	r3, [pc, #572]	; (800df3c <report_realtime_status+0x7e8>)
 800dcfe:	f803 1b01 	strbmi.w	r1, [r3], #1
    if(signals.y)
 800dd02:	0791      	lsls	r1, r2, #30
        *buf++ = 'Y';
 800dd04:	bf44      	itt	mi
 800dd06:	2159      	movmi	r1, #89	; 0x59
 800dd08:	f803 1b01 	strbmi.w	r1, [r3], #1
    if (signals.z)
 800dd0c:	0752      	lsls	r2, r2, #29
        *buf++ = 'Z';
 800dd0e:	bf44      	itt	mi
 800dd10:	225a      	movmi	r2, #90	; 0x5a
 800dd12:	f803 2b01 	strbmi.w	r2, [r3], #1
    *buf = '\0';
 800dd16:	2200      	movs	r2, #0
            hal.stream.write_all("|Sc:");
 800dd18:	4889      	ldr	r0, [pc, #548]	; (800df40 <report_realtime_status+0x7ec>)
    *buf = '\0';
 800dd1a:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all("|Sc:");
 800dd1c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd1e:	4798      	blx	r3
            hal.stream.write_all(buf);
 800dd20:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd22:	4886      	ldr	r0, [pc, #536]	; (800df3c <report_realtime_status+0x7e8>)
 800dd24:	4798      	blx	r3
 800dd26:	7d2b      	ldrb	r3, [r5, #20]
 800dd28:	e6af      	b.n	800da8a <report_realtime_status+0x336>
            hal.stream.write_all(appendbuf(2, "|Ov:", uitoa((uint32_t)sys.override.feed_rate)));
 800dd2a:	7ba8      	ldrb	r0, [r5, #14]
 800dd2c:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800dd30:	f7fc f9a0 	bl	800a074 <uitoa>
 800dd34:	4983      	ldr	r1, [pc, #524]	; (800df44 <report_realtime_status+0x7f0>)
 800dd36:	4602      	mov	r2, r0
 800dd38:	2002      	movs	r0, #2
 800dd3a:	f7fe f90f 	bl	800bf5c <appendbuf.constprop.1>
 800dd3e:	47c0      	blx	r8
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.rapid_rate)));
 800dd40:	7be8      	ldrb	r0, [r5, #15]
 800dd42:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800dd46:	f7fc f995 	bl	800a074 <uitoa>
 800dd4a:	497f      	ldr	r1, [pc, #508]	; (800df48 <report_realtime_status+0x7f4>)
 800dd4c:	4602      	mov	r2, r0
 800dd4e:	2002      	movs	r0, #2
 800dd50:	f7fe f904 	bl	800bf5c <appendbuf.constprop.1>
 800dd54:	47c0      	blx	r8
            hal.stream.write_all(appendbuf(2, ",", uitoa((uint32_t)sys.override.spindle_rpm)));
 800dd56:	7c28      	ldrb	r0, [r5, #16]
 800dd58:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800dd5c:	f7fc f98a 	bl	800a074 <uitoa>
 800dd60:	4979      	ldr	r1, [pc, #484]	; (800df48 <report_realtime_status+0x7f4>)
 800dd62:	4602      	mov	r2, r0
 800dd64:	2002      	movs	r0, #2
 800dd66:	f7fe f8f9 	bl	800bf5c <appendbuf.constprop.1>
 800dd6a:	47c0      	blx	r8
 800dd6c:	7d2b      	ldrb	r3, [r5, #20]
 800dd6e:	e651      	b.n	800da14 <report_realtime_status+0x2c0>
            hal.stream.write_all("Idle");
 800dd70:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd72:	4876      	ldr	r0, [pc, #472]	; (800df4c <report_realtime_status+0x7f8>)
 800dd74:	4798      	blx	r3
            break;
 800dd76:	4e76      	ldr	r6, [pc, #472]	; (800df50 <report_realtime_status+0x7fc>)
 800dd78:	e535      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all("Home");
 800dd7a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd7c:	4875      	ldr	r0, [pc, #468]	; (800df54 <report_realtime_status+0x800>)
 800dd7e:	4798      	blx	r3
            break;
 800dd80:	4e73      	ldr	r6, [pc, #460]	; (800df50 <report_realtime_status+0x7fc>)
 800dd82:	e530      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all("Run");
 800dd84:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd86:	4874      	ldr	r0, [pc, #464]	; (800df58 <report_realtime_status+0x804>)
 800dd88:	4798      	blx	r3
            if(sys.flags.feed_hold_pending)
 800dd8a:	7a6b      	ldrb	r3, [r5, #9]
 800dd8c:	0699      	lsls	r1, r3, #26
 800dd8e:	f57f ad29 	bpl.w	800d7e4 <report_realtime_status+0x90>
                hal.stream.write_all(":1");
 800dd92:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dd94:	4871      	ldr	r0, [pc, #452]	; (800df5c <report_realtime_status+0x808>)
 800dd96:	4798      	blx	r3
 800dd98:	4e6d      	ldr	r6, [pc, #436]	; (800df50 <report_realtime_status+0x7fc>)
 800dd9a:	e524      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all(appendbuf(2, "Hold:", uitoa((uint32_t)(sys.holding_state - 1))));
 800dd9c:	7de8      	ldrb	r0, [r5, #23]
 800dd9e:	6ea6      	ldr	r6, [r4, #104]	; 0x68
 800dda0:	3801      	subs	r0, #1
 800dda2:	f7fc f967 	bl	800a074 <uitoa>
 800dda6:	496e      	ldr	r1, [pc, #440]	; (800df60 <report_realtime_status+0x80c>)
 800dda8:	4602      	mov	r2, r0
 800ddaa:	2002      	movs	r0, #2
 800ddac:	f7fe f8d6 	bl	800bf5c <appendbuf.constprop.1>
 800ddb0:	47b0      	blx	r6
            break;
 800ddb2:	4e67      	ldr	r6, [pc, #412]	; (800df50 <report_realtime_status+0x7fc>)
 800ddb4:	e517      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all("Jog");
 800ddb6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800ddb8:	486a      	ldr	r0, [pc, #424]	; (800df64 <report_realtime_status+0x810>)
 800ddba:	4798      	blx	r3
            break;
 800ddbc:	4e64      	ldr	r6, [pc, #400]	; (800df50 <report_realtime_status+0x7fc>)
 800ddbe:	e512      	b.n	800d7e6 <report_realtime_status+0x92>
            if(settings.flags.report_alarm_substate)
 800ddc0:	4e63      	ldr	r6, [pc, #396]	; (800df50 <report_realtime_status+0x7fc>)
 800ddc2:	f896 30bd 	ldrb.w	r3, [r6, #189]	; 0xbd
 800ddc6:	071a      	lsls	r2, r3, #28
 800ddc8:	f100 80ec 	bmi.w	800dfa4 <report_realtime_status+0x850>
                hal.stream.write_all("Alarm");
 800ddcc:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800ddce:	4866      	ldr	r0, [pc, #408]	; (800df68 <report_realtime_status+0x814>)
 800ddd0:	4798      	blx	r3
 800ddd2:	e508      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all("Check");
 800ddd4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800ddd6:	4865      	ldr	r0, [pc, #404]	; (800df6c <report_realtime_status+0x818>)
 800ddd8:	4798      	blx	r3
            break;
 800ddda:	4e5d      	ldr	r6, [pc, #372]	; (800df50 <report_realtime_status+0x7fc>)
 800dddc:	e503      	b.n	800d7e6 <report_realtime_status+0x92>
            hal.stream.write_all(sys.mpg_mode ? "|MPG:1" : "|MPG:0");
 800ddde:	7a28      	ldrb	r0, [r5, #8]
 800dde0:	4963      	ldr	r1, [pc, #396]	; (800df70 <report_realtime_status+0x81c>)
 800dde2:	4a64      	ldr	r2, [pc, #400]	; (800df74 <report_realtime_status+0x820>)
 800dde4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800dde6:	2800      	cmp	r0, #0
 800dde8:	bf14      	ite	ne
 800ddea:	4608      	movne	r0, r1
 800ddec:	4610      	moveq	r0, r2
 800ddee:	4798      	blx	r3
 800ddf0:	7d2b      	ldrb	r3, [r5, #20]
 800ddf2:	e651      	b.n	800da98 <report_realtime_status+0x344>
 800ddf4:	2001      	movs	r0, #1
            sys.report.spindle = sys.report.spindle || hal.spindle_get_state().on;
 800ddf6:	7d2b      	ldrb	r3, [r5, #20]
 800ddf8:	f360 1304 	bfi	r3, r0, #4, #1
 800ddfc:	752b      	strb	r3, [r5, #20]
            sys.report.coolant = sys.report.coolant || hal.coolant_get_state().value != 0;
 800ddfe:	069b      	lsls	r3, r3, #26
 800de00:	f57f aeff 	bpl.w	800dc02 <report_realtime_status+0x4ae>
 800de04:	2301      	movs	r3, #1
 800de06:	e702      	b.n	800dc0e <report_realtime_status+0x4ba>
                *append++ = 'P';
 800de08:	2150      	movs	r1, #80	; 0x50
            strcpy(buf, "|Pn:");
 800de0a:	4b4c      	ldr	r3, [pc, #304]	; (800df3c <report_realtime_status+0x7e8>)
 800de0c:	4a5a      	ldr	r2, [pc, #360]	; (800df78 <report_realtime_status+0x824>)
                *append++ = 'P';
 800de0e:	7119      	strb	r1, [r3, #4]
            strcpy(buf, "|Pn:");
 800de10:	601a      	str	r2, [r3, #0]
                *append++ = 'P';
 800de12:	3305      	adds	r3, #5
            if (lim_pin_state.value)
 800de14:	f1b9 0f00 	cmp.w	r9, #0
 800de18:	d013      	beq.n	800de42 <report_realtime_status+0x6ee>
    if(signals.x)
 800de1a:	f019 0f01 	tst.w	r9, #1
        *buf++ = 'X';
 800de1e:	bf1c      	itt	ne
 800de20:	2258      	movne	r2, #88	; 0x58
 800de22:	f803 2b01 	strbne.w	r2, [r3], #1
    if(signals.y)
 800de26:	f019 0f02 	tst.w	r9, #2
        *buf++ = 'Y';
 800de2a:	bf1c      	itt	ne
 800de2c:	2259      	movne	r2, #89	; 0x59
 800de2e:	f803 2b01 	strbne.w	r2, [r3], #1
    if (signals.z)
 800de32:	f019 0f04 	tst.w	r9, #4
        *buf++ = 'Z';
 800de36:	bf1c      	itt	ne
 800de38:	225a      	movne	r2, #90	; 0x5a
 800de3a:	f803 2b01 	strbne.w	r2, [r3], #1
    *buf = '\0';
 800de3e:	2200      	movs	r2, #0
 800de40:	701a      	strb	r2, [r3, #0]
            if (ctrl_pin_state.value) {
 800de42:	2f00      	cmp	r7, #0
 800de44:	d030      	beq.n	800dea8 <report_realtime_status+0x754>
                if (ctrl_pin_state.safety_door_ajar && hal.driver_cap.safety_door)
 800de46:	0738      	lsls	r0, r7, #28
 800de48:	d506      	bpl.n	800de58 <report_realtime_status+0x704>
 800de4a:	f894 2144 	ldrb.w	r2, [r4, #324]	; 0x144
 800de4e:	0751      	lsls	r1, r2, #29
                    *append++ = 'D';
 800de50:	bf44      	itt	mi
 800de52:	2244      	movmi	r2, #68	; 0x44
 800de54:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (ctrl_pin_state.reset)
 800de58:	07fa      	lsls	r2, r7, #31
                    *append++ = 'R';
 800de5a:	bf44      	itt	mi
 800de5c:	2252      	movmi	r2, #82	; 0x52
 800de5e:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (ctrl_pin_state.feed_hold)
 800de62:	07b8      	lsls	r0, r7, #30
                    *append++ = 'H';
 800de64:	bf44      	itt	mi
 800de66:	2248      	movmi	r2, #72	; 0x48
 800de68:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (ctrl_pin_state.cycle_start)
 800de6c:	0779      	lsls	r1, r7, #29
                    *append++ = 'S';
 800de6e:	bf44      	itt	mi
 800de70:	2253      	movmi	r2, #83	; 0x53
 800de72:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (ctrl_pin_state.e_stop)
 800de76:	067a      	lsls	r2, r7, #25
                    *append++ = 'E';
 800de78:	bf44      	itt	mi
 800de7a:	2245      	movmi	r2, #69	; 0x45
 800de7c:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (ctrl_pin_state.block_delete && sys.flags.block_delete_enabled)
 800de80:	06f8      	lsls	r0, r7, #27
 800de82:	d505      	bpl.n	800de90 <report_realtime_status+0x73c>
 800de84:	7a6a      	ldrb	r2, [r5, #9]
 800de86:	06d1      	lsls	r1, r2, #27
                    *append++ = 'B';
 800de88:	bf44      	itt	mi
 800de8a:	2242      	movmi	r2, #66	; 0x42
 800de8c:	f803 2b01 	strbmi.w	r2, [r3], #1
                if (hal.driver_cap.program_stop ? ctrl_pin_state.stop_disable : sys.flags.optional_stop_disable)
 800de90:	f894 2145 	ldrb.w	r2, [r4, #325]	; 0x145
 800de94:	0712      	lsls	r2, r2, #28
 800de96:	bf56      	itet	pl
 800de98:	7a6f      	ldrbpl	r7, [r5, #9]
 800de9a:	f3c7 1740 	ubfxmi	r7, r7, #5, #1
 800de9e:	09ff      	lsrpl	r7, r7, #7
 800dea0:	b117      	cbz	r7, 800dea8 <report_realtime_status+0x754>
                    *append++ = 'T';
 800dea2:	2254      	movs	r2, #84	; 0x54
 800dea4:	f803 2b01 	strb.w	r2, [r3], #1
            *append = '\0';
 800dea8:	2200      	movs	r2, #0
            hal.stream.write_all(buf);
 800deaa:	4824      	ldr	r0, [pc, #144]	; (800df3c <report_realtime_status+0x7e8>)
            *append = '\0';
 800deac:	701a      	strb	r2, [r3, #0]
            hal.stream.write_all(buf);
 800deae:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800deb0:	4798      	blx	r3
 800deb2:	e521      	b.n	800d8f8 <report_realtime_status+0x1a4>
 800deb4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800deb8:	f8d7 b048 	ldr.w	fp, [r7, #72]	; 0x48
 800debc:	f893 c010 	ldrb.w	ip, [r3, #16]
 800dec0:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 800df90 <report_realtime_status+0x83c>
 800dec4:	4f1c      	ldr	r7, [pc, #112]	; (800df38 <report_realtime_status+0x7e4>)
 800dec6:	e649      	b.n	800db5c <report_realtime_status+0x408>
            hal.stream.write_all(appendbuf(2, "|Ln:", uitoa((uint32_t)cur_block->line_number)));
 800dec8:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800deca:	f7fc f8d3 	bl	800a074 <uitoa>
 800dece:	492b      	ldr	r1, [pc, #172]	; (800df7c <report_realtime_status+0x828>)
 800ded0:	4602      	mov	r2, r0
 800ded2:	2002      	movs	r0, #2
 800ded4:	f7fe f842 	bl	800bf5c <appendbuf.constprop.1>
 800ded8:	47b8      	blx	r7
 800deda:	e676      	b.n	800dbca <report_realtime_status+0x476>
                hal.stream.write_all(appendbuf(2, ",", uitoa(sys.homed.mask)));
 800dedc:	7b68      	ldrb	r0, [r5, #13]
 800dede:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800dee2:	f7fc f8c7 	bl	800a074 <uitoa>
 800dee6:	4918      	ldr	r1, [pc, #96]	; (800df48 <report_realtime_status+0x7f4>)
 800dee8:	4602      	mov	r2, r0
 800deea:	2002      	movs	r0, #2
 800deec:	f7fe f836 	bl	800bf5c <appendbuf.constprop.1>
 800def0:	47c0      	blx	r8
 800def2:	e5ed      	b.n	800dad0 <report_realtime_status+0x37c>
            hal.stream.write_all(appendbuf(2, "|T:", uitoa((uint32_t)gc_state.tool->tool)));
 800def4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800def8:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
 800defc:	7c18      	ldrb	r0, [r3, #16]
 800defe:	f7fc f8b9 	bl	800a074 <uitoa>
 800df02:	491f      	ldr	r1, [pc, #124]	; (800df80 <report_realtime_status+0x82c>)
 800df04:	4602      	mov	r2, r0
 800df06:	2002      	movs	r0, #2
 800df08:	f7fe f828 	bl	800bf5c <appendbuf.constprop.1>
 800df0c:	47c0      	blx	r8
 800df0e:	e5f3      	b.n	800daf8 <report_realtime_status+0x3a4>
        strcat(buf, ".");
 800df10:	4a1c      	ldr	r2, [pc, #112]	; (800df84 <report_realtime_status+0x830>)
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800df12:	f1a8 003b 	sub.w	r0, r8, #59	; 0x3b
        strcat(buf, ".");
 800df16:	8812      	ldrh	r2, [r2, #0]
 800df18:	801a      	strh	r2, [r3, #0]
        strcat(buf, uitoa((uint32_t)(g5x - 59)));
 800df1a:	f7fc f8ab 	bl	800a074 <uitoa>
 800df1e:	4601      	mov	r1, r0
 800df20:	4806      	ldr	r0, [pc, #24]	; (800df3c <report_realtime_status+0x7e8>)
 800df22:	f004 fa64 	bl	80123ee <strcat>
 800df26:	e56f      	b.n	800da08 <report_realtime_status+0x2b4>
            hal.stream.write_all("Sleep");
 800df28:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800df2a:	4817      	ldr	r0, [pc, #92]	; (800df88 <report_realtime_status+0x834>)
 800df2c:	4798      	blx	r3
            break;
 800df2e:	4e08      	ldr	r6, [pc, #32]	; (800df50 <report_realtime_status+0x7fc>)
 800df30:	e459      	b.n	800d7e6 <report_realtime_status+0x92>
 800df32:	bf00      	nop
 800df34:	08014d74 	.word	0x08014d74
 800df38:	20001ad0 	.word	0x20001ad0
 800df3c:	20001a68 	.word	0x20001a68
 800df40:	08014d90 	.word	0x08014d90
 800df44:	08014d88 	.word	0x08014d88
 800df48:	080149a4 	.word	0x080149a4
 800df4c:	08014d0c 	.word	0x08014d0c
 800df50:	20002620 	.word	0x20002620
 800df54:	08014d24 	.word	0x08014d24
 800df58:	08014d14 	.word	0x08014d14
 800df5c:	08014ce8 	.word	0x08014ce8
 800df60:	08014d18 	.word	0x08014d18
 800df64:	08014d20 	.word	0x08014d20
 800df68:	08014d34 	.word	0x08014d34
 800df6c:	08014d3c 	.word	0x08014d3c
 800df70:	08014ce4 	.word	0x08014ce4
 800df74:	08014cec 	.word	0x08014cec
 800df78:	3a6e507c 	.word	0x3a6e507c
 800df7c:	08014d64 	.word	0x08014d64
 800df80:	08014d9c 	.word	0x08014d9c
 800df84:	08014b48 	.word	0x08014b48
 800df88:	08014d4c 	.word	0x08014d4c
 800df8c:	20001a94 	.word	0x20001a94
 800df90:	20001acc 	.word	0x20001acc
            strcpy(buf, "|Pn:");
 800df94:	4a09      	ldr	r2, [pc, #36]	; (800dfbc <report_realtime_status+0x868>)
 800df96:	490a      	ldr	r1, [pc, #40]	; (800dfc0 <report_realtime_status+0x86c>)
 800df98:	4613      	mov	r3, r2
 800df9a:	c903      	ldmia	r1, {r0, r1}
 800df9c:	6010      	str	r0, [r2, #0]
 800df9e:	f803 1f04 	strb.w	r1, [r3, #4]!
            if (prb_pin_state)
 800dfa2:	e737      	b.n	800de14 <report_realtime_status+0x6c0>
                hal.stream.write_all(appendbuf(2, "Alarm:", uitoa((uint32_t)current_alarm)));
 800dfa4:	4b07      	ldr	r3, [pc, #28]	; (800dfc4 <report_realtime_status+0x870>)
 800dfa6:	6ea7      	ldr	r7, [r4, #104]	; 0x68
 800dfa8:	7818      	ldrb	r0, [r3, #0]
 800dfaa:	f7fc f863 	bl	800a074 <uitoa>
 800dfae:	4906      	ldr	r1, [pc, #24]	; (800dfc8 <report_realtime_status+0x874>)
 800dfb0:	4602      	mov	r2, r0
 800dfb2:	2002      	movs	r0, #2
 800dfb4:	f7fd ffd2 	bl	800bf5c <appendbuf.constprop.1>
 800dfb8:	47b8      	blx	r7
 800dfba:	e414      	b.n	800d7e6 <report_realtime_status+0x92>
 800dfbc:	20001a68 	.word	0x20001a68
 800dfc0:	08014da4 	.word	0x08014da4
 800dfc4:	20001a92 	.word	0x20001a92
 800dfc8:	08014d2c 	.word	0x08014d2c

0800dfcc <report_pid_log>:
    } while(idx != sys.pid_log.idx);

    hal.stream.write("]\r\n");
    hal.report.status_message(Status_OK);
#else
    hal.report.status_message(Status_GcodeUnsupportedCommand);
 800dfcc:	4b02      	ldr	r3, [pc, #8]	; (800dfd8 <report_pid_log+0xc>)
 800dfce:	2014      	movs	r0, #20
 800dfd0:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 800dfd4:	4718      	bx	r3
 800dfd6:	bf00      	nop
 800dfd8:	200024bc 	.word	0x200024bc

0800dfdc <settings_write_coord_data.part.0>:
    }
    return true;
}

// Write selected coordinate data to persistent storage.
void settings_write_coord_data (uint8_t idx, float (*coord_data)[N_AXIS])
 800dfdc:	b508      	push	{r3, lr}
{
    assert(idx <= SETTING_INDEX_NCOORD);
 800dfde:	21df      	movs	r1, #223	; 0xdf
 800dfe0:	4b02      	ldr	r3, [pc, #8]	; (800dfec <settings_write_coord_data.part.0+0x10>)
 800dfe2:	4a03      	ldr	r2, [pc, #12]	; (800dff0 <settings_write_coord_data.part.0+0x14>)
 800dfe4:	4803      	ldr	r0, [pc, #12]	; (800dff4 <settings_write_coord_data.part.0+0x18>)
 800dfe6:	f003 fdc7 	bl	8011b78 <__assert_func>
 800dfea:	bf00      	nop
 800dfec:	08014dac 	.word	0x08014dac
 800dff0:	08014e2c 	.word	0x08014e2c
 800dff4:	08014dc8 	.word	0x08014dc8

0800dff8 <settings_write_build_info>:
    if(hal.eeprom.type != EEPROM_None)
 800dff8:	4b05      	ldr	r3, [pc, #20]	; (800e010 <settings_write_build_info+0x18>)
{
 800dffa:	4601      	mov	r1, r0
    if(hal.eeprom.type != EEPROM_None)
 800dffc:	f893 20f4 	ldrb.w	r2, [r3, #244]	; 0xf4
 800e000:	b12a      	cbz	r2, 800e00e <settings_write_build_info+0x16>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_BUILD_INFO, (uint8_t *)line, MAX_STORED_LINE_LENGTH);
 800e002:	2246      	movs	r2, #70	; 0x46
 800e004:	f240 30ae 	movw	r0, #942	; 0x3ae
 800e008:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800e00c:	4718      	bx	r3
}
 800e00e:	4770      	bx	lr
 800e010:	200024bc 	.word	0x200024bc

0800e014 <settings_read_build_info>:
{
 800e014:	b570      	push	{r4, r5, r6, lr}
    if (!(hal.eeprom.type != EEPROM_None && hal.eeprom.memcpy_from_with_checksum((uint8_t *)line, EEPROM_ADDR_BUILD_INFO, MAX_STORED_LINE_LENGTH))) {
 800e016:	4e0e      	ldr	r6, [pc, #56]	; (800e050 <settings_read_build_info+0x3c>)
{
 800e018:	4605      	mov	r5, r0
    if (!(hal.eeprom.type != EEPROM_None && hal.eeprom.memcpy_from_with_checksum((uint8_t *)line, EEPROM_ADDR_BUILD_INFO, MAX_STORED_LINE_LENGTH))) {
 800e01a:	f896 30f4 	ldrb.w	r3, [r6, #244]	; 0xf4
 800e01e:	b13b      	cbz	r3, 800e030 <settings_read_build_info+0x1c>
 800e020:	2246      	movs	r2, #70	; 0x46
 800e022:	f240 31ae 	movw	r1, #942	; 0x3ae
 800e026:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800e02a:	4798      	blx	r3
 800e02c:	b100      	cbz	r0, 800e030 <settings_read_build_info+0x1c>
}
 800e02e:	bd70      	pop	{r4, r5, r6, pc}
        line[0] = 0; // Empty line
 800e030:	2400      	movs	r4, #0
 800e032:	702c      	strb	r4, [r5, #0]
    if(hal.eeprom.type != EEPROM_None)
 800e034:	f896 00f4 	ldrb.w	r0, [r6, #244]	; 0xf4
 800e038:	2800      	cmp	r0, #0
 800e03a:	d0f8      	beq.n	800e02e <settings_read_build_info+0x1a>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_BUILD_INFO, (uint8_t *)line, MAX_STORED_LINE_LENGTH);
 800e03c:	4629      	mov	r1, r5
 800e03e:	2246      	movs	r2, #70	; 0x46
 800e040:	f240 30ae 	movw	r0, #942	; 0x3ae
 800e044:	f8d6 3104 	ldr.w	r3, [r6, #260]	; 0x104
 800e048:	4798      	blx	r3
        return false;
 800e04a:	4620      	mov	r0, r4
}
 800e04c:	bd70      	pop	{r4, r5, r6, pc}
 800e04e:	bf00      	nop
 800e050:	200024bc 	.word	0x200024bc

0800e054 <settings_write_startup_line>:
    assert(idx < N_STARTUP_LINE);
 800e054:	2801      	cmp	r0, #1
 800e056:	d80e      	bhi.n	800e076 <settings_write_startup_line+0x22>
    if(hal.eeprom.type != EEPROM_None)
 800e058:	4b0a      	ldr	r3, [pc, #40]	; (800e084 <settings_write_startup_line+0x30>)
 800e05a:	f893 20f4 	ldrb.w	r2, [r3, #244]	; 0xf4
 800e05e:	b14a      	cbz	r2, 800e074 <settings_write_startup_line+0x20>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1), (uint8_t *)line, MAX_STORED_LINE_LENGTH);
 800e060:	eb00 02c0 	add.w	r2, r0, r0, lsl #3
 800e064:	ebc0 00c2 	rsb	r0, r0, r2, lsl #3
 800e068:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800e06c:	2246      	movs	r2, #70	; 0x46
 800e06e:	f200 301f 	addw	r0, r0, #799	; 0x31f
 800e072:	4718      	bx	r3
 800e074:	4770      	bx	lr
    assert(idx < N_STARTUP_LINE);
 800e076:	21c4      	movs	r1, #196	; 0xc4
{
 800e078:	b510      	push	{r4, lr}
    assert(idx < N_STARTUP_LINE);
 800e07a:	4b03      	ldr	r3, [pc, #12]	; (800e088 <settings_write_startup_line+0x34>)
 800e07c:	4a03      	ldr	r2, [pc, #12]	; (800e08c <settings_write_startup_line+0x38>)
 800e07e:	4804      	ldr	r0, [pc, #16]	; (800e090 <settings_write_startup_line+0x3c>)
 800e080:	f003 fd7a 	bl	8011b78 <__assert_func>
 800e084:	200024bc 	.word	0x200024bc
 800e088:	08014ddc 	.word	0x08014ddc
 800e08c:	08014df4 	.word	0x08014df4
 800e090:	08014dc8 	.word	0x08014dc8

0800e094 <settings_read_startup_line>:
    assert(idx < N_STARTUP_LINE);
 800e094:	2801      	cmp	r0, #1
{
 800e096:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    assert(idx < N_STARTUP_LINE);
 800e098:	d825      	bhi.n	800e0e6 <settings_read_startup_line+0x52>
    if (!(hal.eeprom.type != EEPROM_None && hal.eeprom.memcpy_from_with_checksum((uint8_t *)line, EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1), MAX_STORED_LINE_LENGTH))) {
 800e09a:	4f16      	ldr	r7, [pc, #88]	; (800e0f4 <settings_read_startup_line+0x60>)
 800e09c:	4604      	mov	r4, r0
 800e09e:	f897 30f4 	ldrb.w	r3, [r7, #244]	; 0xf4
 800e0a2:	460e      	mov	r6, r1
 800e0a4:	b163      	cbz	r3, 800e0c0 <settings_read_startup_line+0x2c>
 800e0a6:	eb00 01c0 	add.w	r1, r0, r0, lsl #3
 800e0aa:	ebc0 01c1 	rsb	r1, r0, r1, lsl #3
 800e0ae:	2246      	movs	r2, #70	; 0x46
 800e0b0:	4630      	mov	r0, r6
 800e0b2:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800e0b6:	f201 311f 	addw	r1, r1, #799	; 0x31f
 800e0ba:	4798      	blx	r3
 800e0bc:	b100      	cbz	r0, 800e0c0 <settings_read_startup_line+0x2c>
}
 800e0be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        *line = '\0'; // Empty line
 800e0c0:	2500      	movs	r5, #0
 800e0c2:	7035      	strb	r5, [r6, #0]
    if(hal.eeprom.type != EEPROM_None)
 800e0c4:	f897 00f4 	ldrb.w	r0, [r7, #244]	; 0xf4
 800e0c8:	2800      	cmp	r0, #0
 800e0ca:	d0f8      	beq.n	800e0be <settings_read_startup_line+0x2a>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_STARTUP_BLOCK + idx * (MAX_STORED_LINE_LENGTH + 1), (uint8_t *)line, MAX_STORED_LINE_LENGTH);
 800e0cc:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 800e0d0:	ebc4 00c0 	rsb	r0, r4, r0, lsl #3
 800e0d4:	4631      	mov	r1, r6
 800e0d6:	2246      	movs	r2, #70	; 0x46
 800e0d8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800e0dc:	f200 301f 	addw	r0, r0, #799	; 0x31f
 800e0e0:	4798      	blx	r3
        return false;
 800e0e2:	4628      	mov	r0, r5
}
 800e0e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert(idx < N_STARTUP_LINE);
 800e0e6:	21d1      	movs	r1, #209	; 0xd1
 800e0e8:	4b03      	ldr	r3, [pc, #12]	; (800e0f8 <settings_read_startup_line+0x64>)
 800e0ea:	4a04      	ldr	r2, [pc, #16]	; (800e0fc <settings_read_startup_line+0x68>)
 800e0ec:	4804      	ldr	r0, [pc, #16]	; (800e100 <settings_read_startup_line+0x6c>)
 800e0ee:	f003 fd43 	bl	8011b78 <__assert_func>
 800e0f2:	bf00      	nop
 800e0f4:	200024bc 	.word	0x200024bc
 800e0f8:	08014ddc 	.word	0x08014ddc
 800e0fc:	08014e10 	.word	0x08014e10
 800e100:	08014dc8 	.word	0x08014dc8

0800e104 <settings_write_coord_data>:
    assert(idx <= SETTING_INDEX_NCOORD);
 800e104:	280b      	cmp	r0, #11
 800e106:	d80e      	bhi.n	800e126 <settings_write_coord_data+0x22>

#ifdef FORCE_BUFFER_SYNC_DURING_EEPROM_WRITE
    protocol_buffer_synchronize();
#endif

    if(hal.eeprom.type != EEPROM_None)
 800e108:	4b08      	ldr	r3, [pc, #32]	; (800e12c <settings_write_coord_data+0x28>)
 800e10a:	f893 20f4 	ldrb.w	r2, [r3, #244]	; 0xf4
 800e10e:	b14a      	cbz	r2, 800e124 <settings_write_coord_data+0x20>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + 1), (uint8_t *)coord_data, sizeof(coord_data_t));
 800e110:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 800e114:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 800e118:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 800e11c:	220c      	movs	r2, #12
 800e11e:	f500 7000 	add.w	r0, r0, #512	; 0x200
 800e122:	4718      	bx	r3
 800e124:	4770      	bx	lr
{
 800e126:	b510      	push	{r4, lr}
 800e128:	f7ff ff58 	bl	800dfdc <settings_write_coord_data.part.0>
 800e12c:	200024bc 	.word	0x200024bc

0800e130 <settings_read_coord_data>:
}

// Read selected coordinate data from persistent storage.
bool settings_read_coord_data (uint8_t idx, float (*coord_data)[N_AXIS])
{
    assert(idx <= SETTING_INDEX_NCOORD);
 800e130:	280b      	cmp	r0, #11
{
 800e132:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    assert(idx <= SETTING_INDEX_NCOORD);
 800e134:	d827      	bhi.n	800e186 <settings_read_coord_data+0x56>

    if (!(hal.eeprom.type != EEPROM_None && hal.eeprom.memcpy_from_with_checksum((uint8_t *)coord_data, EEPROM_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + 1), sizeof(coord_data_t)))) {
 800e136:	4f17      	ldr	r7, [pc, #92]	; (800e194 <settings_read_coord_data+0x64>)
 800e138:	4604      	mov	r4, r0
 800e13a:	f897 30f4 	ldrb.w	r3, [r7, #244]	; 0xf4
 800e13e:	460e      	mov	r6, r1
 800e140:	b163      	cbz	r3, 800e15c <settings_read_coord_data+0x2c>
 800e142:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 800e146:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 800e14a:	220c      	movs	r2, #12
 800e14c:	4630      	mov	r0, r6
 800e14e:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 800e152:	f501 7100 	add.w	r1, r1, #512	; 0x200
 800e156:	4798      	blx	r3
 800e158:	b100      	cbz	r0, 800e15c <settings_read_coord_data+0x2c>
        memset(coord_data, 0, sizeof(coord_data_t));
        settings_write_coord_data(idx, coord_data);
        return false;
    }
    return true;
}
 800e15a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset(coord_data, 0, sizeof(coord_data_t));
 800e15c:	2500      	movs	r5, #0
 800e15e:	6035      	str	r5, [r6, #0]
 800e160:	6075      	str	r5, [r6, #4]
 800e162:	60b5      	str	r5, [r6, #8]
    if(hal.eeprom.type != EEPROM_None)
 800e164:	f897 00f4 	ldrb.w	r0, [r7, #244]	; 0xf4
 800e168:	2800      	cmp	r0, #0
 800e16a:	d0f6      	beq.n	800e15a <settings_read_coord_data+0x2a>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + 1), (uint8_t *)coord_data, sizeof(coord_data_t));
 800e16c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 800e170:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 800e174:	4631      	mov	r1, r6
 800e176:	220c      	movs	r2, #12
 800e178:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 800e17c:	f500 7000 	add.w	r0, r0, #512	; 0x200
 800e180:	4798      	blx	r3
        return false;
 800e182:	4628      	mov	r0, r5
}
 800e184:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert(idx <= SETTING_INDEX_NCOORD);
 800e186:	21ec      	movs	r1, #236	; 0xec
 800e188:	4b03      	ldr	r3, [pc, #12]	; (800e198 <settings_read_coord_data+0x68>)
 800e18a:	4a04      	ldr	r2, [pc, #16]	; (800e19c <settings_read_coord_data+0x6c>)
 800e18c:	4804      	ldr	r0, [pc, #16]	; (800e1a0 <settings_read_coord_data+0x70>)
 800e18e:	f003 fcf3 	bl	8011b78 <__assert_func>
 800e192:	bf00      	nop
 800e194:	200024bc 	.word	0x200024bc
 800e198:	08014dac 	.word	0x08014dac
 800e19c:	08014e48 	.word	0x08014e48
 800e1a0:	08014dc8 	.word	0x08014dc8

0800e1a4 <settings_restore>:
    }
}


// Restore Grbl global settings to defaults and write to persistent storage
void settings_restore (settings_restore_t restore) {
 800e1a4:	b5f0      	push	{r4, r5, r6, r7, lr}

    if (restore.defaults) {
 800e1a6:	07c1      	lsls	r1, r0, #31
void settings_restore (settings_restore_t restore) {
 800e1a8:	b085      	sub	sp, #20
    if (restore.defaults) {
 800e1aa:	b2c6      	uxtb	r6, r0
 800e1ac:	d429      	bmi.n	800e202 <settings_restore+0x5e>
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;

        write_global_settings();
    }

    if (restore.parameters) {
 800e1ae:	4c54      	ldr	r4, [pc, #336]	; (800e300 <settings_restore+0x15c>)
 800e1b0:	07b2      	lsls	r2, r6, #30
 800e1b2:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e1b6:	d473      	bmi.n	800e2a0 <settings_restore+0xfc>
            settings_write_tool_data(&tool_data);
        }
#endif
    }

    if (hal.eeprom.type != EEPROM_None && restore.startup_lines) {
 800e1b8:	b1cb      	cbz	r3, 800e1ee <settings_restore+0x4a>
 800e1ba:	0777      	lsls	r7, r6, #29
 800e1bc:	f140 8095 	bpl.w	800e2ea <settings_restore+0x146>
      #if N_STARTUP_LINE > 0
        hal.eeprom.put_byte(EEPROM_ADDR_STARTUP_BLOCK, 0);
 800e1c0:	2100      	movs	r1, #0
 800e1c2:	f240 301f 	movw	r0, #799	; 0x31f
 800e1c6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e1ca:	4798      	blx	r3
      #endif
      #if N_STARTUP_LINE > 1
        hal.eeprom.put_byte(EEPROM_ADDR_STARTUP_BLOCK + (MAX_STORED_LINE_LENGTH + 1), 0);
 800e1cc:	2100      	movs	r1, #0
 800e1ce:	f240 3066 	movw	r0, #870	; 0x366
 800e1d2:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e1d6:	4798      	blx	r3
      #endif
    }

    if (restore.build_info && hal.eeprom.type != EEPROM_None)
 800e1d8:	0735      	lsls	r5, r6, #28
 800e1da:	d508      	bpl.n	800e1ee <settings_restore+0x4a>
 800e1dc:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e1e0:	b12b      	cbz	r3, 800e1ee <settings_restore+0x4a>
        hal.eeprom.put_byte(EEPROM_ADDR_BUILD_INFO, 0);
 800e1e2:	2100      	movs	r1, #0
 800e1e4:	f240 30ae 	movw	r0, #942	; 0x3ae
 800e1e8:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e1ec:	4798      	blx	r3

    if(restore.driver_parameters && hal.driver_settings_restore)
 800e1ee:	06f0      	lsls	r0, r6, #27
 800e1f0:	d503      	bpl.n	800e1fa <settings_restore+0x56>
 800e1f2:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800e1f6:	b103      	cbz	r3, 800e1fa <settings_restore+0x56>
        hal.driver_settings_restore();
 800e1f8:	4798      	blx	r3

    eeprom_emu_sync_physical();
 800e1fa:	f7f7 f875 	bl	80052e8 <eeprom_emu_sync_physical>
}
 800e1fe:	b005      	add	sp, #20
 800e200:	bdf0      	pop	{r4, r5, r6, r7, pc}
        memcpy(&settings, &defaults, sizeof(settings_t));
 800e202:	4d40      	ldr	r5, [pc, #256]	; (800e304 <settings_restore+0x160>)
 800e204:	f44f 7286 	mov.w	r2, #268	; 0x10c
 800e208:	493f      	ldr	r1, [pc, #252]	; (800e308 <settings_restore+0x164>)
 800e20a:	4628      	mov	r0, r5
 800e20c:	f003 fd2c 	bl	8011c68 <memcpy>
        settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e210:	f895 1041 	ldrb.w	r1, [r5, #65]	; 0x41
        settings.control_disable_pullup.block_delete &= hal.driver_cap.block_delete;
 800e214:	f895 2042 	ldrb.w	r2, [r5, #66]	; 0x42
        settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e218:	4608      	mov	r0, r1
        settings.control_disable_pullup.block_delete &= hal.driver_cap.block_delete;
 800e21a:	4613      	mov	r3, r2
        settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e21c:	4c38      	ldr	r4, [pc, #224]	; (800e300 <settings_restore+0x15c>)
 800e21e:	f3c1 1100 	ubfx	r1, r1, #4, #1
 800e222:	f894 7145 	ldrb.w	r7, [r4, #325]	; 0x145
        settings.control_disable_pullup.block_delete &= hal.driver_cap.block_delete;
 800e226:	f3c2 1200 	ubfx	r2, r2, #4, #1
        settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e22a:	ea01 1117 	and.w	r1, r1, r7, lsr #4
 800e22e:	f361 1004 	bfi	r0, r1, #4, #1
        settings.control_disable_pullup.block_delete &= hal.driver_cap.block_delete;
 800e232:	ea02 1217 	and.w	r2, r2, r7, lsr #4
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e236:	f3c0 1140 	ubfx	r1, r0, #5, #1
        settings.control_disable_pullup.block_delete &= hal.driver_cap.block_delete;
 800e23a:	f362 1304 	bfi	r3, r2, #4, #1
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e23e:	ea01 01d7 	and.w	r1, r1, r7, lsr #3
        settings.control_invert.e_stop &= hal.driver_cap.e_stop;
 800e242:	f3c0 1c80 	ubfx	ip, r0, #6, #1
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e246:	ea0c 1c57 	and.w	ip, ip, r7, lsr #5
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e24a:	f3c3 1240 	ubfx	r2, r3, #5, #1
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e24e:	0149      	lsls	r1, r1, #5
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e250:	ea02 02d7 	and.w	r2, r2, r7, lsr #3
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e254:	ea41 118c 	orr.w	r1, r1, ip, lsl #6
        settings.control_disable_pullup.e_stop &= hal.driver_cap.e_stop;
 800e258:	f3c3 1c80 	ubfx	ip, r3, #6, #1
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e25c:	ea0c 1c57 	and.w	ip, ip, r7, lsr #5
 800e260:	0152      	lsls	r2, r2, #5
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e262:	f000 079f 	and.w	r7, r0, #159	; 0x9f
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e266:	ea42 128c 	orr.w	r2, r2, ip, lsl #6
 800e26a:	f003 009f 	and.w	r0, r3, #159	; 0x9f
    if(hal.eeprom.type != EEPROM_None) {
 800e26e:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e272:	4339      	orrs	r1, r7
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e274:	4302      	orrs	r2, r0
        settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e276:	f885 1041 	strb.w	r1, [r5, #65]	; 0x41
        settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e27a:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
    if(hal.eeprom.type != EEPROM_None) {
 800e27e:	b37b      	cbz	r3, 800e2e0 <settings_restore+0x13c>
        hal.eeprom.put_byte(0, SETTINGS_VERSION);
 800e280:	210f      	movs	r1, #15
 800e282:	2000      	movs	r0, #0
 800e284:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e288:	4798      	blx	r3
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_GLOBAL, (uint8_t *)&settings, sizeof(settings_t));
 800e28a:	f44f 7286 	mov.w	r2, #268	; 0x10c
 800e28e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 800e292:	4629      	mov	r1, r5
 800e294:	2001      	movs	r0, #1
 800e296:	4798      	blx	r3
    if (restore.parameters) {
 800e298:	07b2      	lsls	r2, r6, #30
 800e29a:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e29e:	d58b      	bpl.n	800e1b8 <settings_restore+0x14>
        memset(coord_data, 0, sizeof(coord_data));
 800e2a0:	2200      	movs	r2, #0
 800e2a2:	f44f 7500 	mov.w	r5, #512	; 0x200
 800e2a6:	e9cd 2201 	strd	r2, r2, [sp, #4]
 800e2aa:	9203      	str	r2, [sp, #12]
    if(hal.eeprom.type != EEPROM_None)
 800e2ac:	2b00      	cmp	r3, #0
 800e2ae:	d09e      	beq.n	800e1ee <settings_restore+0x4a>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + 1), (uint8_t *)coord_data, sizeof(coord_data_t));
 800e2b0:	4628      	mov	r0, r5
 800e2b2:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 800e2b6:	220c      	movs	r2, #12
 800e2b8:	a901      	add	r1, sp, #4
 800e2ba:	350d      	adds	r5, #13
 800e2bc:	4798      	blx	r3
        for (idx = 0; idx <= SETTING_INDEX_NCOORD; idx++)
 800e2be:	f5b5 7f27 	cmp.w	r5, #668	; 0x29c
 800e2c2:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e2c6:	d1f1      	bne.n	800e2ac <settings_restore+0x108>
    if(hal.eeprom.type != EEPROM_None)
 800e2c8:	2b00      	cmp	r3, #0
 800e2ca:	d090      	beq.n	800e1ee <settings_restore+0x4a>
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_PARAMETERS + idx * (sizeof(coord_data_t) + 1), (uint8_t *)coord_data, sizeof(coord_data_t));
 800e2cc:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 800e2d0:	220c      	movs	r2, #12
 800e2d2:	f240 208f 	movw	r0, #655	; 0x28f
 800e2d6:	a901      	add	r1, sp, #4
 800e2d8:	4798      	blx	r3
 800e2da:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e2de:	e76b      	b.n	800e1b8 <settings_restore+0x14>
    if (restore.parameters) {
 800e2e0:	07b2      	lsls	r2, r6, #30
 800e2e2:	d4dd      	bmi.n	800e2a0 <settings_restore+0xfc>
    if(restore.driver_parameters && hal.driver_settings_restore)
 800e2e4:	06f0      	lsls	r0, r6, #27
 800e2e6:	d588      	bpl.n	800e1fa <settings_restore+0x56>
 800e2e8:	e783      	b.n	800e1f2 <settings_restore+0x4e>
    if (restore.build_info && hal.eeprom.type != EEPROM_None)
 800e2ea:	0731      	lsls	r1, r6, #28
 800e2ec:	f57f af7f 	bpl.w	800e1ee <settings_restore+0x4a>
        hal.eeprom.put_byte(EEPROM_ADDR_BUILD_INFO, 0);
 800e2f0:	2100      	movs	r1, #0
 800e2f2:	f240 30ae 	movw	r0, #942	; 0x3ae
 800e2f6:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e2fa:	4798      	blx	r3
 800e2fc:	e777      	b.n	800e1ee <settings_restore+0x4a>
 800e2fe:	bf00      	nop
 800e300:	200024bc 	.word	0x200024bc
 800e304:	20002620 	.word	0x20002620
 800e308:	08014e64 	.word	0x08014e64

0800e30c <settings_store_global_setting>:

// A helper method to set settings from command line
status_code_t settings_store_global_setting (setting_type_t setting, char *svalue)
{
    uint_fast8_t set_idx = 0;
 800e30c:	2300      	movs	r3, #0
{
 800e30e:	b570      	push	{r4, r5, r6, lr}
 800e310:	b082      	sub	sp, #8
 800e312:	460c      	mov	r4, r1
 800e314:	4605      	mov	r5, r0
    float value;

    if (!read_float(svalue, &set_idx, &value)) {
 800e316:	aa01      	add	r2, sp, #4
 800e318:	4608      	mov	r0, r1
 800e31a:	4669      	mov	r1, sp
    uint_fast8_t set_idx = 0;
 800e31c:	9300      	str	r3, [sp, #0]
    if (!read_float(svalue, &set_idx, &value)) {
 800e31e:	f7fb ff57 	bl	800a1d0 <read_float>
 800e322:	b970      	cbnz	r0, 800e342 <settings_store_global_setting+0x36>
        status_code_t status;
        if(hal.driver_setting && (status = hal.driver_setting(setting, NAN, svalue)) != Status_Unhandled)
 800e324:	4bce      	ldr	r3, [pc, #824]	; (800e660 <settings_store_global_setting+0x354>)
 800e326:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e32a:	2b00      	cmp	r3, #0
 800e32c:	f000 8123 	beq.w	800e576 <settings_store_global_setting+0x26a>
 800e330:	4622      	mov	r2, r4
 800e332:	4628      	mov	r0, r5
 800e334:	49cb      	ldr	r1, [pc, #812]	; (800e664 <settings_store_global_setting+0x358>)
 800e336:	4798      	blx	r3
 800e338:	283b      	cmp	r0, #59	; 0x3b
 800e33a:	f000 811c 	beq.w	800e576 <settings_store_global_setting+0x26a>
    mc_backlash_init();
#endif
    hal.settings_changed(&settings);

    return Status_OK;
}
 800e33e:	b002      	add	sp, #8
 800e340:	bd70      	pop	{r4, r5, r6, pc}
    if (value < 0.0f && setting != Setting_ParkingTarget)
 800e342:	9e01      	ldr	r6, [sp, #4]
 800e344:	2100      	movs	r1, #0
 800e346:	4630      	mov	r0, r6
 800e348:	f7f2 fbc2 	bl	8000ad0 <__aeabi_fcmplt>
 800e34c:	2800      	cmp	r0, #0
 800e34e:	d134      	bne.n	800e3ba <settings_store_global_setting+0xae>
    if (setting >= Setting_AxisSettingsBase && setting <= Setting_AxisSettingsMax) {
 800e350:	f1a5 0264 	sub.w	r2, r5, #100	; 0x64
 800e354:	b293      	uxth	r3, r2
 800e356:	2b9b      	cmp	r3, #155	; 0x9b
 800e358:	d836      	bhi.n	800e3c8 <settings_store_global_setting+0xbc>
        uint_fast8_t axis_idx = base_idx % AXIS_SETTINGS_INCREMENT;
 800e35a:	49c3      	ldr	r1, [pc, #780]	; (800e668 <settings_store_global_setting+0x35c>)
 800e35c:	fba1 0302 	umull	r0, r3, r1, r2
 800e360:	08db      	lsrs	r3, r3, #3
 800e362:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800e366:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
        if(axis_idx < N_AXIS) switch((base_idx - axis_idx) / AXIS_SETTINGS_INCREMENT) {
 800e36a:	2b02      	cmp	r3, #2
 800e36c:	f240 80f6 	bls.w	800e55c <settings_store_global_setting+0x250>
        if(!(found || (hal.driver_setting && hal.driver_setting(setting, value, svalue) == Status_OK)))
 800e370:	4bbb      	ldr	r3, [pc, #748]	; (800e660 <settings_store_global_setting+0x354>)
 800e372:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e376:	2b00      	cmp	r3, #0
 800e378:	f000 810b 	beq.w	800e592 <settings_store_global_setting+0x286>
 800e37c:	4622      	mov	r2, r4
 800e37e:	4631      	mov	r1, r6
 800e380:	4628      	mov	r0, r5
 800e382:	4798      	blx	r3
 800e384:	2800      	cmp	r0, #0
 800e386:	f040 8104 	bne.w	800e592 <settings_store_global_setting+0x286>
    if(hal.eeprom.type != EEPROM_None) {
 800e38a:	4cb5      	ldr	r4, [pc, #724]	; (800e660 <settings_store_global_setting+0x354>)
 800e38c:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800e390:	b15b      	cbz	r3, 800e3aa <settings_store_global_setting+0x9e>
        hal.eeprom.put_byte(0, SETTINGS_VERSION);
 800e392:	210f      	movs	r1, #15
 800e394:	2000      	movs	r0, #0
 800e396:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 800e39a:	4798      	blx	r3
        hal.eeprom.memcpy_to_with_checksum(EEPROM_ADDR_GLOBAL, (uint8_t *)&settings, sizeof(settings_t));
 800e39c:	f44f 7286 	mov.w	r2, #268	; 0x10c
 800e3a0:	2001      	movs	r0, #1
 800e3a2:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 800e3a6:	49b1      	ldr	r1, [pc, #708]	; (800e66c <settings_store_global_setting+0x360>)
 800e3a8:	4798      	blx	r3
    hal.settings_changed(&settings);
 800e3aa:	4bad      	ldr	r3, [pc, #692]	; (800e660 <settings_store_global_setting+0x354>)
 800e3ac:	48af      	ldr	r0, [pc, #700]	; (800e66c <settings_store_global_setting+0x360>)
 800e3ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800e3b2:	4798      	blx	r3
    return Status_OK;
 800e3b4:	2000      	movs	r0, #0
}
 800e3b6:	b002      	add	sp, #8
 800e3b8:	bd70      	pop	{r4, r5, r6, pc}
    if (value < 0.0f && setting != Setting_ParkingTarget)
 800e3ba:	2d3a      	cmp	r5, #58	; 0x3a
 800e3bc:	f040 80d9 	bne.w	800e572 <settings_store_global_setting+0x266>
                settings.parking.target = value;
 800e3c0:	4baa      	ldr	r3, [pc, #680]	; (800e66c <settings_store_global_setting+0x360>)
 800e3c2:	f8c3 60dc 	str.w	r6, [r3, #220]	; 0xdc
                break;
 800e3c6:	e7e0      	b.n	800e38a <settings_store_global_setting+0x7e>
        uint_fast16_t int_value = (uint_fast16_t)truncf(value);
 800e3c8:	4630      	mov	r0, r6
 800e3ca:	f7f2 fbe5 	bl	8000b98 <__aeabi_f2uiz>
        switch(setting) {
 800e3ce:	2d5f      	cmp	r5, #95	; 0x5f
 800e3d0:	f200 80d4 	bhi.w	800e57c <settings_store_global_setting+0x270>
 800e3d4:	a301      	add	r3, pc, #4	; (adr r3, 800e3dc <settings_store_global_setting+0xd0>)
 800e3d6:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
 800e3da:	bf00      	nop
 800e3dc:	0800e8e3 	.word	0x0800e8e3
 800e3e0:	0800e5e7 	.word	0x0800e5e7
 800e3e4:	0800e8b3 	.word	0x0800e8b3
 800e3e8:	0800e8bf 	.word	0x0800e8bf
 800e3ec:	0800e8cb 	.word	0x0800e8cb
 800e3f0:	0800e8d7 	.word	0x0800e8d7
 800e3f4:	0800e6b1 	.word	0x0800e6b1
 800e3f8:	0800e57d 	.word	0x0800e57d
 800e3fc:	0800e57d 	.word	0x0800e57d
 800e400:	0800e57d 	.word	0x0800e57d
 800e404:	0800e6d7 	.word	0x0800e6d7
 800e408:	0800e703 	.word	0x0800e703
 800e40c:	0800e709 	.word	0x0800e709
 800e410:	0800e70f 	.word	0x0800e70f
 800e414:	0800e72d 	.word	0x0800e72d
 800e418:	0800e76f 	.word	0x0800e76f
 800e41c:	0800e777 	.word	0x0800e777
 800e420:	0800e5db 	.word	0x0800e5db
 800e424:	0800e5ef 	.word	0x0800e5ef
 800e428:	0800e5f7 	.word	0x0800e5f7
 800e42c:	0800e619 	.word	0x0800e619
 800e430:	0800e63b 	.word	0x0800e63b
 800e434:	0800e819 	.word	0x0800e819
 800e438:	0800e845 	.word	0x0800e845
 800e43c:	0800e851 	.word	0x0800e851
 800e440:	0800e859 	.word	0x0800e859
 800e444:	0800e861 	.word	0x0800e861
 800e448:	0800e869 	.word	0x0800e869
 800e44c:	0800e871 	.word	0x0800e871
 800e450:	0800e877 	.word	0x0800e877
 800e454:	0800e675 	.word	0x0800e675
 800e458:	0800e67b 	.word	0x0800e67b
 800e45c:	0800e681 	.word	0x0800e681
 800e460:	0800e9a9 	.word	0x0800e9a9
 800e464:	0800e983 	.word	0x0800e983
 800e468:	0800e989 	.word	0x0800e989
 800e46c:	0800e98f 	.word	0x0800e98f
 800e470:	0800e995 	.word	0x0800e995
 800e474:	0800e8f9 	.word	0x0800e8f9
 800e478:	0800e901 	.word	0x0800e901
 800e47c:	0800e917 	.word	0x0800e917
 800e480:	0800e971 	.word	0x0800e971
 800e484:	0800e88d 	.word	0x0800e88d
 800e488:	0800e895 	.word	0x0800e895
 800e48c:	0800e5cd 	.word	0x0800e5cd
 800e490:	0800e5cd 	.word	0x0800e5cd
 800e494:	0800e5cd 	.word	0x0800e5cd
 800e498:	0800e5cd 	.word	0x0800e5cd
 800e49c:	0800e5cd 	.word	0x0800e5cd
 800e4a0:	0800e5cd 	.word	0x0800e5cd
 800e4a4:	0800e57d 	.word	0x0800e57d
 800e4a8:	0800e57d 	.word	0x0800e57d
 800e4ac:	0800e57d 	.word	0x0800e57d
 800e4b0:	0800e57d 	.word	0x0800e57d
 800e4b4:	0800e57d 	.word	0x0800e57d
 800e4b8:	0800e57d 	.word	0x0800e57d
 800e4bc:	0800e937 	.word	0x0800e937
 800e4c0:	0800e93f 	.word	0x0800e93f
 800e4c4:	0800e3c1 	.word	0x0800e3c1
 800e4c8:	0800e947 	.word	0x0800e947
 800e4cc:	0800e94f 	.word	0x0800e94f
 800e4d0:	0800e7a1 	.word	0x0800e7a1
 800e4d4:	0800e7b7 	.word	0x0800e7b7
 800e4d8:	0800e7cd 	.word	0x0800e7cd
 800e4dc:	0800e7ed 	.word	0x0800e7ed
 800e4e0:	0800e803 	.word	0x0800e803
 800e4e4:	0800e57d 	.word	0x0800e57d
 800e4e8:	0800e57d 	.word	0x0800e57d
 800e4ec:	0800e57d 	.word	0x0800e57d
 800e4f0:	0800e57d 	.word	0x0800e57d
 800e4f4:	0800e57d 	.word	0x0800e57d
 800e4f8:	0800e57d 	.word	0x0800e57d
 800e4fc:	0800e57d 	.word	0x0800e57d
 800e500:	0800e57d 	.word	0x0800e57d
 800e504:	0800e57d 	.word	0x0800e57d
 800e508:	0800e57d 	.word	0x0800e57d
 800e50c:	0800e57d 	.word	0x0800e57d
 800e510:	0800e57d 	.word	0x0800e57d
 800e514:	0800e57d 	.word	0x0800e57d
 800e518:	0800e57d 	.word	0x0800e57d
 800e51c:	0800e57d 	.word	0x0800e57d
 800e520:	0800e57d 	.word	0x0800e57d
 800e524:	0800e57d 	.word	0x0800e57d
 800e528:	0800e57d 	.word	0x0800e57d
 800e52c:	0800e57d 	.word	0x0800e57d
 800e530:	0800e57d 	.word	0x0800e57d
 800e534:	0800e57d 	.word	0x0800e57d
 800e538:	0800e57d 	.word	0x0800e57d
 800e53c:	0800e57d 	.word	0x0800e57d
 800e540:	0800e57d 	.word	0x0800e57d
 800e544:	0800e8f1 	.word	0x0800e8f1
 800e548:	0800e9af 	.word	0x0800e9af
 800e54c:	0800e9a1 	.word	0x0800e9a1
 800e550:	0800e57d 	.word	0x0800e57d
 800e554:	0800e57d 	.word	0x0800e57d
 800e558:	0800e8ab 	.word	0x0800e8ab
        if(axis_idx < N_AXIS) switch((base_idx - axis_idx) / AXIS_SETTINGS_INCREMENT) {
 800e55c:	1ad2      	subs	r2, r2, r3
 800e55e:	fba1 1202 	umull	r1, r2, r1, r2
 800e562:	08d2      	lsrs	r2, r2, #3
 800e564:	2a03      	cmp	r2, #3
 800e566:	f63f af03 	bhi.w	800e370 <settings_store_global_setting+0x64>
 800e56a:	e8df f002 	tbb	[pc, r2]
 800e56e:	2a25      	.short	0x2a25
 800e570:	141b      	.short	0x141b
        return Status_NegativeValue;
 800e572:	2004      	movs	r0, #4
 800e574:	e6e3      	b.n	800e33e <settings_store_global_setting+0x32>
            return Status_BadNumberFormat;
 800e576:	2002      	movs	r0, #2
}
 800e578:	b002      	add	sp, #8
 800e57a:	bd70      	pop	{r4, r5, r6, pc}
                status_code_t status = hal.driver_setting ? hal.driver_setting(setting, value, svalue) : Status_Unhandled;
 800e57c:	4b38      	ldr	r3, [pc, #224]	; (800e660 <settings_store_global_setting+0x354>)
 800e57e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800e582:	b133      	cbz	r3, 800e592 <settings_store_global_setting+0x286>
 800e584:	4622      	mov	r2, r4
 800e586:	4631      	mov	r1, r6
 800e588:	4628      	mov	r0, r5
 800e58a:	4798      	blx	r3
                return status == Status_Unhandled ? Status_InvalidStatement : status;
 800e58c:	283b      	cmp	r0, #59	; 0x3b
 800e58e:	f47f aed6 	bne.w	800e33e <settings_store_global_setting+0x32>
            return Status_InvalidStatement;
 800e592:	2003      	movs	r0, #3
 800e594:	e6d3      	b.n	800e33e <settings_store_global_setting+0x32>
                settings.max_travel[axis_idx] = -value; // Store as negative for grbl internal use.
 800e596:	4a35      	ldr	r2, [pc, #212]	; (800e66c <settings_store_global_setting+0x360>)
 800e598:	330a      	adds	r3, #10
 800e59a:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
 800e59e:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
        if(!(found || (hal.driver_setting && hal.driver_setting(setting, value, svalue) == Status_OK)))
 800e5a2:	e6f2      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.acceleration[axis_idx] = value * 60.0f * 60.0f; // Convert to mm/min^2 for grbl internal use.
 800e5a4:	4c31      	ldr	r4, [pc, #196]	; (800e66c <settings_store_global_setting+0x360>)
 800e5a6:	3306      	adds	r3, #6
 800e5a8:	4630      	mov	r0, r6
 800e5aa:	4931      	ldr	r1, [pc, #196]	; (800e670 <settings_store_global_setting+0x364>)
 800e5ac:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 800e5b0:	f7f2 f8f0 	bl	8000794 <__aeabi_fmul>
 800e5b4:	6060      	str	r0, [r4, #4]
        if(!(found || (hal.driver_setting && hal.driver_setting(setting, value, svalue) == Status_OK)))
 800e5b6:	e6e8      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steps_per_mm[axis_idx] = value;
 800e5b8:	4a2c      	ldr	r2, [pc, #176]	; (800e66c <settings_store_global_setting+0x360>)
 800e5ba:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800e5be:	605e      	str	r6, [r3, #4]
        if(!(found || (hal.driver_setting && hal.driver_setting(setting, value, svalue) == Status_OK)))
 800e5c0:	e6e3      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.max_rate[axis_idx] = value;
 800e5c2:	4a2a      	ldr	r2, [pc, #168]	; (800e66c <settings_store_global_setting+0x360>)
 800e5c4:	3304      	adds	r3, #4
 800e5c6:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
        if(!(found || (hal.driver_setting && hal.driver_setting(setting, value, svalue) == Status_OK)))
 800e5ca:	e6de      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.cycle[setting - Setting_HomingCycle_1].mask = int_value;
 800e5cc:	4b27      	ldr	r3, [pc, #156]	; (800e66c <settings_store_global_setting+0x360>)
 800e5ce:	441d      	add	r5, r3
 800e5d0:	f885 00a5 	strb.w	r0, [r5, #165]	; 0xa5
                limits_set_homing_axes();
 800e5d4:	f7fa fb22 	bl	8008c1c <limits_set_homing_axes>
                break;
 800e5d8:	e6d7      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.control_disable_pullup.mask = int_value & 0x0F;
 800e5da:	4b24      	ldr	r3, [pc, #144]	; (800e66c <settings_store_global_setting+0x360>)
                settings.control_disable_pullup.stop_disable &= hal.driver_cap.program_stop;
 800e5dc:	f000 000f 	and.w	r0, r0, #15
 800e5e0:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
                break;
 800e5e4:	e6d1      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steppers.idle_lock_time = int_value;
 800e5e6:	4b21      	ldr	r3, [pc, #132]	; (800e66c <settings_store_global_setting+0x360>)
 800e5e8:	f883 00ba 	strb.w	r0, [r3, #186]	; 0xba
                break;
 800e5ec:	e6cd      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.limits.disable_pullup.mask = int_value;
 800e5ee:	4b1f      	ldr	r3, [pc, #124]	; (800e66c <settings_store_global_setting+0x360>)
 800e5f0:	f883 00d6 	strb.w	r0, [r3, #214]	; 0xd6
                break;
 800e5f4:	e6c9      	b.n	800e38a <settings_store_global_setting+0x7e>
                if(!hal.probe_configure_invert_mask)
 800e5f6:	4b1a      	ldr	r3, [pc, #104]	; (800e660 <settings_store_global_setting+0x354>)
 800e5f8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800e5fc:	2b00      	cmp	r3, #0
 800e5fe:	f000 8202 	beq.w	800ea06 <settings_store_global_setting+0x6fa>
                settings.flags.disable_probe_pullup = int_value != 0;
 800e602:	3800      	subs	r0, #0
 800e604:	bf18      	it	ne
 800e606:	2001      	movne	r0, #1
 800e608:	4b18      	ldr	r3, [pc, #96]	; (800e66c <settings_store_global_setting+0x360>)
 800e60a:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
 800e60e:	f360 02c3 	bfi	r2, r0, #3, #1
 800e612:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
                break;
 800e616:	e6b8      	b.n	800e38a <settings_store_global_setting+0x7e>
                if (int_value && !settings.homing.flags.enabled)
 800e618:	4b14      	ldr	r3, [pc, #80]	; (800e66c <settings_store_global_setting+0x360>)
 800e61a:	b120      	cbz	r0, 800e626 <settings_store_global_setting+0x31a>
 800e61c:	f893 20d0 	ldrb.w	r2, [r3, #208]	; 0xd0
 800e620:	07d4      	lsls	r4, r2, #31
 800e622:	f140 81f4 	bpl.w	800ea0e <settings_store_global_setting+0x702>
                settings.limits.flags.soft_enabled = int_value != 0;
 800e626:	3800      	subs	r0, #0
 800e628:	bf18      	it	ne
 800e62a:	2001      	movne	r0, #1
 800e62c:	f893 20d4 	ldrb.w	r2, [r3, #212]	; 0xd4
 800e630:	f360 0241 	bfi	r2, r0, #1, #1
 800e634:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4
                break;
 800e638:	e6a7      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.limits.flags.hard_enabled = bit_istrue(int_value, bit(0));
 800e63a:	490c      	ldr	r1, [pc, #48]	; (800e66c <settings_store_global_setting+0x360>)
 800e63c:	f000 0201 	and.w	r2, r0, #1
 800e640:	f891 30d4 	ldrb.w	r3, [r1, #212]	; 0xd4
                hal.limits_enable(settings.limits.flags.hard_enabled, false); // Change immediately. NOTE: Nice to have but could be problematic later.
 800e644:	4c06      	ldr	r4, [pc, #24]	; (800e660 <settings_store_global_setting+0x354>)
                settings.limits.flags.check_at_init = bit_istrue(int_value, bit(1));
 800e646:	f3c0 0040 	ubfx	r0, r0, #1, #1
                settings.limits.flags.hard_enabled = bit_istrue(int_value, bit(0));
 800e64a:	f362 0300 	bfi	r3, r2, #0, #1
                settings.limits.flags.check_at_init = bit_istrue(int_value, bit(1));
 800e64e:	f360 0382 	bfi	r3, r0, #2, #1
 800e652:	f881 30d4 	strb.w	r3, [r1, #212]	; 0xd4
                hal.limits_enable(settings.limits.flags.hard_enabled, false); // Change immediately. NOTE: Nice to have but could be problematic later.
 800e656:	4610      	mov	r0, r2
 800e658:	2100      	movs	r1, #0
 800e65a:	69e3      	ldr	r3, [r4, #28]
 800e65c:	4798      	blx	r3
                break;
 800e65e:	e694      	b.n	800e38a <settings_store_global_setting+0x7e>
 800e660:	200024bc 	.word	0x200024bc
 800e664:	7fc00000 	.word	0x7fc00000
 800e668:	cccccccd 	.word	0xcccccccd
 800e66c:	20002620 	.word	0x20002620
 800e670:	45610000 	.word	0x45610000
                settings.spindle.rpm_max = value;
 800e674:	4bbb      	ldr	r3, [pc, #748]	; (800e964 <settings_store_global_setting+0x658>)
 800e676:	645e      	str	r6, [r3, #68]	; 0x44
                break;
 800e678:	e687      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.rpm_min = value;
 800e67a:	4bba      	ldr	r3, [pc, #744]	; (800e964 <settings_store_global_setting+0x658>)
 800e67c:	649e      	str	r6, [r3, #72]	; 0x48
                break;
 800e67e:	e684      	b.n	800e38a <settings_store_global_setting+0x7e>
                switch(int_value) {
 800e680:	2801      	cmp	r0, #1
 800e682:	f000 81b0 	beq.w	800e9e6 <settings_store_global_setting+0x6da>
 800e686:	2802      	cmp	r0, #2
 800e688:	f000 81a0 	beq.w	800e9cc <settings_store_global_setting+0x6c0>
                        settings.flags.laser_mode = Off;
 800e68c:	4bb5      	ldr	r3, [pc, #724]	; (800e964 <settings_store_global_setting+0x658>)
 800e68e:	f8b3 20bc 	ldrh.w	r2, [r3, #188]	; 0xbc
 800e692:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800e696:	f022 0202 	bic.w	r2, r2, #2
 800e69a:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
                if(!settings.flags.lathe_mode)
 800e69e:	f993 30bd 	ldrsb.w	r3, [r3, #189]	; 0xbd
 800e6a2:	2b00      	cmp	r3, #0
 800e6a4:	f6ff ae71 	blt.w	800e38a <settings_store_global_setting+0x7e>
                    gc_state.modal.diameter_mode = false;
 800e6a8:	2200      	movs	r2, #0
 800e6aa:	4baf      	ldr	r3, [pc, #700]	; (800e968 <settings_store_global_setting+0x65c>)
 800e6ac:	711a      	strb	r2, [r3, #4]
 800e6ae:	e66c      	b.n	800e38a <settings_store_global_setting+0x7e>
                if(!hal.probe_configure_invert_mask)
 800e6b0:	4bae      	ldr	r3, [pc, #696]	; (800e96c <settings_store_global_setting+0x660>)
 800e6b2:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800e6b6:	2b00      	cmp	r3, #0
 800e6b8:	f000 81a5 	beq.w	800ea06 <settings_store_global_setting+0x6fa>
                settings.flags.invert_probe_pin = int_value != 0;
 800e6bc:	1e04      	subs	r4, r0, #0
 800e6be:	bf18      	it	ne
 800e6c0:	2401      	movne	r4, #1
 800e6c2:	4aa8      	ldr	r2, [pc, #672]	; (800e964 <settings_store_global_setting+0x658>)
                hal.probe_configure_invert_mask(false);
 800e6c4:	2000      	movs	r0, #0
                settings.flags.invert_probe_pin = int_value != 0;
 800e6c6:	f892 10bc 	ldrb.w	r1, [r2, #188]	; 0xbc
 800e6ca:	f364 0182 	bfi	r1, r4, #2, #1
 800e6ce:	f882 10bc 	strb.w	r1, [r2, #188]	; 0xbc
                hal.probe_configure_invert_mask(false);
 800e6d2:	4798      	blx	r3
                break;
 800e6d4:	e659      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.status_report.mask = int_value & 0xFF;
 800e6d6:	4aa3      	ldr	r2, [pc, #652]	; (800e964 <settings_store_global_setting+0x658>)
                settings.flags.report_parser_state = bit_istrue(int_value, bit(10));
 800e6d8:	f3c0 2380 	ubfx	r3, r0, #10, #1
 800e6dc:	f892 10bd 	ldrb.w	r1, [r2, #189]	; 0xbd
                settings.flags.report_alarm_substate = bit_istrue(int_value, bit(9));
 800e6e0:	f3c0 2440 	ubfx	r4, r0, #9, #1
                settings.flags.report_parser_state = bit_istrue(int_value, bit(10));
 800e6e4:	005b      	lsls	r3, r3, #1
 800e6e6:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
                settings.flags.force_buffer_sync_on_wco_change = bit_istrue(int_value, bit(8));
 800e6ea:	f3c0 2400 	ubfx	r4, r0, #8, #1
                settings.flags.report_parser_state = bit_istrue(int_value, bit(10));
 800e6ee:	ea43 1384 	orr.w	r3, r3, r4, lsl #6
 800e6f2:	f021 014a 	bic.w	r1, r1, #74	; 0x4a
 800e6f6:	430b      	orrs	r3, r1
                settings.status_report.mask = int_value & 0xFF;
 800e6f8:	f882 00bb 	strb.w	r0, [r2, #187]	; 0xbb
                settings.flags.report_parser_state = bit_istrue(int_value, bit(10));
 800e6fc:	f882 30bd 	strb.w	r3, [r2, #189]	; 0xbd
                break;
 800e700:	e643      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.junction_deviation = value;
 800e702:	4b98      	ldr	r3, [pc, #608]	; (800e964 <settings_store_global_setting+0x658>)
 800e704:	635e      	str	r6, [r3, #52]	; 0x34
                break;
 800e706:	e640      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.arc_tolerance = value;
 800e708:	4b96      	ldr	r3, [pc, #600]	; (800e964 <settings_store_global_setting+0x658>)
 800e70a:	639e      	str	r6, [r3, #56]	; 0x38
                break;
 800e70c:	e63d      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.report_inches = int_value != 0;
 800e70e:	3800      	subs	r0, #0
 800e710:	bf18      	it	ne
 800e712:	2001      	movne	r0, #1
 800e714:	4b93      	ldr	r3, [pc, #588]	; (800e964 <settings_store_global_setting+0x658>)
 800e716:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
 800e71a:	f360 0200 	bfi	r2, r0, #0, #1
 800e71e:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
                report_init();
 800e722:	f7fd fc39 	bl	800bf98 <report_init>
                system_flag_wco_change(); // Make sure WCO is immediately updated.
 800e726:	f002 ffe7 	bl	80116f8 <system_flag_wco_change>
                break;
 800e72a:	e62e      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e72c:	4602      	mov	r2, r0
 800e72e:	4b8f      	ldr	r3, [pc, #572]	; (800e96c <settings_store_global_setting+0x660>)
 800e730:	f3c0 1000 	ubfx	r0, r0, #4, #1
 800e734:	f893 1145 	ldrb.w	r1, [r3, #325]	; 0x145
                settings.control_invert.mask = int_value;
 800e738:	4c8a      	ldr	r4, [pc, #552]	; (800e964 <settings_store_global_setting+0x658>)
                settings.control_invert.block_delete &= hal.driver_cap.block_delete;
 800e73a:	f3c1 1300 	ubfx	r3, r1, #4, #1
 800e73e:	4003      	ands	r3, r0
 800e740:	f363 1204 	bfi	r2, r3, #4, #1
                settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e744:	f3c1 00c0 	ubfx	r0, r1, #3, #1
 800e748:	f3c2 1340 	ubfx	r3, r2, #5, #1
 800e74c:	4003      	ands	r3, r0
                settings.control_invert.e_stop &= hal.driver_cap.e_stop;
 800e74e:	f3c1 1140 	ubfx	r1, r1, #5, #1
 800e752:	f3c2 1080 	ubfx	r0, r2, #6, #1
                settings.control_invert.stop_disable &= hal.driver_cap.program_stop;
 800e756:	015b      	lsls	r3, r3, #5
 800e758:	4001      	ands	r1, r0
 800e75a:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 800e75e:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800e762:	f002 029f 	and.w	r2, r2, #159	; 0x9f
 800e766:	4313      	orrs	r3, r2
 800e768:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
                break;
 800e76c:	e60d      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.coolant_invert.mask = int_value;
 800e76e:	4b7d      	ldr	r3, [pc, #500]	; (800e964 <settings_store_global_setting+0x658>)
 800e770:	f883 0043 	strb.w	r0, [r3, #67]	; 0x43
                break;
 800e774:	e609      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.invert.mask = int_value;
 800e776:	b2c0      	uxtb	r0, r0
 800e778:	4b7a      	ldr	r3, [pc, #488]	; (800e964 <settings_store_global_setting+0x658>)
                if(settings.spindle.invert.pwm && !hal.driver_cap.spindle_pwm_invert) {
 800e77a:	0745      	lsls	r5, r0, #29
                settings.spindle.invert.mask = int_value;
 800e77c:	f883 00b2 	strb.w	r0, [r3, #178]	; 0xb2
                if(settings.spindle.invert.pwm && !hal.driver_cap.spindle_pwm_invert) {
 800e780:	f57f ae03 	bpl.w	800e38a <settings_store_global_setting+0x7e>
 800e784:	4a79      	ldr	r2, [pc, #484]	; (800e96c <settings_store_global_setting+0x660>)
 800e786:	f892 2146 	ldrb.w	r2, [r2, #326]	; 0x146
 800e78a:	f012 0220 	ands.w	r2, r2, #32
 800e78e:	f47f adfc 	bne.w	800e38a <settings_store_global_setting+0x7e>
                    settings.spindle.invert.pwm = Off;
 800e792:	b2c1      	uxtb	r1, r0
 800e794:	f362 0182 	bfi	r1, r2, #2, #1
                    return Status_SettingDisabled;
 800e798:	2005      	movs	r0, #5
                    settings.spindle.invert.pwm = Off;
 800e79a:	f883 10b2 	strb.w	r1, [r3, #178]	; 0xb2
                    return Status_SettingDisabled;
 800e79e:	e5ce      	b.n	800e33e <settings_store_global_setting+0x32>
                settings.flags.safety_door_ignore_when_idle = int_value != 0;
 800e7a0:	3800      	subs	r0, #0
 800e7a2:	bf18      	it	ne
 800e7a4:	2001      	movne	r0, #1
 800e7a6:	4b6f      	ldr	r3, [pc, #444]	; (800e964 <settings_store_global_setting+0x658>)
 800e7a8:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
 800e7ac:	f360 1245 	bfi	r2, r0, #5, #1
 800e7b0:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
                break;
 800e7b4:	e5e9      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.sleep_enable = int_value != 0;
 800e7b6:	3800      	subs	r0, #0
 800e7b8:	bf18      	it	ne
 800e7ba:	2001      	movne	r0, #1
 800e7bc:	4b69      	ldr	r3, [pc, #420]	; (800e964 <settings_store_global_setting+0x658>)
 800e7be:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
 800e7c2:	f360 1286 	bfi	r2, r0, #6, #1
 800e7c6:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
                break;
 800e7ca:	e5de      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.disable_laser_during_hold =  bit_istrue(int_value, bit(0));
 800e7cc:	4965      	ldr	r1, [pc, #404]	; (800e964 <settings_store_global_setting+0x658>)
 800e7ce:	f000 0301 	and.w	r3, r0, #1
 800e7d2:	f8b1 20bc 	ldrh.w	r2, [r1, #188]	; 0xbc
 800e7d6:	01db      	lsls	r3, r3, #7
                settings.flags.restore_after_feed_hold =  bit_istrue(int_value, bit(1));
 800e7d8:	f3c0 0040 	ubfx	r0, r0, #1, #1
                settings.flags.disable_laser_during_hold =  bit_istrue(int_value, bit(0));
 800e7dc:	f422 5284 	bic.w	r2, r2, #4224	; 0x1080
 800e7e0:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
 800e7e4:	4313      	orrs	r3, r2
 800e7e6:	f8a1 30bc 	strh.w	r3, [r1, #188]	; 0xbc
                break;
 800e7ea:	e5ce      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.force_initialization_alarm = int_value != 0;
 800e7ec:	3800      	subs	r0, #0
 800e7ee:	bf18      	it	ne
 800e7f0:	2001      	movne	r0, #1
 800e7f2:	4b5c      	ldr	r3, [pc, #368]	; (800e964 <settings_store_global_setting+0x658>)
 800e7f4:	f893 20bd 	ldrb.w	r2, [r3, #189]	; 0xbd
 800e7f8:	f360 0200 	bfi	r2, r0, #0, #1
 800e7fc:	f883 20bd 	strb.w	r2, [r3, #189]	; 0xbd
                break;
 800e800:	e5c3      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.allow_probing_feed_override = int_value != 0;
 800e802:	3800      	subs	r0, #0
 800e804:	bf18      	it	ne
 800e806:	2001      	movne	r0, #1
 800e808:	4b56      	ldr	r3, [pc, #344]	; (800e964 <settings_store_global_setting+0x658>)
 800e80a:	f893 20bd 	ldrb.w	r2, [r3, #189]	; 0xbd
 800e80e:	f360 0282 	bfi	r2, r0, #2, #1
 800e812:	f883 20bd 	strb.w	r2, [r3, #189]	; 0xbd
                break;
 800e816:	e5b8      	b.n	800e38a <settings_store_global_setting+0x7e>
                if (bit_istrue(int_value, bit(0))) {
 800e818:	f010 0101 	ands.w	r1, r0, #1
                    settings.homing.flags.value = int_value & 0x0F;
 800e81c:	4b51      	ldr	r3, [pc, #324]	; (800e964 <settings_store_global_setting+0x658>)
                if (bit_istrue(int_value, bit(0))) {
 800e81e:	f000 80ca 	beq.w	800e9b6 <settings_store_global_setting+0x6aa>
                    settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 800e822:	f893 20d4 	ldrb.w	r2, [r3, #212]	; 0xd4
                    settings.homing.flags.manual = bit_istrue(int_value, bit(5));
 800e826:	f3c0 1440 	ubfx	r4, r0, #5, #1
 800e82a:	f000 010f 	and.w	r1, r0, #15
                    settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 800e82e:	f3c0 1000 	ubfx	r0, r0, #4, #1
                    settings.homing.flags.manual = bit_istrue(int_value, bit(5));
 800e832:	f364 1104 	bfi	r1, r4, #4, #1
                    settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 800e836:	f360 1204 	bfi	r2, r0, #4, #1
                    settings.homing.flags.manual = bit_istrue(int_value, bit(5));
 800e83a:	f883 10d0 	strb.w	r1, [r3, #208]	; 0xd0
                    settings.limits.flags.two_switches = bit_istrue(int_value, bit(4));
 800e83e:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4
 800e842:	e5a2      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.dir_mask.value = int_value & AXES_BITMASK;
 800e844:	4b47      	ldr	r3, [pc, #284]	; (800e964 <settings_store_global_setting+0x658>)
 800e846:	f000 0007 	and.w	r0, r0, #7
 800e84a:	f883 00cc 	strb.w	r0, [r3, #204]	; 0xcc
                break;
 800e84e:	e59c      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.feed_rate = value;
 800e850:	4b44      	ldr	r3, [pc, #272]	; (800e964 <settings_store_global_setting+0x658>)
 800e852:	f8c3 60c0 	str.w	r6, [r3, #192]	; 0xc0
                break;
 800e856:	e598      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.seek_rate = value;
 800e858:	4b42      	ldr	r3, [pc, #264]	; (800e964 <settings_store_global_setting+0x658>)
 800e85a:	f8c3 60c4 	str.w	r6, [r3, #196]	; 0xc4
                break;
 800e85e:	e594      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.debounce_delay = int_value;
 800e860:	4b40      	ldr	r3, [pc, #256]	; (800e964 <settings_store_global_setting+0x658>)
 800e862:	f8a3 00ce 	strh.w	r0, [r3, #206]	; 0xce
                break;
 800e866:	e590      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.pulloff = value;
 800e868:	4b3e      	ldr	r3, [pc, #248]	; (800e964 <settings_store_global_setting+0x658>)
 800e86a:	f8c3 60c8 	str.w	r6, [r3, #200]	; 0xc8
                break;
 800e86e:	e58c      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.g73_retract = value;
 800e870:	4b3c      	ldr	r3, [pc, #240]	; (800e964 <settings_store_global_setting+0x658>)
 800e872:	63de      	str	r6, [r3, #60]	; 0x3c
                break;
 800e874:	e589      	b.n	800e38a <settings_store_global_setting+0x7e>
                if(int_value > 0 && !hal.driver_cap.step_pulse_delay)
 800e876:	b128      	cbz	r0, 800e884 <settings_store_global_setting+0x578>
 800e878:	4b3c      	ldr	r3, [pc, #240]	; (800e96c <settings_store_global_setting+0x660>)
 800e87a:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 800e87e:	069e      	lsls	r6, r3, #26
 800e880:	f140 80c1 	bpl.w	800ea06 <settings_store_global_setting+0x6fa>
                settings.steppers.pulse_delay_microseconds = int_value;
 800e884:	4b37      	ldr	r3, [pc, #220]	; (800e964 <settings_store_global_setting+0x658>)
 800e886:	f883 00b9 	strb.w	r0, [r3, #185]	; 0xb9
                break;
 800e88a:	e57e      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.parking.axis = int_value;
 800e88c:	4b35      	ldr	r3, [pc, #212]	; (800e964 <settings_store_global_setting+0x658>)
 800e88e:	f883 00d9 	strb.w	r0, [r3, #217]	; 0xd9
                break;
 800e892:	e57a      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.locate_cycles = int_value < 1 ? 1 :(int_value > 127 ? 127 : int_value);
 800e894:	2800      	cmp	r0, #0
 800e896:	f000 8097 	beq.w	800e9c8 <settings_store_global_setting+0x6bc>
 800e89a:	287f      	cmp	r0, #127	; 0x7f
 800e89c:	bf28      	it	cs
 800e89e:	207f      	movcs	r0, #127	; 0x7f
 800e8a0:	b2c3      	uxtb	r3, r0
 800e8a2:	4a30      	ldr	r2, [pc, #192]	; (800e964 <settings_store_global_setting+0x658>)
 800e8a4:	f882 30cd 	strb.w	r3, [r2, #205]	; 0xcd
                break;
 800e8a8:	e56f      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.position.pid.i_max_error = value;
 800e8aa:	4b2e      	ldr	r3, [pc, #184]	; (800e964 <settings_store_global_setting+0x658>)
 800e8ac:	f8c3 60fc 	str.w	r6, [r3, #252]	; 0xfc
                break;
 800e8b0:	e56b      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steppers.step_invert.mask = int_value & AXES_BITMASK;
 800e8b2:	4b2c      	ldr	r3, [pc, #176]	; (800e964 <settings_store_global_setting+0x658>)
 800e8b4:	f000 0007 	and.w	r0, r0, #7
 800e8b8:	f883 00b4 	strb.w	r0, [r3, #180]	; 0xb4
                break;
 800e8bc:	e565      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steppers.dir_invert.mask = int_value & AXES_BITMASK;
 800e8be:	4b29      	ldr	r3, [pc, #164]	; (800e964 <settings_store_global_setting+0x658>)
 800e8c0:	f000 0007 	and.w	r0, r0, #7
 800e8c4:	f883 00b5 	strb.w	r0, [r3, #181]	; 0xb5
                break;
 800e8c8:	e55f      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steppers.enable_invert.mask = int_value & AXES_BITMASK;
 800e8ca:	4b26      	ldr	r3, [pc, #152]	; (800e964 <settings_store_global_setting+0x658>)
 800e8cc:	f000 0007 	and.w	r0, r0, #7
 800e8d0:	f883 00b6 	strb.w	r0, [r3, #182]	; 0xb6
                break;
 800e8d4:	e559      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.limits.invert.mask = int_value & AXES_BITMASK;
 800e8d6:	4b23      	ldr	r3, [pc, #140]	; (800e964 <settings_store_global_setting+0x658>)
 800e8d8:	f000 0007 	and.w	r0, r0, #7
 800e8dc:	f883 00d5 	strb.w	r0, [r3, #213]	; 0xd5
                break;
 800e8e0:	e553      	b.n	800e38a <settings_store_global_setting+0x7e>
                if (int_value < 3)
 800e8e2:	2802      	cmp	r0, #2
 800e8e4:	f240 8091 	bls.w	800ea0a <settings_store_global_setting+0x6fe>
                settings.steppers.pulse_microseconds = int_value;
 800e8e8:	4b1e      	ldr	r3, [pc, #120]	; (800e964 <settings_store_global_setting+0x658>)
 800e8ea:	f883 00b8 	strb.w	r0, [r3, #184]	; 0xb8
                break;
 800e8ee:	e54c      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.position.pid.p_gain = value;
 800e8f0:	4b1c      	ldr	r3, [pc, #112]	; (800e964 <settings_store_global_setting+0x658>)
 800e8f2:	f8c3 60ec 	str.w	r6, [r3, #236]	; 0xec
                break;
 800e8f6:	e548      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.ppr = int_value;
 800e8f8:	4b1a      	ldr	r3, [pc, #104]	; (800e964 <settings_store_global_setting+0x658>)
 800e8fa:	f8a3 00b0 	strh.w	r0, [r3, #176]	; 0xb0
                break;
 800e8fe:	e544      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.legacy_rt_commands = value != 0;
 800e900:	4630      	mov	r0, r6
 800e902:	2100      	movs	r1, #0
 800e904:	f7f2 f8da 	bl	8000abc <__aeabi_fcmpeq>
 800e908:	fab0 f380 	clz	r3, r0
 800e90c:	4a15      	ldr	r2, [pc, #84]	; (800e964 <settings_store_global_setting+0x658>)
 800e90e:	095b      	lsrs	r3, r3, #5
 800e910:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
                break;
 800e914:	e539      	b.n	800e38a <settings_store_global_setting+0x7e>
                if (int_value && !settings.homing.flags.enabled)
 800e916:	4b13      	ldr	r3, [pc, #76]	; (800e964 <settings_store_global_setting+0x658>)
 800e918:	b118      	cbz	r0, 800e922 <settings_store_global_setting+0x616>
 800e91a:	f893 20d0 	ldrb.w	r2, [r3, #208]	; 0xd0
 800e91e:	07d1      	lsls	r1, r2, #31
 800e920:	d575      	bpl.n	800ea0e <settings_store_global_setting+0x702>
                settings.limits.flags.jog_soft_limited = int_value != 0;
 800e922:	3800      	subs	r0, #0
 800e924:	bf18      	it	ne
 800e926:	2001      	movne	r0, #1
 800e928:	f893 20d4 	ldrb.w	r2, [r3, #212]	; 0xd4
 800e92c:	f360 02c3 	bfi	r2, r0, #3, #1
 800e930:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4
                break;
 800e934:	e529      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.parking.pullout_increment = value;
 800e936:	4b0b      	ldr	r3, [pc, #44]	; (800e964 <settings_store_global_setting+0x658>)
 800e938:	f8c3 60e8 	str.w	r6, [r3, #232]	; 0xe8
                break;
 800e93c:	e525      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.parking.pullout_rate = value;
 800e93e:	4b09      	ldr	r3, [pc, #36]	; (800e964 <settings_store_global_setting+0x658>)
 800e940:	f8c3 60e4 	str.w	r6, [r3, #228]	; 0xe4
                break;
 800e944:	e521      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.parking.rate = value;
 800e946:	4b07      	ldr	r3, [pc, #28]	; (800e964 <settings_store_global_setting+0x658>)
 800e948:	f8c3 60e0 	str.w	r6, [r3, #224]	; 0xe0
                break;
 800e94c:	e51d      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.flags.restore_overrides = int_value != 0;
 800e94e:	3800      	subs	r0, #0
 800e950:	bf18      	it	ne
 800e952:	2001      	movne	r0, #1
 800e954:	4b03      	ldr	r3, [pc, #12]	; (800e964 <settings_store_global_setting+0x658>)
 800e956:	f893 20bc 	ldrb.w	r2, [r3, #188]	; 0xbc
 800e95a:	f360 1204 	bfi	r2, r0, #4, #1
 800e95e:	f883 20bc 	strb.w	r2, [r3, #188]	; 0xbc
                break;
 800e962:	e512      	b.n	800e38a <settings_store_global_setting+0x7e>
 800e964:	20002620 	.word	0x20002620
 800e968:	200023dc 	.word	0x200023dc
 800e96c:	200024bc 	.word	0x200024bc
                if (bit_istrue(int_value, bit(0)))
 800e970:	07c3      	lsls	r3, r0, #31
 800e972:	f57f ad0a 	bpl.w	800e38a <settings_store_global_setting+0x7e>
                    settings.parking.flags.value = bit_istrue(int_value, bit(0)) ? (int_value & 0x07) : 0;
 800e976:	4b28      	ldr	r3, [pc, #160]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e978:	f000 0007 	and.w	r0, r0, #7
 800e97c:	f883 00d8 	strb.w	r0, [r3, #216]	; 0xd8
 800e980:	e503      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.pwm_off_value = value;
 800e982:	4b25      	ldr	r3, [pc, #148]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e984:	655e      	str	r6, [r3, #84]	; 0x54
                break;
 800e986:	e500      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.pwm_min_value = value;
 800e988:	4b23      	ldr	r3, [pc, #140]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e98a:	659e      	str	r6, [r3, #88]	; 0x58
                break;
 800e98c:	e4fd      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.pwm_max_value = value;
 800e98e:	4b22      	ldr	r3, [pc, #136]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e990:	65de      	str	r6, [r3, #92]	; 0x5c
                break;
 800e992:	e4fa      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.steppers.deenergize.mask = int_value & AXES_BITMASK;
 800e994:	4b20      	ldr	r3, [pc, #128]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e996:	f000 0007 	and.w	r0, r0, #7
 800e99a:	f883 00b7 	strb.w	r0, [r3, #183]	; 0xb7
                break;
 800e99e:	e4f4      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.position.pid.d_gain = value;
 800e9a0:	4b1d      	ldr	r3, [pc, #116]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e9a2:	f8c3 60f4 	str.w	r6, [r3, #244]	; 0xf4
                break;
 800e9a6:	e4f0      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.spindle.pwm_freq = value;
 800e9a8:	4b1b      	ldr	r3, [pc, #108]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e9aa:	64de      	str	r6, [r3, #76]	; 0x4c
                break;
 800e9ac:	e4ed      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.position.pid.i_gain = value;
 800e9ae:	4b1a      	ldr	r3, [pc, #104]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e9b0:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
                break;
 800e9b4:	e4e9      	b.n	800e38a <settings_store_global_setting+0x7e>
                    settings.limits.flags.soft_enabled = Off; // Force disable soft-limits.
 800e9b6:	f893 20d4 	ldrb.w	r2, [r3, #212]	; 0xd4
                    settings.homing.flags.value = 0;
 800e9ba:	f883 10d0 	strb.w	r1, [r3, #208]	; 0xd0
                    settings.limits.flags.soft_enabled = Off; // Force disable soft-limits.
 800e9be:	f022 020a 	bic.w	r2, r2, #10
 800e9c2:	f883 20d4 	strb.w	r2, [r3, #212]	; 0xd4
 800e9c6:	e4e0      	b.n	800e38a <settings_store_global_setting+0x7e>
                settings.homing.locate_cycles = int_value < 1 ? 1 :(int_value > 127 ? 127 : int_value);
 800e9c8:	2301      	movs	r3, #1
 800e9ca:	e76a      	b.n	800e8a2 <settings_store_global_setting+0x596>
                        settings.flags.laser_mode = Off;
 800e9cc:	f647 72fd 	movw	r2, #32765	; 0x7ffd
 800e9d0:	4b11      	ldr	r3, [pc, #68]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e9d2:	f8b3 10bc 	ldrh.w	r1, [r3, #188]	; 0xbc
 800e9d6:	400a      	ands	r2, r1
 800e9d8:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 800e9dc:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 800e9e0:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
                        break;
 800e9e4:	e65b      	b.n	800e69e <settings_store_global_setting+0x392>
                        if(!hal.driver_cap.variable_spindle)
 800e9e6:	4b0d      	ldr	r3, [pc, #52]	; (800ea1c <settings_store_global_setting+0x710>)
 800e9e8:	f893 3144 	ldrb.w	r3, [r3, #324]	; 0x144
 800e9ec:	079a      	lsls	r2, r3, #30
 800e9ee:	d510      	bpl.n	800ea12 <settings_store_global_setting+0x706>
                        settings.flags.laser_mode = On;
 800e9f0:	f647 72fd 	movw	r2, #32765	; 0x7ffd
 800e9f4:	4b08      	ldr	r3, [pc, #32]	; (800ea18 <settings_store_global_setting+0x70c>)
 800e9f6:	f8b3 10bc 	ldrh.w	r1, [r3, #188]	; 0xbc
 800e9fa:	400a      	ands	r2, r1
 800e9fc:	f042 0202 	orr.w	r2, r2, #2
 800ea00:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
                        break;
 800ea04:	e64b      	b.n	800e69e <settings_store_global_setting+0x392>
                    return Status_SettingDisabled;
 800ea06:	2005      	movs	r0, #5
 800ea08:	e499      	b.n	800e33e <settings_store_global_setting+0x32>
                    return Status_SettingStepPulseMin;
 800ea0a:	2006      	movs	r0, #6
 800ea0c:	e497      	b.n	800e33e <settings_store_global_setting+0x32>
                    return Status_SoftLimitError;
 800ea0e:	200a      	movs	r0, #10
 800ea10:	e495      	b.n	800e33e <settings_store_global_setting+0x32>
                            return Status_SettingDisabledLaser;
 800ea12:	2011      	movs	r0, #17
 800ea14:	e493      	b.n	800e33e <settings_store_global_setting+0x32>
 800ea16:	bf00      	nop
 800ea18:	20002620 	.word	0x20002620
 800ea1c:	200024bc 	.word	0x200024bc

0800ea20 <settings_init>:

// Initialize the config subsystem
void settings_init() {
 800ea20:	b570      	push	{r4, r5, r6, lr}
    return hal.eeprom.type != EEPROM_None && SETTINGS_VERSION == hal.eeprom.get_byte(0) && hal.eeprom.memcpy_from_with_checksum((uint8_t *)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t));
 800ea22:	4c1b      	ldr	r4, [pc, #108]	; (800ea90 <settings_init+0x70>)
 800ea24:	f894 30f4 	ldrb.w	r3, [r4, #244]	; 0xf4
 800ea28:	b12b      	cbz	r3, 800ea36 <settings_init+0x16>
 800ea2a:	2000      	movs	r0, #0
 800ea2c:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
 800ea30:	4798      	blx	r3
 800ea32:	280f      	cmp	r0, #15
 800ea34:	d00d      	beq.n	800ea52 <settings_init+0x32>
    if(!read_global_settings()) {
        settings_restore_t settings = settings_all;
        settings.defaults = 1; // Ensure global settings get restored
        hal.report.status_message(Status_SettingReadFail);
 800ea36:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 800ea3a:	2007      	movs	r0, #7
 800ea3c:	4798      	blx	r3
        settings_restore(settings); // Force restore all EEPROM data.
 800ea3e:	f04f 001f 	mov.w	r0, #31
 800ea42:	f7ff fbaf 	bl	800e1a4 <settings_restore>
        report_init();
 800ea46:	f7fd faa7 	bl	800bf98 <report_init>
#endif
        hal.settings_changed(&settings);
        if(hal.probe_configure_invert_mask) // Initialize probe invert mask.
            hal.probe_configure_invert_mask(false);
    }
}
 800ea4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        report_grbl_settings();
 800ea4e:	f7fd bba3 	b.w	800c198 <report_grbl_settings>
    return hal.eeprom.type != EEPROM_None && SETTINGS_VERSION == hal.eeprom.get_byte(0) && hal.eeprom.memcpy_from_with_checksum((uint8_t *)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t));
 800ea52:	f44f 7286 	mov.w	r2, #268	; 0x10c
 800ea56:	2101      	movs	r1, #1
 800ea58:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
 800ea5c:	480d      	ldr	r0, [pc, #52]	; (800ea94 <settings_init+0x74>)
 800ea5e:	4798      	blx	r3
 800ea60:	2800      	cmp	r0, #0
 800ea62:	d0e8      	beq.n	800ea36 <settings_init+0x16>
        memset(&tool_table, 0, sizeof(tool_data_t)); // First entry is for tools not in tool table
 800ea64:	2500      	movs	r5, #0
 800ea66:	4b0c      	ldr	r3, [pc, #48]	; (800ea98 <settings_init+0x78>)
 800ea68:	e9c3 5500 	strd	r5, r5, [r3]
 800ea6c:	e9c3 5502 	strd	r5, r5, [r3, #8]
 800ea70:	611d      	str	r5, [r3, #16]
        report_init();
 800ea72:	f7fd fa91 	bl	800bf98 <report_init>
        hal.settings_changed(&settings);
 800ea76:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 800ea7a:	4806      	ldr	r0, [pc, #24]	; (800ea94 <settings_init+0x74>)
 800ea7c:	4798      	blx	r3
        if(hal.probe_configure_invert_mask) // Initialize probe invert mask.
 800ea7e:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800ea82:	b11b      	cbz	r3, 800ea8c <settings_init+0x6c>
            hal.probe_configure_invert_mask(false);
 800ea84:	4628      	mov	r0, r5
}
 800ea86:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.probe_configure_invert_mask(false);
 800ea8a:	4718      	bx	r3
}
 800ea8c:	bd70      	pop	{r4, r5, r6, pc}
 800ea8e:	bf00      	nop
 800ea90:	200024bc 	.word	0x200024bc
 800ea94:	20002620 	.word	0x20002620
 800ea98:	2000247c 	.word	0x2000247c

0800ea9c <fall_asleep>:

volatile bool slumber;

static void fall_asleep()
{
    slumber = false;
 800ea9c:	2200      	movs	r2, #0
 800ea9e:	4b01      	ldr	r3, [pc, #4]	; (800eaa4 <fall_asleep+0x8>)
 800eaa0:	701a      	strb	r2, [r3, #0]
}
 800eaa2:	4770      	bx	lr
 800eaa4:	2000272c 	.word	0x2000272c

0800eaa8 <sleep_execute>:

// Starts sleep timer if running conditions are satified. When elapsed, sleep mode is executed.
static void sleep_execute()
{
    // Enable sleep timeout
    slumber = true;
 800eaa8:	2301      	movs	r3, #1
{
 800eaaa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    hal.delay_ms((uint32_t)(SLEEP_DURATION * 1000.0f * 60.0f), fall_asleep);
 800eaae:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800eb20 <sleep_execute+0x78>
    slumber = true;
 800eab2:	4d16      	ldr	r5, [pc, #88]	; (800eb0c <sleep_execute+0x64>)
    hal.delay_ms((uint32_t)(SLEEP_DURATION * 1000.0f * 60.0f), fall_asleep);
 800eab4:	4916      	ldr	r1, [pc, #88]	; (800eb10 <sleep_execute+0x68>)
 800eab6:	4817      	ldr	r0, [pc, #92]	; (800eb14 <sleep_execute+0x6c>)
    slumber = true;
 800eab8:	702b      	strb	r3, [r5, #0]
    hal.delay_ms((uint32_t)(SLEEP_DURATION * 1000.0f * 60.0f), fall_asleep);
 800eaba:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800eabe:	4798      	blx	r3

    // Fetch current number of buffered characters in input stream buffer.
    uint16_t rx_initial = hal.stream.get_rx_buffer_available();
 800eac0:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
 800eac4:	4798      	blx	r3

    do {
        // Monitor for any new input stream data or external events (queries, buttons, alarms) to exit.
        if ((hal.stream.get_rx_buffer_available() != rx_initial) || sys_rt_exec_state || sys_rt_exec_alarm ) {
 800eac6:	4e14      	ldr	r6, [pc, #80]	; (800eb18 <sleep_execute+0x70>)
    uint16_t rx_initial = hal.stream.get_rx_buffer_available();
 800eac8:	4604      	mov	r4, r0
        if ((hal.stream.get_rx_buffer_available() != rx_initial) || sys_rt_exec_state || sys_rt_exec_alarm ) {
 800eaca:	4f14      	ldr	r7, [pc, #80]	; (800eb1c <sleep_execute+0x74>)
 800eacc:	e005      	b.n	800eada <sleep_execute+0x32>
 800eace:	6833      	ldr	r3, [r6, #0]
 800ead0:	b943      	cbnz	r3, 800eae4 <sleep_execute+0x3c>
 800ead2:	683b      	ldr	r3, [r7, #0]
 800ead4:	b933      	cbnz	r3, 800eae4 <sleep_execute+0x3c>
            // Disable sleep timeout and return to normal operation.
            hal.delay_ms(0, NULL);
            return;
        }
    } while(slumber);
 800ead6:	782b      	ldrb	r3, [r5, #0]
 800ead8:	b15b      	cbz	r3, 800eaf2 <sleep_execute+0x4a>
        if ((hal.stream.get_rx_buffer_available() != rx_initial) || sys_rt_exec_state || sys_rt_exec_alarm ) {
 800eada:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
 800eade:	4798      	blx	r3
 800eae0:	42a0      	cmp	r0, r4
 800eae2:	d0f4      	beq.n	800eace <sleep_execute+0x26>
            hal.delay_ms(0, NULL);
 800eae4:	2100      	movs	r1, #0
 800eae6:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800eaea:	4608      	mov	r0, r1
    // If reached, sleep counter has expired. Execute sleep procedures.
    // Notify user that Grbl has timed out and will be parking.
    // To exit sleep, resume or reset. Either way, the job will not be recoverable.
    hal.report.feedback_message(Message_SleepMode);
    system_set_exec_state_flag(EXEC_SLEEP);
}
 800eaec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            hal.delay_ms(0, NULL);
 800eaf0:	4718      	bx	r3
    hal.report.feedback_message(Message_SleepMode);
 800eaf2:	f8d8 3128 	ldr.w	r3, [r8, #296]	; 0x128
 800eaf6:	200b      	movs	r0, #11
 800eaf8:	4798      	blx	r3
    system_set_exec_state_flag(EXEC_SLEEP);
 800eafa:	f8d8 3080 	ldr.w	r3, [r8, #128]	; 0x80
 800eafe:	f44f 7180 	mov.w	r1, #256	; 0x100
}
 800eb02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    system_set_exec_state_flag(EXEC_SLEEP);
 800eb06:	4804      	ldr	r0, [pc, #16]	; (800eb18 <sleep_execute+0x70>)
 800eb08:	4718      	bx	r3
 800eb0a:	bf00      	nop
 800eb0c:	2000272c 	.word	0x2000272c
 800eb10:	0800ea9d 	.word	0x0800ea9d
 800eb14:	000493e0 	.word	0x000493e0
 800eb18:	200024b4 	.word	0x200024b4
 800eb1c:	2000261c 	.word	0x2000261c
 800eb20:	200024bc 	.word	0x200024bc

0800eb24 <sleep_check>:
{
    // The sleep execution feature will continue only if the machine is in an IDLE or HOLD state and
    // has any powered components enabled.
    // NOTE: With overrides or in laser mode, modal spindle and coolant state are not guaranteed. Need
    // to directly monitor and record running state during parking to ensure proper function.
    if (!sys.steppers_deenergize && (gc_state.modal.spindle.value || gc_state.modal.coolant.value)) {
 800eb24:	4a0c      	ldr	r2, [pc, #48]	; (800eb58 <sleep_check+0x34>)
 800eb26:	79d3      	ldrb	r3, [r2, #7]
 800eb28:	b963      	cbnz	r3, 800eb44 <sleep_check+0x20>
 800eb2a:	4b0c      	ldr	r3, [pc, #48]	; (800eb5c <sleep_check+0x38>)
 800eb2c:	699b      	ldr	r3, [r3, #24]
 800eb2e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800eb32:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800eb36:	b12b      	cbz	r3, 800eb44 <sleep_check+0x20>
        switch(sys.state) {
 800eb38:	6813      	ldr	r3, [r2, #0]
 800eb3a:	2b10      	cmp	r3, #16
 800eb3c:	d003      	beq.n	800eb46 <sleep_check+0x22>
 800eb3e:	2b40      	cmp	r3, #64	; 0x40
 800eb40:	d006      	beq.n	800eb50 <sleep_check+0x2c>
 800eb42:	b11b      	cbz	r3, 800eb4c <sleep_check+0x28>
                if(sys.parking_state == Parking_DoorAjar)
                    sleep_execute();
                break;
        }
    }
}
 800eb44:	4770      	bx	lr
                if(sys.holding_state == Hold_Complete)
 800eb46:	7dd3      	ldrb	r3, [r2, #23]
 800eb48:	2b01      	cmp	r3, #1
 800eb4a:	d1fb      	bne.n	800eb44 <sleep_check+0x20>
                    sleep_execute();
 800eb4c:	f7ff bfac 	b.w	800eaa8 <sleep_execute>
                if(sys.parking_state == Parking_DoorAjar)
 800eb50:	7d93      	ldrb	r3, [r2, #22]
 800eb52:	2b01      	cmp	r3, #1
 800eb54:	d1f6      	bne.n	800eb44 <sleep_check+0x20>
 800eb56:	e7f9      	b.n	800eb4c <sleep_check+0x28>
 800eb58:	20002494 	.word	0x20002494
 800eb5c:	200023dc 	.word	0x200023dc

0800eb60 <spindle_set_state>:

// Immediately sets spindle running state with direction and spindle rpm, if enabled.
// Called by g-code parser spindle_sync(), parking retract and restore, g-code program end,
// sleep, and spindle stop override.
bool spindle_set_state (spindle_state_t state, float rpm)
{
 800eb60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!ABORTED) { // Block during abort.
 800eb64:	4e2e      	ldr	r6, [pc, #184]	; (800ec20 <spindle_set_state+0xc0>)
 800eb66:	7933      	ldrb	r3, [r6, #4]
 800eb68:	b90b      	cbnz	r3, 800eb6e <spindle_set_state+0xe>
 800eb6a:	7973      	ldrb	r3, [r6, #5]
 800eb6c:	b113      	cbz	r3, 800eb74 <spindle_set_state+0x14>

        if (!state.on) { // Halt or set spindle direction and rpm.
            sys.spindle_rpm = rpm = 0.0f;
 800eb6e:	2000      	movs	r0, #0

        st_rpm_changed(rpm);
    }

    return !ABORTED;
}
 800eb70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (!state.on) { // Halt or set spindle direction and rpm.
 800eb74:	4605      	mov	r5, r0
 800eb76:	b2c3      	uxtb	r3, r0
 800eb78:	f015 0001 	ands.w	r0, r5, #1
 800eb7c:	d115      	bne.n	800ebaa <spindle_set_state+0x4a>
            sys.spindle_rpm = rpm = 0.0f;
 800eb7e:	2100      	movs	r1, #0
            hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 800eb80:	4b28      	ldr	r3, [pc, #160]	; (800ec24 <spindle_set_state+0xc4>)
            sys.spindle_rpm = rpm = 0.0f;
 800eb82:	61b1      	str	r1, [r6, #24]
            hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 800eb84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
            sys.spindle_rpm = rpm = 0.0f;
 800eb86:	460c      	mov	r4, r1
            hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 800eb88:	4798      	blx	r3
        sys.report.spindle = On; // Set to report change immediately
 800eb8a:	7d33      	ldrb	r3, [r6, #20]
        st_rpm_changed(rpm);
 800eb8c:	4620      	mov	r0, r4
        sys.report.spindle = On; // Set to report change immediately
 800eb8e:	f043 0310 	orr.w	r3, r3, #16
 800eb92:	7533      	strb	r3, [r6, #20]
        st_rpm_changed(rpm);
 800eb94:	f001 fcba 	bl	801050c <st_rpm_changed>
    return !ABORTED;
 800eb98:	7933      	ldrb	r3, [r6, #4]
 800eb9a:	2b00      	cmp	r3, #0
 800eb9c:	d1e7      	bne.n	800eb6e <spindle_set_state+0xe>
 800eb9e:	7973      	ldrb	r3, [r6, #5]
 800eba0:	2b00      	cmp	r3, #0
 800eba2:	d1e4      	bne.n	800eb6e <spindle_set_state+0xe>
 800eba4:	2001      	movs	r0, #1
}
 800eba6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (settings.flags.laser_mode && state.ccw)
 800ebaa:	f8df 9080 	ldr.w	r9, [pc, #128]	; 800ec2c <spindle_set_state+0xcc>
 800ebae:	460c      	mov	r4, r1
 800ebb0:	f899 20bc 	ldrb.w	r2, [r9, #188]	; 0xbc
 800ebb4:	0792      	lsls	r2, r2, #30
 800ebb6:	d501      	bpl.n	800ebbc <spindle_set_state+0x5c>
 800ebb8:	079b      	lsls	r3, r3, #30
 800ebba:	d427      	bmi.n	800ec0c <spindle_set_state+0xac>
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ebbc:	7c30      	ldrb	r0, [r6, #16]
 800ebbe:	4b19      	ldr	r3, [pc, #100]	; (800ec24 <spindle_set_state+0xc4>)
}

// Calculate and set programmed RPM according to override and max/min limits
float spindle_set_rpm (float rpm, uint8_t override_pct)
{
    if(override_pct != 100)
 800ebc0:	2864      	cmp	r0, #100	; 0x64
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ebc2:	f8d3 a030 	ldr.w	sl, [r3, #48]	; 0x30
    if(override_pct != 100)
 800ebc6:	d027      	beq.n	800ec18 <spindle_set_state+0xb8>
 800ebc8:	f7f1 fd8c 	bl	80006e4 <__aeabi_ui2f>
 800ebcc:	4916      	ldr	r1, [pc, #88]	; (800ec28 <spindle_set_state+0xc8>)
 800ebce:	f7f1 fde1 	bl	8000794 <__aeabi_fmul>
 800ebd2:	4621      	mov	r1, r4
 800ebd4:	f7f1 fdde 	bl	8000794 <__aeabi_fmul>
 800ebd8:	4680      	mov	r8, r0
        rpm *= 0.01f * (float)override_pct; // Scale RPM by override value.

    // Apply RPM limits
    if (rpm <= 0.0f)
 800ebda:	2100      	movs	r1, #0
 800ebdc:	4640      	mov	r0, r8
 800ebde:	f7f1 ff81 	bl	8000ae4 <__aeabi_fcmple>
 800ebe2:	b9d8      	cbnz	r0, 800ec1c <spindle_set_state+0xbc>
        rpm = 0.0f;
    else if (rpm > settings.spindle.rpm_max)
 800ebe4:	f8d9 7044 	ldr.w	r7, [r9, #68]	; 0x44
 800ebe8:	4640      	mov	r0, r8
 800ebea:	4639      	mov	r1, r7
 800ebec:	f7f1 ff8e 	bl	8000b0c <__aeabi_fcmpgt>
 800ebf0:	b938      	cbnz	r0, 800ec02 <spindle_set_state+0xa2>
        rpm = settings.spindle.rpm_max;
    else if (rpm < settings.spindle.rpm_min)
 800ebf2:	f8d9 7048 	ldr.w	r7, [r9, #72]	; 0x48
 800ebf6:	4641      	mov	r1, r8
 800ebf8:	4638      	mov	r0, r7
 800ebfa:	f7f1 ff7d 	bl	8000af8 <__aeabi_fcmpge>
 800ebfe:	b900      	cbnz	r0, 800ec02 <spindle_set_state+0xa2>
 800ec00:	4647      	mov	r7, r8
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ec02:	4639      	mov	r1, r7
 800ec04:	4628      	mov	r0, r5
        rpm = settings.spindle.rpm_min;

    sys.spindle_rpm = rpm;
 800ec06:	61b7      	str	r7, [r6, #24]
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ec08:	47d0      	blx	sl
 800ec0a:	e7be      	b.n	800eb8a <spindle_set_state+0x2a>
                rpm = 0.0f; // TODO: May need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE);
 800ec0c:	2400      	movs	r4, #0
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ec0e:	4b05      	ldr	r3, [pc, #20]	; (800ec24 <spindle_set_state+0xc4>)
        rpm = 0.0f;
 800ec10:	4627      	mov	r7, r4
            hal.spindle_set_state(state, spindle_set_rpm(rpm, sys.override.spindle_rpm));
 800ec12:	f8d3 a030 	ldr.w	sl, [r3, #48]	; 0x30
    if(override_pct != 100)
 800ec16:	e7f4      	b.n	800ec02 <spindle_set_state+0xa2>
 800ec18:	46a0      	mov	r8, r4
 800ec1a:	e7de      	b.n	800ebda <spindle_set_state+0x7a>
        rpm = 0.0f;
 800ec1c:	2700      	movs	r7, #0
 800ec1e:	e7f0      	b.n	800ec02 <spindle_set_state+0xa2>
 800ec20:	20002494 	.word	0x20002494
 800ec24:	200024bc 	.word	0x200024bc
 800ec28:	3c23d70a 	.word	0x3c23d70a
 800ec2c:	20002620 	.word	0x20002620

0800ec30 <spindle_set_override>:
{
 800ec30:	b510      	push	{r4, lr}
    if(sys.override.control.spindle_rpm_disable)
 800ec32:	4c10      	ldr	r4, [pc, #64]	; (800ec74 <spindle_set_override+0x44>)
 800ec34:	7ca3      	ldrb	r3, [r4, #18]
 800ec36:	075b      	lsls	r3, r3, #29
 800ec38:	d414      	bmi.n	800ec64 <spindle_set_override+0x34>
    speed_override = max(min(speed_override, MAX_SPINDLE_RPM_OVERRIDE), MIN_SPINDLE_RPM_OVERRIDE);
 800ec3a:	28c8      	cmp	r0, #200	; 0xc8
 800ec3c:	bf28      	it	cs
 800ec3e:	20c8      	movcs	r0, #200	; 0xc8
    if ((uint8_t)speed_override != sys.override.spindle_rpm) {
 800ec40:	280a      	cmp	r0, #10
 800ec42:	bf38      	it	cc
 800ec44:	200a      	movcc	r0, #10
 800ec46:	7c23      	ldrb	r3, [r4, #16]
 800ec48:	b2c0      	uxtb	r0, r0
 800ec4a:	4283      	cmp	r3, r0
 800ec4c:	d00a      	beq.n	800ec64 <spindle_set_override+0x34>
        if(sys.state == STATE_IDLE)
 800ec4e:	6823      	ldr	r3, [r4, #0]
        sys.override.spindle_rpm = (uint8_t)speed_override;
 800ec50:	7420      	strb	r0, [r4, #16]
        if(sys.state == STATE_IDLE)
 800ec52:	b143      	cbz	r3, 800ec66 <spindle_set_override+0x36>
            sys.step_control.update_spindle_rpm = On;
 800ec54:	7aa3      	ldrb	r3, [r4, #10]
 800ec56:	f043 0308 	orr.w	r3, r3, #8
 800ec5a:	72a3      	strb	r3, [r4, #10]
       sys.report.overrides = On; // Set to report change immediately
 800ec5c:	7d23      	ldrb	r3, [r4, #20]
 800ec5e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ec62:	7523      	strb	r3, [r4, #20]
}
 800ec64:	bd10      	pop	{r4, pc}
            spindle_set_state(gc_state.modal.spindle, gc_state.spindle.rpm);
 800ec66:	4b04      	ldr	r3, [pc, #16]	; (800ec78 <spindle_set_override+0x48>)
 800ec68:	6c99      	ldr	r1, [r3, #72]	; 0x48
 800ec6a:	7e98      	ldrb	r0, [r3, #26]
 800ec6c:	f7ff ff78 	bl	800eb60 <spindle_set_state>
 800ec70:	e7f4      	b.n	800ec5c <spindle_set_override+0x2c>
 800ec72:	bf00      	nop
 800ec74:	20002494 	.word	0x20002494
 800ec78:	200023dc 	.word	0x200023dc

0800ec7c <spindle_sync>:
{
 800ec7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    bool at_speed = sys.state == STATE_CHECK_MODE || !hal.driver_cap.spindle_at_speed;
 800ec80:	4f1a      	ldr	r7, [pc, #104]	; (800ecec <spindle_sync+0x70>)
 800ec82:	683b      	ldr	r3, [r7, #0]
 800ec84:	2b02      	cmp	r3, #2
 800ec86:	d014      	beq.n	800ecb2 <spindle_sync+0x36>
 800ec88:	f8df 8068 	ldr.w	r8, [pc, #104]	; 800ecf4 <spindle_sync+0x78>
 800ec8c:	4606      	mov	r6, r0
 800ec8e:	460d      	mov	r5, r1
 800ec90:	f898 9145 	ldrb.w	r9, [r8, #325]	; 0x145
        if((ok = protocol_buffer_synchronize()) && spindle_set_state(state, rpm) && !at_speed) {
 800ec94:	f7fc ff0e 	bl	800bab4 <protocol_buffer_synchronize>
 800ec98:	4604      	mov	r4, r0
 800ec9a:	b910      	cbnz	r0, 800eca2 <spindle_sync+0x26>
}
 800ec9c:	4620      	mov	r0, r4
 800ec9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if((ok = protocol_buffer_synchronize()) && spindle_set_state(state, rpm) && !at_speed) {
 800eca2:	4629      	mov	r1, r5
 800eca4:	4630      	mov	r0, r6
 800eca6:	f7ff ff5b 	bl	800eb60 <spindle_set_state>
    bool at_speed = sys.state == STATE_CHECK_MODE || !hal.driver_cap.spindle_at_speed;
 800ecaa:	f009 0440 	and.w	r4, r9, #64	; 0x40
        if((ok = protocol_buffer_synchronize()) && spindle_set_state(state, rpm) && !at_speed) {
 800ecae:	b120      	cbz	r0, 800ecba <spindle_sync+0x3e>
 800ecb0:	b93c      	cbnz	r4, 800ecc2 <spindle_sync+0x46>
    bool at_speed = sys.state == STATE_CHECK_MODE || !hal.driver_cap.spindle_at_speed;
 800ecb2:	2401      	movs	r4, #1
}
 800ecb4:	4620      	mov	r0, r4
 800ecb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    bool at_speed = sys.state == STATE_CHECK_MODE || !hal.driver_cap.spindle_at_speed;
 800ecba:	fab4 f484 	clz	r4, r4
 800ecbe:	0964      	lsrs	r4, r4, #5
 800ecc0:	e7ec      	b.n	800ec9c <spindle_sync+0x20>
 800ecc2:	2529      	movs	r5, #41	; 0x29
                delay_sec(0.1f, DelayMode_Dwell);
 800ecc4:	4e0a      	ldr	r6, [pc, #40]	; (800ecf0 <spindle_sync+0x74>)
 800ecc6:	e008      	b.n	800ecda <spindle_sync+0x5e>
 800ecc8:	4621      	mov	r1, r4
 800ecca:	4630      	mov	r0, r6
 800eccc:	f7fb fb18 	bl	800a300 <delay_sec>
                if(ABORTED || delay >= SAFETY_DOOR_SPINDLE_DELAY)
 800ecd0:	88bb      	ldrh	r3, [r7, #4]
 800ecd2:	2b00      	cmp	r3, #0
 800ecd4:	d1e2      	bne.n	800ec9c <spindle_sync+0x20>
 800ecd6:	3d01      	subs	r5, #1
 800ecd8:	d0e0      	beq.n	800ec9c <spindle_sync+0x20>
            while(!(at_speed = hal.spindle_get_state().at_speed)) {
 800ecda:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 800ecde:	4798      	blx	r3
 800ece0:	0643      	lsls	r3, r0, #25
 800ece2:	f3c0 1480 	ubfx	r4, r0, #6, #1
 800ece6:	d5ef      	bpl.n	800ecc8 <spindle_sync+0x4c>
 800ece8:	e7e3      	b.n	800ecb2 <spindle_sync+0x36>
 800ecea:	bf00      	nop
 800ecec:	20002494 	.word	0x20002494
 800ecf0:	3dcccccd 	.word	0x3dcccccd
 800ecf4:	200024bc 	.word	0x200024bc

0800ecf8 <spindle_restore>:
    if(settings.flags.laser_mode) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 800ecf8:	4b1a      	ldr	r3, [pc, #104]	; (800ed64 <spindle_restore+0x6c>)
{
 800ecfa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(settings.flags.laser_mode) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 800ecfe:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 800ed02:	079c      	lsls	r4, r3, #30
 800ed04:	d508      	bpl.n	800ed18 <spindle_restore+0x20>
    bool ok = true;
 800ed06:	2501      	movs	r5, #1
        sys.step_control.update_spindle_rpm = On;
 800ed08:	4a17      	ldr	r2, [pc, #92]	; (800ed68 <spindle_restore+0x70>)
 800ed0a:	7a93      	ldrb	r3, [r2, #10]
 800ed0c:	f043 0308 	orr.w	r3, r3, #8
 800ed10:	7293      	strb	r3, [r2, #10]
}
 800ed12:	4628      	mov	r0, r5
 800ed14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((ok = !hal.driver_cap.spindle_at_speed))
 800ed18:	4e14      	ldr	r6, [pc, #80]	; (800ed6c <spindle_restore+0x74>)
        spindle_set_state(state, rpm);
 800ed1a:	f7ff ff21 	bl	800eb60 <spindle_set_state>
        if((ok = !hal.driver_cap.spindle_at_speed))
 800ed1e:	f896 3145 	ldrb.w	r3, [r6, #325]	; 0x145
 800ed22:	065a      	lsls	r2, r3, #25
 800ed24:	d514      	bpl.n	800ed50 <spindle_restore+0x58>
 800ed26:	2429      	movs	r4, #41	; 0x29
                delay_sec(0.1f, DelayMode_SysSuspend);
 800ed28:	f8df 8044 	ldr.w	r8, [pc, #68]	; 800ed70 <spindle_restore+0x78>
                if(ABORTED || delay >= SAFETY_DOOR_SPINDLE_DELAY)
 800ed2c:	4f0e      	ldr	r7, [pc, #56]	; (800ed68 <spindle_restore+0x70>)
 800ed2e:	e008      	b.n	800ed42 <spindle_restore+0x4a>
                delay_sec(0.1f, DelayMode_SysSuspend);
 800ed30:	2101      	movs	r1, #1
 800ed32:	4640      	mov	r0, r8
 800ed34:	f7fb fae4 	bl	800a300 <delay_sec>
                if(ABORTED || delay >= SAFETY_DOOR_SPINDLE_DELAY)
 800ed38:	88bb      	ldrh	r3, [r7, #4]
 800ed3a:	2b00      	cmp	r3, #0
 800ed3c:	d1e9      	bne.n	800ed12 <spindle_restore+0x1a>
 800ed3e:	3c01      	subs	r4, #1
 800ed40:	d0e7      	beq.n	800ed12 <spindle_restore+0x1a>
            while(!(ok = hal.spindle_get_state().at_speed)) {
 800ed42:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800ed44:	4798      	blx	r3
 800ed46:	0643      	lsls	r3, r0, #25
 800ed48:	f3c0 1580 	ubfx	r5, r0, #6, #1
 800ed4c:	d5f0      	bpl.n	800ed30 <spindle_restore+0x38>
 800ed4e:	e7e0      	b.n	800ed12 <spindle_restore+0x1a>
        if((ok = !hal.driver_cap.spindle_at_speed))
 800ed50:	2501      	movs	r5, #1
            delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DelayMode_SysSuspend);
 800ed52:	2101      	movs	r1, #1
 800ed54:	f04f 4081 	mov.w	r0, #1082130432	; 0x40800000
 800ed58:	f7fb fad2 	bl	800a300 <delay_sec>
}
 800ed5c:	4628      	mov	r0, r5
 800ed5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ed62:	bf00      	nop
 800ed64:	20002620 	.word	0x20002620
 800ed68:	20002494 	.word	0x20002494
 800ed6c:	200024bc 	.word	0x200024bc
 800ed70:	3dcccccd 	.word	0x3dcccccd

0800ed74 <spindle_set_rpm>:
    if(override_pct != 100)
 800ed74:	2964      	cmp	r1, #100	; 0x64
{
 800ed76:	b570      	push	{r4, r5, r6, lr}
    if(override_pct != 100)
 800ed78:	d02c      	beq.n	800edd4 <spindle_set_rpm+0x60>
 800ed7a:	460d      	mov	r5, r1
        rpm *= 0.01f * (float)override_pct; // Scale RPM by override value.
 800ed7c:	4916      	ldr	r1, [pc, #88]	; (800edd8 <spindle_set_rpm+0x64>)
 800ed7e:	f7f1 fd09 	bl	8000794 <__aeabi_fmul>
 800ed82:	4604      	mov	r4, r0
 800ed84:	4628      	mov	r0, r5
 800ed86:	f7f1 fcad 	bl	80006e4 <__aeabi_ui2f>
 800ed8a:	4621      	mov	r1, r4
 800ed8c:	f7f1 fd02 	bl	8000794 <__aeabi_fmul>
 800ed90:	4604      	mov	r4, r0
    if (rpm <= 0.0f)
 800ed92:	2100      	movs	r1, #0
 800ed94:	4620      	mov	r0, r4
 800ed96:	f7f1 fea5 	bl	8000ae4 <__aeabi_fcmple>
 800ed9a:	b9b0      	cbnz	r0, 800edca <spindle_set_rpm+0x56>
    else if (rpm > settings.spindle.rpm_max)
 800ed9c:	4e0f      	ldr	r6, [pc, #60]	; (800eddc <spindle_set_rpm+0x68>)
 800ed9e:	4621      	mov	r1, r4
 800eda0:	6c75      	ldr	r5, [r6, #68]	; 0x44
 800eda2:	4628      	mov	r0, r5
 800eda4:	f7f1 fe94 	bl	8000ad0 <__aeabi_fcmplt>
 800eda8:	b118      	cbz	r0, 800edb2 <spindle_set_rpm+0x3e>
    sys.spindle_rpm = rpm;
 800edaa:	4b0d      	ldr	r3, [pc, #52]	; (800ede0 <spindle_set_rpm+0x6c>)

    return rpm;
}
 800edac:	4628      	mov	r0, r5
    sys.spindle_rpm = rpm;
 800edae:	619d      	str	r5, [r3, #24]
}
 800edb0:	bd70      	pop	{r4, r5, r6, pc}
    else if (rpm < settings.spindle.rpm_min)
 800edb2:	6cb5      	ldr	r5, [r6, #72]	; 0x48
 800edb4:	4621      	mov	r1, r4
 800edb6:	4628      	mov	r0, r5
 800edb8:	f7f1 fe9e 	bl	8000af8 <__aeabi_fcmpge>
 800edbc:	2800      	cmp	r0, #0
 800edbe:	d1f4      	bne.n	800edaa <spindle_set_rpm+0x36>
 800edc0:	4625      	mov	r5, r4
    sys.spindle_rpm = rpm;
 800edc2:	4b07      	ldr	r3, [pc, #28]	; (800ede0 <spindle_set_rpm+0x6c>)
}
 800edc4:	4628      	mov	r0, r5
    sys.spindle_rpm = rpm;
 800edc6:	619d      	str	r5, [r3, #24]
}
 800edc8:	bd70      	pop	{r4, r5, r6, pc}
        rpm = 0.0f;
 800edca:	2500      	movs	r5, #0
    sys.spindle_rpm = rpm;
 800edcc:	4b04      	ldr	r3, [pc, #16]	; (800ede0 <spindle_set_rpm+0x6c>)
}
 800edce:	4628      	mov	r0, r5
    sys.spindle_rpm = rpm;
 800edd0:	619d      	str	r5, [r3, #24]
}
 800edd2:	bd70      	pop	{r4, r5, r6, pc}
 800edd4:	4604      	mov	r4, r0
 800edd6:	e7dc      	b.n	800ed92 <spindle_set_rpm+0x1e>
 800edd8:	3c23d70a 	.word	0x3c23d70a
 800eddc:	20002620 	.word	0x20002620
 800ede0:	20002494 	.word	0x20002494

0800ede4 <spindle_precompute_pwm_values>:
}

// Precompute PWM values for faster conversion.
// Returns false if no PWM range possible, driver should revert to simple on/off spindle control if so.
bool spindle_precompute_pwm_values (spindle_pwm_t *pwm_data, uint32_t clock_hz)
{
 800ede4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if(settings.spindle.rpm_max > settings.spindle.rpm_min) {
 800ede8:	4d36      	ldr	r5, [pc, #216]	; (800eec4 <spindle_precompute_pwm_values+0xe0>)
{
 800edea:	460e      	mov	r6, r1
    if(settings.spindle.rpm_max > settings.spindle.rpm_min) {
 800edec:	6c6f      	ldr	r7, [r5, #68]	; 0x44
 800edee:	f8d5 8048 	ldr.w	r8, [r5, #72]	; 0x48
{
 800edf2:	4604      	mov	r4, r0
    if(settings.spindle.rpm_max > settings.spindle.rpm_min) {
 800edf4:	4641      	mov	r1, r8
 800edf6:	4638      	mov	r0, r7
 800edf8:	f7f1 fe88 	bl	8000b0c <__aeabi_fcmpgt>
 800edfc:	2800      	cmp	r0, #0
 800edfe:	d045      	beq.n	800ee8c <spindle_precompute_pwm_values+0xa8>
        pwm_data->period = (uint_fast16_t)((float)clock_hz / settings.spindle.pwm_freq);
 800ee00:	4630      	mov	r0, r6
 800ee02:	f7f1 fc6f 	bl	80006e4 <__aeabi_ui2f>
 800ee06:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
 800ee08:	f7f1 fd78 	bl	80008fc <__aeabi_fdiv>
 800ee0c:	f7f1 fec4 	bl	8000b98 <__aeabi_f2uiz>
        if(settings.spindle.pwm_off_value == 0.0f)
 800ee10:	f8d5 a054 	ldr.w	sl, [r5, #84]	; 0x54
        pwm_data->period = (uint_fast16_t)((float)clock_hz / settings.spindle.pwm_freq);
 800ee14:	4606      	mov	r6, r0
 800ee16:	6020      	str	r0, [r4, #0]
        if(settings.spindle.pwm_off_value == 0.0f)
 800ee18:	2100      	movs	r1, #0
 800ee1a:	4650      	mov	r0, sl
 800ee1c:	f7f1 fe4e 	bl	8000abc <__aeabi_fcmpeq>
 800ee20:	2800      	cmp	r0, #0
 800ee22:	d03c      	beq.n	800ee9e <spindle_precompute_pwm_values+0xba>
            pwm_data->off_value = pwm_data->invert_pwm ? pwm_data->period : 0;
 800ee24:	7d23      	ldrb	r3, [r4, #20]
 800ee26:	4630      	mov	r0, r6
 800ee28:	2b00      	cmp	r3, #0
 800ee2a:	bf08      	it	eq
 800ee2c:	2600      	moveq	r6, #0
 800ee2e:	6066      	str	r6, [r4, #4]
 800ee30:	f7f1 fc58 	bl	80006e4 <__aeabi_ui2f>
 800ee34:	4681      	mov	r9, r0
        else
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
        pwm_data->min_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_min_value / 100.0f);
 800ee36:	6da8      	ldr	r0, [r5, #88]	; 0x58
 800ee38:	4923      	ldr	r1, [pc, #140]	; (800eec8 <spindle_precompute_pwm_values+0xe4>)
 800ee3a:	f7f1 fcab 	bl	8000794 <__aeabi_fmul>
 800ee3e:	4649      	mov	r1, r9
 800ee40:	f7f1 fca8 	bl	8000794 <__aeabi_fmul>
 800ee44:	f7f1 fea8 	bl	8000b98 <__aeabi_f2uiz>
 800ee48:	4606      	mov	r6, r0
        pwm_data->max_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_max_value / 100.0f) - 1;
 800ee4a:	491f      	ldr	r1, [pc, #124]	; (800eec8 <spindle_precompute_pwm_values+0xe4>)
 800ee4c:	6de8      	ldr	r0, [r5, #92]	; 0x5c
        pwm_data->min_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_min_value / 100.0f);
 800ee4e:	60a6      	str	r6, [r4, #8]
        pwm_data->max_value = (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_max_value / 100.0f) - 1;
 800ee50:	f7f1 fca0 	bl	8000794 <__aeabi_fmul>
 800ee54:	4649      	mov	r1, r9
 800ee56:	f7f1 fc9d 	bl	8000794 <__aeabi_fmul>
 800ee5a:	f7f1 fe9d 	bl	8000b98 <__aeabi_f2uiz>
 800ee5e:	3801      	subs	r0, #1
 800ee60:	60e0      	str	r0, [r4, #12]
        pwm_data->pwm_gradient = (float)(pwm_data->max_value - pwm_data->min_value) / (settings.spindle.rpm_max - settings.spindle.rpm_min);
 800ee62:	1b80      	subs	r0, r0, r6
 800ee64:	f7f1 fc3e 	bl	80006e4 <__aeabi_ui2f>
 800ee68:	4641      	mov	r1, r8
 800ee6a:	4605      	mov	r5, r0
 800ee6c:	4638      	mov	r0, r7
 800ee6e:	f7f1 fb87 	bl	8000580 <__aeabi_fsub>
 800ee72:	4601      	mov	r1, r0
 800ee74:	4628      	mov	r0, r5
 800ee76:	f7f1 fd41 	bl	80008fc <__aeabi_fdiv>
        pwm_data->always_on = settings.spindle.pwm_off_value != 0.0f;
 800ee7a:	2100      	movs	r1, #0
        pwm_data->pwm_gradient = (float)(pwm_data->max_value - pwm_data->min_value) / (settings.spindle.rpm_max - settings.spindle.rpm_min);
 800ee7c:	6120      	str	r0, [r4, #16]
        pwm_data->always_on = settings.spindle.pwm_off_value != 0.0f;
 800ee7e:	4650      	mov	r0, sl
 800ee80:	f7f1 fe1c 	bl	8000abc <__aeabi_fcmpeq>
 800ee84:	fab0 f080 	clz	r0, r0
 800ee88:	0940      	lsrs	r0, r0, #5
 800ee8a:	7560      	strb	r0, [r4, #21]
        if(!isnan(settings.spindle.pwm_piece[idx].rpm) && settings.spindle.pwm_piece[idx].start != 0.0f)
            memcpy(&pwm_data->piece[pwm_data->n_pieces++], &settings.spindle.pwm_piece[idx], sizeof(pwm_piece_t));
    }
#endif

    return settings.spindle.rpm_max > settings.spindle.rpm_min;
 800ee8c:	4641      	mov	r1, r8
 800ee8e:	4638      	mov	r0, r7
 800ee90:	f7f1 fe3c 	bl	8000b0c <__aeabi_fcmpgt>
}
 800ee94:	3800      	subs	r0, #0
 800ee96:	bf18      	it	ne
 800ee98:	2001      	movne	r0, #1
 800ee9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
 800ee9e:	4630      	mov	r0, r6
 800eea0:	f7f1 fc20 	bl	80006e4 <__aeabi_ui2f>
 800eea4:	4681      	mov	r9, r0
 800eea6:	4908      	ldr	r1, [pc, #32]	; (800eec8 <spindle_precompute_pwm_values+0xe4>)
 800eea8:	4650      	mov	r0, sl
 800eeaa:	f7f1 fc73 	bl	8000794 <__aeabi_fmul>
 800eeae:	4649      	mov	r1, r9
 800eeb0:	f7f1 fc70 	bl	8000794 <__aeabi_fmul>
 800eeb4:	f7f1 fe70 	bl	8000b98 <__aeabi_f2uiz>
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 800eeb8:	7d23      	ldrb	r3, [r4, #20]
 800eeba:	b10b      	cbz	r3, 800eec0 <spindle_precompute_pwm_values+0xdc>
 800eebc:	3e01      	subs	r6, #1
 800eebe:	1a30      	subs	r0, r6, r0
            pwm_data->off_value = invert_pwm(pwm_data, (uint_fast16_t)(pwm_data->period * settings.spindle.pwm_off_value / 100.0f));
 800eec0:	6060      	str	r0, [r4, #4]
 800eec2:	e7b8      	b.n	800ee36 <spindle_precompute_pwm_values+0x52>
 800eec4:	20002620 	.word	0x20002620
 800eec8:	3c23d70a 	.word	0x3c23d70a

0800eecc <spindle_compute_pwm_value>:

// Spindle RPM to PWM conversion.
uint_fast16_t spindle_compute_pwm_value (spindle_pwm_t *pwm_data, float rpm, bool pid_limit)
{
 800eecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint_fast16_t pwm_value;

    if(rpm > settings.spindle.rpm_min) {
 800eece:	4b1c      	ldr	r3, [pc, #112]	; (800ef40 <spindle_compute_pwm_value+0x74>)
{
 800eed0:	4604      	mov	r4, r0
    if(rpm > settings.spindle.rpm_min) {
 800eed2:	6c9e      	ldr	r6, [r3, #72]	; 0x48
{
 800eed4:	4617      	mov	r7, r2
    if(rpm > settings.spindle.rpm_min) {
 800eed6:	4630      	mov	r0, r6
{
 800eed8:	460d      	mov	r5, r1
    if(rpm > settings.spindle.rpm_min) {
 800eeda:	f7f1 fdf9 	bl	8000ad0 <__aeabi_fcmplt>
 800eede:	b1b0      	cbz	r0, 800ef0e <spindle_compute_pwm_value+0x42>
                }
            } while(idx);
        } else
      #endif
        // Compute intermediate PWM value with linear spindle speed model.
        pwm_value = (uint_fast16_t)floorf((rpm - settings.spindle.rpm_min) * pwm_data->pwm_gradient) + pwm_data->min_value;
 800eee0:	4631      	mov	r1, r6
 800eee2:	4628      	mov	r0, r5
 800eee4:	f7f1 fb4c 	bl	8000580 <__aeabi_fsub>
 800eee8:	6921      	ldr	r1, [r4, #16]
 800eeea:	f7f1 fc53 	bl	8000794 <__aeabi_fmul>
 800eeee:	f003 fef9 	bl	8012ce4 <floorf>
 800eef2:	f7f1 fe51 	bl	8000b98 <__aeabi_f2uiz>
 800eef6:	68a1      	ldr	r1, [r4, #8]
 800eef8:	1843      	adds	r3, r0, r1

        if(pwm_value >= (pid_limit ? pwm_data->period : pwm_data->max_value))
 800eefa:	b1bf      	cbz	r7, 800ef2c <spindle_compute_pwm_value+0x60>
 800eefc:	6822      	ldr	r2, [r4, #0]
 800eefe:	4293      	cmp	r3, r2
 800ef00:	d318      	bcc.n	800ef34 <spindle_compute_pwm_value+0x68>
            pwm_value = pid_limit ? pwm_data->period - 1 : pwm_data->max_value;
 800ef02:	1e50      	subs	r0, r2, #1
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 800ef04:	7d23      	ldrb	r3, [r4, #20]
 800ef06:	b10b      	cbz	r3, 800ef0c <spindle_compute_pwm_value+0x40>
 800ef08:	3a01      	subs	r2, #1
 800ef0a:	1a10      	subs	r0, r2, r0
        pwm_value = invert_pwm(pwm_data, pwm_value);
    } else
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);

    return pwm_value;
}
 800ef0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);
 800ef0e:	4628      	mov	r0, r5
 800ef10:	2100      	movs	r1, #0
 800ef12:	f7f1 fdd3 	bl	8000abc <__aeabi_fcmpeq>
 800ef16:	b108      	cbz	r0, 800ef1c <spindle_compute_pwm_value+0x50>
 800ef18:	6860      	ldr	r0, [r4, #4]
}
 800ef1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 800ef1c:	7d22      	ldrb	r2, [r4, #20]
        pwm_value = rpm == 0.0f ? pwm_data->off_value : invert_pwm(pwm_data, pwm_data->min_value);
 800ef1e:	68a0      	ldr	r0, [r4, #8]
 800ef20:	6823      	ldr	r3, [r4, #0]
    return pwm_data->invert_pwm ? pwm_data->period - pwm_value - 1 : pwm_value;
 800ef22:	2a00      	cmp	r2, #0
 800ef24:	d0f2      	beq.n	800ef0c <spindle_compute_pwm_value+0x40>
 800ef26:	3b01      	subs	r3, #1
 800ef28:	1a18      	subs	r0, r3, r0
}
 800ef2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if(pwm_value >= (pid_limit ? pwm_data->period : pwm_data->max_value))
 800ef2c:	68e0      	ldr	r0, [r4, #12]
 800ef2e:	6822      	ldr	r2, [r4, #0]
 800ef30:	4283      	cmp	r3, r0
 800ef32:	d2e7      	bcs.n	800ef04 <spindle_compute_pwm_value+0x38>
        else if(pwm_value < pwm_data->min_value)
 800ef34:	4299      	cmp	r1, r3
 800ef36:	bf38      	it	cc
 800ef38:	4619      	movcc	r1, r3
 800ef3a:	4608      	mov	r0, r1
 800ef3c:	e7e2      	b.n	800ef04 <spindle_compute_pwm_value+0x38>
 800ef3e:	bf00      	nop
 800ef40:	20002620 	.word	0x20002620

0800ef44 <state_noop>:
}

static void state_noop (uint_fast16_t rt_exec)
{
    // Do nothing - state change requests are handled elsewhere or ignored.
}
 800ef44:	4770      	bx	lr
 800ef46:	bf00      	nop

0800ef48 <state_await_hold.part.0>:
static void state_await_hold (uint_fast16_t rt_exec)
 800ef48:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        sys.step_control.flags = 0;
 800ef4c:	2500      	movs	r5, #0
 800ef4e:	4c4e      	ldr	r4, [pc, #312]	; (800f088 <state_await_hold.part.0+0x140>)
        plan_cycle_reinitialize();
 800ef50:	f7fc f878 	bl	800b044 <plan_cycle_reinitialize>
        switch (sys.state) {
 800ef54:	6823      	ldr	r3, [r4, #0]
        sys.step_control.flags = 0;
 800ef56:	72a5      	strb	r5, [r4, #10]
        switch (sys.state) {
 800ef58:	2b80      	cmp	r3, #128	; 0x80
 800ef5a:	d00b      	beq.n	800ef74 <state_await_hold.part.0+0x2c>
 800ef5c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800ef60:	d01b      	beq.n	800ef9a <state_await_hold.part.0+0x52>
 800ef62:	2b40      	cmp	r3, #64	; 0x40
 800ef64:	d006      	beq.n	800ef74 <state_await_hold.part.0+0x2c>
            sys.holding_state = Hold_Complete;
 800ef66:	2101      	movs	r1, #1
            stateHandler = state_await_resume;
 800ef68:	4b48      	ldr	r3, [pc, #288]	; (800f08c <state_await_hold.part.0+0x144>)
 800ef6a:	4a49      	ldr	r2, [pc, #292]	; (800f090 <state_await_hold.part.0+0x148>)
            sys.holding_state = Hold_Complete;
 800ef6c:	75e1      	strb	r1, [r4, #23]
            stateHandler = state_await_resume;
 800ef6e:	601a      	str	r2, [r3, #0]
}
 800ef70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                sys.override.spindle_stop.value = 0;
 800ef74:	2300      	movs	r3, #0
                if(settings.parking.flags.enabled) {
 800ef76:	4e47      	ldr	r6, [pc, #284]	; (800f094 <state_await_hold.part.0+0x14c>)
                sys.override.spindle_stop.value = 0;
 800ef78:	7463      	strb	r3, [r4, #17]
                if(settings.parking.flags.enabled) {
 800ef7a:	f896 00d8 	ldrb.w	r0, [r6, #216]	; 0xd8
 800ef7e:	f010 0501 	ands.w	r5, r0, #1
 800ef82:	d113      	bne.n	800efac <state_await_hold.part.0+0x64>
                    hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800ef84:	4e44      	ldr	r6, [pc, #272]	; (800f098 <state_await_hold.part.0+0x150>)
 800ef86:	2100      	movs	r1, #0
 800ef88:	4628      	mov	r0, r5
 800ef8a:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800ef8c:	4798      	blx	r3
                    hal.coolant_set_state((coolant_state_t){0}); // De-energize
 800ef8e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800ef90:	4628      	mov	r0, r5
 800ef92:	4798      	blx	r3
                    sys.parking_state = Parking_DoorAjar;
 800ef94:	2301      	movs	r3, #1
 800ef96:	75a3      	strb	r3, [r4, #22]
        if(!handler_changed) {
 800ef98:	e7e5      	b.n	800ef66 <state_await_hold.part.0+0x1e>
                hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800ef9a:	4e3f      	ldr	r6, [pc, #252]	; (800f098 <state_await_hold.part.0+0x150>)
 800ef9c:	4628      	mov	r0, r5
 800ef9e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800efa0:	2100      	movs	r1, #0
 800efa2:	4798      	blx	r3
                hal.coolant_set_state((coolant_state_t){0}); // De-energize
 800efa4:	4628      	mov	r0, r5
 800efa6:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800efa8:	4798      	blx	r3
        if(!handler_changed) {
 800efaa:	e7dc      	b.n	800ef66 <state_await_hold.part.0+0x1e>
                    system_convert_array_steps_to_mpos(park.target, sys_position);
 800efac:	4d3b      	ldr	r5, [pc, #236]	; (800f09c <state_await_hold.part.0+0x154>)
 800efae:	493c      	ldr	r1, [pc, #240]	; (800f0a0 <state_await_hold.part.0+0x158>)
 800efb0:	4628      	mov	r0, r5
 800efb2:	f002 fbb9 	bl	8011728 <system_convert_array_steps_to_mpos>
                    if (!park.restart_retract) {
 800efb6:	7f6b      	ldrb	r3, [r5, #29]
 800efb8:	2b00      	cmp	r3, #0
 800efba:	d032      	beq.n	800f022 <state_await_hold.part.0+0xda>
 800efbc:	f896 70d9 	ldrb.w	r7, [r6, #217]	; 0xd9
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.target[settings.parking.axis] < settings.parking.target) && !settings.flags.laser_mode && !sys.override.control.parking_disable) {
 800efc0:	7b63      	ldrb	r3, [r4, #13]
 800efc2:	40fb      	lsrs	r3, r7
 800efc4:	07db      	lsls	r3, r3, #31
 800efc6:	d51f      	bpl.n	800f008 <state_await_hold.part.0+0xc0>
 800efc8:	f855 8027 	ldr.w	r8, [r5, r7, lsl #2]
 800efcc:	f8d6 10dc 	ldr.w	r1, [r6, #220]	; 0xdc
 800efd0:	4640      	mov	r0, r8
 800efd2:	f7f1 fd7d 	bl	8000ad0 <__aeabi_fcmplt>
 800efd6:	b1b8      	cbz	r0, 800f008 <state_await_hold.part.0+0xc0>
 800efd8:	f896 20bc 	ldrb.w	r2, [r6, #188]	; 0xbc
 800efdc:	7ca3      	ldrb	r3, [r4, #18]
 800efde:	f002 0202 	and.w	r2, r2, #2
 800efe2:	f003 0308 	and.w	r3, r3, #8
 800efe6:	4313      	orrs	r3, r2
 800efe8:	d10e      	bne.n	800f008 <state_await_hold.part.0+0xc0>
                        stateHandler = state_await_waypoint_retract;
 800efea:	4c28      	ldr	r4, [pc, #160]	; (800f08c <state_await_hold.part.0+0x144>)
 800efec:	4b2d      	ldr	r3, [pc, #180]	; (800f0a4 <state_await_hold.part.0+0x15c>)
                        if (park.target[settings.parking.axis] < park.retract_waypoint) {
 800efee:	f8d5 9018 	ldr.w	r9, [r5, #24]
 800eff2:	4640      	mov	r0, r8
 800eff4:	4649      	mov	r1, r9
                        stateHandler = state_await_waypoint_retract;
 800eff6:	6023      	str	r3, [r4, #0]
                        if (park.target[settings.parking.axis] < park.retract_waypoint) {
 800eff8:	f7f1 fd6a 	bl	8000ad0 <__aeabi_fcmplt>
 800effc:	bb58      	cbnz	r0, 800f056 <state_await_hold.part.0+0x10e>
                            stateHandler(EXEC_CYCLE_COMPLETE);
 800effe:	6823      	ldr	r3, [r4, #0]
 800f000:	2004      	movs	r0, #4
}
 800f002:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                            stateHandler(EXEC_CYCLE_COMPLETE);
 800f006:	4718      	bx	r3
                        hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800f008:	4d23      	ldr	r5, [pc, #140]	; (800f098 <state_await_hold.part.0+0x150>)
 800f00a:	2100      	movs	r1, #0
 800f00c:	f04f 0000 	mov.w	r0, #0
 800f010:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800f012:	4798      	blx	r3
                        hal.coolant_set_state((coolant_state_t){0});     // De-energize
 800f014:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800f016:	f04f 0000 	mov.w	r0, #0
 800f01a:	4798      	blx	r3
                        sys.parking_state = Parking_DoorAjar;
 800f01c:	2301      	movs	r3, #1
 800f01e:	75a3      	strb	r3, [r4, #22]
        if(!handler_changed) {
 800f020:	e7a1      	b.n	800ef66 <state_await_hold.part.0+0x1e>
                        memcpy(park.restore_target, park.target, sizeof(park.target));
 800f022:	f105 030c 	add.w	r3, r5, #12
 800f026:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800f02a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                        park.retract_waypoint += park.restore_target[settings.parking.axis];
 800f02e:	f896 70d9 	ldrb.w	r7, [r6, #217]	; 0xd9
 800f032:	69a8      	ldr	r0, [r5, #24]
 800f034:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 800f038:	68d9      	ldr	r1, [r3, #12]
 800f03a:	f7f1 faa3 	bl	8000584 <__addsf3>
                        park.retract_waypoint = min(park.retract_waypoint, settings.parking.target);
 800f03e:	f8d6 90dc 	ldr.w	r9, [r6, #220]	; 0xdc
 800f042:	4680      	mov	r8, r0
 800f044:	4649      	mov	r1, r9
 800f046:	f7f1 fd4d 	bl	8000ae4 <__aeabi_fcmple>
 800f04a:	b110      	cbz	r0, 800f052 <state_await_hold.part.0+0x10a>
 800f04c:	f8c5 8018 	str.w	r8, [r5, #24]
 800f050:	e7b6      	b.n	800efc0 <state_await_hold.part.0+0x78>
 800f052:	46c8      	mov	r8, r9
 800f054:	e7fa      	b.n	800f04c <state_await_hold.part.0+0x104>
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f056:	f8d6 10e4 	ldr.w	r1, [r6, #228]	; 0xe4
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f05a:	4b13      	ldr	r3, [pc, #76]	; (800f0a8 <state_await_hold.part.0+0x160>)
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f05c:	4a13      	ldr	r2, [pc, #76]	; (800f0ac <state_await_hold.part.0+0x164>)
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f05e:	78d8      	ldrb	r0, [r3, #3]
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f060:	6229      	str	r1, [r5, #32]
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f062:	4913      	ldr	r1, [pc, #76]	; (800f0b0 <state_await_hold.part.0+0x168>)
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f064:	6812      	ldr	r2, [r2, #0]
                            park.plan_data.condition.spindle = restore_condition.spindle; // Retain spindle state
 800f066:	789b      	ldrb	r3, [r3, #2]
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f068:	f885 0043 	strb.w	r0, [r5, #67]	; 0x43
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f06c:	f1a1 0020 	sub.w	r0, r1, #32
                            park.target[settings.parking.axis] = park.retract_waypoint;
 800f070:	f845 9027 	str.w	r9, [r5, r7, lsl #2]
                            park.plan_data.condition.spindle = restore_condition.spindle; // Retain spindle state
 800f074:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f078:	626a      	str	r2, [r5, #36]	; 0x24
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f07a:	f7fa fe8b 	bl	8009d94 <mc_parking_motion>
 800f07e:	7728      	strb	r0, [r5, #28]
 800f080:	2800      	cmp	r0, #0
 800f082:	f47f af75 	bne.w	800ef70 <state_await_hold.part.0+0x28>
 800f086:	e7ba      	b.n	800effe <state_await_hold.part.0+0xb6>
 800f088:	20002494 	.word	0x20002494
 800f08c:	20000018 	.word	0x20000018
 800f090:	0800fc81 	.word	0x0800fc81
 800f094:	20002620 	.word	0x20002620
 800f098:	200024bc 	.word	0x200024bc
 800f09c:	20001ad4 	.word	0x20001ad4
 800f0a0:	20002610 	.word	0x20002610
 800f0a4:	0800f0b5 	.word	0x0800f0b5
 800f0a8:	20001b30 	.word	0x20001b30
 800f0ac:	20001b34 	.word	0x20001b34
 800f0b0:	20001af4 	.word	0x20001af4

0800f0b4 <state_await_waypoint_retract>:
{
 800f0b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f0b8:	0744      	lsls	r4, r0, #29
 800f0ba:	d525      	bpl.n	800f108 <state_await_waypoint_retract+0x54>
        if(sys.step_control.execute_sys_motion) {
 800f0bc:	4a29      	ldr	r2, [pc, #164]	; (800f164 <state_await_waypoint_retract+0xb0>)
 800f0be:	7a93      	ldrb	r3, [r2, #10]
 800f0c0:	0758      	lsls	r0, r3, #29
 800f0c2:	d43f      	bmi.n	800f144 <state_await_waypoint_retract+0x90>
        park.plan_data.condition.spindle.value = 0;
 800f0c4:	2500      	movs	r5, #0
        park.plan_data.spindle.rpm = 0.0f;
 800f0c6:	2100      	movs	r1, #0
        park.plan_data.condition.spindle.value = 0;
 800f0c8:	4c27      	ldr	r4, [pc, #156]	; (800f168 <state_await_waypoint_retract+0xb4>)
        hal.spindle_set_state(park.plan_data.condition.spindle, 0.0f); // De-energize
 800f0ca:	4f28      	ldr	r7, [pc, #160]	; (800f16c <state_await_waypoint_retract+0xb8>)
 800f0cc:	4628      	mov	r0, r5
 800f0ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        park.plan_data.spindle.rpm = 0.0f;
 800f0d0:	6261      	str	r1, [r4, #36]	; 0x24
        if (park.target[settings.parking.axis] < settings.parking.target) {
 800f0d2:	4e27      	ldr	r6, [pc, #156]	; (800f170 <state_await_waypoint_retract+0xbc>)
        park.plan_data.condition.spindle.value = 0;
 800f0d4:	f884 5042 	strb.w	r5, [r4, #66]	; 0x42
        hal.spindle_set_state(park.plan_data.condition.spindle, 0.0f); // De-energize
 800f0d8:	4798      	blx	r3
        hal.coolant_set_state(park.plan_data.condition.coolant); // De-energize
 800f0da:	4628      	mov	r0, r5
 800f0dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        park.plan_data.condition.coolant.value = 0;
 800f0de:	f884 5043 	strb.w	r5, [r4, #67]	; 0x43
        hal.coolant_set_state(park.plan_data.condition.coolant); // De-energize
 800f0e2:	4798      	blx	r3
        stateHandler = state_await_resume;
 800f0e4:	4d23      	ldr	r5, [pc, #140]	; (800f174 <state_await_waypoint_retract+0xc0>)
        if (park.target[settings.parking.axis] < settings.parking.target) {
 800f0e6:	f896 70d9 	ldrb.w	r7, [r6, #217]	; 0xd9
 800f0ea:	f8d6 80dc 	ldr.w	r8, [r6, #220]	; 0xdc
        stateHandler = state_await_resume;
 800f0ee:	4b22      	ldr	r3, [pc, #136]	; (800f178 <state_await_waypoint_retract+0xc4>)
        if (park.target[settings.parking.axis] < settings.parking.target) {
 800f0f0:	4641      	mov	r1, r8
 800f0f2:	f854 0027 	ldr.w	r0, [r4, r7, lsl #2]
        stateHandler = state_await_resume;
 800f0f6:	602b      	str	r3, [r5, #0]
        if (park.target[settings.parking.axis] < settings.parking.target) {
 800f0f8:	f7f1 fcea 	bl	8000ad0 <__aeabi_fcmplt>
 800f0fc:	b990      	cbnz	r0, 800f124 <state_await_waypoint_retract+0x70>
            stateHandler(EXEC_CYCLE_COMPLETE);
 800f0fe:	682b      	ldr	r3, [r5, #0]
 800f100:	2004      	movs	r0, #4
}
 800f102:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            stateHandler(EXEC_CYCLE_COMPLETE);
 800f106:	4718      	bx	r3
    } else if (rt_exec & EXEC_CYCLE_START) {
 800f108:	0781      	lsls	r1, r0, #30
 800f10a:	d519      	bpl.n	800f140 <state_await_waypoint_retract+0x8c>
        if (sys.step_control.execute_sys_motion) {
 800f10c:	4c15      	ldr	r4, [pc, #84]	; (800f164 <state_await_waypoint_retract+0xb0>)
        stateHandler = state_await_waypoint_cancel;
 800f10e:	4b19      	ldr	r3, [pc, #100]	; (800f174 <state_await_waypoint_retract+0xc0>)
        if (sys.step_control.execute_sys_motion) {
 800f110:	7aa2      	ldrb	r2, [r4, #10]
        stateHandler = state_await_waypoint_cancel;
 800f112:	491a      	ldr	r1, [pc, #104]	; (800f17c <state_await_waypoint_retract+0xc8>)
        if (sys.step_control.execute_sys_motion) {
 800f114:	0752      	lsls	r2, r2, #29
        stateHandler = state_await_waypoint_cancel;
 800f116:	6019      	str	r1, [r3, #0]
        if (sys.step_control.execute_sys_motion) {
 800f118:	d41a      	bmi.n	800f150 <state_await_waypoint_retract+0x9c>
}
 800f11a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            stateHandler(EXEC_CYCLE_COMPLETE);
 800f11e:	2004      	movs	r0, #4
 800f120:	681b      	ldr	r3, [r3, #0]
 800f122:	4718      	bx	r3
            park.plan_data.feed_rate = settings.parking.rate;
 800f124:	4621      	mov	r1, r4
 800f126:	f8d6 30e0 	ldr.w	r3, [r6, #224]	; 0xe0
            if(mc_parking_motion(park.target, &park.plan_data))
 800f12a:	4620      	mov	r0, r4
            park.plan_data.feed_rate = settings.parking.rate;
 800f12c:	f841 3f20 	str.w	r3, [r1, #32]!
            park.target[settings.parking.axis] = settings.parking.target;
 800f130:	f844 8027 	str.w	r8, [r4, r7, lsl #2]
            if(mc_parking_motion(park.target, &park.plan_data))
 800f134:	f7fa fe2e 	bl	8009d94 <mc_parking_motion>
 800f138:	2800      	cmp	r0, #0
 800f13a:	d0e0      	beq.n	800f0fe <state_await_waypoint_retract+0x4a>
                park.retracting = true;
 800f13c:	2301      	movs	r3, #1
 800f13e:	7723      	strb	r3, [r4, #28]
}
 800f140:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            sys.step_control.execute_sys_motion = Off;
 800f144:	f36f 0382 	bfc	r3, #2, #1
 800f148:	7293      	strb	r3, [r2, #10]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 800f14a:	f001 fa1b 	bl	8010584 <st_parking_restore_buffer>
 800f14e:	e7b9      	b.n	800f0c4 <state_await_waypoint_retract+0x10>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 800f150:	f001 f9e2 	bl	8010518 <st_update_plan_block_parameters>
            sys.step_control.execute_hold = On;
 800f154:	7aa3      	ldrb	r3, [r4, #10]
 800f156:	f023 0306 	bic.w	r3, r3, #6
 800f15a:	f043 0306 	orr.w	r3, r3, #6
 800f15e:	72a3      	strb	r3, [r4, #10]
 800f160:	e7ee      	b.n	800f140 <state_await_waypoint_retract+0x8c>
 800f162:	bf00      	nop
 800f164:	20002494 	.word	0x20002494
 800f168:	20001ad4 	.word	0x20001ad4
 800f16c:	200024bc 	.word	0x200024bc
 800f170:	20002620 	.word	0x20002620
 800f174:	20000018 	.word	0x20000018
 800f178:	0800fc81 	.word	0x0800fc81
 800f17c:	0800f2b5 	.word	0x0800f2b5

0800f180 <state_restore>:
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f180:	f010 0240 	ands.w	r2, r0, #64	; 0x40
{
 800f184:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f188:	d141      	bne.n	800f20e <state_restore+0x8e>
    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f18a:	0740      	lsls	r0, r0, #29
 800f18c:	d53d      	bpl.n	800f20a <state_restore+0x8a>
        if(sys.step_control.execute_sys_motion) {
 800f18e:	4d3e      	ldr	r5, [pc, #248]	; (800f288 <state_restore+0x108>)
 800f190:	7aab      	ldrb	r3, [r5, #10]
 800f192:	0759      	lsls	r1, r3, #29
 800f194:	d472      	bmi.n	800f27c <state_restore+0xfc>
        if(sys.parking_state != Parking_Cancel)
 800f196:	7dab      	ldrb	r3, [r5, #22]
        stateHandler = state_await_resumed;
 800f198:	f8df 9108 	ldr.w	r9, [pc, #264]	; 800f2a4 <state_restore+0x124>
 800f19c:	4a3b      	ldr	r2, [pc, #236]	; (800f28c <state_restore+0x10c>)
        if(sys.parking_state != Parking_Cancel)
 800f19e:	2b03      	cmp	r3, #3
        stateHandler = state_await_resumed;
 800f1a0:	f8c9 2000 	str.w	r2, [r9]
        if(sys.parking_state != Parking_Cancel)
 800f1a4:	d064      	beq.n	800f270 <state_restore+0xf0>
    if(!settings.parking.flags.enabled || !park.restart_retract) {
 800f1a6:	4f3a      	ldr	r7, [pc, #232]	; (800f290 <state_restore+0x110>)
            state_restore_conditions(&restore_condition, restore_spindle_rpm);
 800f1a8:	f8df 8104 	ldr.w	r8, [pc, #260]	; 800f2b0 <state_restore+0x130>
    if(!settings.parking.flags.enabled || !park.restart_retract) {
 800f1ac:	f897 20d8 	ldrb.w	r2, [r7, #216]	; 0xd8
            state_restore_conditions(&restore_condition, restore_spindle_rpm);
 800f1b0:	f8d8 3000 	ldr.w	r3, [r8]
    if(!settings.parking.flags.enabled || !park.restart_retract) {
 800f1b4:	07d2      	lsls	r2, r2, #31
 800f1b6:	4c37      	ldr	r4, [pc, #220]	; (800f294 <state_restore+0x114>)
 800f1b8:	d53f      	bpl.n	800f23a <state_restore+0xba>
 800f1ba:	7f62      	ldrb	r2, [r4, #29]
 800f1bc:	2a00      	cmp	r2, #0
 800f1be:	d03c      	beq.n	800f23a <state_restore+0xba>
 800f1c0:	4e35      	ldr	r6, [pc, #212]	; (800f298 <state_restore+0x118>)
        park.restart_retract = false;
 800f1c2:	2000      	movs	r0, #0
        sys.parking_state = Parking_Resuming;
 800f1c4:	f04f 0804 	mov.w	r8, #4
        park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f1c8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
        if(!mc_parking_motion(park.restore_target, &park.plan_data))
 800f1cc:	4933      	ldr	r1, [pc, #204]	; (800f29c <state_restore+0x11c>)
        park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f1ce:	6222      	str	r2, [r4, #32]
        park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f1d0:	6263      	str	r3, [r4, #36]	; 0x24
        park.plan_data.condition.coolant = restore_condition.coolant;
 800f1d2:	78f2      	ldrb	r2, [r6, #3]
        park.plan_data.condition.spindle = restore_condition.spindle;
 800f1d4:	78b3      	ldrb	r3, [r6, #2]
        park.restart_retract = false;
 800f1d6:	7760      	strb	r0, [r4, #29]
        if(!mc_parking_motion(park.restore_target, &park.plan_data))
 800f1d8:	f1a1 0014 	sub.w	r0, r1, #20
        sys.parking_state = Parking_Resuming;
 800f1dc:	f885 8016 	strb.w	r8, [r5, #22]
        park.plan_data.condition.coolant = restore_condition.coolant;
 800f1e0:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
        park.plan_data.condition.spindle = restore_condition.spindle;
 800f1e4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        if(!mc_parking_motion(park.restore_target, &park.plan_data))
 800f1e8:	f7fa fdd4 	bl	8009d94 <mc_parking_motion>
 800f1ec:	b968      	cbnz	r0, 800f20a <state_restore+0x8a>
            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step
 800f1ee:	4640      	mov	r0, r8
 800f1f0:	f8d9 3000 	ldr.w	r3, [r9]
}
 800f1f4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            stateHandler(EXEC_CYCLE_COMPLETE); // No motion, proceed to next step
 800f1f8:	4718      	bx	r3
        st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 800f1fa:	f001 f98d 	bl	8010518 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On;
 800f1fe:	7aa3      	ldrb	r3, [r4, #10]
 800f200:	f023 0306 	bic.w	r3, r3, #6
 800f204:	f043 0306 	orr.w	r3, r3, #6
 800f208:	72a3      	strb	r3, [r4, #10]
}
 800f20a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f20e:	4b24      	ldr	r3, [pc, #144]	; (800f2a0 <state_restore+0x120>)
    park.restart_retract = true;
 800f210:	2501      	movs	r5, #1
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f212:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 800f216:	2006      	movs	r0, #6
 800f218:	4798      	blx	r3
    sys.parking_state = Parking_Retracting;
 800f21a:	2002      	movs	r0, #2
 800f21c:	4c1a      	ldr	r4, [pc, #104]	; (800f288 <state_restore+0x108>)
    park.restart_retract = true;
 800f21e:	491d      	ldr	r1, [pc, #116]	; (800f294 <state_restore+0x114>)
    if (sys.step_control.execute_sys_motion) {
 800f220:	7aa2      	ldrb	r2, [r4, #10]
    park.restart_retract = true;
 800f222:	774d      	strb	r5, [r1, #29]
    stateHandler = state_await_hold;
 800f224:	4b1f      	ldr	r3, [pc, #124]	; (800f2a4 <state_restore+0x124>)
 800f226:	4920      	ldr	r1, [pc, #128]	; (800f2a8 <state_restore+0x128>)
    if (sys.step_control.execute_sys_motion) {
 800f228:	0755      	lsls	r5, r2, #29
    sys.parking_state = Parking_Retracting;
 800f22a:	75a0      	strb	r0, [r4, #22]
    stateHandler = state_await_hold;
 800f22c:	6019      	str	r1, [r3, #0]
    if (sys.step_control.execute_sys_motion) {
 800f22e:	d4e4      	bmi.n	800f1fa <state_restore+0x7a>
}
 800f230:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        stateHandler(EXEC_CYCLE_COMPLETE);
 800f234:	2004      	movs	r0, #4
 800f236:	681b      	ldr	r3, [r3, #0]
 800f238:	4718      	bx	r3
        spindle_restore(condition->spindle, rpm);
 800f23a:	4e17      	ldr	r6, [pc, #92]	; (800f298 <state_restore+0x118>)
 800f23c:	4619      	mov	r1, r3
 800f23e:	78b0      	ldrb	r0, [r6, #2]
 800f240:	f7ff fd5a 	bl	800ecf8 <spindle_restore>
        if (gc_state.modal.coolant.value != hal.coolant_get_state().value) {
 800f244:	4b16      	ldr	r3, [pc, #88]	; (800f2a0 <state_restore+0x120>)
 800f246:	4a19      	ldr	r2, [pc, #100]	; (800f2ac <state_restore+0x12c>)
 800f248:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f24a:	f892 a019 	ldrb.w	sl, [r2, #25]
 800f24e:	4798      	blx	r3
 800f250:	b2c0      	uxtb	r0, r0
 800f252:	4550      	cmp	r0, sl
 800f254:	d007      	beq.n	800f266 <state_restore+0xe6>
            coolant_set_state(condition->coolant);
 800f256:	78f0      	ldrb	r0, [r6, #3]
 800f258:	f7f5 fea2 	bl	8004fa0 <coolant_set_state>
            delay_sec(SAFETY_DOOR_COOLANT_DELAY, DelayMode_SysSuspend);
 800f25c:	2101      	movs	r1, #1
 800f25e:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800f262:	f7fb f84d 	bl	800a300 <delay_sec>
        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 800f266:	2200      	movs	r2, #0
 800f268:	f8d8 3000 	ldr.w	r3, [r8]
 800f26c:	746a      	strb	r2, [r5, #17]
}
 800f26e:	e7a8      	b.n	800f1c2 <state_restore+0x42>
 800f270:	4b0f      	ldr	r3, [pc, #60]	; (800f2b0 <state_restore+0x130>)
 800f272:	4c08      	ldr	r4, [pc, #32]	; (800f294 <state_restore+0x114>)
 800f274:	681b      	ldr	r3, [r3, #0]
 800f276:	4f06      	ldr	r7, [pc, #24]	; (800f290 <state_restore+0x110>)
 800f278:	4e07      	ldr	r6, [pc, #28]	; (800f298 <state_restore+0x118>)
 800f27a:	e7a2      	b.n	800f1c2 <state_restore+0x42>
            sys.step_control.execute_sys_motion = Off;
 800f27c:	f362 0382 	bfi	r3, r2, #2, #1
 800f280:	72ab      	strb	r3, [r5, #10]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 800f282:	f001 f97f 	bl	8010584 <st_parking_restore_buffer>
 800f286:	e786      	b.n	800f196 <state_restore+0x16>
 800f288:	20002494 	.word	0x20002494
 800f28c:	0800f32d 	.word	0x0800f32d
 800f290:	20002620 	.word	0x20002620
 800f294:	20001ad4 	.word	0x20001ad4
 800f298:	20001b30 	.word	0x20001b30
 800f29c:	20001af4 	.word	0x20001af4
 800f2a0:	200024bc 	.word	0x200024bc
 800f2a4:	20000018 	.word	0x20000018
 800f2a8:	0800f525 	.word	0x0800f525
 800f2ac:	200023dc 	.word	0x200023dc
 800f2b0:	20001b34 	.word	0x20001b34

0800f2b4 <state_await_waypoint_cancel>:
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f2b4:	f010 0240 	ands.w	r2, r0, #64	; 0x40
{
 800f2b8:	b570      	push	{r4, r5, r6, lr}
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f2ba:	d10e      	bne.n	800f2da <state_await_waypoint_cancel+0x26>
    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f2bc:	4603      	mov	r3, r0
 800f2be:	075b      	lsls	r3, r3, #29
 800f2c0:	d400      	bmi.n	800f2c4 <state_await_waypoint_cancel+0x10>
}
 800f2c2:	bd70      	pop	{r4, r5, r6, pc}
        sys.parking_state = Parking_Cancel;
 800f2c4:	2403      	movs	r4, #3
 800f2c6:	4b14      	ldr	r3, [pc, #80]	; (800f318 <state_await_waypoint_cancel+0x64>)
        sys.step_control.execute_hold = Off;
 800f2c8:	7a99      	ldrb	r1, [r3, #10]
        sys.parking_state = Parking_Cancel;
 800f2ca:	759c      	strb	r4, [r3, #22]
        sys.step_control.execute_hold = Off;
 800f2cc:	f362 0141 	bfi	r1, r2, #1, #1
}
 800f2d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        sys.step_control.execute_hold = Off;
 800f2d4:	7299      	strb	r1, [r3, #10]
        state_restore(rt_exec);
 800f2d6:	f7ff bf53 	b.w	800f180 <state_restore>
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f2da:	4b10      	ldr	r3, [pc, #64]	; (800f31c <state_await_waypoint_cancel+0x68>)
    park.restart_retract = true;
 800f2dc:	2501      	movs	r5, #1
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f2de:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 800f2e2:	2006      	movs	r0, #6
 800f2e4:	4798      	blx	r3
    sys.parking_state = Parking_Retracting;
 800f2e6:	2002      	movs	r0, #2
 800f2e8:	4c0b      	ldr	r4, [pc, #44]	; (800f318 <state_await_waypoint_cancel+0x64>)
    park.restart_retract = true;
 800f2ea:	490d      	ldr	r1, [pc, #52]	; (800f320 <state_await_waypoint_cancel+0x6c>)
    if (sys.step_control.execute_sys_motion) {
 800f2ec:	7aa2      	ldrb	r2, [r4, #10]
    stateHandler = state_await_hold;
 800f2ee:	4b0d      	ldr	r3, [pc, #52]	; (800f324 <state_await_waypoint_cancel+0x70>)
    park.restart_retract = true;
 800f2f0:	774d      	strb	r5, [r1, #29]
    stateHandler = state_await_hold;
 800f2f2:	490d      	ldr	r1, [pc, #52]	; (800f328 <state_await_waypoint_cancel+0x74>)
    if (sys.step_control.execute_sys_motion) {
 800f2f4:	0752      	lsls	r2, r2, #29
    sys.parking_state = Parking_Retracting;
 800f2f6:	75a0      	strb	r0, [r4, #22]
    stateHandler = state_await_hold;
 800f2f8:	6019      	str	r1, [r3, #0]
    if (sys.step_control.execute_sys_motion) {
 800f2fa:	d404      	bmi.n	800f306 <state_await_waypoint_cancel+0x52>
}
 800f2fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        stateHandler(EXEC_CYCLE_COMPLETE);
 800f300:	2004      	movs	r0, #4
 800f302:	681b      	ldr	r3, [r3, #0]
 800f304:	4718      	bx	r3
        st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 800f306:	f001 f907 	bl	8010518 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On;
 800f30a:	7aa3      	ldrb	r3, [r4, #10]
 800f30c:	f023 0306 	bic.w	r3, r3, #6
 800f310:	f043 0306 	orr.w	r3, r3, #6
 800f314:	72a3      	strb	r3, [r4, #10]
}
 800f316:	bd70      	pop	{r4, r5, r6, pc}
 800f318:	20002494 	.word	0x20002494
 800f31c:	200024bc 	.word	0x200024bc
 800f320:	20001ad4 	.word	0x20001ad4
 800f324:	20000018 	.word	0x20000018
 800f328:	0800f525 	.word	0x0800f525

0800f32c <state_await_resumed>:
{
 800f32c:	b570      	push	{r4, r5, r6, lr}
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f32e:	f010 0340 	ands.w	r3, r0, #64	; 0x40
{
 800f332:	b090      	sub	sp, #64	; 0x40
    if (rt_exec & EXEC_SAFETY_DOOR)
 800f334:	d11c      	bne.n	800f370 <state_await_resumed+0x44>
    else if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f336:	0741      	lsls	r1, r0, #29
 800f338:	d518      	bpl.n	800f36c <state_await_resumed+0x40>
        if(sys.step_control.execute_sys_motion) {
 800f33a:	4c3a      	ldr	r4, [pc, #232]	; (800f424 <state_await_resumed+0xf8>)
 800f33c:	7aa2      	ldrb	r2, [r4, #10]
 800f33e:	0752      	lsls	r2, r2, #29
 800f340:	d44d      	bmi.n	800f3de <state_await_resumed+0xb2>
    if(new_state != sys.state) {
 800f342:	6823      	ldr	r3, [r4, #0]
 800f344:	2b00      	cmp	r3, #0
 800f346:	d02a      	beq.n	800f39e <state_await_resumed+0x72>
                sys.suspend = false;        // Break suspend state.
 800f348:	2000      	movs	r0, #0
        if(hal.state_change_requested)
 800f34a:	4d37      	ldr	r5, [pc, #220]	; (800f428 <state_await_resumed+0xfc>)
                sys.state = pending_state = new_state;
 800f34c:	4e37      	ldr	r6, [pc, #220]	; (800f42c <state_await_resumed+0x100>)
                stateHandler = state_idle;
 800f34e:	4a38      	ldr	r2, [pc, #224]	; (800f430 <state_await_resumed+0x104>)
 800f350:	4938      	ldr	r1, [pc, #224]	; (800f434 <state_await_resumed+0x108>)
        if(hal.state_change_requested)
 800f352:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
                sys.suspend = false;        // Break suspend state.
 800f356:	71a0      	strb	r0, [r4, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800f358:	72a0      	strb	r0, [r4, #10]
                sys.parking_state = Parking_DoorClosed;
 800f35a:	82e0      	strh	r0, [r4, #22]
                sys.state = pending_state = new_state;
 800f35c:	6020      	str	r0, [r4, #0]
 800f35e:	6030      	str	r0, [r6, #0]
                stateHandler = state_idle;
 800f360:	6011      	str	r1, [r2, #0]
        if(hal.state_change_requested)
 800f362:	b1eb      	cbz	r3, 800f3a0 <state_await_resumed+0x74>
            hal.state_change_requested(new_state);
 800f364:	4798      	blx	r3
    if(new_state != sys.state) {
 800f366:	6823      	ldr	r3, [r4, #0]
 800f368:	2b08      	cmp	r3, #8
 800f36a:	d12d      	bne.n	800f3c8 <state_await_resumed+0x9c>
}
 800f36c:	b010      	add	sp, #64	; 0x40
 800f36e:	bd70      	pop	{r4, r5, r6, pc}
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f370:	4b2d      	ldr	r3, [pc, #180]	; (800f428 <state_await_resumed+0xfc>)
 800f372:	2006      	movs	r0, #6
 800f374:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
    park.restart_retract = true;
 800f378:	2501      	movs	r5, #1
    hal.report.feedback_message(Message_SafetyDoorAjar);
 800f37a:	4798      	blx	r3
    sys.parking_state = Parking_Retracting;
 800f37c:	2002      	movs	r0, #2
 800f37e:	4c29      	ldr	r4, [pc, #164]	; (800f424 <state_await_resumed+0xf8>)
    park.restart_retract = true;
 800f380:	492d      	ldr	r1, [pc, #180]	; (800f438 <state_await_resumed+0x10c>)
    if (sys.step_control.execute_sys_motion) {
 800f382:	7aa2      	ldrb	r2, [r4, #10]
    stateHandler = state_await_hold;
 800f384:	4b2a      	ldr	r3, [pc, #168]	; (800f430 <state_await_resumed+0x104>)
    park.restart_retract = true;
 800f386:	774d      	strb	r5, [r1, #29]
    stateHandler = state_await_hold;
 800f388:	492c      	ldr	r1, [pc, #176]	; (800f43c <state_await_resumed+0x110>)
    sys.parking_state = Parking_Retracting;
 800f38a:	75a0      	strb	r0, [r4, #22]
    if (sys.step_control.execute_sys_motion) {
 800f38c:	0750      	lsls	r0, r2, #29
    stateHandler = state_await_hold;
 800f38e:	6019      	str	r1, [r3, #0]
    if (sys.step_control.execute_sys_motion) {
 800f390:	d429      	bmi.n	800f3e6 <state_await_resumed+0xba>
        stateHandler(EXEC_CYCLE_COMPLETE);
 800f392:	2004      	movs	r0, #4
 800f394:	681b      	ldr	r3, [r3, #0]
}
 800f396:	b010      	add	sp, #64	; 0x40
 800f398:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800f39c:	4718      	bx	r3
 800f39e:	4d22      	ldr	r5, [pc, #136]	; (800f428 <state_await_resumed+0xfc>)
                    if ((block = plan_get_current_block())) {
 800f3a0:	f7fb fa56 	bl	800a850 <plan_get_current_block>
 800f3a4:	4606      	mov	r6, r0
 800f3a6:	b188      	cbz	r0, 800f3cc <state_await_resumed+0xa0>
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800f3a8:	2300      	movs	r3, #0
                        sys.state = new_state;
 800f3aa:	2208      	movs	r2, #8
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800f3ac:	71e3      	strb	r3, [r4, #7]
                        sys.state = new_state;
 800f3ae:	6022      	str	r2, [r4, #0]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 800f3b0:	f001 f90e 	bl	80105d0 <st_prep_buffer>
                        if(block->condition.spindle.synchronized) {
 800f3b4:	f996 3016 	ldrsb.w	r3, [r6, #22]
 800f3b8:	2b00      	cmp	r3, #0
 800f3ba:	db1e      	blt.n	800f3fa <state_await_resumed+0xce>
                        st_wake_up();
 800f3bc:	f000 fe7c 	bl	80100b8 <st_wake_up>
                        stateHandler = state_cycle;
 800f3c0:	4b1b      	ldr	r3, [pc, #108]	; (800f430 <state_await_resumed+0x104>)
 800f3c2:	4a1f      	ldr	r2, [pc, #124]	; (800f440 <state_await_resumed+0x114>)
 800f3c4:	601a      	str	r2, [r3, #0]
 800f3c6:	e001      	b.n	800f3cc <state_await_resumed+0xa0>
                if(sys.state == STATE_IDLE) {
 800f3c8:	2b00      	cmp	r3, #0
 800f3ca:	d0e9      	beq.n	800f3a0 <state_await_resumed+0x74>
        if(hal.state_change_requested)
 800f3cc:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 800f3d0:	2b00      	cmp	r3, #0
 800f3d2:	d0cb      	beq.n	800f36c <state_await_resumed+0x40>
            hal.state_change_requested(new_state);
 800f3d4:	2008      	movs	r0, #8
}
 800f3d6:	b010      	add	sp, #64	; 0x40
 800f3d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800f3dc:	4718      	bx	r3
            sys.step_control.flags = 0;
 800f3de:	72a3      	strb	r3, [r4, #10]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 800f3e0:	f001 f8d0 	bl	8010584 <st_parking_restore_buffer>
 800f3e4:	e7ad      	b.n	800f342 <state_await_resumed+0x16>
        st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
 800f3e6:	f001 f897 	bl	8010518 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On;
 800f3ea:	7aa3      	ldrb	r3, [r4, #10]
 800f3ec:	f023 0306 	bic.w	r3, r3, #6
 800f3f0:	f043 0306 	orr.w	r3, r3, #6
 800f3f4:	72a3      	strb	r3, [r4, #10]
}
 800f3f6:	b010      	add	sp, #64	; 0x40
 800f3f8:	bd70      	pop	{r4, r5, r6, pc}
                            if(hal.spindle_reset_data)
 800f3fa:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 800f3fe:	b103      	cbz	r3, 800f402 <state_await_resumed+0xd6>
                                hal.spindle_reset_data();
 800f400:	4798      	blx	r3
                            uint32_t index = hal.spindle_get_data(SpindleData_Counters).index_count + 2;
 800f402:	2100      	movs	r1, #0
 800f404:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800f408:	a808      	add	r0, sp, #32
 800f40a:	4798      	blx	r3
 800f40c:	9c08      	ldr	r4, [sp, #32]
 800f40e:	3402      	adds	r4, #2
                            while(index != hal.spindle_get_data(SpindleData_Counters).index_count); // check for abort in this loop?
 800f410:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800f414:	2100      	movs	r1, #0
 800f416:	4668      	mov	r0, sp
 800f418:	4798      	blx	r3
 800f41a:	9b00      	ldr	r3, [sp, #0]
 800f41c:	429c      	cmp	r4, r3
 800f41e:	d1f7      	bne.n	800f410 <state_await_resumed+0xe4>
 800f420:	e7cc      	b.n	800f3bc <state_await_resumed+0x90>
 800f422:	bf00      	nop
 800f424:	20002494 	.word	0x20002494
 800f428:	200024bc 	.word	0x200024bc
 800f42c:	20001b28 	.word	0x20001b28
 800f430:	20000018 	.word	0x20000018
 800f434:	0800fb8d 	.word	0x0800fb8d
 800f438:	20001ad4 	.word	0x20001ad4
 800f43c:	0800f525 	.word	0x0800f525
 800f440:	0800ff21 	.word	0x0800ff21

0800f444 <state_await_toolchanged>:
    if ((rt_exec & EXEC_CYCLE_START) && !gc_state.tool_change) {
 800f444:	0783      	lsls	r3, r0, #30
 800f446:	d400      	bmi.n	800f44a <state_await_toolchanged+0x6>
 800f448:	4770      	bx	lr
 800f44a:	4b2f      	ldr	r3, [pc, #188]	; (800f508 <state_await_toolchanged+0xc4>)
 800f44c:	f893 0080 	ldrb.w	r0, [r3, #128]	; 0x80
 800f450:	2800      	cmp	r0, #0
 800f452:	d1f9      	bne.n	800f448 <state_await_toolchanged+0x4>
{
 800f454:	b570      	push	{r4, r5, r6, lr}
        if(hal.stream.suspend_read && hal.stream.suspend_read(false)) {
 800f456:	4d2d      	ldr	r5, [pc, #180]	; (800f50c <state_await_toolchanged+0xc8>)
{
 800f458:	b090      	sub	sp, #64	; 0x40
        if(hal.stream.suspend_read && hal.stream.suspend_read(false)) {
 800f45a:	6fab      	ldr	r3, [r5, #120]	; 0x78
 800f45c:	b10b      	cbz	r3, 800f462 <state_await_toolchanged+0x1e>
 800f45e:	4798      	blx	r3
 800f460:	bb18      	cbnz	r0, 800f4aa <state_await_toolchanged+0x66>
 800f462:	4c2b      	ldr	r4, [pc, #172]	; (800f510 <state_await_toolchanged+0xcc>)
        pending_state = STATE_IDLE;
 800f464:	2000      	movs	r0, #0
        sys.report.tool = On;
 800f466:	7d23      	ldrb	r3, [r4, #20]
        pending_state = STATE_IDLE;
 800f468:	492a      	ldr	r1, [pc, #168]	; (800f514 <state_await_toolchanged+0xd0>)
    if(new_state != sys.state) {
 800f46a:	6822      	ldr	r2, [r4, #0]
        sys.report.tool = On;
 800f46c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f470:	7523      	strb	r3, [r4, #20]
        pending_state = STATE_IDLE;
 800f472:	6008      	str	r0, [r1, #0]
    if(new_state != sys.state) {
 800f474:	b1fa      	cbz	r2, 800f4b6 <state_await_toolchanged+0x72>
                stateHandler = state_idle;
 800f476:	4a28      	ldr	r2, [pc, #160]	; (800f518 <state_await_toolchanged+0xd4>)
 800f478:	4928      	ldr	r1, [pc, #160]	; (800f51c <state_await_toolchanged+0xd8>)
        if(hal.state_change_requested)
 800f47a:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
                sys.suspend = false;        // Break suspend state.
 800f47e:	71a0      	strb	r0, [r4, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800f480:	72a0      	strb	r0, [r4, #10]
                sys.parking_state = Parking_DoorClosed;
 800f482:	82e0      	strh	r0, [r4, #22]
                sys.state = pending_state = new_state;
 800f484:	6020      	str	r0, [r4, #0]
                stateHandler = state_idle;
 800f486:	6011      	str	r1, [r2, #0]
        if(hal.state_change_requested)
 800f488:	b1ab      	cbz	r3, 800f4b6 <state_await_toolchanged+0x72>
            hal.state_change_requested(new_state);
 800f48a:	4798      	blx	r3
    if(new_state != sys.state) {
 800f48c:	6823      	ldr	r3, [r4, #0]
 800f48e:	2b08      	cmp	r3, #8
 800f490:	d101      	bne.n	800f496 <state_await_toolchanged+0x52>
}
 800f492:	b010      	add	sp, #64	; 0x40
 800f494:	bd70      	pop	{r4, r5, r6, pc}
                if(sys.state == STATE_IDLE) {
 800f496:	b173      	cbz	r3, 800f4b6 <state_await_toolchanged+0x72>
        if(hal.state_change_requested)
 800f498:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 800f49c:	2b00      	cmp	r3, #0
 800f49e:	d0f8      	beq.n	800f492 <state_await_toolchanged+0x4e>
            hal.state_change_requested(new_state);
 800f4a0:	2008      	movs	r0, #8
}
 800f4a2:	b010      	add	sp, #64	; 0x40
 800f4a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800f4a8:	4718      	bx	r3
            sys.state = STATE_CYCLE;    // Force a running state realtime report
 800f4aa:	2308      	movs	r3, #8
 800f4ac:	4c18      	ldr	r4, [pc, #96]	; (800f510 <state_await_toolchanged+0xcc>)
 800f4ae:	6023      	str	r3, [r4, #0]
            report_realtime_status();   // to get streaming going again
 800f4b0:	f7fe f950 	bl	800d754 <report_realtime_status>
 800f4b4:	e7d6      	b.n	800f464 <state_await_toolchanged+0x20>
                    if ((block = plan_get_current_block())) {
 800f4b6:	f7fb f9cb 	bl	800a850 <plan_get_current_block>
 800f4ba:	4606      	mov	r6, r0
 800f4bc:	2800      	cmp	r0, #0
 800f4be:	d0eb      	beq.n	800f498 <state_await_toolchanged+0x54>
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800f4c0:	2300      	movs	r3, #0
                        sys.state = new_state;
 800f4c2:	2208      	movs	r2, #8
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800f4c4:	71e3      	strb	r3, [r4, #7]
                        sys.state = new_state;
 800f4c6:	6022      	str	r2, [r4, #0]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 800f4c8:	f001 f882 	bl	80105d0 <st_prep_buffer>
                        if(block->condition.spindle.synchronized) {
 800f4cc:	f996 3016 	ldrsb.w	r3, [r6, #22]
 800f4d0:	2b00      	cmp	r3, #0
 800f4d2:	db05      	blt.n	800f4e0 <state_await_toolchanged+0x9c>
                        st_wake_up();
 800f4d4:	f000 fdf0 	bl	80100b8 <st_wake_up>
                        stateHandler = state_cycle;
 800f4d8:	4b0f      	ldr	r3, [pc, #60]	; (800f518 <state_await_toolchanged+0xd4>)
 800f4da:	4a11      	ldr	r2, [pc, #68]	; (800f520 <state_await_toolchanged+0xdc>)
 800f4dc:	601a      	str	r2, [r3, #0]
 800f4de:	e7db      	b.n	800f498 <state_await_toolchanged+0x54>
                            if(hal.spindle_reset_data)
 800f4e0:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 800f4e4:	b103      	cbz	r3, 800f4e8 <state_await_toolchanged+0xa4>
                                hal.spindle_reset_data();
 800f4e6:	4798      	blx	r3
                            uint32_t index = hal.spindle_get_data(SpindleData_Counters).index_count + 2;
 800f4e8:	2100      	movs	r1, #0
 800f4ea:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800f4ee:	a808      	add	r0, sp, #32
 800f4f0:	4798      	blx	r3
 800f4f2:	9c08      	ldr	r4, [sp, #32]
 800f4f4:	3402      	adds	r4, #2
                            while(index != hal.spindle_get_data(SpindleData_Counters).index_count); // check for abort in this loop?
 800f4f6:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 800f4fa:	2100      	movs	r1, #0
 800f4fc:	4668      	mov	r0, sp
 800f4fe:	4798      	blx	r3
 800f500:	9b00      	ldr	r3, [sp, #0]
 800f502:	429c      	cmp	r4, r3
 800f504:	d1f7      	bne.n	800f4f6 <state_await_toolchanged+0xb2>
 800f506:	e7e5      	b.n	800f4d4 <state_await_toolchanged+0x90>
 800f508:	200023dc 	.word	0x200023dc
 800f50c:	200024bc 	.word	0x200024bc
 800f510:	20002494 	.word	0x20002494
 800f514:	20001b28 	.word	0x20001b28
 800f518:	20000018 	.word	0x20000018
 800f51c:	0800fb8d 	.word	0x0800fb8d
 800f520:	0800ff21 	.word	0x0800ff21

0800f524 <state_await_hold>:
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f524:	0742      	lsls	r2, r0, #29
 800f526:	d400      	bmi.n	800f52a <state_await_hold+0x6>
 800f528:	4770      	bx	lr
{
 800f52a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        sys.step_control.flags = 0;
 800f52e:	2500      	movs	r5, #0
 800f530:	4c4d      	ldr	r4, [pc, #308]	; (800f668 <state_await_hold+0x144>)
        plan_cycle_reinitialize();
 800f532:	f7fb fd87 	bl	800b044 <plan_cycle_reinitialize>
        switch (sys.state) {
 800f536:	6823      	ldr	r3, [r4, #0]
        sys.step_control.flags = 0;
 800f538:	72a5      	strb	r5, [r4, #10]
        switch (sys.state) {
 800f53a:	2b80      	cmp	r3, #128	; 0x80
 800f53c:	d014      	beq.n	800f568 <state_await_hold+0x44>
 800f53e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f542:	d008      	beq.n	800f556 <state_await_hold+0x32>
 800f544:	2b40      	cmp	r3, #64	; 0x40
 800f546:	d00f      	beq.n	800f568 <state_await_hold+0x44>
            sys.holding_state = Hold_Complete;
 800f548:	2101      	movs	r1, #1
            stateHandler = state_await_resume;
 800f54a:	4b48      	ldr	r3, [pc, #288]	; (800f66c <state_await_hold+0x148>)
 800f54c:	4a48      	ldr	r2, [pc, #288]	; (800f670 <state_await_hold+0x14c>)
            sys.holding_state = Hold_Complete;
 800f54e:	75e1      	strb	r1, [r4, #23]
            stateHandler = state_await_resume;
 800f550:	601a      	str	r2, [r3, #0]
}
 800f552:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800f556:	4e47      	ldr	r6, [pc, #284]	; (800f674 <state_await_hold+0x150>)
 800f558:	4628      	mov	r0, r5
 800f55a:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800f55c:	2100      	movs	r1, #0
 800f55e:	4798      	blx	r3
                hal.coolant_set_state((coolant_state_t){0}); // De-energize
 800f560:	4628      	mov	r0, r5
 800f562:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800f564:	4798      	blx	r3
        if(!handler_changed) {
 800f566:	e7ef      	b.n	800f548 <state_await_hold+0x24>
                sys.override.spindle_stop.value = 0;
 800f568:	2300      	movs	r3, #0
                if(settings.parking.flags.enabled) {
 800f56a:	4e43      	ldr	r6, [pc, #268]	; (800f678 <state_await_hold+0x154>)
                sys.override.spindle_stop.value = 0;
 800f56c:	7463      	strb	r3, [r4, #17]
                if(settings.parking.flags.enabled) {
 800f56e:	f896 00d8 	ldrb.w	r0, [r6, #216]	; 0xd8
 800f572:	f010 0501 	ands.w	r5, r0, #1
 800f576:	d10a      	bne.n	800f58e <state_await_hold+0x6a>
                    hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800f578:	4e3e      	ldr	r6, [pc, #248]	; (800f674 <state_await_hold+0x150>)
 800f57a:	2100      	movs	r1, #0
 800f57c:	4628      	mov	r0, r5
 800f57e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800f580:	4798      	blx	r3
                    hal.coolant_set_state((coolant_state_t){0}); // De-energize
 800f582:	6a73      	ldr	r3, [r6, #36]	; 0x24
 800f584:	4628      	mov	r0, r5
 800f586:	4798      	blx	r3
                    sys.parking_state = Parking_DoorAjar;
 800f588:	2301      	movs	r3, #1
 800f58a:	75a3      	strb	r3, [r4, #22]
        if(!handler_changed) {
 800f58c:	e7dc      	b.n	800f548 <state_await_hold+0x24>
                    system_convert_array_steps_to_mpos(park.target, sys_position);
 800f58e:	4d3b      	ldr	r5, [pc, #236]	; (800f67c <state_await_hold+0x158>)
 800f590:	493b      	ldr	r1, [pc, #236]	; (800f680 <state_await_hold+0x15c>)
 800f592:	4628      	mov	r0, r5
 800f594:	f002 f8c8 	bl	8011728 <system_convert_array_steps_to_mpos>
                    if (!park.restart_retract) {
 800f598:	7f6b      	ldrb	r3, [r5, #29]
 800f59a:	2b00      	cmp	r3, #0
 800f59c:	d032      	beq.n	800f604 <state_await_hold+0xe0>
 800f59e:	f896 70d9 	ldrb.w	r7, [r6, #217]	; 0xd9
                    if (bit_istrue(sys.homed.mask, bit(settings.parking.axis)) && (park.target[settings.parking.axis] < settings.parking.target) && !settings.flags.laser_mode && !sys.override.control.parking_disable) {
 800f5a2:	7b63      	ldrb	r3, [r4, #13]
 800f5a4:	40fb      	lsrs	r3, r7
 800f5a6:	07db      	lsls	r3, r3, #31
 800f5a8:	d51f      	bpl.n	800f5ea <state_await_hold+0xc6>
 800f5aa:	f855 8027 	ldr.w	r8, [r5, r7, lsl #2]
 800f5ae:	f8d6 10dc 	ldr.w	r1, [r6, #220]	; 0xdc
 800f5b2:	4640      	mov	r0, r8
 800f5b4:	f7f1 fa8c 	bl	8000ad0 <__aeabi_fcmplt>
 800f5b8:	b1b8      	cbz	r0, 800f5ea <state_await_hold+0xc6>
 800f5ba:	f896 20bc 	ldrb.w	r2, [r6, #188]	; 0xbc
 800f5be:	7ca3      	ldrb	r3, [r4, #18]
 800f5c0:	f002 0202 	and.w	r2, r2, #2
 800f5c4:	f003 0308 	and.w	r3, r3, #8
 800f5c8:	4313      	orrs	r3, r2
 800f5ca:	d10e      	bne.n	800f5ea <state_await_hold+0xc6>
                        stateHandler = state_await_waypoint_retract;
 800f5cc:	4c27      	ldr	r4, [pc, #156]	; (800f66c <state_await_hold+0x148>)
 800f5ce:	4b2d      	ldr	r3, [pc, #180]	; (800f684 <state_await_hold+0x160>)
                        if (park.target[settings.parking.axis] < park.retract_waypoint) {
 800f5d0:	f8d5 9018 	ldr.w	r9, [r5, #24]
 800f5d4:	4640      	mov	r0, r8
 800f5d6:	4649      	mov	r1, r9
                        stateHandler = state_await_waypoint_retract;
 800f5d8:	6023      	str	r3, [r4, #0]
                        if (park.target[settings.parking.axis] < park.retract_waypoint) {
 800f5da:	f7f1 fa79 	bl	8000ad0 <__aeabi_fcmplt>
 800f5de:	bb50      	cbnz	r0, 800f636 <state_await_hold+0x112>
                            stateHandler(EXEC_CYCLE_COMPLETE);
 800f5e0:	6823      	ldr	r3, [r4, #0]
 800f5e2:	2004      	movs	r0, #4
}
 800f5e4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                            stateHandler(EXEC_CYCLE_COMPLETE);
 800f5e8:	4718      	bx	r3
                        hal.spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 800f5ea:	4d22      	ldr	r5, [pc, #136]	; (800f674 <state_await_hold+0x150>)
 800f5ec:	2100      	movs	r1, #0
 800f5ee:	f04f 0000 	mov.w	r0, #0
 800f5f2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800f5f4:	4798      	blx	r3
                        hal.coolant_set_state((coolant_state_t){0});     // De-energize
 800f5f6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800f5f8:	f04f 0000 	mov.w	r0, #0
 800f5fc:	4798      	blx	r3
                        sys.parking_state = Parking_DoorAjar;
 800f5fe:	2301      	movs	r3, #1
 800f600:	75a3      	strb	r3, [r4, #22]
        if(!handler_changed) {
 800f602:	e7a1      	b.n	800f548 <state_await_hold+0x24>
                        memcpy(park.restore_target, park.target, sizeof(park.target));
 800f604:	f105 030c 	add.w	r3, r5, #12
 800f608:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800f60c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                        park.retract_waypoint += park.restore_target[settings.parking.axis];
 800f610:	f896 70d9 	ldrb.w	r7, [r6, #217]	; 0xd9
 800f614:	69a8      	ldr	r0, [r5, #24]
 800f616:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 800f61a:	68d9      	ldr	r1, [r3, #12]
 800f61c:	f7f0 ffb2 	bl	8000584 <__addsf3>
                        park.retract_waypoint = min(park.retract_waypoint, settings.parking.target);
 800f620:	f8d6 90dc 	ldr.w	r9, [r6, #220]	; 0xdc
 800f624:	4680      	mov	r8, r0
 800f626:	4649      	mov	r1, r9
 800f628:	f7f1 fa5c 	bl	8000ae4 <__aeabi_fcmple>
 800f62c:	b900      	cbnz	r0, 800f630 <state_await_hold+0x10c>
 800f62e:	46c8      	mov	r8, r9
 800f630:	f8c5 8018 	str.w	r8, [r5, #24]
 800f634:	e7b5      	b.n	800f5a2 <state_await_hold+0x7e>
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f636:	f8d6 10e4 	ldr.w	r1, [r6, #228]	; 0xe4
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f63a:	4b13      	ldr	r3, [pc, #76]	; (800f688 <state_await_hold+0x164>)
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f63c:	4a13      	ldr	r2, [pc, #76]	; (800f68c <state_await_hold+0x168>)
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f63e:	78d8      	ldrb	r0, [r3, #3]
                            park.plan_data.feed_rate = settings.parking.pullout_rate;
 800f640:	6229      	str	r1, [r5, #32]
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f642:	4913      	ldr	r1, [pc, #76]	; (800f690 <state_await_hold+0x16c>)
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f644:	6812      	ldr	r2, [r2, #0]
                            park.plan_data.condition.spindle = restore_condition.spindle; // Retain spindle state
 800f646:	789b      	ldrb	r3, [r3, #2]
                            park.plan_data.condition.coolant = restore_condition.coolant; // Retain coolant state
 800f648:	f885 0043 	strb.w	r0, [r5, #67]	; 0x43
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f64c:	f1a1 0020 	sub.w	r0, r1, #32
                            park.target[settings.parking.axis] = park.retract_waypoint;
 800f650:	f845 9027 	str.w	r9, [r5, r7, lsl #2]
                            park.plan_data.condition.spindle = restore_condition.spindle; // Retain spindle state
 800f654:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
                            park.plan_data.spindle.rpm = restore_spindle_rpm;
 800f658:	626a      	str	r2, [r5, #36]	; 0x24
                            if(!(park.retracting = mc_parking_motion(park.target, &park.plan_data)))
 800f65a:	f7fa fb9b 	bl	8009d94 <mc_parking_motion>
 800f65e:	7728      	strb	r0, [r5, #28]
 800f660:	2800      	cmp	r0, #0
 800f662:	f47f af76 	bne.w	800f552 <state_await_hold+0x2e>
 800f666:	e7bb      	b.n	800f5e0 <state_await_hold+0xbc>
 800f668:	20002494 	.word	0x20002494
 800f66c:	20000018 	.word	0x20000018
 800f670:	0800fc81 	.word	0x0800fc81
 800f674:	200024bc 	.word	0x200024bc
 800f678:	20002620 	.word	0x20002620
 800f67c:	20001ad4 	.word	0x20001ad4
 800f680:	20002610 	.word	0x20002610
 800f684:	0800f0b5 	.word	0x0800f0b5
 800f688:	20001b30 	.word	0x20001b30
 800f68c:	20001b34 	.word	0x20001b34
 800f690:	20001af4 	.word	0x20001af4

0800f694 <initiate_hold>:
{
 800f694:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(settings.parking.flags.enabled) {
 800f698:	4d33      	ldr	r5, [pc, #204]	; (800f768 <initiate_hold+0xd4>)
{
 800f69a:	4604      	mov	r4, r0
    if(settings.parking.flags.enabled) {
 800f69c:	f895 30d8 	ldrb.w	r3, [r5, #216]	; 0xd8
 800f6a0:	07db      	lsls	r3, r3, #31
 800f6a2:	d427      	bmi.n	800f6f4 <initiate_hold+0x60>
    plan_block_t *block = plan_get_current_block();
 800f6a4:	f7fb f8d4 	bl	800a850 <plan_get_current_block>
    if (block == NULL) {
 800f6a8:	2800      	cmp	r0, #0
 800f6aa:	d034      	beq.n	800f716 <initiate_hold+0x82>
        restore_spindle_rpm = block->spindle.rpm;
 800f6ac:	4b2f      	ldr	r3, [pc, #188]	; (800f76c <initiate_hold+0xd8>)
 800f6ae:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
        restore_condition = block->condition;
 800f6b0:	492f      	ldr	r1, [pc, #188]	; (800f770 <initiate_hold+0xdc>)
        restore_spindle_rpm = block->spindle.rpm;
 800f6b2:	601a      	str	r2, [r3, #0]
    if(settings.flags.laser_mode && settings.flags.disable_laser_during_hold)
 800f6b4:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
        restore_condition = block->condition;
 800f6b8:	6946      	ldr	r6, [r0, #20]
    if(settings.flags.laser_mode && settings.flags.disable_laser_during_hold)
 800f6ba:	f003 0382 	and.w	r3, r3, #130	; 0x82
 800f6be:	2b82      	cmp	r3, #130	; 0x82
        restore_condition = block->condition;
 800f6c0:	600e      	str	r6, [r1, #0]
    if(settings.flags.laser_mode && settings.flags.disable_laser_during_hold)
 800f6c2:	d03e      	beq.n	800f742 <initiate_hold+0xae>
    if(sys.state & (STATE_CYCLE|STATE_JOG)) {
 800f6c4:	4d2b      	ldr	r5, [pc, #172]	; (800f774 <initiate_hold+0xe0>)
 800f6c6:	6828      	ldr	r0, [r5, #0]
 800f6c8:	f010 0f28 	tst.w	r0, #40	; 0x28
 800f6cc:	d141      	bne.n	800f752 <initiate_hold+0xbe>
        sys.holding_state = Hold_Pending;
 800f6ce:	2302      	movs	r3, #2
    if(new_state == STATE_HOLD)
 800f6d0:	2c10      	cmp	r4, #16
        sys.holding_state = Hold_Pending;
 800f6d2:	bf0c      	ite	eq
 800f6d4:	75eb      	strbeq	r3, [r5, #23]
        sys.parking_state = Parking_Retracting;
 800f6d6:	75ab      	strbne	r3, [r5, #22]
    pending_state = sys.state == STATE_JOG ? new_state : STATE_IDLE;
 800f6d8:	2820      	cmp	r0, #32
}
 800f6da:	f1a0 0008 	sub.w	r0, r0, #8
    pending_state = sys.state == STATE_JOG ? new_state : STATE_IDLE;
 800f6de:	bf18      	it	ne
 800f6e0:	2400      	movne	r4, #0
    sys.suspend = true;
 800f6e2:	2301      	movs	r3, #1
}
 800f6e4:	fab0 f080 	clz	r0, r0
    pending_state = sys.state == STATE_JOG ? new_state : STATE_IDLE;
 800f6e8:	4a23      	ldr	r2, [pc, #140]	; (800f778 <initiate_hold+0xe4>)
}
 800f6ea:	0940      	lsrs	r0, r0, #5
    pending_state = sys.state == STATE_JOG ? new_state : STATE_IDLE;
 800f6ec:	6014      	str	r4, [r2, #0]
    sys.suspend = true;
 800f6ee:	71ab      	strb	r3, [r5, #6]
}
 800f6f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        memset(&park.plan_data, 0, sizeof(plan_line_data_t));
 800f6f4:	4e21      	ldr	r6, [pc, #132]	; (800f77c <initiate_hold+0xe8>)
 800f6f6:	2234      	movs	r2, #52	; 0x34
 800f6f8:	2100      	movs	r1, #0
 800f6fa:	f106 0020 	add.w	r0, r6, #32
 800f6fe:	f002 fac1 	bl	8011c84 <memset>
        park.plan_data.condition.system_motion = On;
 800f702:	2212      	movs	r2, #18
        park.retract_waypoint = settings.parking.pullout_increment;
 800f704:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
        park.plan_data.condition.system_motion = On;
 800f708:	f886 2040 	strb.w	r2, [r6, #64]	; 0x40
        park.retract_waypoint = settings.parking.pullout_increment;
 800f70c:	61b3      	str	r3, [r6, #24]
    plan_block_t *block = plan_get_current_block();
 800f70e:	f7fb f89f 	bl	800a850 <plan_get_current_block>
    if (block == NULL) {
 800f712:	2800      	cmp	r0, #0
 800f714:	d1ca      	bne.n	800f6ac <initiate_hold+0x18>
        restore_condition.spindle = gc_state.modal.spindle;
 800f716:	4f1a      	ldr	r7, [pc, #104]	; (800f780 <initiate_hold+0xec>)
 800f718:	f8df 8054 	ldr.w	r8, [pc, #84]	; 800f770 <initiate_hold+0xdc>
 800f71c:	7eba      	ldrb	r2, [r7, #26]
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant_get_state().mask;
 800f71e:	4b19      	ldr	r3, [pc, #100]	; (800f784 <initiate_hold+0xf0>)
        restore_condition.spindle = gc_state.modal.spindle;
 800f720:	f888 2002 	strb.w	r2, [r8, #2]
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant_get_state().mask;
 800f724:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f726:	7e7e      	ldrb	r6, [r7, #25]
 800f728:	4798      	blx	r3
        restore_spindle_rpm = gc_state.spindle.rpm;
 800f72a:	4b10      	ldr	r3, [pc, #64]	; (800f76c <initiate_hold+0xd8>)
 800f72c:	6cba      	ldr	r2, [r7, #72]	; 0x48
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant_get_state().mask;
 800f72e:	4306      	orrs	r6, r0
        restore_spindle_rpm = gc_state.spindle.rpm;
 800f730:	601a      	str	r2, [r3, #0]
    if(settings.flags.laser_mode && settings.flags.disable_laser_during_hold)
 800f732:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
        restore_condition.coolant.mask = gc_state.modal.coolant.mask | hal.coolant_get_state().mask;
 800f736:	f888 6003 	strb.w	r6, [r8, #3]
    if(settings.flags.laser_mode && settings.flags.disable_laser_during_hold)
 800f73a:	f003 0382 	and.w	r3, r3, #130	; 0x82
 800f73e:	2b82      	cmp	r3, #130	; 0x82
 800f740:	d1c0      	bne.n	800f6c4 <initiate_hold+0x30>
    if(sys.state & (STATE_CYCLE|STATE_JOG)) {
 800f742:	4d0c      	ldr	r5, [pc, #48]	; (800f774 <initiate_hold+0xe0>)
        enqueue_accessory_override(CMD_OVERRIDE_SPINDLE_STOP);
 800f744:	209e      	movs	r0, #158	; 0x9e
 800f746:	f7fa fecd 	bl	800a4e4 <enqueue_accessory_override>
    if(sys.state & (STATE_CYCLE|STATE_JOG)) {
 800f74a:	6828      	ldr	r0, [r5, #0]
 800f74c:	f010 0f28 	tst.w	r0, #40	; 0x28
 800f750:	d0bd      	beq.n	800f6ce <initiate_hold+0x3a>
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 800f752:	f000 fee1 	bl	8010518 <st_update_plan_block_parameters>
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 800f756:	7aab      	ldrb	r3, [r5, #10]
        stateHandler = state_await_hold;
 800f758:	4a0b      	ldr	r2, [pc, #44]	; (800f788 <initiate_hold+0xf4>)
 800f75a:	490c      	ldr	r1, [pc, #48]	; (800f78c <initiate_hold+0xf8>)
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 800f75c:	f043 0302 	orr.w	r3, r3, #2
 800f760:	6828      	ldr	r0, [r5, #0]
 800f762:	72ab      	strb	r3, [r5, #10]
        stateHandler = state_await_hold;
 800f764:	6011      	str	r1, [r2, #0]
 800f766:	e7b2      	b.n	800f6ce <initiate_hold+0x3a>
 800f768:	20002620 	.word	0x20002620
 800f76c:	20001b34 	.word	0x20001b34
 800f770:	20001b30 	.word	0x20001b30
 800f774:	20002494 	.word	0x20002494
 800f778:	20001b28 	.word	0x20001b28
 800f77c:	20001ad4 	.word	0x20001ad4
 800f780:	200023dc 	.word	0x200023dc
 800f784:	200024bc 	.word	0x200024bc
 800f788:	20000018 	.word	0x20000018
 800f78c:	0800f525 	.word	0x0800f525

0800f790 <state_await_motion_cancel>:
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f790:	0741      	lsls	r1, r0, #29
 800f792:	d400      	bmi.n	800f796 <state_await_motion_cancel+0x6>
 800f794:	4770      	bx	lr
{
 800f796:	b5f0      	push	{r4, r5, r6, r7, lr}
        if(sys.state == STATE_JOG) {
 800f798:	4d66      	ldr	r5, [pc, #408]	; (800f934 <state_await_motion_cancel+0x1a4>)
{
 800f79a:	b091      	sub	sp, #68	; 0x44
        if(sys.state == STATE_JOG) {
 800f79c:	682e      	ldr	r6, [r5, #0]
 800f79e:	2e20      	cmp	r6, #32
 800f7a0:	d056      	beq.n	800f850 <state_await_motion_cancel+0xc0>
        set_state(pending_state);
 800f7a2:	4f65      	ldr	r7, [pc, #404]	; (800f938 <state_await_motion_cancel+0x1a8>)
 800f7a4:	683c      	ldr	r4, [r7, #0]
    if(new_state != sys.state) {
 800f7a6:	42b4      	cmp	r4, r6
 800f7a8:	d041      	beq.n	800f82e <state_await_motion_cancel+0x9e>
        switch(new_state) {    // Set up new state and handler
 800f7aa:	2c20      	cmp	r4, #32
 800f7ac:	d841      	bhi.n	800f832 <state_await_motion_cancel+0xa2>
 800f7ae:	2c20      	cmp	r4, #32
 800f7b0:	d82e      	bhi.n	800f810 <state_await_motion_cancel+0x80>
 800f7b2:	e8df f004 	tbb	[pc, r4]
 800f7b6:	847a      	.short	0x847a
 800f7b8:	2d842d84 	.word	0x2d842d84
 800f7bc:	2d8c2d2d 	.word	0x2d8c2d2d
 800f7c0:	2d2d2d2d 	.word	0x2d2d2d2d
 800f7c4:	2d112d2d 	.word	0x2d112d2d
 800f7c8:	2d2d2d2d 	.word	0x2d2d2d2d
 800f7cc:	2d2d2d2d 	.word	0x2d2d2d2d
 800f7d0:	2d2d2d2d 	.word	0x2d2d2d2d
 800f7d4:	2d2d      	.short	0x2d2d
 800f7d6:	6f          	.byte	0x6f
 800f7d7:	00          	.byte	0x00
                if(sys.override.control.sync && sys.override.control.feed_hold_disable)
 800f7d8:	7cab      	ldrb	r3, [r5, #18]
 800f7da:	f003 0282 	and.w	r2, r3, #130	; 0x82
 800f7de:	2a82      	cmp	r2, #130	; 0x82
 800f7e0:	d103      	bne.n	800f7ea <state_await_motion_cancel+0x5a>
                    sys.flags.feed_hold_pending = On;
 800f7e2:	7a6a      	ldrb	r2, [r5, #9]
 800f7e4:	f042 0220 	orr.w	r2, r2, #32
 800f7e8:	726a      	strb	r2, [r5, #9]
                if(!((sys.state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 800f7ea:	06b2      	lsls	r2, r6, #26
 800f7ec:	d410      	bmi.n	800f810 <state_await_motion_cancel+0x80>
 800f7ee:	079b      	lsls	r3, r3, #30
 800f7f0:	d40e      	bmi.n	800f810 <state_await_motion_cancel+0x80>
                    if(!initiate_hold(new_state)) {
 800f7f2:	2010      	movs	r0, #16
 800f7f4:	f7ff ff4e 	bl	800f694 <initiate_hold>
 800f7f8:	b920      	cbnz	r0, 800f804 <state_await_motion_cancel+0x74>
                        sys.holding_state = Hold_Complete;
 800f7fa:	2101      	movs	r1, #1
                        stateHandler = state_await_resume;
 800f7fc:	4b4f      	ldr	r3, [pc, #316]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f7fe:	4a50      	ldr	r2, [pc, #320]	; (800f940 <state_await_motion_cancel+0x1b0>)
                        sys.holding_state = Hold_Complete;
 800f800:	75e9      	strb	r1, [r5, #23]
                        stateHandler = state_await_resume;
 800f802:	601a      	str	r2, [r3, #0]
                    sys.state = new_state;
 800f804:	2210      	movs	r2, #16
                    sys.flags.feed_hold_pending = Off;
 800f806:	7a6b      	ldrb	r3, [r5, #9]
                    sys.state = new_state;
 800f808:	602a      	str	r2, [r5, #0]
                    sys.flags.feed_hold_pending = Off;
 800f80a:	f36f 1345 	bfc	r3, #5, #1
 800f80e:	726b      	strb	r3, [r5, #9]
 800f810:	4e4c      	ldr	r6, [pc, #304]	; (800f944 <state_await_motion_cancel+0x1b4>)
        if(hal.state_change_requested)
 800f812:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
 800f816:	b153      	cbz	r3, 800f82e <state_await_motion_cancel+0x9e>
            hal.state_change_requested(new_state);
 800f818:	4620      	mov	r0, r4
}
 800f81a:	b011      	add	sp, #68	; 0x44
 800f81c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            hal.state_change_requested(new_state);
 800f820:	4718      	bx	r3
        switch(new_state) {    // Set up new state and handler
 800f822:	2c40      	cmp	r4, #64	; 0x40
 800f824:	d1f4      	bne.n	800f810 <state_await_motion_cancel+0x80>
                if((sys.state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE)))
 800f826:	f240 1383 	movw	r3, #387	; 0x183
 800f82a:	421e      	tst	r6, r3
 800f82c:	d068      	beq.n	800f900 <state_await_motion_cancel+0x170>
}
 800f82e:	b011      	add	sp, #68	; 0x44
 800f830:	bdf0      	pop	{r4, r5, r6, r7, pc}
        switch(new_state) {    // Set up new state and handler
 800f832:	2c80      	cmp	r4, #128	; 0x80
 800f834:	d01f      	beq.n	800f876 <state_await_motion_cancel+0xe6>
 800f836:	d9f4      	bls.n	800f822 <state_await_motion_cancel+0x92>
 800f838:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 800f83c:	d03f      	beq.n	800f8be <state_await_motion_cancel+0x12e>
 800f83e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 800f842:	d1e5      	bne.n	800f810 <state_await_motion_cancel+0x80>
                stateHandler = state_await_toolchanged;
 800f844:	4b3d      	ldr	r3, [pc, #244]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f846:	4a40      	ldr	r2, [pc, #256]	; (800f948 <state_await_motion_cancel+0x1b8>)
 800f848:	4e3e      	ldr	r6, [pc, #248]	; (800f944 <state_await_motion_cancel+0x1b4>)
                sys.state = new_state;
 800f84a:	602c      	str	r4, [r5, #0]
                stateHandler = state_await_toolchanged;
 800f84c:	601a      	str	r2, [r3, #0]
                break;
 800f84e:	e7e0      	b.n	800f812 <state_await_motion_cancel+0x82>
            sys.step_control.flags = 0;
 800f850:	2400      	movs	r4, #0
        set_state(pending_state);
 800f852:	4f39      	ldr	r7, [pc, #228]	; (800f938 <state_await_motion_cancel+0x1a8>)
            sys.step_control.flags = 0;
 800f854:	72ac      	strb	r4, [r5, #10]
            plan_reset();
 800f856:	f7fa ff71 	bl	800a73c <plan_reset>
            st_reset();
 800f85a:	f000 fda5 	bl	80103a8 <st_reset>
            gc_sync_position();
 800f85e:	493b      	ldr	r1, [pc, #236]	; (800f94c <state_await_motion_cancel+0x1bc>)
 800f860:	483b      	ldr	r0, [pc, #236]	; (800f950 <state_await_motion_cancel+0x1c0>)
 800f862:	f001 ff61 	bl	8011728 <system_convert_array_steps_to_mpos>
            plan_sync_position();
 800f866:	f7fb fbd3 	bl	800b010 <plan_sync_position>
            sys.suspend = false;
 800f86a:	682e      	ldr	r6, [r5, #0]
 800f86c:	71ac      	strb	r4, [r5, #6]
        set_state(pending_state);
 800f86e:	683c      	ldr	r4, [r7, #0]
    if(new_state != sys.state) {
 800f870:	42b4      	cmp	r4, r6
 800f872:	d19a      	bne.n	800f7aa <state_await_motion_cancel+0x1a>
 800f874:	e7db      	b.n	800f82e <state_await_motion_cancel+0x9e>
 800f876:	4e33      	ldr	r6, [pc, #204]	; (800f944 <state_await_motion_cancel+0x1b4>)
                sys.parking_state = Parking_Retracting;
 800f878:	2302      	movs	r3, #2
                if(!initiate_hold(new_state)) {
 800f87a:	4620      	mov	r0, r4
                sys.parking_state = Parking_Retracting;
 800f87c:	75ab      	strb	r3, [r5, #22]
                if(!initiate_hold(new_state)) {
 800f87e:	f7ff ff09 	bl	800f694 <initiate_hold>
 800f882:	2800      	cmp	r0, #0
 800f884:	d13a      	bne.n	800f8fc <state_await_motion_cancel+0x16c>
                    if(pending_state != new_state) {
 800f886:	683b      	ldr	r3, [r7, #0]
 800f888:	429c      	cmp	r4, r3
 800f88a:	d0c2      	beq.n	800f812 <state_await_motion_cancel+0x82>
                        sys.state = new_state;
 800f88c:	602c      	str	r4, [r5, #0]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f88e:	f7ff fb5b 	bl	800ef48 <state_await_hold.part.0>
}
 800f892:	e7be      	b.n	800f812 <state_await_motion_cancel+0x82>
                sys.state = new_state;
 800f894:	2120      	movs	r1, #32
                stateHandler = state_cycle;
 800f896:	4b29      	ldr	r3, [pc, #164]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f898:	4a2e      	ldr	r2, [pc, #184]	; (800f954 <state_await_motion_cancel+0x1c4>)
                if(sys.state == STATE_TOOL_CHANGE)
 800f89a:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
                    pending_state = STATE_TOOL_CHANGE;
 800f89e:	bf08      	it	eq
 800f8a0:	603e      	streq	r6, [r7, #0]
                sys.state = new_state;
 800f8a2:	6029      	str	r1, [r5, #0]
                stateHandler = state_cycle;
 800f8a4:	4e27      	ldr	r6, [pc, #156]	; (800f944 <state_await_motion_cancel+0x1b4>)
 800f8a6:	601a      	str	r2, [r3, #0]
                break;
 800f8a8:	e7b3      	b.n	800f812 <state_await_motion_cancel+0x82>
                sys.suspend = false;        // Break suspend state.
 800f8aa:	2300      	movs	r3, #0
                stateHandler = state_idle;
 800f8ac:	4a23      	ldr	r2, [pc, #140]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f8ae:	492a      	ldr	r1, [pc, #168]	; (800f958 <state_await_motion_cancel+0x1c8>)
 800f8b0:	4e24      	ldr	r6, [pc, #144]	; (800f944 <state_await_motion_cancel+0x1b4>)
                sys.suspend = false;        // Break suspend state.
 800f8b2:	71ab      	strb	r3, [r5, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800f8b4:	72ab      	strb	r3, [r5, #10]
                sys.parking_state = Parking_DoorClosed;
 800f8b6:	82eb      	strh	r3, [r5, #22]
                sys.state = pending_state = new_state;
 800f8b8:	602b      	str	r3, [r5, #0]
                stateHandler = state_idle;
 800f8ba:	6011      	str	r1, [r2, #0]
                break;
 800f8bc:	e7a9      	b.n	800f812 <state_await_motion_cancel+0x82>
                sys.suspend = false;
 800f8be:	2100      	movs	r1, #0
                stateHandler = state_noop;
 800f8c0:	4b1e      	ldr	r3, [pc, #120]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f8c2:	4a26      	ldr	r2, [pc, #152]	; (800f95c <state_await_motion_cancel+0x1cc>)
 800f8c4:	4e1f      	ldr	r6, [pc, #124]	; (800f944 <state_await_motion_cancel+0x1b4>)
                sys.state = new_state;
 800f8c6:	602c      	str	r4, [r5, #0]
                sys.suspend = false;
 800f8c8:	71a9      	strb	r1, [r5, #6]
                stateHandler = state_noop;
 800f8ca:	601a      	str	r2, [r3, #0]
                break;
 800f8cc:	e7a1      	b.n	800f812 <state_await_motion_cancel+0x82>
                if(sys.state == STATE_IDLE) {
 800f8ce:	2e00      	cmp	r6, #0
 800f8d0:	d19e      	bne.n	800f810 <state_await_motion_cancel+0x80>
                    if ((block = plan_get_current_block())) {
 800f8d2:	f7fa ffbd 	bl	800a850 <plan_get_current_block>
 800f8d6:	4607      	mov	r7, r0
 800f8d8:	2800      	cmp	r0, #0
 800f8da:	d099      	beq.n	800f810 <state_await_motion_cancel+0x80>
                        sys.state = new_state;
 800f8dc:	2308      	movs	r3, #8
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800f8de:	71ee      	strb	r6, [r5, #7]
                        sys.state = new_state;
 800f8e0:	602b      	str	r3, [r5, #0]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 800f8e2:	f000 fe75 	bl	80105d0 <st_prep_buffer>
                        if(block->condition.spindle.synchronized) {
 800f8e6:	f997 3016 	ldrsb.w	r3, [r7, #22]
                            if(hal.spindle_reset_data)
 800f8ea:	4e16      	ldr	r6, [pc, #88]	; (800f944 <state_await_motion_cancel+0x1b4>)
                        if(block->condition.spindle.synchronized) {
 800f8ec:	2b00      	cmp	r3, #0
 800f8ee:	db0d      	blt.n	800f90c <state_await_motion_cancel+0x17c>
                        st_wake_up();
 800f8f0:	f000 fbe2 	bl	80100b8 <st_wake_up>
                        stateHandler = state_cycle;
 800f8f4:	4b11      	ldr	r3, [pc, #68]	; (800f93c <state_await_motion_cancel+0x1ac>)
 800f8f6:	4a17      	ldr	r2, [pc, #92]	; (800f954 <state_await_motion_cancel+0x1c4>)
 800f8f8:	601a      	str	r2, [r3, #0]
 800f8fa:	e78a      	b.n	800f812 <state_await_motion_cancel+0x82>
                    sys.state = new_state;
 800f8fc:	602c      	str	r4, [r5, #0]
 800f8fe:	e788      	b.n	800f812 <state_await_motion_cancel+0x82>
                hal.report.feedback_message(Message_SafetyDoorAjar);
 800f900:	4e10      	ldr	r6, [pc, #64]	; (800f944 <state_await_motion_cancel+0x1b4>)
 800f902:	2006      	movs	r0, #6
 800f904:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
 800f908:	4798      	blx	r3
 800f90a:	e7b5      	b.n	800f878 <state_await_motion_cancel+0xe8>
                            if(hal.spindle_reset_data)
 800f90c:	f8d6 30ec 	ldr.w	r3, [r6, #236]	; 0xec
 800f910:	b103      	cbz	r3, 800f914 <state_await_motion_cancel+0x184>
                                hal.spindle_reset_data();
 800f912:	4798      	blx	r3
                            uint32_t index = hal.spindle_get_data(SpindleData_Counters).index_count + 2;
 800f914:	2100      	movs	r1, #0
 800f916:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
 800f91a:	a808      	add	r0, sp, #32
 800f91c:	4798      	blx	r3
 800f91e:	9d08      	ldr	r5, [sp, #32]
 800f920:	3502      	adds	r5, #2
                            while(index != hal.spindle_get_data(SpindleData_Counters).index_count); // check for abort in this loop?
 800f922:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
 800f926:	2100      	movs	r1, #0
 800f928:	4668      	mov	r0, sp
 800f92a:	4798      	blx	r3
 800f92c:	9b00      	ldr	r3, [sp, #0]
 800f92e:	429d      	cmp	r5, r3
 800f930:	d1f7      	bne.n	800f922 <state_await_motion_cancel+0x192>
 800f932:	e7dd      	b.n	800f8f0 <state_await_motion_cancel+0x160>
 800f934:	20002494 	.word	0x20002494
 800f938:	20001b28 	.word	0x20001b28
 800f93c:	20000018 	.word	0x20000018
 800f940:	0800fc81 	.word	0x0800fc81
 800f944:	200024bc 	.word	0x200024bc
 800f948:	0800f445 	.word	0x0800f445
 800f94c:	20002610 	.word	0x20002610
 800f950:	20002448 	.word	0x20002448
 800f954:	0800ff21 	.word	0x0800ff21
 800f958:	0800fb8d 	.word	0x0800fb8d
 800f95c:	0800ef45 	.word	0x0800ef45

0800f960 <state_door_reopened>:
    return settings.parking.flags.enabled && park.restart_retract;
 800f960:	4b04      	ldr	r3, [pc, #16]	; (800f974 <state_door_reopened+0x14>)
 800f962:	f893 00d8 	ldrb.w	r0, [r3, #216]	; 0xd8
 800f966:	f010 0001 	ands.w	r0, r0, #1
 800f96a:	bf1c      	itt	ne
 800f96c:	4b02      	ldrne	r3, [pc, #8]	; (800f978 <state_door_reopened+0x18>)
 800f96e:	7f58      	ldrbne	r0, [r3, #29]
}
 800f970:	4770      	bx	lr
 800f972:	bf00      	nop
 800f974:	20002620 	.word	0x20002620
 800f978:	20001ad4 	.word	0x20001ad4

0800f97c <update_state>:
    if((rt_exec & EXEC_SAFETY_DOOR) && sys.state != STATE_SAFETY_DOOR)
 800f97c:	0643      	lsls	r3, r0, #25
 800f97e:	d402      	bmi.n	800f986 <update_state+0xa>
        stateHandler(rt_exec);
 800f980:	4b17      	ldr	r3, [pc, #92]	; (800f9e0 <update_state+0x64>)
 800f982:	681b      	ldr	r3, [r3, #0]
 800f984:	4718      	bx	r3
{
 800f986:	b570      	push	{r4, r5, r6, lr}
    if((rt_exec & EXEC_SAFETY_DOOR) && sys.state != STATE_SAFETY_DOOR)
 800f988:	4c16      	ldr	r4, [pc, #88]	; (800f9e4 <update_state+0x68>)
 800f98a:	6823      	ldr	r3, [r4, #0]
 800f98c:	2b40      	cmp	r3, #64	; 0x40
 800f98e:	d104      	bne.n	800f99a <update_state+0x1e>
}
 800f990:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        stateHandler(rt_exec);
 800f994:	4b12      	ldr	r3, [pc, #72]	; (800f9e0 <update_state+0x64>)
 800f996:	681b      	ldr	r3, [r3, #0]
 800f998:	4718      	bx	r3
                if((sys.state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE)))
 800f99a:	f240 1283 	movw	r2, #387	; 0x183
 800f99e:	4213      	tst	r3, r2
 800f9a0:	d115      	bne.n	800f9ce <update_state+0x52>
                hal.report.feedback_message(Message_SafetyDoorAjar);
 800f9a2:	4d11      	ldr	r5, [pc, #68]	; (800f9e8 <update_state+0x6c>)
 800f9a4:	2006      	movs	r0, #6
 800f9a6:	f8d5 3128 	ldr.w	r3, [r5, #296]	; 0x128
 800f9aa:	4798      	blx	r3
                sys.parking_state = Parking_Retracting;
 800f9ac:	2302      	movs	r3, #2
                if(!initiate_hold(new_state)) {
 800f9ae:	2040      	movs	r0, #64	; 0x40
                sys.parking_state = Parking_Retracting;
 800f9b0:	75a3      	strb	r3, [r4, #22]
                if(!initiate_hold(new_state)) {
 800f9b2:	f7ff fe6f 	bl	800f694 <initiate_hold>
 800f9b6:	b958      	cbnz	r0, 800f9d0 <update_state+0x54>
                    if(pending_state != new_state) {
 800f9b8:	4b0c      	ldr	r3, [pc, #48]	; (800f9ec <update_state+0x70>)
 800f9ba:	681b      	ldr	r3, [r3, #0]
 800f9bc:	2b40      	cmp	r3, #64	; 0x40
 800f9be:	d10a      	bne.n	800f9d6 <update_state+0x5a>
        if(hal.state_change_requested)
 800f9c0:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 800f9c4:	b11b      	cbz	r3, 800f9ce <update_state+0x52>
}
 800f9c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800f9ca:	2040      	movs	r0, #64	; 0x40
 800f9cc:	4718      	bx	r3
}
 800f9ce:	bd70      	pop	{r4, r5, r6, pc}
                    sys.state = new_state;
 800f9d0:	2340      	movs	r3, #64	; 0x40
 800f9d2:	6023      	str	r3, [r4, #0]
 800f9d4:	e7f4      	b.n	800f9c0 <update_state+0x44>
                        sys.state = new_state;
 800f9d6:	2340      	movs	r3, #64	; 0x40
 800f9d8:	6023      	str	r3, [r4, #0]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800f9da:	f7ff fab5 	bl	800ef48 <state_await_hold.part.0>
}
 800f9de:	e7ef      	b.n	800f9c0 <update_state+0x44>
 800f9e0:	20000018 	.word	0x20000018
 800f9e4:	20002494 	.word	0x20002494
 800f9e8:	200024bc 	.word	0x200024bc
 800f9ec:	20001b28 	.word	0x20001b28

0800f9f0 <set_state>:
{
 800f9f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if(new_state != sys.state) {
 800f9f2:	4d5d      	ldr	r5, [pc, #372]	; (800fb68 <set_state+0x178>)
{
 800f9f4:	b091      	sub	sp, #68	; 0x44
    if(new_state != sys.state) {
 800f9f6:	682e      	ldr	r6, [r5, #0]
 800f9f8:	4286      	cmp	r6, r0
 800f9fa:	d033      	beq.n	800fa64 <set_state+0x74>
        switch(new_state) {    // Set up new state and handler
 800f9fc:	2820      	cmp	r0, #32
 800f9fe:	4604      	mov	r4, r0
 800fa00:	d814      	bhi.n	800fa2c <set_state+0x3c>
 800fa02:	2820      	cmp	r0, #32
 800fa04:	d81f      	bhi.n	800fa46 <set_state+0x56>
 800fa06:	e8df f000 	tbb	[pc, r0]
 800fa0a:	473c      	.short	0x473c
 800fa0c:	1e471e47 	.word	0x1e471e47
 800fa10:	1e4f1e1e 	.word	0x1e4f1e1e
 800fa14:	1e1e1e1e 	.word	0x1e1e1e1e
 800fa18:	1e661e1e 	.word	0x1e661e1e
 800fa1c:	1e1e1e1e 	.word	0x1e1e1e1e
 800fa20:	1e1e1e1e 	.word	0x1e1e1e1e
 800fa24:	1e1e1e1e 	.word	0x1e1e1e1e
 800fa28:	1e1e      	.short	0x1e1e
 800fa2a:	2f          	.byte	0x2f
 800fa2b:	00          	.byte	0x00
 800fa2c:	2880      	cmp	r0, #128	; 0x80
 800fa2e:	d06b      	beq.n	800fb08 <set_state+0x118>
 800fa30:	d912      	bls.n	800fa58 <set_state+0x68>
 800fa32:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 800fa36:	d02f      	beq.n	800fa98 <set_state+0xa8>
 800fa38:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800fa3c:	d103      	bne.n	800fa46 <set_state+0x56>
                stateHandler = state_await_toolchanged;
 800fa3e:	4b4b      	ldr	r3, [pc, #300]	; (800fb6c <set_state+0x17c>)
 800fa40:	4a4b      	ldr	r2, [pc, #300]	; (800fb70 <set_state+0x180>)
                sys.state = new_state;
 800fa42:	6028      	str	r0, [r5, #0]
                stateHandler = state_await_toolchanged;
 800fa44:	601a      	str	r2, [r3, #0]
                break;
 800fa46:	4e4b      	ldr	r6, [pc, #300]	; (800fb74 <set_state+0x184>)
        if(hal.state_change_requested)
 800fa48:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
 800fa4c:	b153      	cbz	r3, 800fa64 <set_state+0x74>
            hal.state_change_requested(new_state);
 800fa4e:	4620      	mov	r0, r4
}
 800fa50:	b011      	add	sp, #68	; 0x44
 800fa52:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
            hal.state_change_requested(new_state);
 800fa56:	4718      	bx	r3
        switch(new_state) {    // Set up new state and handler
 800fa58:	2840      	cmp	r0, #64	; 0x40
 800fa5a:	d1f4      	bne.n	800fa46 <set_state+0x56>
                if((sys.state & (STATE_ALARM|STATE_ESTOP|STATE_SLEEP|STATE_CHECK_MODE)))
 800fa5c:	f240 1383 	movw	r3, #387	; 0x183
 800fa60:	421e      	tst	r6, r3
 800fa62:	d062      	beq.n	800fb2a <set_state+0x13a>
}
 800fa64:	b011      	add	sp, #68	; 0x44
 800fa66:	bdf0      	pop	{r4, r5, r6, r7, pc}
                sys.state = new_state;
 800fa68:	2120      	movs	r1, #32
                if(sys.state == STATE_TOOL_CHANGE)
 800fa6a:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
                    pending_state = STATE_TOOL_CHANGE;
 800fa6e:	bf08      	it	eq
 800fa70:	4b41      	ldreq	r3, [pc, #260]	; (800fb78 <set_state+0x188>)
                stateHandler = state_cycle;
 800fa72:	4a42      	ldr	r2, [pc, #264]	; (800fb7c <set_state+0x18c>)
                    pending_state = STATE_TOOL_CHANGE;
 800fa74:	bf08      	it	eq
 800fa76:	601e      	streq	r6, [r3, #0]
                stateHandler = state_cycle;
 800fa78:	4b3c      	ldr	r3, [pc, #240]	; (800fb6c <set_state+0x17c>)
 800fa7a:	4e3e      	ldr	r6, [pc, #248]	; (800fb74 <set_state+0x184>)
                sys.state = new_state;
 800fa7c:	6029      	str	r1, [r5, #0]
                stateHandler = state_cycle;
 800fa7e:	601a      	str	r2, [r3, #0]
                break;
 800fa80:	e7e2      	b.n	800fa48 <set_state+0x58>
                sys.suspend = false;        // Break suspend state.
 800fa82:	2300      	movs	r3, #0
                sys.state = pending_state = new_state;
 800fa84:	483c      	ldr	r0, [pc, #240]	; (800fb78 <set_state+0x188>)
                stateHandler = state_idle;
 800fa86:	4a39      	ldr	r2, [pc, #228]	; (800fb6c <set_state+0x17c>)
 800fa88:	493d      	ldr	r1, [pc, #244]	; (800fb80 <set_state+0x190>)
                sys.suspend = false;        // Break suspend state.
 800fa8a:	71ab      	strb	r3, [r5, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800fa8c:	72ab      	strb	r3, [r5, #10]
                sys.parking_state = Parking_DoorClosed;
 800fa8e:	82eb      	strh	r3, [r5, #22]
                sys.state = pending_state = new_state;
 800fa90:	602b      	str	r3, [r5, #0]
 800fa92:	6003      	str	r3, [r0, #0]
                stateHandler = state_idle;
 800fa94:	6011      	str	r1, [r2, #0]
                break;
 800fa96:	e7d6      	b.n	800fa46 <set_state+0x56>
                sys.suspend = false;
 800fa98:	2100      	movs	r1, #0
                stateHandler = state_noop;
 800fa9a:	4b34      	ldr	r3, [pc, #208]	; (800fb6c <set_state+0x17c>)
 800fa9c:	4a39      	ldr	r2, [pc, #228]	; (800fb84 <set_state+0x194>)
 800fa9e:	4e35      	ldr	r6, [pc, #212]	; (800fb74 <set_state+0x184>)
                sys.state = new_state;
 800faa0:	602c      	str	r4, [r5, #0]
                sys.suspend = false;
 800faa2:	71a9      	strb	r1, [r5, #6]
                stateHandler = state_noop;
 800faa4:	601a      	str	r2, [r3, #0]
                break;
 800faa6:	e7cf      	b.n	800fa48 <set_state+0x58>
                if(sys.state == STATE_IDLE) {
 800faa8:	2e00      	cmp	r6, #0
 800faaa:	d1cc      	bne.n	800fa46 <set_state+0x56>
                    if ((block = plan_get_current_block())) {
 800faac:	f7fa fed0 	bl	800a850 <plan_get_current_block>
 800fab0:	4607      	mov	r7, r0
 800fab2:	2800      	cmp	r0, #0
 800fab4:	d0c7      	beq.n	800fa46 <set_state+0x56>
                        sys.state = new_state;
 800fab6:	2308      	movs	r3, #8
                        sys.steppers_deenergize = false;    // Cancel stepper deenergize if pending.
 800fab8:	71ee      	strb	r6, [r5, #7]
                        sys.state = new_state;
 800faba:	602b      	str	r3, [r5, #0]
                        st_prep_buffer();                   // Initialize step segment buffer before beginning cycle.
 800fabc:	f000 fd88 	bl	80105d0 <st_prep_buffer>
                        if(block->condition.spindle.synchronized) {
 800fac0:	f997 3016 	ldrsb.w	r3, [r7, #22]
                            if(hal.spindle_reset_data)
 800fac4:	4e2b      	ldr	r6, [pc, #172]	; (800fb74 <set_state+0x184>)
                        if(block->condition.spindle.synchronized) {
 800fac6:	2b00      	cmp	r3, #0
 800fac8:	db3a      	blt.n	800fb40 <set_state+0x150>
                        st_wake_up();
 800faca:	f000 faf5 	bl	80100b8 <st_wake_up>
                        stateHandler = state_cycle;
 800face:	4b27      	ldr	r3, [pc, #156]	; (800fb6c <set_state+0x17c>)
 800fad0:	4a2a      	ldr	r2, [pc, #168]	; (800fb7c <set_state+0x18c>)
 800fad2:	601a      	str	r2, [r3, #0]
 800fad4:	e7b8      	b.n	800fa48 <set_state+0x58>
                if(sys.override.control.sync && sys.override.control.feed_hold_disable)
 800fad6:	7cab      	ldrb	r3, [r5, #18]
 800fad8:	f003 0282 	and.w	r2, r3, #130	; 0x82
 800fadc:	2a82      	cmp	r2, #130	; 0x82
 800fade:	d02a      	beq.n	800fb36 <set_state+0x146>
                if(!((sys.state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 800fae0:	06b2      	lsls	r2, r6, #26
 800fae2:	d4b0      	bmi.n	800fa46 <set_state+0x56>
 800fae4:	079b      	lsls	r3, r3, #30
 800fae6:	d4ae      	bmi.n	800fa46 <set_state+0x56>
                    if(!initiate_hold(new_state)) {
 800fae8:	2010      	movs	r0, #16
 800faea:	f7ff fdd3 	bl	800f694 <initiate_hold>
 800faee:	b920      	cbnz	r0, 800fafa <set_state+0x10a>
                        sys.holding_state = Hold_Complete;
 800faf0:	2101      	movs	r1, #1
                        stateHandler = state_await_resume;
 800faf2:	4b1e      	ldr	r3, [pc, #120]	; (800fb6c <set_state+0x17c>)
 800faf4:	4a24      	ldr	r2, [pc, #144]	; (800fb88 <set_state+0x198>)
                        sys.holding_state = Hold_Complete;
 800faf6:	75e9      	strb	r1, [r5, #23]
                        stateHandler = state_await_resume;
 800faf8:	601a      	str	r2, [r3, #0]
                    sys.state = new_state;
 800fafa:	2210      	movs	r2, #16
                    sys.flags.feed_hold_pending = Off;
 800fafc:	7a6b      	ldrb	r3, [r5, #9]
                    sys.state = new_state;
 800fafe:	602a      	str	r2, [r5, #0]
                    sys.flags.feed_hold_pending = Off;
 800fb00:	f36f 1345 	bfc	r3, #5, #1
 800fb04:	726b      	strb	r3, [r5, #9]
 800fb06:	e79e      	b.n	800fa46 <set_state+0x56>
 800fb08:	4e1a      	ldr	r6, [pc, #104]	; (800fb74 <set_state+0x184>)
                sys.parking_state = Parking_Retracting;
 800fb0a:	2302      	movs	r3, #2
                if(!initiate_hold(new_state)) {
 800fb0c:	4620      	mov	r0, r4
                sys.parking_state = Parking_Retracting;
 800fb0e:	75ab      	strb	r3, [r5, #22]
                if(!initiate_hold(new_state)) {
 800fb10:	f7ff fdc0 	bl	800f694 <initiate_hold>
 800fb14:	b938      	cbnz	r0, 800fb26 <set_state+0x136>
                    if(pending_state != new_state) {
 800fb16:	4b18      	ldr	r3, [pc, #96]	; (800fb78 <set_state+0x188>)
 800fb18:	681b      	ldr	r3, [r3, #0]
 800fb1a:	42a3      	cmp	r3, r4
 800fb1c:	d094      	beq.n	800fa48 <set_state+0x58>
                        sys.state = new_state;
 800fb1e:	602c      	str	r4, [r5, #0]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800fb20:	f7ff fa12 	bl	800ef48 <state_await_hold.part.0>
}
 800fb24:	e790      	b.n	800fa48 <set_state+0x58>
                    sys.state = new_state;
 800fb26:	602c      	str	r4, [r5, #0]
 800fb28:	e78e      	b.n	800fa48 <set_state+0x58>
                hal.report.feedback_message(Message_SafetyDoorAjar);
 800fb2a:	4e12      	ldr	r6, [pc, #72]	; (800fb74 <set_state+0x184>)
 800fb2c:	2006      	movs	r0, #6
 800fb2e:	f8d6 3128 	ldr.w	r3, [r6, #296]	; 0x128
 800fb32:	4798      	blx	r3
 800fb34:	e7e9      	b.n	800fb0a <set_state+0x11a>
                    sys.flags.feed_hold_pending = On;
 800fb36:	7a6a      	ldrb	r2, [r5, #9]
 800fb38:	f042 0220 	orr.w	r2, r2, #32
 800fb3c:	726a      	strb	r2, [r5, #9]
 800fb3e:	e7cf      	b.n	800fae0 <set_state+0xf0>
                            if(hal.spindle_reset_data)
 800fb40:	f8d6 30ec 	ldr.w	r3, [r6, #236]	; 0xec
 800fb44:	b103      	cbz	r3, 800fb48 <set_state+0x158>
                                hal.spindle_reset_data();
 800fb46:	4798      	blx	r3
                            uint32_t index = hal.spindle_get_data(SpindleData_Counters).index_count + 2;
 800fb48:	2100      	movs	r1, #0
 800fb4a:	4668      	mov	r0, sp
 800fb4c:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
 800fb50:	4798      	blx	r3
 800fb52:	9d00      	ldr	r5, [sp, #0]
 800fb54:	3502      	adds	r5, #2
                            while(index != hal.spindle_get_data(SpindleData_Counters).index_count); // check for abort in this loop?
 800fb56:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
 800fb5a:	2100      	movs	r1, #0
 800fb5c:	a808      	add	r0, sp, #32
 800fb5e:	4798      	blx	r3
 800fb60:	9b08      	ldr	r3, [sp, #32]
 800fb62:	42ab      	cmp	r3, r5
 800fb64:	d1f7      	bne.n	800fb56 <set_state+0x166>
 800fb66:	e7b0      	b.n	800faca <set_state+0xda>
 800fb68:	20002494 	.word	0x20002494
 800fb6c:	20000018 	.word	0x20000018
 800fb70:	0800f445 	.word	0x0800f445
 800fb74:	200024bc 	.word	0x200024bc
 800fb78:	20001b28 	.word	0x20001b28
 800fb7c:	0800ff21 	.word	0x0800ff21
 800fb80:	0800fb8d 	.word	0x0800fb8d
 800fb84:	0800ef45 	.word	0x0800ef45
 800fb88:	0800fc81 	.word	0x0800fc81

0800fb8c <state_idle>:
    if((rt_exec & EXEC_CYCLE_START))
 800fb8c:	0782      	lsls	r2, r0, #30
{
 800fb8e:	b570      	push	{r4, r5, r6, lr}
 800fb90:	4604      	mov	r4, r0
    if((rt_exec & EXEC_CYCLE_START))
 800fb92:	d44c      	bmi.n	800fc2e <state_idle+0xa2>
    if(rt_exec & EXEC_FEED_HOLD)
 800fb94:	0723      	lsls	r3, r4, #28
 800fb96:	d435      	bmi.n	800fc04 <state_idle+0x78>
    if ((rt_exec & EXEC_TOOL_CHANGE)) {
 800fb98:	05a1      	lsls	r1, r4, #22
 800fb9a:	d512      	bpl.n	800fbc2 <state_idle+0x36>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 800fb9c:	4e32      	ldr	r6, [pc, #200]	; (800fc68 <state_idle+0xdc>)
    if(new_state != sys.state) {
 800fb9e:	4d33      	ldr	r5, [pc, #204]	; (800fc6c <state_idle+0xe0>)
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 800fba0:	6fb3      	ldr	r3, [r6, #120]	; 0x78
 800fba2:	2001      	movs	r0, #1
 800fba4:	4798      	blx	r3
    if(new_state != sys.state) {
 800fba6:	682b      	ldr	r3, [r5, #0]
 800fba8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800fbac:	d027      	beq.n	800fbfe <state_idle+0x72>
                sys.state = new_state;
 800fbae:	f44f 7000 	mov.w	r0, #512	; 0x200
                stateHandler = state_await_toolchanged;
 800fbb2:	4a2f      	ldr	r2, [pc, #188]	; (800fc70 <state_idle+0xe4>)
 800fbb4:	492f      	ldr	r1, [pc, #188]	; (800fc74 <state_idle+0xe8>)
        if(hal.state_change_requested)
 800fbb6:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
                sys.state = new_state;
 800fbba:	6028      	str	r0, [r5, #0]
                stateHandler = state_await_toolchanged;
 800fbbc:	6011      	str	r1, [r2, #0]
        if(hal.state_change_requested)
 800fbbe:	b1f3      	cbz	r3, 800fbfe <state_idle+0x72>
            hal.state_change_requested(new_state);
 800fbc0:	4798      	blx	r3
    if (rt_exec & EXEC_SLEEP)
 800fbc2:	05e2      	lsls	r2, r4, #23
 800fbc4:	d400      	bmi.n	800fbc8 <state_idle+0x3c>
}
 800fbc6:	bd70      	pop	{r4, r5, r6, pc}
    if(new_state != sys.state) {
 800fbc8:	4d28      	ldr	r5, [pc, #160]	; (800fc6c <state_idle+0xe0>)
 800fbca:	682b      	ldr	r3, [r5, #0]
 800fbcc:	2b80      	cmp	r3, #128	; 0x80
 800fbce:	d0fa      	beq.n	800fbc6 <state_idle+0x3a>
 800fbd0:	4e25      	ldr	r6, [pc, #148]	; (800fc68 <state_idle+0xdc>)
                sys.parking_state = Parking_Retracting;
 800fbd2:	2302      	movs	r3, #2
                if(!initiate_hold(new_state)) {
 800fbd4:	2080      	movs	r0, #128	; 0x80
                sys.parking_state = Parking_Retracting;
 800fbd6:	75ab      	strb	r3, [r5, #22]
                if(!initiate_hold(new_state)) {
 800fbd8:	f7ff fd5c 	bl	800f694 <initiate_hold>
 800fbdc:	bb58      	cbnz	r0, 800fc36 <state_idle+0xaa>
                    if(pending_state != new_state) {
 800fbde:	4b26      	ldr	r3, [pc, #152]	; (800fc78 <state_idle+0xec>)
 800fbe0:	681b      	ldr	r3, [r3, #0]
 800fbe2:	2b80      	cmp	r3, #128	; 0x80
 800fbe4:	d003      	beq.n	800fbee <state_idle+0x62>
                        sys.state = new_state;
 800fbe6:	2380      	movs	r3, #128	; 0x80
 800fbe8:	602b      	str	r3, [r5, #0]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800fbea:	f7ff f9ad 	bl	800ef48 <state_await_hold.part.0>
        if(hal.state_change_requested)
 800fbee:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
 800fbf2:	2b00      	cmp	r3, #0
 800fbf4:	d0e7      	beq.n	800fbc6 <state_idle+0x3a>
}
 800fbf6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800fbfa:	2080      	movs	r0, #128	; 0x80
 800fbfc:	4718      	bx	r3
    if (rt_exec & EXEC_SLEEP)
 800fbfe:	05e3      	lsls	r3, r4, #23
 800fc00:	d4e7      	bmi.n	800fbd2 <state_idle+0x46>
}
 800fc02:	bd70      	pop	{r4, r5, r6, pc}
    if(new_state != sys.state) {
 800fc04:	4d19      	ldr	r5, [pc, #100]	; (800fc6c <state_idle+0xe0>)
 800fc06:	682b      	ldr	r3, [r5, #0]
 800fc08:	2b10      	cmp	r3, #16
 800fc0a:	d0c5      	beq.n	800fb98 <state_idle+0xc>
                if(sys.override.control.sync && sys.override.control.feed_hold_disable)
 800fc0c:	7caa      	ldrb	r2, [r5, #18]
 800fc0e:	f002 0182 	and.w	r1, r2, #130	; 0x82
 800fc12:	2982      	cmp	r1, #130	; 0x82
 800fc14:	d012      	beq.n	800fc3c <state_idle+0xb0>
                if(!((sys.state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 800fc16:	069e      	lsls	r6, r3, #26
 800fc18:	d401      	bmi.n	800fc1e <state_idle+0x92>
 800fc1a:	0790      	lsls	r0, r2, #30
 800fc1c:	d513      	bpl.n	800fc46 <state_idle+0xba>
        if(hal.state_change_requested)
 800fc1e:	4e12      	ldr	r6, [pc, #72]	; (800fc68 <state_idle+0xdc>)
 800fc20:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
 800fc24:	2b00      	cmp	r3, #0
 800fc26:	d0b7      	beq.n	800fb98 <state_idle+0xc>
            hal.state_change_requested(new_state);
 800fc28:	2010      	movs	r0, #16
 800fc2a:	4798      	blx	r3
 800fc2c:	e7b4      	b.n	800fb98 <state_idle+0xc>
        set_state(STATE_CYCLE);
 800fc2e:	2008      	movs	r0, #8
 800fc30:	f7ff fede 	bl	800f9f0 <set_state>
 800fc34:	e7ae      	b.n	800fb94 <state_idle+0x8>
                    sys.state = new_state;
 800fc36:	2380      	movs	r3, #128	; 0x80
 800fc38:	602b      	str	r3, [r5, #0]
 800fc3a:	e7d8      	b.n	800fbee <state_idle+0x62>
                    sys.flags.feed_hold_pending = On;
 800fc3c:	7a69      	ldrb	r1, [r5, #9]
 800fc3e:	f041 0120 	orr.w	r1, r1, #32
 800fc42:	7269      	strb	r1, [r5, #9]
 800fc44:	e7e7      	b.n	800fc16 <state_idle+0x8a>
                    if(!initiate_hold(new_state)) {
 800fc46:	2010      	movs	r0, #16
 800fc48:	f7ff fd24 	bl	800f694 <initiate_hold>
 800fc4c:	b920      	cbnz	r0, 800fc58 <state_idle+0xcc>
                        sys.holding_state = Hold_Complete;
 800fc4e:	2101      	movs	r1, #1
                        stateHandler = state_await_resume;
 800fc50:	4b07      	ldr	r3, [pc, #28]	; (800fc70 <state_idle+0xe4>)
 800fc52:	4a0a      	ldr	r2, [pc, #40]	; (800fc7c <state_idle+0xf0>)
                        sys.holding_state = Hold_Complete;
 800fc54:	75e9      	strb	r1, [r5, #23]
                        stateHandler = state_await_resume;
 800fc56:	601a      	str	r2, [r3, #0]
                    sys.state = new_state;
 800fc58:	2210      	movs	r2, #16
                    sys.flags.feed_hold_pending = Off;
 800fc5a:	7a6b      	ldrb	r3, [r5, #9]
                    sys.state = new_state;
 800fc5c:	602a      	str	r2, [r5, #0]
                    sys.flags.feed_hold_pending = Off;
 800fc5e:	f36f 1345 	bfc	r3, #5, #1
 800fc62:	726b      	strb	r3, [r5, #9]
 800fc64:	e7db      	b.n	800fc1e <state_idle+0x92>
 800fc66:	bf00      	nop
 800fc68:	200024bc 	.word	0x200024bc
 800fc6c:	20002494 	.word	0x20002494
 800fc70:	20000018 	.word	0x20000018
 800fc74:	0800f445 	.word	0x0800f445
 800fc78:	20001b28 	.word	0x20001b28
 800fc7c:	0800fc81 	.word	0x0800fc81

0800fc80 <state_await_resume>:
{
 800fc80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if((rt_exec & EXEC_CYCLE_COMPLETE) && settings.parking.flags.enabled) {
 800fc84:	0745      	lsls	r5, r0, #29
{
 800fc86:	4604      	mov	r4, r0
    if((rt_exec & EXEC_CYCLE_COMPLETE) && settings.parking.flags.enabled) {
 800fc88:	d504      	bpl.n	800fc94 <state_await_resume+0x14>
 800fc8a:	4b68      	ldr	r3, [pc, #416]	; (800fe2c <state_await_resume+0x1ac>)
 800fc8c:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
 800fc90:	07d8      	lsls	r0, r3, #31
 800fc92:	d44e      	bmi.n	800fd32 <state_await_resume+0xb2>
    if ((rt_exec & EXEC_CYCLE_START) && !(sys.state == STATE_SAFETY_DOOR && hal.system_control_get_state().safety_door_ajar)) {
 800fc94:	07a2      	lsls	r2, r4, #30
 800fc96:	d548      	bpl.n	800fd2a <state_await_resume+0xaa>
 800fc98:	4d65      	ldr	r5, [pc, #404]	; (800fe30 <state_await_resume+0x1b0>)
 800fc9a:	682b      	ldr	r3, [r5, #0]
 800fc9c:	2b40      	cmp	r3, #64	; 0x40
 800fc9e:	d019      	beq.n	800fcd4 <state_await_resume+0x54>
        if(sys.state == STATE_HOLD && !sys.override.spindle_stop.value)
 800fca0:	2b10      	cmp	r3, #16
 800fca2:	d14d      	bne.n	800fd40 <state_await_resume+0xc0>
 800fca4:	7c6b      	ldrb	r3, [r5, #17]
 800fca6:	b90b      	cbnz	r3, 800fcac <state_await_resume+0x2c>
            sys.override.spindle_stop.restore_cycle = On;
 800fca8:	2308      	movs	r3, #8
 800fcaa:	746b      	strb	r3, [r5, #17]
                if (!settings.flags.restore_after_feed_hold) {
 800fcac:	4b5f      	ldr	r3, [pc, #380]	; (800fe2c <state_await_resume+0x1ac>)
 800fcae:	f893 30bd 	ldrb.w	r3, [r3, #189]	; 0xbd
 800fcb2:	06d9      	lsls	r1, r3, #27
 800fcb4:	f100 8083 	bmi.w	800fdbe <state_await_resume+0x13e>
                    if(!hal.spindle_get_state().on) {
 800fcb8:	4e5e      	ldr	r6, [pc, #376]	; (800fe34 <state_await_resume+0x1b4>)
 800fcba:	6b73      	ldr	r3, [r6, #52]	; 0x34
 800fcbc:	4798      	blx	r3
 800fcbe:	07c2      	lsls	r2, r0, #31
 800fcc0:	f140 8084 	bpl.w	800fdcc <state_await_resume+0x14c>
                    sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 800fcc4:	2200      	movs	r2, #0
 800fcc6:	682b      	ldr	r3, [r5, #0]
 800fcc8:	746a      	strb	r2, [r5, #17]
        if(!(handler_changed || sys.state == STATE_SLEEP)) {
 800fcca:	2b80      	cmp	r3, #128	; 0x80
 800fccc:	d02f      	beq.n	800fd2e <state_await_resume+0xae>
    if(new_state != sys.state) {
 800fcce:	2b00      	cmp	r3, #0
 800fcd0:	d04c      	beq.n	800fd6c <state_await_resume+0xec>
 800fcd2:	e03d      	b.n	800fd50 <state_await_resume+0xd0>
    if ((rt_exec & EXEC_CYCLE_START) && !(sys.state == STATE_SAFETY_DOOR && hal.system_control_get_state().safety_door_ajar)) {
 800fcd4:	4e57      	ldr	r6, [pc, #348]	; (800fe34 <state_await_resume+0x1b4>)
 800fcd6:	6c33      	ldr	r3, [r6, #64]	; 0x40
 800fcd8:	4798      	blx	r3
 800fcda:	f010 0008 	ands.w	r0, r0, #8
 800fcde:	d124      	bne.n	800fd2a <state_await_resume+0xaa>
 800fce0:	682b      	ldr	r3, [r5, #0]
        if(sys.state == STATE_HOLD && !sys.override.spindle_stop.value)
 800fce2:	2b10      	cmp	r3, #16
 800fce4:	d0de      	beq.n	800fca4 <state_await_resume+0x24>
        switch (sys.state) {
 800fce6:	2b40      	cmp	r3, #64	; 0x40
 800fce8:	d12a      	bne.n	800fd40 <state_await_resume+0xc0>
                if(settings.parking.flags.enabled) {
 800fcea:	4f50      	ldr	r7, [pc, #320]	; (800fe2c <state_await_resume+0x1ac>)
 800fcec:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 800fcf0:	07db      	lsls	r3, r3, #31
 800fcf2:	d573      	bpl.n	800fddc <state_await_resume+0x15c>
                    sys.parking_state = Parking_Resuming;
 800fcf4:	f04f 0904 	mov.w	r9, #4
                    park.restart_retract = false;
 800fcf8:	f8df 815c 	ldr.w	r8, [pc, #348]	; 800fe58 <state_await_resume+0x1d8>
                    sys.parking_state = Parking_Resuming;
 800fcfc:	f885 9016 	strb.w	r9, [r5, #22]
                    if (park.retracting) {
 800fd00:	f898 301c 	ldrb.w	r3, [r8, #28]
                    park.restart_retract = false;
 800fd04:	f888 001d 	strb.w	r0, [r8, #29]
                    if (park.retracting) {
 800fd08:	b313      	cbz	r3, 800fd50 <state_await_resume+0xd0>
                        stateHandler = state_restore;
 800fd0a:	4d4b      	ldr	r5, [pc, #300]	; (800fe38 <state_await_resume+0x1b8>)
 800fd0c:	4b4b      	ldr	r3, [pc, #300]	; (800fe3c <state_await_resume+0x1bc>)
                        if (park.target[settings.parking.axis] <= settings.parking.target) {
 800fd0e:	f897 60d9 	ldrb.w	r6, [r7, #217]	; 0xd9
 800fd12:	f8d7 10dc 	ldr.w	r1, [r7, #220]	; 0xdc
 800fd16:	f858 0026 	ldr.w	r0, [r8, r6, lsl #2]
                        stateHandler = state_restore;
 800fd1a:	602b      	str	r3, [r5, #0]
                        if (park.target[settings.parking.axis] <= settings.parking.target) {
 800fd1c:	f7f0 fee2 	bl	8000ae4 <__aeabi_fcmple>
 800fd20:	2800      	cmp	r0, #0
 800fd22:	d173      	bne.n	800fe0c <state_await_resume+0x18c>
                            stateHandler(EXEC_CYCLE_COMPLETE);
 800fd24:	4648      	mov	r0, r9
 800fd26:	682b      	ldr	r3, [r5, #0]
 800fd28:	4798      	blx	r3
    if (rt_exec & EXEC_SLEEP)
 800fd2a:	05e3      	lsls	r3, r4, #23
 800fd2c:	d423      	bmi.n	800fd76 <state_await_resume+0xf6>
}
 800fd2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if(sys.step_control.execute_sys_motion) {
 800fd32:	4d3f      	ldr	r5, [pc, #252]	; (800fe30 <state_await_resume+0x1b0>)
 800fd34:	7aab      	ldrb	r3, [r5, #10]
 800fd36:	0759      	lsls	r1, r3, #29
 800fd38:	d43b      	bmi.n	800fdb2 <state_await_resume+0x132>
        sys.parking_state = Parking_DoorAjar;
 800fd3a:	2301      	movs	r3, #1
 800fd3c:	75ab      	strb	r3, [r5, #22]
 800fd3e:	e7a9      	b.n	800fc94 <state_await_resume+0x14>
        switch (sys.state) {
 800fd40:	2b3f      	cmp	r3, #63	; 0x3f
 800fd42:	d9b3      	bls.n	800fcac <state_await_resume+0x2c>
 800fd44:	2b80      	cmp	r3, #128	; 0x80
 800fd46:	d0f2      	beq.n	800fd2e <state_await_resume+0xae>
 800fd48:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800fd4c:	d1ae      	bne.n	800fcac <state_await_resume+0x2c>
 800fd4e:	4e39      	ldr	r6, [pc, #228]	; (800fe34 <state_await_resume+0x1b4>)
                sys.suspend = false;        // Break suspend state.
 800fd50:	2000      	movs	r0, #0
        if(hal.state_change_requested)
 800fd52:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
                stateHandler = state_idle;
 800fd56:	4a38      	ldr	r2, [pc, #224]	; (800fe38 <state_await_resume+0x1b8>)
                sys.state = pending_state = new_state;
 800fd58:	4e39      	ldr	r6, [pc, #228]	; (800fe40 <state_await_resume+0x1c0>)
                stateHandler = state_idle;
 800fd5a:	493a      	ldr	r1, [pc, #232]	; (800fe44 <state_await_resume+0x1c4>)
                sys.suspend = false;        // Break suspend state.
 800fd5c:	71a8      	strb	r0, [r5, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800fd5e:	72a8      	strb	r0, [r5, #10]
                sys.parking_state = Parking_DoorClosed;
 800fd60:	82e8      	strh	r0, [r5, #22]
                sys.state = pending_state = new_state;
 800fd62:	6028      	str	r0, [r5, #0]
 800fd64:	6030      	str	r0, [r6, #0]
                stateHandler = state_idle;
 800fd66:	6011      	str	r1, [r2, #0]
        if(hal.state_change_requested)
 800fd68:	b103      	cbz	r3, 800fd6c <state_await_resume+0xec>
            hal.state_change_requested(new_state);
 800fd6a:	4798      	blx	r3
            set_state(STATE_CYCLE);
 800fd6c:	2008      	movs	r0, #8
 800fd6e:	f7ff fe3f 	bl	800f9f0 <set_state>
    if (rt_exec & EXEC_SLEEP)
 800fd72:	05e3      	lsls	r3, r4, #23
 800fd74:	d5db      	bpl.n	800fd2e <state_await_resume+0xae>
    if(new_state != sys.state) {
 800fd76:	4c2e      	ldr	r4, [pc, #184]	; (800fe30 <state_await_resume+0x1b0>)
 800fd78:	6823      	ldr	r3, [r4, #0]
 800fd7a:	2b80      	cmp	r3, #128	; 0x80
 800fd7c:	d0d7      	beq.n	800fd2e <state_await_resume+0xae>
                sys.parking_state = Parking_Retracting;
 800fd7e:	2302      	movs	r3, #2
                if(!initiate_hold(new_state)) {
 800fd80:	2080      	movs	r0, #128	; 0x80
                sys.parking_state = Parking_Retracting;
 800fd82:	75a3      	strb	r3, [r4, #22]
                if(!initiate_hold(new_state)) {
 800fd84:	f7ff fc86 	bl	800f694 <initiate_hold>
 800fd88:	b150      	cbz	r0, 800fda0 <state_await_resume+0x120>
                    sys.state = new_state;
 800fd8a:	2380      	movs	r3, #128	; 0x80
 800fd8c:	6023      	str	r3, [r4, #0]
        if(hal.state_change_requested)
 800fd8e:	4b29      	ldr	r3, [pc, #164]	; (800fe34 <state_await_resume+0x1b4>)
 800fd90:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800fd94:	2b00      	cmp	r3, #0
 800fd96:	d0ca      	beq.n	800fd2e <state_await_resume+0xae>
}
 800fd98:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            hal.state_change_requested(new_state);
 800fd9c:	2080      	movs	r0, #128	; 0x80
 800fd9e:	4718      	bx	r3
                    if(pending_state != new_state) {
 800fda0:	4b27      	ldr	r3, [pc, #156]	; (800fe40 <state_await_resume+0x1c0>)
 800fda2:	681b      	ldr	r3, [r3, #0]
 800fda4:	2b80      	cmp	r3, #128	; 0x80
 800fda6:	d0f2      	beq.n	800fd8e <state_await_resume+0x10e>
                        sys.state = new_state;
 800fda8:	2380      	movs	r3, #128	; 0x80
 800fdaa:	6023      	str	r3, [r4, #0]
    if (rt_exec & EXEC_CYCLE_COMPLETE) {
 800fdac:	f7ff f8cc 	bl	800ef48 <state_await_hold.part.0>
}
 800fdb0:	e7ed      	b.n	800fd8e <state_await_resume+0x10e>
            sys.step_control.execute_sys_motion = Off;
 800fdb2:	f36f 0382 	bfc	r3, #2, #1
 800fdb6:	72ab      	strb	r3, [r5, #10]
            st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 800fdb8:	f000 fbe4 	bl	8010584 <st_parking_restore_buffer>
 800fdbc:	e7bd      	b.n	800fd3a <state_await_resume+0xba>
                    stateHandler = state_await_restore;
 800fdbe:	4b1e      	ldr	r3, [pc, #120]	; (800fe38 <state_await_resume+0x1b8>)
 800fdc0:	4a21      	ldr	r2, [pc, #132]	; (800fe48 <state_await_resume+0x1c8>)
                    stateHandler(0);
 800fdc2:	2000      	movs	r0, #0
                    stateHandler = state_await_restore;
 800fdc4:	601a      	str	r2, [r3, #0]
                    stateHandler(0);
 800fdc6:	681b      	ldr	r3, [r3, #0]
 800fdc8:	4798      	blx	r3
        if(!(handler_changed || sys.state == STATE_SLEEP)) {
 800fdca:	e7ae      	b.n	800fd2a <state_await_resume+0xaa>
                        gc_state.spindle.rpm = 0.0f;
 800fdcc:	2100      	movs	r1, #0
 800fdce:	4b1f      	ldr	r3, [pc, #124]	; (800fe4c <state_await_resume+0x1cc>)
                        gc_state.modal.spindle.on = gc_state.modal.spindle.ccw = Off;
 800fdd0:	7e9a      	ldrb	r2, [r3, #26]
                        gc_state.spindle.rpm = 0.0f;
 800fdd2:	6499      	str	r1, [r3, #72]	; 0x48
                        gc_state.modal.spindle.on = gc_state.modal.spindle.ccw = Off;
 800fdd4:	f022 0203 	bic.w	r2, r2, #3
 800fdd8:	769a      	strb	r2, [r3, #26]
 800fdda:	e773      	b.n	800fcc4 <state_await_resume+0x44>
                    state_restore_conditions(&restore_condition, restore_spindle_rpm);
 800fddc:	4b1c      	ldr	r3, [pc, #112]	; (800fe50 <state_await_resume+0x1d0>)
        spindle_restore(condition->spindle, rpm);
 800fdde:	4f1d      	ldr	r7, [pc, #116]	; (800fe54 <state_await_resume+0x1d4>)
 800fde0:	6819      	ldr	r1, [r3, #0]
 800fde2:	78b8      	ldrb	r0, [r7, #2]
 800fde4:	f7fe ff88 	bl	800ecf8 <spindle_restore>
        if (gc_state.modal.coolant.value != hal.coolant_get_state().value) {
 800fde8:	4a18      	ldr	r2, [pc, #96]	; (800fe4c <state_await_resume+0x1cc>)
 800fdea:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800fdec:	f892 8019 	ldrb.w	r8, [r2, #25]
 800fdf0:	4798      	blx	r3
 800fdf2:	b2c0      	uxtb	r0, r0
 800fdf4:	4540      	cmp	r0, r8
 800fdf6:	f43f af65 	beq.w	800fcc4 <state_await_resume+0x44>
            coolant_set_state(condition->coolant);
 800fdfa:	78f8      	ldrb	r0, [r7, #3]
 800fdfc:	f7f5 f8d0 	bl	8004fa0 <coolant_set_state>
            delay_sec(SAFETY_DOOR_COOLANT_DELAY, DelayMode_SysSuspend);
 800fe00:	2101      	movs	r1, #1
 800fe02:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800fe06:	f7fa fa7b 	bl	800a300 <delay_sec>
        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 800fe0a:	e75b      	b.n	800fcc4 <state_await_resume+0x44>
                            park.plan_data.feed_rate = settings.parking.rate;
 800fe0c:	4641      	mov	r1, r8
 800fe0e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
                            park.target[settings.parking.axis] = park.retract_waypoint;
 800fe12:	f8d8 3018 	ldr.w	r3, [r8, #24]
                            if(!mc_parking_motion(park.target, &park.plan_data))
 800fe16:	4640      	mov	r0, r8
                            park.plan_data.feed_rate = settings.parking.rate;
 800fe18:	f841 2f20 	str.w	r2, [r1, #32]!
                            park.target[settings.parking.axis] = park.retract_waypoint;
 800fe1c:	f848 3026 	str.w	r3, [r8, r6, lsl #2]
                            if(!mc_parking_motion(park.target, &park.plan_data))
 800fe20:	f7f9 ffb8 	bl	8009d94 <mc_parking_motion>
 800fe24:	2800      	cmp	r0, #0
 800fe26:	d180      	bne.n	800fd2a <state_await_resume+0xaa>
 800fe28:	e77c      	b.n	800fd24 <state_await_resume+0xa4>
 800fe2a:	bf00      	nop
 800fe2c:	20002620 	.word	0x20002620
 800fe30:	20002494 	.word	0x20002494
 800fe34:	200024bc 	.word	0x200024bc
 800fe38:	20000018 	.word	0x20000018
 800fe3c:	0800f181 	.word	0x0800f181
 800fe40:	20001b28 	.word	0x20001b28
 800fe44:	0800fb8d 	.word	0x0800fb8d
 800fe48:	0800fe5d 	.word	0x0800fe5d
 800fe4c:	200023dc 	.word	0x200023dc
 800fe50:	20001b34 	.word	0x20001b34
 800fe54:	20001b30 	.word	0x20001b30
 800fe58:	20001ad4 	.word	0x20001ad4

0800fe5c <state_await_restore>:
{
 800fe5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if(rt_exec == 0) {
 800fe5e:	bb28      	cbnz	r0, 800feac <state_await_restore+0x50>
        restart = true;
 800fe60:	2201      	movs	r2, #1
        if (restore_condition.spindle.on != hal.spindle_get_state().on) {
 800fe62:	4d26      	ldr	r5, [pc, #152]	; (800fefc <state_await_restore+0xa0>)
 800fe64:	4c26      	ldr	r4, [pc, #152]	; (800ff00 <state_await_restore+0xa4>)
 800fe66:	78ae      	ldrb	r6, [r5, #2]
        restart = true;
 800fe68:	4f26      	ldr	r7, [pc, #152]	; (800ff04 <state_await_restore+0xa8>)
        if (restore_condition.spindle.on != hal.spindle_get_state().on) {
 800fe6a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800fe6c:	4016      	ands	r6, r2
        restart = true;
 800fe6e:	703a      	strb	r2, [r7, #0]
        if (restore_condition.spindle.on != hal.spindle_get_state().on) {
 800fe70:	4798      	blx	r3
 800fe72:	f000 0001 	and.w	r0, r0, #1
 800fe76:	42b0      	cmp	r0, r6
 800fe78:	d008      	beq.n	800fe8c <state_await_restore+0x30>
            hal.report.feedback_message(Message_SpindleRestore);
 800fe7a:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 800fe7e:	200a      	movs	r0, #10
 800fe80:	4798      	blx	r3
            spindle_restore(restore_condition.spindle, restore_spindle_rpm);
 800fe82:	4b21      	ldr	r3, [pc, #132]	; (800ff08 <state_await_restore+0xac>)
 800fe84:	78a8      	ldrb	r0, [r5, #2]
 800fe86:	6819      	ldr	r1, [r3, #0]
 800fe88:	f7fe ff36 	bl	800ecf8 <spindle_restore>
        if (restore_condition.coolant.value != hal.coolant_get_state().value) {
 800fe8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800fe8e:	78ee      	ldrb	r6, [r5, #3]
 800fe90:	4798      	blx	r3
 800fe92:	b2c0      	uxtb	r0, r0
 800fe94:	42b0      	cmp	r0, r6
 800fe96:	d112      	bne.n	800febe <state_await_restore+0x62>
        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 800fe98:	2500      	movs	r5, #0
 800fe9a:	4e1c      	ldr	r6, [pc, #112]	; (800ff0c <state_await_restore+0xb0>)
        hal.report.feedback_message(Message_None);
 800fe9c:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 800fea0:	4628      	mov	r0, r5
        sys.override.spindle_stop.value = 0; // Clear spindle stop override states
 800fea2:	7475      	strb	r5, [r6, #17]
        hal.report.feedback_message(Message_None);
 800fea4:	4798      	blx	r3
        if(restart) {
 800fea6:	783b      	ldrb	r3, [r7, #0]
 800fea8:	b993      	cbnz	r3, 800fed0 <state_await_restore+0x74>
}
 800feaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(rt_exec & EXEC_FEED_HOLD) {
 800feac:	0703      	lsls	r3, r0, #28
 800feae:	d5fc      	bpl.n	800feaa <state_await_restore+0x4e>
    	restart = false;
 800feb0:	2000      	movs	r0, #0
 800feb2:	4914      	ldr	r1, [pc, #80]	; (800ff04 <state_await_restore+0xa8>)
    	stateHandler = state_await_resume;
 800feb4:	4b16      	ldr	r3, [pc, #88]	; (800ff10 <state_await_restore+0xb4>)
 800feb6:	4a17      	ldr	r2, [pc, #92]	; (800ff14 <state_await_restore+0xb8>)
    	restart = false;
 800feb8:	7008      	strb	r0, [r1, #0]
    	stateHandler = state_await_resume;
 800feba:	601a      	str	r2, [r3, #0]
}
 800febc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            coolant_set_state(restore_condition.coolant);
 800febe:	78e8      	ldrb	r0, [r5, #3]
 800fec0:	f7f5 f86e 	bl	8004fa0 <coolant_set_state>
            delay_sec(SAFETY_DOOR_COOLANT_DELAY, DelayMode_SysSuspend);
 800fec4:	2101      	movs	r1, #1
 800fec6:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800feca:	f7fa fa19 	bl	800a300 <delay_sec>
 800fece:	e7e3      	b.n	800fe98 <state_await_restore+0x3c>
    if(new_state != sys.state) {
 800fed0:	6833      	ldr	r3, [r6, #0]
 800fed2:	b16b      	cbz	r3, 800fef0 <state_await_restore+0x94>
                sys.state = pending_state = new_state;
 800fed4:	4810      	ldr	r0, [pc, #64]	; (800ff18 <state_await_restore+0xbc>)
                stateHandler = state_idle;
 800fed6:	4a0e      	ldr	r2, [pc, #56]	; (800ff10 <state_await_restore+0xb4>)
 800fed8:	4910      	ldr	r1, [pc, #64]	; (800ff1c <state_await_restore+0xc0>)
        if(hal.state_change_requested)
 800feda:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
                sys.suspend = false;        // Break suspend state.
 800fede:	71b5      	strb	r5, [r6, #6]
                sys.step_control.flags = 0; // Restore step control to normal operation.
 800fee0:	72b5      	strb	r5, [r6, #10]
                sys.parking_state = Parking_DoorClosed;
 800fee2:	82f5      	strh	r5, [r6, #22]
                sys.state = pending_state = new_state;
 800fee4:	6035      	str	r5, [r6, #0]
 800fee6:	6005      	str	r5, [r0, #0]
                stateHandler = state_idle;
 800fee8:	6011      	str	r1, [r2, #0]
        if(hal.state_change_requested)
 800feea:	b10b      	cbz	r3, 800fef0 <state_await_restore+0x94>
            hal.state_change_requested(new_state);
 800feec:	4628      	mov	r0, r5
 800feee:	4798      	blx	r3
}
 800fef0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            set_state(STATE_CYCLE);
 800fef4:	2008      	movs	r0, #8
 800fef6:	f7ff bd7b 	b.w	800f9f0 <set_state>
 800fefa:	bf00      	nop
 800fefc:	20001b30 	.word	0x20001b30
 800ff00:	200024bc 	.word	0x200024bc
 800ff04:	20001b2c 	.word	0x20001b2c
 800ff08:	20001b34 	.word	0x20001b34
 800ff0c:	20002494 	.word	0x20002494
 800ff10:	20000018 	.word	0x20000018
 800ff14:	0800fc81 	.word	0x0800fc81
 800ff18:	20001b28 	.word	0x20001b28
 800ff1c:	0800fb8d 	.word	0x0800fb8d

0800ff20 <state_cycle>:
    if ((rt_exec & EXEC_TOOL_CHANGE))
 800ff20:	0583      	lsls	r3, r0, #22
{
 800ff22:	b570      	push	{r4, r5, r6, lr}
 800ff24:	4604      	mov	r4, r0
    if ((rt_exec & EXEC_TOOL_CHANGE))
 800ff26:	d503      	bpl.n	800ff30 <state_cycle+0x10>
        hal.stream.suspend_read(true); // Block reading from input stream until tool change state is acknowledged
 800ff28:	4b26      	ldr	r3, [pc, #152]	; (800ffc4 <state_cycle+0xa4>)
 800ff2a:	2001      	movs	r0, #1
 800ff2c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800ff2e:	4798      	blx	r3
    if (rt_exec & EXEC_CYCLE_COMPLETE)
 800ff30:	0766      	lsls	r6, r4, #29
 800ff32:	d509      	bpl.n	800ff48 <state_cycle+0x28>
        set_state(gc_state.tool_change ? STATE_TOOL_CHANGE : STATE_IDLE);
 800ff34:	4b24      	ldr	r3, [pc, #144]	; (800ffc8 <state_cycle+0xa8>)
 800ff36:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800ff3a:	2b00      	cmp	r3, #0
 800ff3c:	bf14      	ite	ne
 800ff3e:	f44f 7000 	movne.w	r0, #512	; 0x200
 800ff42:	2000      	moveq	r0, #0
 800ff44:	f7ff fd54 	bl	800f9f0 <set_state>
    if (rt_exec & EXEC_MOTION_CANCEL) {
 800ff48:	0625      	lsls	r5, r4, #24
 800ff4a:	d418      	bmi.n	800ff7e <state_cycle+0x5e>
    if ((rt_exec & EXEC_FEED_HOLD))
 800ff4c:	0720      	lsls	r0, r4, #28
 800ff4e:	d400      	bmi.n	800ff52 <state_cycle+0x32>
}
 800ff50:	bd70      	pop	{r4, r5, r6, pc}
    if(new_state != sys.state) {
 800ff52:	4c1e      	ldr	r4, [pc, #120]	; (800ffcc <state_cycle+0xac>)
 800ff54:	6823      	ldr	r3, [r4, #0]
 800ff56:	2b10      	cmp	r3, #16
 800ff58:	d0fa      	beq.n	800ff50 <state_cycle+0x30>
                if(sys.override.control.sync && sys.override.control.feed_hold_disable)
 800ff5a:	7ca2      	ldrb	r2, [r4, #18]
 800ff5c:	f002 0182 	and.w	r1, r2, #130	; 0x82
 800ff60:	2982      	cmp	r1, #130	; 0x82
 800ff62:	d019      	beq.n	800ff98 <state_cycle+0x78>
                if(!((sys.state & STATE_JOG) || sys.override.control.feed_hold_disable)) {
 800ff64:	0699      	lsls	r1, r3, #26
 800ff66:	d401      	bmi.n	800ff6c <state_cycle+0x4c>
 800ff68:	0793      	lsls	r3, r2, #30
 800ff6a:	d51a      	bpl.n	800ffa2 <state_cycle+0x82>
        if(hal.state_change_requested)
 800ff6c:	4b15      	ldr	r3, [pc, #84]	; (800ffc4 <state_cycle+0xa4>)
 800ff6e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 800ff72:	2b00      	cmp	r3, #0
 800ff74:	d0ec      	beq.n	800ff50 <state_cycle+0x30>
}
 800ff76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            hal.state_change_requested(new_state);
 800ff7a:	2010      	movs	r0, #16
 800ff7c:	4718      	bx	r3
        sys.suspend = true;
 800ff7e:	2501      	movs	r5, #1
        st_update_plan_block_parameters();  // Notify stepper module to recompute for hold deceleration.
 800ff80:	f000 faca 	bl	8010518 <st_update_plan_block_parameters>
        sys.suspend = true;
 800ff84:	4b11      	ldr	r3, [pc, #68]	; (800ffcc <state_cycle+0xac>)
        stateHandler = state_await_motion_cancel;
 800ff86:	4912      	ldr	r1, [pc, #72]	; (800ffd0 <state_cycle+0xb0>)
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 800ff88:	7a9a      	ldrb	r2, [r3, #10]
        stateHandler = state_await_motion_cancel;
 800ff8a:	4812      	ldr	r0, [pc, #72]	; (800ffd4 <state_cycle+0xb4>)
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 800ff8c:	f042 0202 	orr.w	r2, r2, #2
        sys.suspend = true;
 800ff90:	719d      	strb	r5, [r3, #6]
        sys.step_control.execute_hold = On; // Initiate suspend state with active flag.
 800ff92:	729a      	strb	r2, [r3, #10]
        stateHandler = state_await_motion_cancel;
 800ff94:	6008      	str	r0, [r1, #0]
 800ff96:	e7d9      	b.n	800ff4c <state_cycle+0x2c>
                    sys.flags.feed_hold_pending = On;
 800ff98:	7a61      	ldrb	r1, [r4, #9]
 800ff9a:	f041 0120 	orr.w	r1, r1, #32
 800ff9e:	7261      	strb	r1, [r4, #9]
 800ffa0:	e7e0      	b.n	800ff64 <state_cycle+0x44>
                    if(!initiate_hold(new_state)) {
 800ffa2:	2010      	movs	r0, #16
 800ffa4:	f7ff fb76 	bl	800f694 <initiate_hold>
 800ffa8:	b920      	cbnz	r0, 800ffb4 <state_cycle+0x94>
                        sys.holding_state = Hold_Complete;
 800ffaa:	2101      	movs	r1, #1
                        stateHandler = state_await_resume;
 800ffac:	4b08      	ldr	r3, [pc, #32]	; (800ffd0 <state_cycle+0xb0>)
 800ffae:	4a0a      	ldr	r2, [pc, #40]	; (800ffd8 <state_cycle+0xb8>)
                        sys.holding_state = Hold_Complete;
 800ffb0:	75e1      	strb	r1, [r4, #23]
                        stateHandler = state_await_resume;
 800ffb2:	601a      	str	r2, [r3, #0]
                    sys.state = new_state;
 800ffb4:	2210      	movs	r2, #16
                    sys.flags.feed_hold_pending = Off;
 800ffb6:	7a63      	ldrb	r3, [r4, #9]
                    sys.state = new_state;
 800ffb8:	6022      	str	r2, [r4, #0]
                    sys.flags.feed_hold_pending = Off;
 800ffba:	f36f 1345 	bfc	r3, #5, #1
 800ffbe:	7263      	strb	r3, [r4, #9]
 800ffc0:	e7d4      	b.n	800ff6c <state_cycle+0x4c>
 800ffc2:	bf00      	nop
 800ffc4:	200024bc 	.word	0x200024bc
 800ffc8:	200023dc 	.word	0x200023dc
 800ffcc:	20002494 	.word	0x20002494
 800ffd0:	20000018 	.word	0x20000018
 800ffd4:	0800f791 	.word	0x0800f791
 800ffd8:	0800fc81 	.word	0x0800fc81

0800ffdc <state_suspend_manager>:
    if(stateHandler != state_await_resume || !gc_state.modal.spindle.on)
 800ffdc:	4a24      	ldr	r2, [pc, #144]	; (8010070 <state_suspend_manager+0x94>)
{
 800ffde:	b538      	push	{r3, r4, r5, lr}
    if(stateHandler != state_await_resume || !gc_state.modal.spindle.on)
 800ffe0:	6812      	ldr	r2, [r2, #0]
 800ffe2:	4b24      	ldr	r3, [pc, #144]	; (8010074 <state_suspend_manager+0x98>)
 800ffe4:	429a      	cmp	r2, r3
 800ffe6:	d000      	beq.n	800ffea <state_suspend_manager+0xe>
}
 800ffe8:	bd38      	pop	{r3, r4, r5, pc}
    if(stateHandler != state_await_resume || !gc_state.modal.spindle.on)
 800ffea:	4b23      	ldr	r3, [pc, #140]	; (8010078 <state_suspend_manager+0x9c>)
 800ffec:	7e9b      	ldrb	r3, [r3, #26]
 800ffee:	07da      	lsls	r2, r3, #31
 800fff0:	d5fa      	bpl.n	800ffe8 <state_suspend_manager+0xc>
    if (sys.override.spindle_stop.value) {
 800fff2:	4c22      	ldr	r4, [pc, #136]	; (801007c <state_suspend_manager+0xa0>)
 800fff4:	7c65      	ldrb	r5, [r4, #17]
 800fff6:	b1a5      	cbz	r5, 8010022 <state_suspend_manager+0x46>
        if (sys.override.spindle_stop.initiate) {
 800fff8:	07ab      	lsls	r3, r5, #30
 800fffa:	d425      	bmi.n	8010048 <state_suspend_manager+0x6c>
        if (sys.override.spindle_stop.restore) {
 800fffc:	0768      	lsls	r0, r5, #29
 800fffe:	d5f3      	bpl.n	800ffe8 <state_suspend_manager+0xc>
            hal.report.feedback_message(Message_SpindleRestore);
 8010000:	4b1f      	ldr	r3, [pc, #124]	; (8010080 <state_suspend_manager+0xa4>)
 8010002:	200a      	movs	r0, #10
 8010004:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 8010008:	4798      	blx	r3
            if (settings.flags.laser_mode) // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
 801000a:	4b1e      	ldr	r3, [pc, #120]	; (8010084 <state_suspend_manager+0xa8>)
 801000c:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 8010010:	0799      	lsls	r1, r3, #30
 8010012:	d525      	bpl.n	8010060 <state_suspend_manager+0x84>
                sys.step_control.update_spindle_rpm = On;
 8010014:	7aa3      	ldrb	r3, [r4, #10]
 8010016:	f043 0308 	orr.w	r3, r3, #8
 801001a:	72a3      	strb	r3, [r4, #10]
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801001c:	2300      	movs	r3, #0
 801001e:	7463      	strb	r3, [r4, #17]
}
 8010020:	bd38      	pop	{r3, r4, r5, pc}
    } else if (sys.step_control.update_spindle_rpm && hal.spindle_get_state().on) {
 8010022:	7aa3      	ldrb	r3, [r4, #10]
 8010024:	071a      	lsls	r2, r3, #28
 8010026:	d5df      	bpl.n	800ffe8 <state_suspend_manager+0xc>
 8010028:	4b15      	ldr	r3, [pc, #84]	; (8010080 <state_suspend_manager+0xa4>)
 801002a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801002c:	4798      	blx	r3
 801002e:	07c3      	lsls	r3, r0, #31
 8010030:	d5da      	bpl.n	800ffe8 <state_suspend_manager+0xc>
        spindle_set_state(restore_condition.spindle, restore_spindle_rpm);
 8010032:	4b15      	ldr	r3, [pc, #84]	; (8010088 <state_suspend_manager+0xac>)
 8010034:	4a15      	ldr	r2, [pc, #84]	; (801008c <state_suspend_manager+0xb0>)
 8010036:	7898      	ldrb	r0, [r3, #2]
 8010038:	6811      	ldr	r1, [r2, #0]
 801003a:	f7fe fd91 	bl	800eb60 <spindle_set_state>
        sys.step_control.update_spindle_rpm = Off;
 801003e:	7aa3      	ldrb	r3, [r4, #10]
 8010040:	f365 03c3 	bfi	r3, r5, #3, #1
 8010044:	72a3      	strb	r3, [r4, #10]
}
 8010046:	bd38      	pop	{r3, r4, r5, pc}
            sys.override.spindle_stop.value = 0; // Clear stop override state
 8010048:	2300      	movs	r3, #0
            spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 801004a:	2100      	movs	r1, #0
 801004c:	4618      	mov	r0, r3
            sys.override.spindle_stop.value = 0; // Clear stop override state
 801004e:	7463      	strb	r3, [r4, #17]
            spindle_set_state((spindle_state_t){0}, 0.0f); // De-energize
 8010050:	f7fe fd86 	bl	800eb60 <spindle_set_state>
            sys.override.spindle_stop.enabled = On; // Set stop override state to enabled, if de-energized.
 8010054:	7c63      	ldrb	r3, [r4, #17]
 8010056:	f043 0301 	orr.w	r3, r3, #1
 801005a:	461d      	mov	r5, r3
 801005c:	7463      	strb	r3, [r4, #17]
 801005e:	e7cd      	b.n	800fffc <state_suspend_manager+0x20>
                spindle_set_state(restore_condition.spindle, restore_spindle_rpm);
 8010060:	4a0a      	ldr	r2, [pc, #40]	; (801008c <state_suspend_manager+0xb0>)
 8010062:	4b09      	ldr	r3, [pc, #36]	; (8010088 <state_suspend_manager+0xac>)
 8010064:	6811      	ldr	r1, [r2, #0]
 8010066:	7898      	ldrb	r0, [r3, #2]
 8010068:	f7fe fd7a 	bl	800eb60 <spindle_set_state>
 801006c:	e7d6      	b.n	801001c <state_suspend_manager+0x40>
 801006e:	bf00      	nop
 8010070:	20000018 	.word	0x20000018
 8010074:	0800fc81 	.word	0x0800fc81
 8010078:	200023dc 	.word	0x200023dc
 801007c:	20002494 	.word	0x20002494
 8010080:	200024bc 	.word	0x200024bc
 8010084:	20002620 	.word	0x20002620
 8010088:	20001b30 	.word	0x20001b30
 801008c:	20001b34 	.word	0x20001b34

08010090 <st_deenergize>:
  are shown and defined in the above illustration.
*/

// Callback from delay to deenergize steppers after movement, might been cancelled
void st_deenergize ()
{
 8010090:	b510      	push	{r4, lr}
    if(sys.steppers_deenergize) {
 8010092:	4c06      	ldr	r4, [pc, #24]	; (80100ac <st_deenergize+0x1c>)
 8010094:	79e3      	ldrb	r3, [r4, #7]
 8010096:	b13b      	cbz	r3, 80100a8 <st_deenergize+0x18>
        hal.stepper_enable(settings.steppers.deenergize);
 8010098:	4a05      	ldr	r2, [pc, #20]	; (80100b0 <st_deenergize+0x20>)
 801009a:	4b06      	ldr	r3, [pc, #24]	; (80100b4 <st_deenergize+0x24>)
 801009c:	f892 00b7 	ldrb.w	r0, [r2, #183]	; 0xb7
 80100a0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80100a2:	4798      	blx	r3
        sys.steppers_deenergize = false;
 80100a4:	2300      	movs	r3, #0
 80100a6:	71e3      	strb	r3, [r4, #7]
    }
}
 80100a8:	bd10      	pop	{r4, pc}
 80100aa:	bf00      	nop
 80100ac:	20002494 	.word	0x20002494
 80100b0:	20002620 	.word	0x20002620
 80100b4:	200024bc 	.word	0x200024bc

080100b8 <st_wake_up>:
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up ()
{
    // Initialize stepper data to ensure first ISR call does not step and
    // cancel any pending steppers deenergize
    st.exec_block = NULL;
 80100b8:	2300      	movs	r3, #0
 80100ba:	4803      	ldr	r0, [pc, #12]	; (80100c8 <st_wake_up+0x10>)
    sys.steppers_deenergize = false;
 80100bc:	4903      	ldr	r1, [pc, #12]	; (80100cc <st_wake_up+0x14>)

    hal.stepper_wake_up();
 80100be:	4a04      	ldr	r2, [pc, #16]	; (80100d0 <st_wake_up+0x18>)
    st.exec_block = NULL;
 80100c0:	6283      	str	r3, [r0, #40]	; 0x28
    sys.steppers_deenergize = false;
 80100c2:	71cb      	strb	r3, [r1, #7]
    hal.stepper_wake_up();
 80100c4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80100c6:	4718      	bx	r3
 80100c8:	20001ce8 	.word	0x20001ce8
 80100cc:	20002494 	.word	0x20002494
 80100d0:	200024bc 	.word	0x200024bc

080100d4 <st_go_idle>:
}


// Stepper shutdown
ISR_CODE void st_go_idle ()
{
 80100d4:	b510      	push	{r4, lr}
    // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.

    hal.stepper_go_idle(false);
 80100d6:	4c11      	ldr	r4, [pc, #68]	; (801011c <st_go_idle+0x48>)
 80100d8:	2000      	movs	r0, #0
 80100da:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80100dc:	4798      	blx	r3

    // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
    if (((settings.steppers.idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 80100de:	4a10      	ldr	r2, [pc, #64]	; (8010120 <st_go_idle+0x4c>)
 80100e0:	f892 00ba 	ldrb.w	r0, [r2, #186]	; 0xba
 80100e4:	28ff      	cmp	r0, #255	; 0xff
 80100e6:	d00a      	beq.n	80100fe <st_go_idle+0x2a>
 80100e8:	4b0e      	ldr	r3, [pc, #56]	; (8010124 <st_go_idle+0x50>)
 80100ea:	6819      	ldr	r1, [r3, #0]
 80100ec:	2904      	cmp	r1, #4
 80100ee:	d00e      	beq.n	801010e <st_go_idle+0x3a>
        // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
        // stop and not drift from residual inertial forces at the end of the last movement.
        sys.steppers_deenergize = true;
 80100f0:	2101      	movs	r1, #1
        hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 80100f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        sys.steppers_deenergize = true;
 80100f4:	71d9      	strb	r1, [r3, #7]
    } else
        hal.stepper_enable(settings.steppers.deenergize);
}
 80100f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 80100fa:	490b      	ldr	r1, [pc, #44]	; (8010128 <st_go_idle+0x54>)
 80100fc:	4710      	bx	r2
    if (((settings.steppers.idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 80100fe:	4b0b      	ldr	r3, [pc, #44]	; (801012c <st_go_idle+0x58>)
 8010100:	681b      	ldr	r3, [r3, #0]
 8010102:	2b00      	cmp	r3, #0
 8010104:	d1f0      	bne.n	80100e8 <st_go_idle+0x14>
 8010106:	4b07      	ldr	r3, [pc, #28]	; (8010124 <st_go_idle+0x50>)
 8010108:	6819      	ldr	r1, [r3, #0]
 801010a:	2980      	cmp	r1, #128	; 0x80
 801010c:	d0f0      	beq.n	80100f0 <st_go_idle+0x1c>
        hal.stepper_enable(settings.steppers.deenergize);
 801010e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8010110:	f892 00b7 	ldrb.w	r0, [r2, #183]	; 0xb7
}
 8010114:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        hal.stepper_enable(settings.steppers.deenergize);
 8010118:	4718      	bx	r3
 801011a:	bf00      	nop
 801011c:	200024bc 	.word	0x200024bc
 8010120:	20002620 	.word	0x20002620
 8010124:	20002494 	.word	0x20002494
 8010128:	08010091 	.word	0x08010091
 801012c:	2000261c 	.word	0x2000261c

08010130 <stepper_driver_interrupt_handler>:
   which for Grbl must be less than 33.3usec (@30kHz ISR rate). Oscilloscope measured time in
   ISR is 5usec typical and 25usec maximum, well below requirement.
   NOTE: This ISR expects at least one step to be executed per segment.
*/
ISR_CODE void stepper_driver_interrupt_handler (void)
{
 8010130:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#ifdef ENABLE_BACKLASH_COMPENSATION
    static bool backlash_motion;
#endif

    // Start a step pulse when there is a block to execute.
    if(st.exec_block)
 8010134:	4c8f      	ldr	r4, [pc, #572]	; (8010374 <stepper_driver_interrupt_handler+0x244>)
 8010136:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010138:	b11b      	cbz	r3, 8010142 <stepper_driver_interrupt_handler+0x12>
        hal.stepper_pulse_start(&st);
 801013a:	4b8f      	ldr	r3, [pc, #572]	; (8010378 <stepper_driver_interrupt_handler+0x248>)
 801013c:	4620      	mov	r0, r4
 801013e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010140:	4798      	blx	r3

    // If there is no step segment, attempt to pop one from the stepper buffer
    if (st.exec_segment == NULL) {
 8010142:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8010144:	2800      	cmp	r0, #0
 8010146:	d077      	beq.n	8010238 <stepper_driver_interrupt_handler+0x108>
 8010148:	4e8c      	ldr	r6, [pc, #560]	; (801037c <stepper_driver_interrupt_handler+0x24c>)
    }

    // Check probing state.
    // Monitors probe pin state and records the system position when detected.
    // NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
    if (sys_probe_state == Probe_Active && hal.probe_get_state()) {
 801014a:	4d8d      	ldr	r5, [pc, #564]	; (8010380 <stepper_driver_interrupt_handler+0x250>)
 801014c:	782b      	ldrb	r3, [r5, #0]
 801014e:	2b01      	cmp	r3, #1
 8010150:	d05c      	beq.n	801020c <stepper_driver_interrupt_handler+0xdc>

    register axes_signals_t step_outbits = (axes_signals_t){0};

    // Execute step displacement profile by Bresenham line algorithm

    st.counter_x += st.steps[X_AXIS];
 8010152:	6821      	ldr	r1, [r4, #0]
 8010154:	6923      	ldr	r3, [r4, #16]
    if (st.counter_x > st.step_event_count) {
 8010156:	6a60      	ldr	r0, [r4, #36]	; 0x24
    st.counter_x += st.steps[X_AXIS];
 8010158:	4419      	add	r1, r3
    if (st.counter_x > st.step_event_count) {
 801015a:	4281      	cmp	r1, r0
    register axes_signals_t step_outbits = (axes_signals_t){0};
 801015c:	f04f 0300 	mov.w	r3, #0
    st.counter_x += st.steps[X_AXIS];
 8010160:	6021      	str	r1, [r4, #0]
    if (st.counter_x > st.step_event_count) {
 8010162:	d90e      	bls.n	8010182 <stepper_driver_interrupt_handler+0x52>
        step_outbits.x = On;
        st.counter_x -= st.step_event_count;
#ifdef ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys_position[X_AXIS] = sys_position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 8010164:	7ba3      	ldrb	r3, [r4, #14]
 8010166:	4d87      	ldr	r5, [pc, #540]	; (8010384 <stepper_driver_interrupt_handler+0x254>)
 8010168:	f013 0f01 	tst.w	r3, #1
 801016c:	bf14      	ite	ne
 801016e:	f04f 37ff 	movne.w	r7, #4294967295	; 0xffffffff
 8010172:	2701      	moveq	r7, #1
        step_outbits.x = On;
 8010174:	f04f 0301 	mov.w	r3, #1
            sys_position[X_AXIS] = sys_position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 8010178:	682a      	ldr	r2, [r5, #0]
        st.counter_x -= st.step_event_count;
 801017a:	1a09      	subs	r1, r1, r0
            sys_position[X_AXIS] = sys_position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 801017c:	443a      	add	r2, r7
        st.counter_x -= st.step_event_count;
 801017e:	6021      	str	r1, [r4, #0]
            sys_position[X_AXIS] = sys_position[X_AXIS] + (st.dir_outbits.x ? -1 : 1);
 8010180:	602a      	str	r2, [r5, #0]
    }

    st.counter_y += st.steps[Y_AXIS];
 8010182:	6861      	ldr	r1, [r4, #4]
 8010184:	6962      	ldr	r2, [r4, #20]
 8010186:	4411      	add	r1, r2
    if (st.counter_y > st.step_event_count) {
 8010188:	4288      	cmp	r0, r1
    st.counter_y += st.steps[Y_AXIS];
 801018a:	6061      	str	r1, [r4, #4]
    if (st.counter_y > st.step_event_count) {
 801018c:	d20e      	bcs.n	80101ac <stepper_driver_interrupt_handler+0x7c>
        step_outbits.y = On;
        st.counter_y -= st.step_event_count;
#ifdef ENABLE_BACKLASH_COMPENSATION
        if(!backlash_motion)
#endif
            sys_position[Y_AXIS] = sys_position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 801018e:	7ba2      	ldrb	r2, [r4, #14]
 8010190:	4d7c      	ldr	r5, [pc, #496]	; (8010384 <stepper_driver_interrupt_handler+0x254>)
 8010192:	f012 0f02 	tst.w	r2, #2
 8010196:	bf14      	ite	ne
 8010198:	f04f 37ff 	movne.w	r7, #4294967295	; 0xffffffff
 801019c:	2701      	moveq	r7, #1
 801019e:	686a      	ldr	r2, [r5, #4]
        st.counter_y -= st.step_event_count;
 80101a0:	1a09      	subs	r1, r1, r0
            sys_position[Y_AXIS] = sys_position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 80101a2:	443a      	add	r2, r7
        st.counter_y -= st.step_event_count;
 80101a4:	6061      	str	r1, [r4, #4]
        step_outbits.y = On;
 80101a6:	f043 0302 	orr.w	r3, r3, #2
            sys_position[Y_AXIS] = sys_position[Y_AXIS] + (st.dir_outbits.y ? -1 : 1);
 80101aa:	606a      	str	r2, [r5, #4]
    }

    st.counter_z += st.steps[Z_AXIS];
 80101ac:	68a2      	ldr	r2, [r4, #8]
 80101ae:	69a1      	ldr	r1, [r4, #24]
 80101b0:	440a      	add	r2, r1
    if (st.counter_z > st.step_event_count) {
 80101b2:	4290      	cmp	r0, r2
    st.counter_z += st.steps[Z_AXIS];
 80101b4:	60a2      	str	r2, [r4, #8]
    if (st.counter_z > st.step_event_count) {
 80101b6:	d319      	bcc.n	80101ec <stepper_driver_interrupt_handler+0xbc>
  #endif

    st.step_outbits.value = step_outbits.value;

    // During a homing cycle, lock out and prevent desired axes from moving.
    if (sys.state == STATE_HOMING)
 80101b8:	6832      	ldr	r2, [r6, #0]
    st.step_outbits.value = step_outbits.value;
 80101ba:	7363      	strb	r3, [r4, #13]
    if (sys.state == STATE_HOMING)
 80101bc:	2a04      	cmp	r2, #4
    st.step_outbits.value = step_outbits.value;
 80101be:	b2db      	uxtb	r3, r3
    if (sys.state == STATE_HOMING)
 80101c0:	d102      	bne.n	80101c8 <stepper_driver_interrupt_handler+0x98>
        st.step_outbits.value &= sys.homing_axis_lock.mask;
 80101c2:	7af2      	ldrb	r2, [r6, #11]
 80101c4:	4013      	ands	r3, r2
 80101c6:	7363      	strb	r3, [r4, #13]

    if (st.step_count == 0 || --st.step_count == 0) {
 80101c8:	6a23      	ldr	r3, [r4, #32]
 80101ca:	b953      	cbnz	r3, 80101e2 <stepper_driver_interrupt_handler+0xb2>
        // Segment is complete. Discard current segment and advance segment indexing.
        st.exec_segment = NULL;
 80101cc:	2300      	movs	r3, #0
        segment_buffer_tail = segment_buffer_tail == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_buffer_tail + 1;
 80101ce:	4a6e      	ldr	r2, [pc, #440]	; (8010388 <stepper_driver_interrupt_handler+0x258>)
        st.exec_segment = NULL;
 80101d0:	62e3      	str	r3, [r4, #44]	; 0x2c
        segment_buffer_tail = segment_buffer_tail == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_buffer_tail + 1;
 80101d2:	6811      	ldr	r1, [r2, #0]
 80101d4:	2909      	cmp	r1, #9
 80101d6:	d001      	beq.n	80101dc <stepper_driver_interrupt_handler+0xac>
 80101d8:	6813      	ldr	r3, [r2, #0]
 80101da:	3301      	adds	r3, #1
 80101dc:	6013      	str	r3, [r2, #0]
    }
}
 80101de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (st.step_count == 0 || --st.step_count == 0) {
 80101e2:	3b01      	subs	r3, #1
 80101e4:	6223      	str	r3, [r4, #32]
 80101e6:	2b00      	cmp	r3, #0
 80101e8:	d0f0      	beq.n	80101cc <stepper_driver_interrupt_handler+0x9c>
 80101ea:	e7f8      	b.n	80101de <stepper_driver_interrupt_handler+0xae>
            sys_position[Z_AXIS] = sys_position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 80101ec:	7ba1      	ldrb	r1, [r4, #14]
 80101ee:	4d65      	ldr	r5, [pc, #404]	; (8010384 <stepper_driver_interrupt_handler+0x254>)
 80101f0:	f011 0f04 	tst.w	r1, #4
 80101f4:	bf14      	ite	ne
 80101f6:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80101fa:	2101      	moveq	r1, #1
        st.counter_z -= st.step_event_count;
 80101fc:	1a12      	subs	r2, r2, r0
 80101fe:	60a2      	str	r2, [r4, #8]
            sys_position[Z_AXIS] = sys_position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 8010200:	68aa      	ldr	r2, [r5, #8]
        step_outbits.z = On;
 8010202:	f043 0304 	orr.w	r3, r3, #4
            sys_position[Z_AXIS] = sys_position[Z_AXIS] + (st.dir_outbits.z ? -1 : 1);
 8010206:	440a      	add	r2, r1
 8010208:	60aa      	str	r2, [r5, #8]
 801020a:	e7d5      	b.n	80101b8 <stepper_driver_interrupt_handler+0x88>
    if (sys_probe_state == Probe_Active && hal.probe_get_state()) {
 801020c:	4b5a      	ldr	r3, [pc, #360]	; (8010378 <stepper_driver_interrupt_handler+0x248>)
 801020e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8010212:	4798      	blx	r3
 8010214:	2800      	cmp	r0, #0
 8010216:	d09c      	beq.n	8010152 <stepper_driver_interrupt_handler+0x22>
        sys_probe_state = Probe_Off;
 8010218:	2300      	movs	r3, #0
        bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 801021a:	f8df c184 	ldr.w	ip, [pc, #388]	; 80103a0 <stepper_driver_interrupt_handler+0x270>
        sys_probe_state = Probe_Off;
 801021e:	702b      	strb	r3, [r5, #0]
        bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 8010220:	f8dc 3000 	ldr.w	r3, [ip]
        memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 8010224:	4a57      	ldr	r2, [pc, #348]	; (8010384 <stepper_driver_interrupt_handler+0x254>)
 8010226:	4f59      	ldr	r7, [pc, #356]	; (801038c <stepper_driver_interrupt_handler+0x25c>)
        bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 8010228:	f043 0380 	orr.w	r3, r3, #128	; 0x80
        memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 801022c:	ca07      	ldmia	r2, {r0, r1, r2}
        bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 801022e:	f8cc 3000 	str.w	r3, [ip]
        memcpy(sys_probe_position, sys_position, sizeof(sys_position));
 8010232:	e887 0007 	stmia.w	r7, {r0, r1, r2}
        bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
 8010236:	e78c      	b.n	8010152 <stepper_driver_interrupt_handler+0x22>
        if (segment_buffer_head != segment_buffer_tail) {
 8010238:	4b53      	ldr	r3, [pc, #332]	; (8010388 <stepper_driver_interrupt_handler+0x258>)
 801023a:	4955      	ldr	r1, [pc, #340]	; (8010390 <stepper_driver_interrupt_handler+0x260>)
 801023c:	681a      	ldr	r2, [r3, #0]
 801023e:	6809      	ldr	r1, [r1, #0]
 8010240:	4291      	cmp	r1, r2
 8010242:	d066      	beq.n	8010312 <stepper_driver_interrupt_handler+0x1e2>
            st.exec_segment = &segment_buffer[segment_buffer_tail];
 8010244:	681a      	ldr	r2, [r3, #0]
 8010246:	4b53      	ldr	r3, [pc, #332]	; (8010394 <stepper_driver_interrupt_handler+0x264>)
            hal.stepper_cycles_per_tick(st.exec_segment->cycles_per_tick);
 8010248:	4f4b      	ldr	r7, [pc, #300]	; (8010378 <stepper_driver_interrupt_handler+0x248>)
            st.exec_segment = &segment_buffer[segment_buffer_tail];
 801024a:	eb03 1342 	add.w	r3, r3, r2, lsl #5
            hal.stepper_cycles_per_tick(st.exec_segment->cycles_per_tick);
 801024e:	6898      	ldr	r0, [r3, #8]
            st.exec_segment = &segment_buffer[segment_buffer_tail];
 8010250:	62e3      	str	r3, [r4, #44]	; 0x2c
            hal.stepper_cycles_per_tick(st.exec_segment->cycles_per_tick);
 8010252:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010254:	4798      	blx	r3
            if (st.exec_block != st.exec_segment->exec_block) {
 8010256:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
 801025a:	6853      	ldr	r3, [r2, #4]
            st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 801025c:	6910      	ldr	r0, [r2, #16]
            if (st.exec_block != st.exec_segment->exec_block) {
 801025e:	4299      	cmp	r1, r3
            st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
 8010260:	6220      	str	r0, [r4, #32]
            if (st.exec_block != st.exec_segment->exec_block) {
 8010262:	d034      	beq.n	80102ce <stepper_driver_interrupt_handler+0x19e>
                st.new_block = true;
 8010264:	2201      	movs	r2, #1
 8010266:	7322      	strb	r2, [r4, #12]
                if(st.exec_block->overrides.sync)
 8010268:	f993 2019 	ldrsb.w	r2, [r3, #25]
                st.dir_outbits = st.exec_block->direction_bits;
 801026c:	7e19      	ldrb	r1, [r3, #24]
                if(st.exec_block->overrides.sync)
 801026e:	2a00      	cmp	r2, #0
                st.step_event_count = st.exec_block->step_event_count;
 8010270:	6958      	ldr	r0, [r3, #20]
                    sys.override.control = st.exec_block->overrides;
 8010272:	4e42      	ldr	r6, [pc, #264]	; (801037c <stepper_driver_interrupt_handler+0x24c>)
 8010274:	bfb8      	it	lt
 8010276:	7e5a      	ldrblt	r2, [r3, #25]
                while(st.exec_block->output_commands) {
 8010278:	6add      	ldr	r5, [r3, #44]	; 0x2c
                st.exec_block = st.exec_segment->exec_block;
 801027a:	62a3      	str	r3, [r4, #40]	; 0x28
                st.step_event_count = st.exec_block->step_event_count;
 801027c:	6260      	str	r0, [r4, #36]	; 0x24
                st.dir_outbits = st.exec_block->direction_bits;
 801027e:	73a1      	strb	r1, [r4, #14]
                    sys.override.control = st.exec_block->overrides;
 8010280:	bfb8      	it	lt
 8010282:	74b2      	strblt	r2, [r6, #18]
                while(st.exec_block->output_commands) {
 8010284:	2d00      	cmp	r5, #0
 8010286:	d036      	beq.n	80102f6 <stepper_driver_interrupt_handler+0x1c6>
                        hal.port.digital_out(cmd->port, cmd->value != 0.0f);
 8010288:	f04f 0800 	mov.w	r8, #0
 801028c:	e013      	b.n	80102b6 <stepper_driver_interrupt_handler+0x186>
 801028e:	f7f0 fa2d 	bl	80006ec <__aeabi_i2f>
 8010292:	4641      	mov	r1, r8
 8010294:	f7f0 fc12 	bl	8000abc <__aeabi_fcmpeq>
 8010298:	fab0 f180 	clz	r1, r0
 801029c:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 80102a0:	7868      	ldrb	r0, [r5, #1]
 80102a2:	0949      	lsrs	r1, r1, #5
 80102a4:	4798      	blx	r3
                    free(st.exec_block->output_commands);
 80102a6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
                    cmd = cmd->next;
 80102a8:	68ad      	ldr	r5, [r5, #8]
                    free(st.exec_block->output_commands);
 80102aa:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80102ac:	f001 fcc6 	bl	8011c3c <free>
                    st.exec_block->output_commands = cmd;
 80102b0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80102b2:	62dd      	str	r5, [r3, #44]	; 0x2c
                while(st.exec_block->output_commands) {
 80102b4:	b1fd      	cbz	r5, 80102f6 <stepper_driver_interrupt_handler+0x1c6>
                    if(cmd->is_digital)
 80102b6:	782b      	ldrb	r3, [r5, #0]
                        hal.port.digital_out(cmd->port, cmd->value != 0.0f);
 80102b8:	6868      	ldr	r0, [r5, #4]
                    if(cmd->is_digital)
 80102ba:	2b00      	cmp	r3, #0
 80102bc:	d1e7      	bne.n	801028e <stepper_driver_interrupt_handler+0x15e>
                        hal.port.analog_out(cmd->port, cmd->value);
 80102be:	f7f0 fa15 	bl	80006ec <__aeabi_i2f>
 80102c2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80102c6:	4601      	mov	r1, r0
 80102c8:	7868      	ldrb	r0, [r5, #1]
 80102ca:	4798      	blx	r3
 80102cc:	e7eb      	b.n	80102a6 <stepper_driver_interrupt_handler+0x176>
 80102ce:	4e2b      	ldr	r6, [pc, #172]	; (801037c <stepper_driver_interrupt_handler+0x24c>)
            st.amass_level = st.exec_segment->amass_level;
 80102d0:	69d1      	ldr	r1, [r2, #28]
            st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.amass_level;
 80102d2:	e9d3 5002 	ldrd	r5, r0, [r3, #8]
            st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.amass_level;
 80102d6:	691b      	ldr	r3, [r3, #16]
            st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.amass_level;
 80102d8:	40cd      	lsrs	r5, r1
            st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.amass_level;
 80102da:	40c8      	lsrs	r0, r1
            st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.amass_level;
 80102dc:	40cb      	lsrs	r3, r1
            st.amass_level = st.exec_segment->amass_level;
 80102de:	61e1      	str	r1, [r4, #28]
            if(st.exec_segment->update_rpm) {
 80102e0:	7e11      	ldrb	r1, [r2, #24]
            st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.amass_level;
 80102e2:	e9c4 5004 	strd	r5, r0, [r4, #16]
            st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.amass_level;
 80102e6:	61a3      	str	r3, [r4, #24]
            if(st.exec_segment->update_rpm) {
 80102e8:	2900      	cmp	r1, #0
 80102ea:	f43f af2e 	beq.w	801014a <stepper_driver_interrupt_handler+0x1a>
                hal.spindle_update_pwm(st.exec_segment->spindle_pwm);
 80102ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80102f0:	6950      	ldr	r0, [r2, #20]
 80102f2:	4798      	blx	r3
 80102f4:	e729      	b.n	801014a <stepper_driver_interrupt_handler+0x1a>
                if(st.exec_block->message) {
 80102f6:	6a98      	ldr	r0, [r3, #40]	; 0x28
 80102f8:	b120      	cbz	r0, 8010304 <stepper_driver_interrupt_handler+0x1d4>
                    protocol_message(st.exec_block->message);
 80102fa:	f7fa ff21 	bl	800b140 <protocol_message>
                    st.exec_block->message = NULL;
 80102fe:	2200      	movs	r2, #0
 8010300:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010302:	629a      	str	r2, [r3, #40]	; 0x28
                  = st.step_event_count >> 1;
 8010304:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8010306:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8010308:	0849      	lsrs	r1, r1, #1
                st.counter_x = st.counter_y = st.counter_z
 801030a:	e9c4 1101 	strd	r1, r1, [r4, #4]
 801030e:	6021      	str	r1, [r4, #0]
 8010310:	e7de      	b.n	80102d0 <stepper_driver_interrupt_handler+0x1a0>
    hal.stepper_go_idle(false);
 8010312:	4f19      	ldr	r7, [pc, #100]	; (8010378 <stepper_driver_interrupt_handler+0x248>)
    if (((settings.steppers.idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 8010314:	4d20      	ldr	r5, [pc, #128]	; (8010398 <stepper_driver_interrupt_handler+0x268>)
    hal.stepper_go_idle(false);
 8010316:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010318:	4798      	blx	r3
    if (((settings.steppers.idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 801031a:	f895 00ba 	ldrb.w	r0, [r5, #186]	; 0xba
 801031e:	4e17      	ldr	r6, [pc, #92]	; (801037c <stepper_driver_interrupt_handler+0x24c>)
 8010320:	28ff      	cmp	r0, #255	; 0xff
 8010322:	d01b      	beq.n	801035c <stepper_driver_interrupt_handler+0x22c>
 8010324:	6833      	ldr	r3, [r6, #0]
 8010326:	2b04      	cmp	r3, #4
 8010328:	d01f      	beq.n	801036a <stepper_driver_interrupt_handler+0x23a>
        sys.steppers_deenergize = true;
 801032a:	2301      	movs	r3, #1
        hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 801032c:	491b      	ldr	r1, [pc, #108]	; (801039c <stepper_driver_interrupt_handler+0x26c>)
        sys.steppers_deenergize = true;
 801032e:	71f3      	strb	r3, [r6, #7]
        hal.delay_ms(settings.steppers.idle_lock_time, st_deenergize);
 8010330:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010332:	4798      	blx	r3
            if (st.exec_block->dynamic_rpm && settings.flags.laser_mode)
 8010334:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8010336:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801033a:	b143      	cbz	r3, 801034e <stepper_driver_interrupt_handler+0x21e>
 801033c:	f895 30bc 	ldrb.w	r3, [r5, #188]	; 0xbc
 8010340:	079b      	lsls	r3, r3, #30
 8010342:	d504      	bpl.n	801034e <stepper_driver_interrupt_handler+0x21e>
                hal.spindle_set_state((spindle_state_t){0}, 0.0f);
 8010344:	2100      	movs	r1, #0
 8010346:	f04f 0000 	mov.w	r0, #0
 801034a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801034c:	4798      	blx	r3
            system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle complete
 801034e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8010352:	2104      	movs	r1, #4
}
 8010354:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            system_set_exec_state_flag(EXEC_CYCLE_COMPLETE); // Flag main program for cycle complete
 8010358:	4811      	ldr	r0, [pc, #68]	; (80103a0 <stepper_driver_interrupt_handler+0x270>)
 801035a:	4718      	bx	r3
    if (((settings.steppers.idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
 801035c:	4b11      	ldr	r3, [pc, #68]	; (80103a4 <stepper_driver_interrupt_handler+0x274>)
 801035e:	681b      	ldr	r3, [r3, #0]
 8010360:	2b00      	cmp	r3, #0
 8010362:	d1df      	bne.n	8010324 <stepper_driver_interrupt_handler+0x1f4>
 8010364:	6833      	ldr	r3, [r6, #0]
 8010366:	2b80      	cmp	r3, #128	; 0x80
 8010368:	d0df      	beq.n	801032a <stepper_driver_interrupt_handler+0x1fa>
        hal.stepper_enable(settings.steppers.deenergize);
 801036a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801036c:	f895 00b7 	ldrb.w	r0, [r5, #183]	; 0xb7
 8010370:	4798      	blx	r3
}
 8010372:	e7df      	b.n	8010334 <stepper_driver_interrupt_handler+0x204>
 8010374:	20001ce8 	.word	0x20001ce8
 8010378:	200024bc 	.word	0x200024bc
 801037c:	20002494 	.word	0x20002494
 8010380:	200024b8 	.word	0x200024b8
 8010384:	20002610 	.word	0x20002610
 8010388:	20001ce0 	.word	0x20001ce0
 801038c:	20002604 	.word	0x20002604
 8010390:	20001cdc 	.word	0x20001cdc
 8010394:	20001b9c 	.word	0x20001b9c
 8010398:	20002620 	.word	0x20002620
 801039c:	08010091 	.word	0x08010091
 80103a0:	200024b4 	.word	0x200024b4
 80103a4:	2000261c 	.word	0x2000261c

080103a8 <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset ()
{
 80103a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

    hal.probe_configure_invert_mask(false);
 80103ac:	4e49      	ldr	r6, [pc, #292]	; (80104d4 <st_reset+0x12c>)
 80103ae:	2000      	movs	r0, #0
 80103b0:	f8d6 3098 	ldr.w	r3, [r6, #152]	; 0x98
 80103b4:	4798      	blx	r3

    // Initialize stepper driver idle state, clear step and direction port pins.
    hal.stepper_go_idle(true);
 80103b6:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 80103b8:	2001      	movs	r0, #1
 80103ba:	4798      	blx	r3
    // NOTE: buffer indices starts from 1 for simpler driver coding!

    // Set up stepper block ringbuffer as circular linked list and add id
    uint_fast8_t idx;
    for(idx = 0 ; idx <= SEGMENT_BUFFER_SIZE - 2 ; idx++) {
        st_block_buffer[idx].next = &st_block_buffer[idx == SEGMENT_BUFFER_SIZE - 2 ? 0 : idx + 1];
 80103bc:	4b46      	ldr	r3, [pc, #280]	; (80104d8 <st_reset+0x130>)
        st_block_buffer[idx].id = idx + 1;
 80103be:	2501      	movs	r5, #1
 80103c0:	461a      	mov	r2, r3
    }

    // Add id to segment buffer enteries
    for(idx = 0 ; idx <= SEGMENT_BUFFER_SIZE - 1 ; idx++) {
        segment_buffer[idx].id = idx + 1;
        segment_buffer[idx].amass_level = 0;
 80103c2:	2400      	movs	r4, #0
        st_block_buffer[idx].id = idx + 1;
 80103c4:	f04f 0e06 	mov.w	lr, #6
 80103c8:	f04f 0c07 	mov.w	ip, #7
 80103cc:	2708      	movs	r7, #8
 80103ce:	2109      	movs	r1, #9
 80103d0:	f04f 0b02 	mov.w	fp, #2
 80103d4:	f04f 0a03 	mov.w	sl, #3
 80103d8:	f04f 0904 	mov.w	r9, #4
 80103dc:	f04f 0805 	mov.w	r8, #5
        st_block_buffer[idx].next = &st_block_buffer[idx == SEGMENT_BUFFER_SIZE - 2 ? 0 : idx + 1];
 80103e0:	f103 0034 	add.w	r0, r3, #52	; 0x34
 80103e4:	6058      	str	r0, [r3, #4]
 80103e6:	f103 009c 	add.w	r0, r3, #156	; 0x9c
 80103ea:	66d8      	str	r0, [r3, #108]	; 0x6c
 80103ec:	f103 00d0 	add.w	r0, r3, #208	; 0xd0
 80103f0:	f8c3 00a0 	str.w	r0, [r3, #160]	; 0xa0
 80103f4:	f503 7082 	add.w	r0, r3, #260	; 0x104
 80103f8:	f8c3 00d4 	str.w	r0, [r3, #212]	; 0xd4
 80103fc:	f503 709c 	add.w	r0, r3, #312	; 0x138
 8010400:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
 8010404:	f503 70b6 	add.w	r0, r3, #364	; 0x16c
        st_block_buffer[idx].id = idx + 1;
 8010408:	f842 5b68 	str.w	r5, [r2], #104
        st_block_buffer[idx].next = &st_block_buffer[idx == SEGMENT_BUFFER_SIZE - 2 ? 0 : idx + 1];
 801040c:	f8c3 013c 	str.w	r0, [r3, #316]	; 0x13c
 8010410:	f503 70d0 	add.w	r0, r3, #416	; 0x1a0
 8010414:	f8c3 0170 	str.w	r0, [r3, #368]	; 0x170
 8010418:	639a      	str	r2, [r3, #56]	; 0x38
        segment_buffer[idx].id = idx + 1;
 801041a:	4830      	ldr	r0, [pc, #192]	; (80104dc <st_reset+0x134>)
    }

    st_prep_block = &st_block_buffer[0];
 801041c:	4a30      	ldr	r2, [pc, #192]	; (80104e0 <st_reset+0x138>)
        st_block_buffer[idx].id = idx + 1;
 801041e:	f8c3 e104 	str.w	lr, [r3, #260]	; 0x104
        segment_buffer[idx].id = idx + 1;
 8010422:	f8c0 e0a0 	str.w	lr, [r0, #160]	; 0xa0
        st_block_buffer[idx].id = idx + 1;
 8010426:	f8c3 c138 	str.w	ip, [r3, #312]	; 0x138
        segment_buffer[idx].id = idx + 1;
 801042a:	f8c0 c0c0 	str.w	ip, [r0, #192]	; 0xc0
        st_block_buffer[idx].id = idx + 1;
 801042e:	f8c3 716c 	str.w	r7, [r3, #364]	; 0x16c
 8010432:	f8c3 11a0 	str.w	r1, [r3, #416]	; 0x1a0
        st_block_buffer[idx].next = &st_block_buffer[idx == SEGMENT_BUFFER_SIZE - 2 ? 0 : idx + 1];
 8010436:	f8c3 31a4 	str.w	r3, [r3, #420]	; 0x1a4
        st_block_buffer[idx].id = idx + 1;
 801043a:	f8c3 b034 	str.w	fp, [r3, #52]	; 0x34
        segment_buffer[idx].id = idx + 1;
 801043e:	f8c0 b020 	str.w	fp, [r0, #32]
 8010442:	6005      	str	r5, [r0, #0]
        st_block_buffer[idx].id = idx + 1;
 8010444:	f8c3 a068 	str.w	sl, [r3, #104]	; 0x68
        segment_buffer[idx].id = idx + 1;
 8010448:	f8c0 a040 	str.w	sl, [r0, #64]	; 0x40
        st_block_buffer[idx].id = idx + 1;
 801044c:	f8c3 909c 	str.w	r9, [r3, #156]	; 0x9c
        segment_buffer[idx].id = idx + 1;
 8010450:	f8c0 9060 	str.w	r9, [r0, #96]	; 0x60
        st_block_buffer[idx].id = idx + 1;
 8010454:	f8c3 80d0 	str.w	r8, [r3, #208]	; 0xd0
        segment_buffer[idx].id = idx + 1;
 8010458:	f8c0 8080 	str.w	r8, [r0, #128]	; 0x80
        segment_buffer[idx].amass_level = 0;
 801045c:	61c4      	str	r4, [r0, #28]
 801045e:	63c4      	str	r4, [r0, #60]	; 0x3c
 8010460:	65c4      	str	r4, [r0, #92]	; 0x5c
 8010462:	67c4      	str	r4, [r0, #124]	; 0x7c
 8010464:	f8c0 409c 	str.w	r4, [r0, #156]	; 0x9c
 8010468:	f8c0 40bc 	str.w	r4, [r0, #188]	; 0xbc
        segment_buffer[idx].id = idx + 1;
 801046c:	e9c0 4737 	strd	r4, r7, [r0, #220]	; 0xdc
    st_prep_block = &st_block_buffer[0];
 8010470:	6013      	str	r3, [r2, #0]
        segment_buffer[idx].id = idx + 1;
 8010472:	230a      	movs	r3, #10

    // Initialize stepper algorithm variables.
    memset(&prep, 0, sizeof(st_prep_t));
    memset(&st, 0, sizeof(stepper_t));
 8010474:	4f1b      	ldr	r7, [pc, #108]	; (80104e4 <st_reset+0x13c>)
        segment_buffer[idx].id = idx + 1;
 8010476:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
 801047a:	e9c0 413f 	strd	r4, r1, [r0, #252]	; 0xfc
    memset(&prep, 0, sizeof(st_prep_t));
 801047e:	2250      	movs	r2, #80	; 0x50
 8010480:	4621      	mov	r1, r4
        segment_buffer[idx].amass_level = 0;
 8010482:	f8c0 411c 	str.w	r4, [r0, #284]	; 0x11c
 8010486:	f8c0 413c 	str.w	r4, [r0, #316]	; 0x13c
    memset(&prep, 0, sizeof(st_prep_t));
 801048a:	4817      	ldr	r0, [pc, #92]	; (80104e8 <st_reset+0x140>)
 801048c:	f001 fbfa 	bl	8011c84 <memset>
    memset(&st, 0, sizeof(stepper_t));
 8010490:	222c      	movs	r2, #44	; 0x2c
 8010492:	4621      	mov	r1, r4
 8010494:	4638      	mov	r0, r7
 8010496:	f001 fbf5 	bl	8011c84 <memset>

#ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    // TODO: move to driver?
    // AMASS_LEVEL0: Normal operation. No AMASS. No upper cutoff frequency. Starts at LEVEL1 cutoff frequency.
    // Defined as step timer frequency / Cutoff frequency in Hz
    amass.level_1 = hal.f_step_timer / 8000;
 801049a:	6930      	ldr	r0, [r6, #16]
 801049c:	4b13      	ldr	r3, [pc, #76]	; (80104ec <st_reset+0x144>)
    pl_block = NULL;  // Planner block pointer used by segment buffer
 801049e:	4e14      	ldr	r6, [pc, #80]	; (80104f0 <st_reset+0x148>)
    amass.level_1 = hal.f_step_timer / 8000;
 80104a0:	fba3 2300 	umull	r2, r3, r3, r0
    segment_buffer_tail = segment_buffer_head = 0; // empty = tail
 80104a4:	4a13      	ldr	r2, [pc, #76]	; (80104f4 <st_reset+0x14c>)
 80104a6:	4914      	ldr	r1, [pc, #80]	; (80104f8 <st_reset+0x150>)
 80104a8:	6014      	str	r4, [r2, #0]
    amass.level_1 = hal.f_step_timer / 8000;
 80104aa:	4a14      	ldr	r2, [pc, #80]	; (80104fc <st_reset+0x154>)
    pl_block = NULL;  // Planner block pointer used by segment buffer
 80104ac:	6034      	str	r4, [r6, #0]
    segment_buffer_tail = segment_buffer_head = 0; // empty = tail
 80104ae:	600c      	str	r4, [r1, #0]
    segment_next_head = 1;
 80104b0:	4e13      	ldr	r6, [pc, #76]	; (8010500 <st_reset+0x158>)
    amass.level_1 = hal.f_step_timer / 8000;
 80104b2:	0a59      	lsrs	r1, r3, #9
 80104b4:	6011      	str	r1, [r2, #0]
    amass.level_2 = hal.f_step_timer / 4000;
 80104b6:	0a19      	lsrs	r1, r3, #8
    amass.level_3 = hal.f_step_timer / 2000;
 80104b8:	09db      	lsrs	r3, r3, #7
 80104ba:	e9c2 1301 	strd	r1, r3, [r2, #4]
    segment_next_head = 1;
 80104be:	6035      	str	r5, [r6, #0]
    st.exec_segment = NULL;
 80104c0:	62fc      	str	r4, [r7, #44]	; 0x2c
#endif

    cycles_per_min = (float)hal.f_step_timer * 60.0f;
 80104c2:	f7f0 f90f 	bl	80006e4 <__aeabi_ui2f>
 80104c6:	490f      	ldr	r1, [pc, #60]	; (8010504 <st_reset+0x15c>)
 80104c8:	f7f0 f964 	bl	8000794 <__aeabi_fmul>
 80104cc:	4b0e      	ldr	r3, [pc, #56]	; (8010508 <st_reset+0x160>)
 80104ce:	6018      	str	r0, [r3, #0]
}
 80104d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80104d4:	200024bc 	.word	0x200024bc
 80104d8:	20001d18 	.word	0x20001d18
 80104dc:	20001b9c 	.word	0x20001b9c
 80104e0:	20001eec 	.word	0x20001eec
 80104e4:	20001ce8 	.word	0x20001ce8
 80104e8:	20001b4c 	.word	0x20001b4c
 80104ec:	10624dd3 	.word	0x10624dd3
 80104f0:	20001b48 	.word	0x20001b48
 80104f4:	20001cdc 	.word	0x20001cdc
 80104f8:	20001ce0 	.word	0x20001ce0
 80104fc:	20001b38 	.word	0x20001b38
 8010500:	20001ce4 	.word	0x20001ce4
 8010504:	42700000 	.word	0x42700000
 8010508:	20001b44 	.word	0x20001b44

0801050c <st_rpm_changed>:

// Called by spindle_set_state() to inform about RPM changes.
// Used by st_prep_buffer() to determine if spindle needs update when dynamic RPM is called for.
void st_rpm_changed (float rpm)
{
    prep.current_spindle_rpm = rpm;
 801050c:	4b01      	ldr	r3, [pc, #4]	; (8010514 <st_rpm_changed+0x8>)
 801050e:	64d8      	str	r0, [r3, #76]	; 0x4c
}
 8010510:	4770      	bx	lr
 8010512:	bf00      	nop
 8010514:	20001b4c 	.word	0x20001b4c

08010518 <st_update_plan_block_parameters>:

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters ()
{
 8010518:	b538      	push	{r3, r4, r5, lr}
    if (pl_block != NULL) { // Ignore if at start of a new block.
 801051a:	4c08      	ldr	r4, [pc, #32]	; (801053c <st_update_plan_block_parameters+0x24>)
 801051c:	6825      	ldr	r5, [r4, #0]
 801051e:	b15d      	cbz	r5, 8010538 <st_update_plan_block_parameters+0x20>
        prep.recalculate.velocity_profile = On;
 8010520:	4b07      	ldr	r3, [pc, #28]	; (8010540 <st_update_plan_block_parameters+0x28>)
 8010522:	781a      	ldrb	r2, [r3, #0]
        pl_block->entry_speed_sqr = prep.current_speed * prep.current_speed; // Update entry speed.
 8010524:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
        prep.recalculate.velocity_profile = On;
 8010526:	f042 0201 	orr.w	r2, r2, #1
 801052a:	701a      	strb	r2, [r3, #0]
        pl_block->entry_speed_sqr = prep.current_speed * prep.current_speed; // Update entry speed.
 801052c:	4608      	mov	r0, r1
 801052e:	f7f0 f931 	bl	8000794 <__aeabi_fmul>
        pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 8010532:	2300      	movs	r3, #0
        pl_block->entry_speed_sqr = prep.current_speed * prep.current_speed; // Update entry speed.
 8010534:	6228      	str	r0, [r5, #32]
        pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
 8010536:	6023      	str	r3, [r4, #0]
    }
}
 8010538:	bd38      	pop	{r3, r4, r5, pc}
 801053a:	bf00      	nop
 801053c:	20001b48 	.word	0x20001b48
 8010540:	20001b4c 	.word	0x20001b4c

08010544 <st_parking_setup_buffer>:

// Changes the run state of the step segment buffer to execute the special parking motion.
void st_parking_setup_buffer()
{
    // Store step execution data of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block) {
 8010544:	4b0c      	ldr	r3, [pc, #48]	; (8010578 <st_parking_setup_buffer+0x34>)
{
 8010546:	b410      	push	{r4}
    if (prep.recalculate.hold_partial_block) {
 8010548:	781a      	ldrb	r2, [r3, #0]
 801054a:	0792      	lsls	r2, r2, #30
 801054c:	d508      	bpl.n	8010560 <st_parking_setup_buffer+0x1c>
        prep.last_st_block = st_prep_block;
 801054e:	4a0b      	ldr	r2, [pc, #44]	; (801057c <st_parking_setup_buffer+0x38>)
        prep.last_steps_remaining = prep.steps_remaining;
 8010550:	6898      	ldr	r0, [r3, #8]
        prep.last_st_block = st_prep_block;
 8010552:	6814      	ldr	r4, [r2, #0]
        prep.last_dt_remainder = prep.dt_remainder;
 8010554:	6859      	ldr	r1, [r3, #4]
        prep.last_steps_per_mm = prep.steps_per_mm;
 8010556:	68da      	ldr	r2, [r3, #12]
        prep.last_steps_remaining = prep.steps_remaining;
 8010558:	e9c3 4005 	strd	r4, r0, [r3, #20]
        prep.last_dt_remainder = prep.dt_remainder;
 801055c:	6219      	str	r1, [r3, #32]
        prep.last_steps_per_mm = prep.steps_per_mm;
 801055e:	61da      	str	r2, [r3, #28]
    }
    // Set flags to execute a parking motion
    prep.recalculate.parking = On;
    prep.recalculate.velocity_profile = Off;
    pl_block = NULL; // Always reset parking motion to reload new block.
 8010560:	2000      	movs	r0, #0
    prep.recalculate.velocity_profile = Off;
 8010562:	781a      	ldrb	r2, [r3, #0]
    pl_block = NULL; // Always reset parking motion to reload new block.
 8010564:	4906      	ldr	r1, [pc, #24]	; (8010580 <st_parking_setup_buffer+0x3c>)
    prep.recalculate.velocity_profile = Off;
 8010566:	f022 0205 	bic.w	r2, r2, #5
 801056a:	f042 0204 	orr.w	r2, r2, #4
}
 801056e:	bc10      	pop	{r4}
    prep.recalculate.velocity_profile = Off;
 8010570:	701a      	strb	r2, [r3, #0]
    pl_block = NULL; // Always reset parking motion to reload new block.
 8010572:	6008      	str	r0, [r1, #0]
}
 8010574:	4770      	bx	lr
 8010576:	bf00      	nop
 8010578:	20001b4c 	.word	0x20001b4c
 801057c:	20001eec 	.word	0x20001eec
 8010580:	20001b48 	.word	0x20001b48

08010584 <st_parking_restore_buffer>:


// Restores the step segment buffer to the normal run state after a parking motion.
void st_parking_restore_buffer()
{
 8010584:	b538      	push	{r3, r4, r5, lr}
    // Restore step execution data and flags of partially completed block, if necessary.
    if (prep.recalculate.hold_partial_block) {
 8010586:	4c0e      	ldr	r4, [pc, #56]	; (80105c0 <st_parking_restore_buffer+0x3c>)
 8010588:	7823      	ldrb	r3, [r4, #0]
 801058a:	f013 0302 	ands.w	r3, r3, #2
 801058e:	d012      	beq.n	80105b6 <st_parking_restore_buffer+0x32>
        st_prep_block = prep.last_st_block;
        prep.steps_remaining = prep.last_steps_remaining;
        prep.dt_remainder = prep.last_dt_remainder;
        prep.steps_per_mm = prep.last_steps_per_mm;
        prep.recalculate.flags = 0;
 8010590:	2303      	movs	r3, #3
        prep.steps_remaining = prep.last_steps_remaining;
 8010592:	69a2      	ldr	r2, [r4, #24]
        st_prep_block = prep.last_st_block;
 8010594:	480b      	ldr	r0, [pc, #44]	; (80105c4 <st_parking_restore_buffer+0x40>)
        prep.steps_per_mm = prep.last_steps_per_mm;
 8010596:	69e1      	ldr	r1, [r4, #28]
        prep.recalculate.flags = 0;
 8010598:	7023      	strb	r3, [r4, #0]
        st_prep_block = prep.last_st_block;
 801059a:	6965      	ldr	r5, [r4, #20]
        prep.dt_remainder = prep.last_dt_remainder;
 801059c:	6a23      	ldr	r3, [r4, #32]
        st_prep_block = prep.last_st_block;
 801059e:	6005      	str	r5, [r0, #0]
        prep.steps_remaining = prep.last_steps_remaining;
 80105a0:	60a2      	str	r2, [r4, #8]
        prep.dt_remainder = prep.last_dt_remainder;
 80105a2:	6063      	str	r3, [r4, #4]
        prep.recalculate.hold_partial_block = prep.recalculate.velocity_profile = On;
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
 80105a4:	4808      	ldr	r0, [pc, #32]	; (80105c8 <st_parking_restore_buffer+0x44>)
        prep.steps_per_mm = prep.last_steps_per_mm;
 80105a6:	60e1      	str	r1, [r4, #12]
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
 80105a8:	f7f0 f9a8 	bl	80008fc <__aeabi_fdiv>
    } else
        prep.recalculate.flags = 0;

    pl_block = NULL; // Set to reload next block.
 80105ac:	2200      	movs	r2, #0
 80105ae:	4b07      	ldr	r3, [pc, #28]	; (80105cc <st_parking_restore_buffer+0x48>)
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm; // Recompute this value.
 80105b0:	6120      	str	r0, [r4, #16]
    pl_block = NULL; // Set to reload next block.
 80105b2:	601a      	str	r2, [r3, #0]
}
 80105b4:	bd38      	pop	{r3, r4, r5, pc}
    pl_block = NULL; // Set to reload next block.
 80105b6:	2200      	movs	r2, #0
        prep.recalculate.flags = 0;
 80105b8:	7023      	strb	r3, [r4, #0]
    pl_block = NULL; // Set to reload next block.
 80105ba:	4b04      	ldr	r3, [pc, #16]	; (80105cc <st_parking_restore_buffer+0x48>)
 80105bc:	601a      	str	r2, [r3, #0]
}
 80105be:	bd38      	pop	{r3, r4, r5, pc}
 80105c0:	20001b4c 	.word	0x20001b4c
 80105c4:	20001eec 	.word	0x20001eec
 80105c8:	3fa00000 	.word	0x3fa00000
 80105cc:	20001b48 	.word	0x20001b48

080105d0 <st_prep_buffer>:
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
    if (sys.step_control.end_motion)
 80105d0:	4b31      	ldr	r3, [pc, #196]	; (8010698 <st_prep_buffer+0xc8>)
 80105d2:	7a9b      	ldrb	r3, [r3, #10]
 80105d4:	07d9      	lsls	r1, r3, #31
 80105d6:	f100 84bb 	bmi.w	8010f50 <st_prep_buffer+0x980>
{
 80105da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80105de:	b08f      	sub	sp, #60	; 0x3c
 80105e0:	4b2e      	ldr	r3, [pc, #184]	; (801069c <st_prep_buffer+0xcc>)
 80105e2:	681c      	ldr	r4, [r3, #0]
        return;

    while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 80105e4:	4b2e      	ldr	r3, [pc, #184]	; (80106a0 <st_prep_buffer+0xd0>)
 80105e6:	681b      	ldr	r3, [r3, #0]
 80105e8:	42a3      	cmp	r3, r4
 80105ea:	f000 827b 	beq.w	8010ae4 <st_prep_buffer+0x514>

        // Determine if we need to load a new planner block or if the block needs to be recomputed.
        if (pl_block == NULL) {
 80105ee:	4b2d      	ldr	r3, [pc, #180]	; (80106a4 <st_prep_buffer+0xd4>)
 80105f0:	681b      	ldr	r3, [r3, #0]
 80105f2:	9301      	str	r3, [sp, #4]
 80105f4:	2b00      	cmp	r3, #0
 80105f6:	f000 8278 	beq.w	8010aea <st_prep_buffer+0x51a>
 80105fa:	4c2b      	ldr	r4, [pc, #172]	; (80106a8 <st_prep_buffer+0xd8>)
 80105fc:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
 8010600:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8010602:	4648      	mov	r0, r9
 8010604:	4619      	mov	r1, r3
 8010606:	9403      	str	r4, [sp, #12]
 8010608:	9304      	str	r3, [sp, #16]
 801060a:	f7ef ffb9 	bl	8000580 <__aeabi_fsub>
 801060e:	4607      	mov	r7, r0
 8010610:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8010612:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
 8010616:	9202      	str	r2, [sp, #8]
 8010618:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 801061a:	f894 5024 	ldrb.w	r5, [r4, #36]	; 0x24
 801061e:	9206      	str	r2, [sp, #24]
 8010620:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8010622:	f8df a094 	ldr.w	sl, [pc, #148]	; 80106b8 <st_prep_buffer+0xe8>
 8010626:	9209      	str	r2, [sp, #36]	; 0x24
        // Initialize new segment
        segment_t *prep_segment = &segment_buffer[segment_buffer_head];

        // Set new segment to point to the current segment data block.
        prep_segment->exec_block = st_prep_block;
        prep_segment->update_rpm = false;
 8010628:	2100      	movs	r1, #0
        segment_t *prep_segment = &segment_buffer[segment_buffer_head];
 801062a:	4b20      	ldr	r3, [pc, #128]	; (80106ac <st_prep_buffer+0xdc>)
        prep_segment->exec_block = st_prep_block;
 801062c:	4a20      	ldr	r2, [pc, #128]	; (80106b0 <st_prep_buffer+0xe0>)
        segment_t *prep_segment = &segment_buffer[segment_buffer_head];
 801062e:	681b      	ldr	r3, [r3, #0]
        prep_segment->exec_block = st_prep_block;
 8010630:	f8da 0000 	ldr.w	r0, [sl]
 8010634:	eb02 1243 	add.w	r2, r2, r3, lsl #5
 8010638:	6050      	str	r0, [r2, #4]
        prep_segment->update_rpm = false;
 801063a:	7611      	strb	r1, [r2, #24]
        float dt = 0.0f; // Initialize segment time
        float time_var = dt_max; // Time worker variable
        float mm_var; // mm - Distance worker variable
        float speed_var; // Speed worker variable
        float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 801063c:	9a03      	ldr	r2, [sp, #12]
        prep_segment->exec_block = st_prep_block;
 801063e:	900d      	str	r0, [sp, #52]	; 0x34
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 8010640:	6911      	ldr	r1, [r2, #16]
        prep_segment->exec_block = st_prep_block;
 8010642:	015b      	lsls	r3, r3, #5
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 8010644:	4648      	mov	r0, r9
        prep_segment->exec_block = st_prep_block;
 8010646:	9307      	str	r3, [sp, #28]
        float minimum_mm = mm_remaining - prep.req_mm_increment; // Guarantee at least one step.
 8010648:	f7ef ff9a 	bl	8000580 <__aeabi_fsub>
 801064c:	2100      	movs	r1, #0
 801064e:	9005      	str	r0, [sp, #20]

        if (minimum_mm < 0.0f)
 8010650:	f7f0 fa52 	bl	8000af8 <__aeabi_fcmpge>
 8010654:	b908      	cbnz	r0, 801065a <st_prep_buffer+0x8a>
 8010656:	2300      	movs	r3, #0
 8010658:	9305      	str	r3, [sp, #20]
                case Ramp_DecelOverride:
                    speed_var = pl_block->acceleration * time_var;
                    if ((prep.current_speed - prep.maximum_speed) <= speed_var) {
                        // Cruise or cruise-deceleration types only for deceleration override.
                        mm_remaining = prep.accelerate_until;
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801065a:	4639      	mov	r1, r7
 801065c:	4638      	mov	r0, r7
 801065e:	f7ef ff91 	bl	8000584 <__addsf3>
 8010662:	4603      	mov	r3, r0
 8010664:	9902      	ldr	r1, [sp, #8]
 8010666:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 801066a:	9308      	str	r3, [sp, #32]
 801066c:	f7f0 f946 	bl	80008fc <__aeabi_fdiv>
 8010670:	4603      	mov	r3, r0
 8010672:	9904      	ldr	r1, [sp, #16]
 8010674:	9806      	ldr	r0, [sp, #24]
 8010676:	930a      	str	r3, [sp, #40]	; 0x28
 8010678:	f7f0 fa20 	bl	8000abc <__aeabi_fcmpeq>
 801067c:	9b03      	ldr	r3, [sp, #12]
 801067e:	6adf      	ldr	r7, [r3, #44]	; 0x2c
 8010680:	2800      	cmp	r0, #0
 8010682:	f000 81f5 	beq.w	8010a70 <st_prep_buffer+0x4a0>
 8010686:	f04f 0202 	mov.w	r2, #2
 801068a:	f8df b028 	ldr.w	fp, [pc, #40]	; 80106b4 <st_prep_buffer+0xe4>
 801068e:	b2d3      	uxtb	r3, r2
 8010690:	2400      	movs	r4, #0
 8010692:	465e      	mov	r6, fp
 8010694:	930b      	str	r3, [sp, #44]	; 0x2c
 8010696:	e01c      	b.n	80106d2 <st_prep_buffer+0x102>
 8010698:	20002494 	.word	0x20002494
 801069c:	20001ce4 	.word	0x20001ce4
 80106a0:	20001ce0 	.word	0x20001ce0
 80106a4:	20001b48 	.word	0x20001b48
 80106a8:	20001b4c 	.word	0x20001b4c
 80106ac:	20001cdc 	.word	0x20001cdc
 80106b0:	20001b9c 	.word	0x20001b9c
 80106b4:	392ec33e 	.word	0x392ec33e
 80106b8:	20001eec 	.word	0x20001eec
            }

            dt += time_var; // Add computed ramp time to total segment time.

            if (dt < dt_max)
                time_var = dt_max - dt;// **Incomplete** At ramp junction.
 80106bc:	4621      	mov	r1, r4
 80106be:	4630      	mov	r0, r6
 80106c0:	f7ef ff5e 	bl	8000580 <__aeabi_fsub>
                    time_var = dt_max - dt;
                } else
                    break; // **Complete** Exit loop. Segment execution time maxed.
            }

        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 80106c4:	4641      	mov	r1, r8
                time_var = dt_max - dt;// **Incomplete** At ramp junction.
 80106c6:	4683      	mov	fp, r0
        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 80106c8:	4648      	mov	r0, r9
 80106ca:	f7f0 fa1f 	bl	8000b0c <__aeabi_fcmpgt>
 80106ce:	2800      	cmp	r0, #0
 80106d0:	d04f      	beq.n	8010772 <st_prep_buffer+0x1a2>
            switch (prep.ramp_type) {
 80106d2:	2d01      	cmp	r5, #1
 80106d4:	f000 816c 	beq.w	80109b0 <st_prep_buffer+0x3e0>
 80106d8:	2d03      	cmp	r5, #3
 80106da:	f000 814c 	beq.w	8010976 <st_prep_buffer+0x3a6>
 80106de:	2d00      	cmp	r5, #0
 80106e0:	f000 8121 	beq.w	8010926 <st_prep_buffer+0x356>
                    speed_var = pl_block->acceleration * time_var; // Used as delta speed (mm/min)
 80106e4:	9b01      	ldr	r3, [sp, #4]
 80106e6:	4658      	mov	r0, fp
 80106e8:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80106ea:	f7f0 f853 	bl	8000794 <__aeabi_fmul>
                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 80106ee:	4639      	mov	r1, r7
                    speed_var = pl_block->acceleration * time_var; // Used as delta speed (mm/min)
 80106f0:	4682      	mov	sl, r0
                    if (prep.current_speed > speed_var) { // Check if at or below zero speed.
 80106f2:	f7f0 f9ed 	bl	8000ad0 <__aeabi_fcmplt>
 80106f6:	2800      	cmp	r0, #0
 80106f8:	f000 8186 	beq.w	8010a08 <st_prep_buffer+0x438>
                        mm_var = mm_remaining - time_var * (prep.current_speed - 0.5f * speed_var); // (mm)
 80106fc:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8010700:	4650      	mov	r0, sl
 8010702:	f7f0 f847 	bl	8000794 <__aeabi_fmul>
 8010706:	4639      	mov	r1, r7
 8010708:	f7ef ff3a 	bl	8000580 <__aeabi_fsub>
 801070c:	4659      	mov	r1, fp
 801070e:	f7f0 f841 	bl	8000794 <__aeabi_fmul>
 8010712:	4649      	mov	r1, r9
 8010714:	f7ef ff36 	bl	8000584 <__addsf3>
                        if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 8010718:	4641      	mov	r1, r8
                        mm_var = mm_remaining - time_var * (prep.current_speed - 0.5f * speed_var); // (mm)
 801071a:	900c      	str	r0, [sp, #48]	; 0x30
                        if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
 801071c:	f7f0 f9f6 	bl	8000b0c <__aeabi_fcmpgt>
 8010720:	2800      	cmp	r0, #0
 8010722:	f000 8171 	beq.w	8010a08 <st_prep_buffer+0x438>
                            prep.current_speed -= speed_var;
 8010726:	4638      	mov	r0, r7
 8010728:	4651      	mov	r1, sl
 801072a:	f7ef ff29 	bl	8000580 <__aeabi_fsub>
 801072e:	4607      	mov	r7, r0
                            mm_remaining = mm_var;
 8010730:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
            dt += time_var; // Add computed ramp time to total segment time.
 8010734:	4659      	mov	r1, fp
 8010736:	4620      	mov	r0, r4
 8010738:	f7ef ff24 	bl	8000584 <__addsf3>
 801073c:	4604      	mov	r4, r0
            if (dt < dt_max)
 801073e:	4630      	mov	r0, r6
 8010740:	4621      	mov	r1, r4
 8010742:	f7f0 f9e3 	bl	8000b0c <__aeabi_fcmpgt>
 8010746:	2800      	cmp	r0, #0
 8010748:	d1b8      	bne.n	80106bc <st_prep_buffer+0xec>
                if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
 801074a:	4648      	mov	r0, r9
 801074c:	9905      	ldr	r1, [sp, #20]
 801074e:	f7f0 f9dd 	bl	8000b0c <__aeabi_fcmpgt>
 8010752:	b170      	cbz	r0, 8010772 <st_prep_buffer+0x1a2>
                    dt_max += DT_SEGMENT;
 8010754:	4630      	mov	r0, r6
 8010756:	49a3      	ldr	r1, [pc, #652]	; (80109e4 <st_prep_buffer+0x414>)
 8010758:	f7ef ff14 	bl	8000584 <__addsf3>
                    time_var = dt_max - dt;
 801075c:	4621      	mov	r1, r4
                    dt_max += DT_SEGMENT;
 801075e:	4606      	mov	r6, r0
                    time_var = dt_max - dt;
 8010760:	f7ef ff0e 	bl	8000580 <__aeabi_fsub>
        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 8010764:	4641      	mov	r1, r8
                    time_var = dt_max - dt;
 8010766:	4683      	mov	fp, r0
        } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
 8010768:	4648      	mov	r0, r9
 801076a:	f7f0 f9cf 	bl	8000b0c <__aeabi_fcmpgt>
 801076e:	2800      	cmp	r0, #0
 8010770:	d1af      	bne.n	80106d2 <st_prep_buffer+0x102>

        /* -----------------------------------------------------------------------------------
           Compute spindle spindle speed for step segment
        */

        if (sys.step_control.update_spindle_rpm || st_prep_block->dynamic_rpm) {
 8010772:	9b03      	ldr	r3, [sp, #12]
 8010774:	f883 5024 	strb.w	r5, [r3, #36]	; 0x24
 8010778:	62df      	str	r7, [r3, #44]	; 0x2c
 801077a:	4b9b      	ldr	r3, [pc, #620]	; (80109e8 <st_prep_buffer+0x418>)
 801077c:	7a9b      	ldrb	r3, [r3, #10]
 801077e:	071e      	lsls	r6, r3, #28
 8010780:	d404      	bmi.n	801078c <st_prep_buffer+0x1bc>
 8010782:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010784:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010788:	2b00      	cmp	r3, #0
 801078a:	d036      	beq.n	80107fa <st_prep_buffer+0x22a>
            float rpm;
            if (pl_block->condition.spindle.on) {
 801078c:	9a01      	ldr	r2, [sp, #4]
 801078e:	7d93      	ldrb	r3, [r2, #22]
 8010790:	07dd      	lsls	r5, r3, #31
 8010792:	f140 8183 	bpl.w	8010a9c <st_prep_buffer+0x4cc>
                // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.
                // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_RPM_OVERRIDE)
                // but this would be instantaneous only and during a motion. May not matter at all.
                rpm = spindle_set_rpm(pl_block->condition.is_rpm_rate_adjusted && !pl_block->condition.is_laser_ppi_mode
 8010796:	8a93      	ldrh	r3, [r2, #20]
 8010798:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 801079a:	f403 73a0 	and.w	r3, r3, #320	; 0x140
 801079e:	2b40      	cmp	r3, #64	; 0x40
 80107a0:	d106      	bne.n	80107b0 <st_prep_buffer+0x1e0>
 80107a2:	9b03      	ldr	r3, [sp, #12]
 80107a4:	6c99      	ldr	r1, [r3, #72]	; 0x48
 80107a6:	f7ef fff5 	bl	8000794 <__aeabi_fmul>
 80107aa:	4639      	mov	r1, r7
 80107ac:	f7ef fff2 	bl	8000794 <__aeabi_fmul>
 80107b0:	4b8d      	ldr	r3, [pc, #564]	; (80109e8 <st_prep_buffer+0x418>)
 80107b2:	7c19      	ldrb	r1, [r3, #16]
 80107b4:	f7fe fade 	bl	800ed74 <spindle_set_rpm>
                                       ? pl_block->spindle.rpm * prep.current_speed * prep.inv_feedrate
                                       : pl_block->spindle.rpm, sys.override.spindle_rpm);

                if(pl_block->condition.is_rpm_pos_adjusted) {
 80107b8:	4b8c      	ldr	r3, [pc, #560]	; (80109ec <st_prep_buffer+0x41c>)
                rpm = spindle_set_rpm(pl_block->condition.is_rpm_rate_adjusted && !pl_block->condition.is_laser_ppi_mode
 80107ba:	4606      	mov	r6, r0
                if(pl_block->condition.is_rpm_pos_adjusted) {
 80107bc:	681d      	ldr	r5, [r3, #0]
 80107be:	f995 3014 	ldrsb.w	r3, [r5, #20]
 80107c2:	2b00      	cmp	r3, #0
 80107c4:	f2c0 825e 	blt.w	8010c84 <st_prep_buffer+0x6b4>
 80107c8:	9b03      	ldr	r3, [sp, #12]
 80107ca:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
                    rpm += (spindle_set_rpm(pl_block->spindle.css.target_rpm, sys.override.spindle_rpm) - prep.current_spindle_rpm) * npos;
                }
            } else
                sys.spindle_rpm = rpm = 0.0f;

            if(rpm != prep.current_spindle_rpm) {
 80107cc:	4629      	mov	r1, r5
 80107ce:	4630      	mov	r0, r6
 80107d0:	f7f0 f974 	bl	8000abc <__aeabi_fcmpeq>
 80107d4:	4605      	mov	r5, r0
 80107d6:	b980      	cbnz	r0, 80107fa <st_prep_buffer+0x22a>
              #ifdef SPINDLE_PWM_DIRECT
                prep.current_spindle_rpm = rpm;
 80107d8:	9a03      	ldr	r2, [sp, #12]
                prep_segment->spindle_pwm = hal.spindle_get_pwm(rpm);
 80107da:	4b85      	ldr	r3, [pc, #532]	; (80109f0 <st_prep_buffer+0x420>)
                prep.current_spindle_rpm = rpm;
 80107dc:	64d6      	str	r6, [r2, #76]	; 0x4c
                prep_segment->spindle_pwm = hal.spindle_get_pwm(rpm);
 80107de:	4630      	mov	r0, r6
 80107e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80107e2:	4798      	blx	r3
              #else
                prep.current_spindle_rpm = prep_segment->spindle_rpm = rpm;
              #endif
                prep_segment->update_rpm = true;
 80107e4:	2101      	movs	r1, #1
                sys.step_control.update_spindle_rpm = Off;
 80107e6:	4e80      	ldr	r6, [pc, #512]	; (80109e8 <st_prep_buffer+0x418>)
                prep_segment->spindle_pwm = hal.spindle_get_pwm(rpm);
 80107e8:	4b82      	ldr	r3, [pc, #520]	; (80109f4 <st_prep_buffer+0x424>)
                sys.step_control.update_spindle_rpm = Off;
 80107ea:	7ab2      	ldrb	r2, [r6, #10]
                prep_segment->spindle_pwm = hal.spindle_get_pwm(rpm);
 80107ec:	9f07      	ldr	r7, [sp, #28]
                sys.step_control.update_spindle_rpm = Off;
 80107ee:	f365 02c3 	bfi	r2, r5, #3, #1
                prep_segment->spindle_pwm = hal.spindle_get_pwm(rpm);
 80107f2:	443b      	add	r3, r7
 80107f4:	6158      	str	r0, [r3, #20]
                prep_segment->update_rpm = true;
 80107f6:	7619      	strb	r1, [r3, #24]
                sys.step_control.update_spindle_rpm = Off;
 80107f8:	72b2      	strb	r2, [r6, #10]
           However, since floats have only 7.2 significant digits, long moves with extremely
           high step counts can exceed the precision of floats, which can lead to lost steps.
           Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
           supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
        */
        float step_dist_remaining = prep.steps_per_mm * mm_remaining; // Convert mm_remaining to steps
 80107fa:	9d03      	ldr	r5, [sp, #12]
 80107fc:	4648      	mov	r0, r9
 80107fe:	68e9      	ldr	r1, [r5, #12]
 8010800:	f7ef ffc8 	bl	8000794 <__aeabi_fmul>
 8010804:	4607      	mov	r7, r0
        uint32_t n_steps_remaining = (uint32_t)ceilf(step_dist_remaining); // Round-up current steps remaining
 8010806:	f002 f9f9 	bl	8012bfc <ceilf>
 801080a:	f7f0 f9c5 	bl	8000b98 <__aeabi_f2uiz>

        prep_segment->n_step = (uint_fast16_t)(prep.steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 801080e:	68ad      	ldr	r5, [r5, #8]
 8010810:	4b78      	ldr	r3, [pc, #480]	; (80109f4 <st_prep_buffer+0x424>)
 8010812:	9a07      	ldr	r2, [sp, #28]
 8010814:	eba5 0800 	sub.w	r8, r5, r0
 8010818:	4413      	add	r3, r2
        uint32_t n_steps_remaining = (uint32_t)ceilf(step_dist_remaining); // Round-up current steps remaining
 801081a:	4606      	mov	r6, r0
        prep_segment->n_step = (uint_fast16_t)(prep.steps_remaining - n_steps_remaining); // Compute number of steps to execute.
 801081c:	f8c3 8010 	str.w	r8, [r3, #16]

        // Bail if we are at the end of a feed hold and don't have a step to execute.
        if (prep_segment->n_step == 0 && sys.step_control.execute_hold) {
 8010820:	f1b8 0f00 	cmp.w	r8, #0
 8010824:	d105      	bne.n	8010832 <st_prep_buffer+0x262>
 8010826:	4b70      	ldr	r3, [pc, #448]	; (80109e8 <st_prep_buffer+0x418>)
 8010828:	7a9b      	ldrb	r3, [r3, #10]
 801082a:	0798      	lsls	r0, r3, #30
 801082c:	461a      	mov	r2, r3
 801082e:	f100 83b1 	bmi.w	8010f94 <st_prep_buffer+0x9c4>
        // compensate, we track the time to execute the previous segment's partial step and simply
        // apply it with the partial step distance to the current segment, so that it minutely
        // adjusts the whole segment rate to keep step output exact. These rate adjustments are
        // typically very small and do not adversely effect performance, but ensures that Grbl
        // outputs the exact acceleration and velocity profiles as computed by the planner.
        dt += prep.dt_remainder; // Apply previous segment partial step execute time
 8010832:	9b03      	ldr	r3, [sp, #12]
 8010834:	4620      	mov	r0, r4
 8010836:	6859      	ldr	r1, [r3, #4]
 8010838:	f7ef fea4 	bl	8000584 <__addsf3>
 801083c:	4604      	mov	r4, r0
        float inv_rate = dt / ((float)prep.steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 801083e:	4628      	mov	r0, r5
 8010840:	f7ef ff50 	bl	80006e4 <__aeabi_ui2f>
 8010844:	4639      	mov	r1, r7
 8010846:	f7ef fe9b 	bl	8000580 <__aeabi_fsub>
 801084a:	4601      	mov	r1, r0
 801084c:	4620      	mov	r0, r4
 801084e:	f7f0 f855 	bl	80008fc <__aeabi_fdiv>

        // Compute timer ticks per step for the prepped segment.
        uint32_t cycles = (uint32_t)ceilf(cycles_per_min * inv_rate); // (cycles/step)
 8010852:	4b69      	ldr	r3, [pc, #420]	; (80109f8 <st_prep_buffer+0x428>)
        float inv_rate = dt / ((float)prep.steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
 8010854:	4682      	mov	sl, r0
        uint32_t cycles = (uint32_t)ceilf(cycles_per_min * inv_rate); // (cycles/step)
 8010856:	6819      	ldr	r1, [r3, #0]
 8010858:	f7ef ff9c 	bl	8000794 <__aeabi_fmul>
 801085c:	f002 f9ce 	bl	8012bfc <ceilf>
 8010860:	f7f0 f99a 	bl	8000b98 <__aeabi_f2uiz>

        // Record end position of segment relative to block if spindle synchronized motion
        if((prep_segment->spindle_sync = pl_block->condition.spindle.synchronized)) {
 8010864:	4a61      	ldr	r2, [pc, #388]	; (80109ec <st_prep_buffer+0x41c>)
 8010866:	9907      	ldr	r1, [sp, #28]
 8010868:	f8d2 b000 	ldr.w	fp, [r2]
 801086c:	4a61      	ldr	r2, [pc, #388]	; (80109f4 <st_prep_buffer+0x424>)
        uint32_t cycles = (uint32_t)ceilf(cycles_per_min * inv_rate); // (cycles/step)
 801086e:	4605      	mov	r5, r0
        if((prep_segment->spindle_sync = pl_block->condition.spindle.synchronized)) {
 8010870:	1853      	adds	r3, r2, r1
 8010872:	f89b 2016 	ldrb.w	r2, [fp, #22]
 8010876:	9301      	str	r3, [sp, #4]
 8010878:	f3c2 11c0 	ubfx	r1, r2, #7, #1
 801087c:	09d2      	lsrs	r2, r2, #7
 801087e:	7659      	strb	r1, [r3, #25]
 8010880:	d012      	beq.n	80108a8 <st_prep_buffer+0x2d8>
            prep.target_position += dt * prep.target_feed;
 8010882:	4620      	mov	r0, r4
 8010884:	9c03      	ldr	r4, [sp, #12]
 8010886:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8010888:	f7ef ff84 	bl	8000794 <__aeabi_fmul>
 801088c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 801088e:	f7ef fe79 	bl	8000584 <__addsf3>
            prep_segment->cruising = prep.ramp_type == Ramp_Cruise;
 8010892:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
            prep_segment->target_position = prep.target_position; //st_prep_block->millimeters - pl_block->millimeters;
 8010896:	9b01      	ldr	r3, [sp, #4]
            prep_segment->cruising = prep.ramp_type == Ramp_Cruise;
 8010898:	f1a2 0201 	sub.w	r2, r2, #1
 801089c:	fab2 f282 	clz	r2, r2
 80108a0:	0952      	lsrs	r2, r2, #5
            prep.target_position += dt * prep.target_feed;
 80108a2:	6420      	str	r0, [r4, #64]	; 0x40
            prep_segment->target_position = prep.target_position; //st_prep_block->millimeters - pl_block->millimeters;
 80108a4:	60d8      	str	r0, [r3, #12]
            prep_segment->cruising = prep.ramp_type == Ramp_Cruise;
 80108a6:	769a      	strb	r2, [r3, #26]
        }

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // Compute step timing and multi-axis smoothing level.
        // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
        if (cycles < amass.level_1)
 80108a8:	4b54      	ldr	r3, [pc, #336]	; (80109fc <st_prep_buffer+0x42c>)
 80108aa:	681a      	ldr	r2, [r3, #0]
 80108ac:	42aa      	cmp	r2, r5
 80108ae:	f240 80e2 	bls.w	8010a76 <st_prep_buffer+0x4a6>
            prep_segment->amass_level = 0;
 80108b2:	2200      	movs	r2, #0
 80108b4:	9907      	ldr	r1, [sp, #28]
 80108b6:	4b4f      	ldr	r3, [pc, #316]	; (80109f4 <st_prep_buffer+0x424>)
 80108b8:	440b      	add	r3, r1
 80108ba:	61da      	str	r2, [r3, #28]
 80108bc:	460b      	mov	r3, r1
      #endif

        prep_segment->cycles_per_tick = cycles;

        // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
        segment_buffer_head = segment_next_head;
 80108be:	4a50      	ldr	r2, [pc, #320]	; (8010a00 <st_prep_buffer+0x430>)
        prep_segment->cycles_per_tick = cycles;
 80108c0:	494c      	ldr	r1, [pc, #304]	; (80109f4 <st_prep_buffer+0x424>)
        segment_buffer_head = segment_next_head;
 80108c2:	6814      	ldr	r4, [r2, #0]
        prep_segment->cycles_per_tick = cycles;
 80108c4:	440b      	add	r3, r1
 80108c6:	609d      	str	r5, [r3, #8]
        segment_buffer_head = segment_next_head;
 80108c8:	4b4e      	ldr	r3, [pc, #312]	; (8010a04 <st_prep_buffer+0x434>)
        segment_next_head = segment_next_head == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_next_head + 1;
 80108ca:	2c09      	cmp	r4, #9
        segment_buffer_head = segment_next_head;
 80108cc:	601c      	str	r4, [r3, #0]
        segment_next_head = segment_next_head == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_next_head + 1;
 80108ce:	f000 80eb 	beq.w	8010aa8 <st_prep_buffer+0x4d8>

        // Update the appropriate planner and segment data.
        pl_block->millimeters = mm_remaining;
        prep.steps_remaining = n_steps_remaining;
 80108d2:	9d03      	ldr	r5, [sp, #12]
        segment_next_head = segment_next_head == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_next_head + 1;
 80108d4:	3401      	adds	r4, #1
 80108d6:	6014      	str	r4, [r2, #0]
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 80108d8:	4630      	mov	r0, r6
        pl_block->millimeters = mm_remaining;
 80108da:	f8cb 902c 	str.w	r9, [fp, #44]	; 0x2c
        prep.steps_remaining = n_steps_remaining;
 80108de:	60ae      	str	r6, [r5, #8]
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 80108e0:	f7ef ff00 	bl	80006e4 <__aeabi_ui2f>
 80108e4:	4639      	mov	r1, r7
 80108e6:	f7ef fe4b 	bl	8000580 <__aeabi_fsub>
 80108ea:	4651      	mov	r1, sl
 80108ec:	f7ef ff52 	bl	8000794 <__aeabi_fmul>

        // Check for exit conditions and flag to load next planner block.
        if (mm_remaining <= prep.mm_complete) {
 80108f0:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 80108f2:	6068      	str	r0, [r5, #4]
        if (mm_remaining <= prep.mm_complete) {
 80108f4:	4648      	mov	r0, r9
 80108f6:	f7f0 f8f5 	bl	8000ae4 <__aeabi_fcmple>
 80108fa:	2800      	cmp	r0, #0
 80108fc:	f43f ae72 	beq.w	80105e4 <st_prep_buffer+0x14>

            // End of planner block or forced-termination. No more distance to be executed.
            if (mm_remaining > 0.0f) { // At end of forced-termination.
 8010900:	4648      	mov	r0, r9
 8010902:	2100      	movs	r1, #0
 8010904:	f7f0 f902 	bl	8000b0c <__aeabi_fcmpgt>
 8010908:	2800      	cmp	r0, #0
 801090a:	f040 837d 	bne.w	8011008 <st_prep_buffer+0xa38>
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
                    prep.recalculate.hold_partial_block = On;
                return; // Bail!
            } else { // End of planner block
                // The planner block is complete. All steps are set to be executed in the segment buffer.
                if (sys.step_control.execute_sys_motion) {
 801090e:	4b36      	ldr	r3, [pc, #216]	; (80109e8 <st_prep_buffer+0x418>)
 8010910:	7a9b      	ldrb	r3, [r3, #10]
 8010912:	461a      	mov	r2, r3
 8010914:	f013 0304 	ands.w	r3, r3, #4
 8010918:	f040 8382 	bne.w	8011020 <st_prep_buffer+0xa50>
                    sys.step_control.end_motion = On;
                    return;
                }
                pl_block = NULL; // Set pointer to indicate check and load next planner block.
 801091c:	4a33      	ldr	r2, [pc, #204]	; (80109ec <st_prep_buffer+0x41c>)
 801091e:	6013      	str	r3, [r2, #0]
                plan_discard_current_block();
 8010920:	f7f9 ff56 	bl	800a7d0 <plan_discard_current_block>
 8010924:	e65c      	b.n	80105e0 <st_prep_buffer+0x10>
                    speed_var = pl_block->acceleration * time_var;
 8010926:	9b01      	ldr	r3, [sp, #4]
 8010928:	4658      	mov	r0, fp
 801092a:	6a99      	ldr	r1, [r3, #40]	; 0x28
 801092c:	f7ef ff32 	bl	8000794 <__aeabi_fmul>
                    mm_remaining -= time_var * (prep.current_speed + 0.5f * speed_var);
 8010930:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
                    speed_var = pl_block->acceleration * time_var;
 8010934:	4682      	mov	sl, r0
                    mm_remaining -= time_var * (prep.current_speed + 0.5f * speed_var);
 8010936:	f7ef ff2d 	bl	8000794 <__aeabi_fmul>
 801093a:	4639      	mov	r1, r7
 801093c:	f7ef fe22 	bl	8000584 <__addsf3>
 8010940:	4659      	mov	r1, fp
 8010942:	f7ef ff27 	bl	8000794 <__aeabi_fmul>
 8010946:	4601      	mov	r1, r0
 8010948:	4648      	mov	r0, r9
 801094a:	f7ef fe19 	bl	8000580 <__aeabi_fsub>
                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 801094e:	9904      	ldr	r1, [sp, #16]
                    mm_remaining -= time_var * (prep.current_speed + 0.5f * speed_var);
 8010950:	4681      	mov	r9, r0
                    if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
 8010952:	f7f0 f8bd 	bl	8000ad0 <__aeabi_fcmplt>
 8010956:	2800      	cmp	r0, #0
 8010958:	d06e      	beq.n	8010a38 <st_prep_buffer+0x468>
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801095a:	4638      	mov	r0, r7
 801095c:	9f02      	ldr	r7, [sp, #8]
 801095e:	4639      	mov	r1, r7
 8010960:	f7ef fe10 	bl	8000584 <__addsf3>
 8010964:	4601      	mov	r1, r0
 8010966:	9808      	ldr	r0, [sp, #32]
 8010968:	f7ef ffc8 	bl	80008fc <__aeabi_fdiv>
                        prep.ramp_type = mm_remaining == prep.decelerate_after ? Ramp_Decel : Ramp_Cruise;
 801096c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801096e:	4683      	mov	fp, r0
                        mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
 8010970:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8010974:	e6de      	b.n	8010734 <st_prep_buffer+0x164>
                    speed_var = pl_block->acceleration * time_var;
 8010976:	9b01      	ldr	r3, [sp, #4]
 8010978:	4658      	mov	r0, fp
 801097a:	6a99      	ldr	r1, [r3, #40]	; 0x28
 801097c:	f7ef ff0a 	bl	8000794 <__aeabi_fmul>
 8010980:	4682      	mov	sl, r0
                    if ((prep.current_speed - prep.maximum_speed) <= speed_var) {
 8010982:	9902      	ldr	r1, [sp, #8]
 8010984:	4638      	mov	r0, r7
 8010986:	f7ef fdfb 	bl	8000580 <__aeabi_fsub>
 801098a:	4651      	mov	r1, sl
 801098c:	f7f0 f8aa 	bl	8000ae4 <__aeabi_fcmple>
 8010990:	2800      	cmp	r0, #0
 8010992:	d057      	beq.n	8010a44 <st_prep_buffer+0x474>
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 8010994:	4638      	mov	r0, r7
 8010996:	9f02      	ldr	r7, [sp, #8]
                        prep.ramp_type = Ramp_Cruise;
 8010998:	2501      	movs	r5, #1
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 801099a:	4639      	mov	r1, r7
 801099c:	f7ef fdf2 	bl	8000584 <__addsf3>
 80109a0:	4601      	mov	r1, r0
 80109a2:	9808      	ldr	r0, [sp, #32]
 80109a4:	f7ef ffaa 	bl	80008fc <__aeabi_fdiv>
                        mm_remaining = prep.accelerate_until;
 80109a8:	f8dd 9010 	ldr.w	r9, [sp, #16]
                        time_var = 2.0f * (pl_block->millimeters - mm_remaining) / (prep.current_speed + prep.maximum_speed);
 80109ac:	4683      	mov	fp, r0
                        prep.current_speed = prep.maximum_speed;
 80109ae:	e6c1      	b.n	8010734 <st_prep_buffer+0x164>
                    mm_var = mm_remaining - prep.maximum_speed * time_var;
 80109b0:	9902      	ldr	r1, [sp, #8]
 80109b2:	4658      	mov	r0, fp
 80109b4:	f7ef feee 	bl	8000794 <__aeabi_fmul>
 80109b8:	4601      	mov	r1, r0
 80109ba:	4648      	mov	r0, r9
 80109bc:	f7ef fde0 	bl	8000580 <__aeabi_fsub>
                    if (mm_var < prep.decelerate_after) { // End of cruise.
 80109c0:	9906      	ldr	r1, [sp, #24]
                    mm_var = mm_remaining - prep.maximum_speed * time_var;
 80109c2:	4682      	mov	sl, r0
                    if (mm_var < prep.decelerate_after) { // End of cruise.
 80109c4:	f7f0 f884 	bl	8000ad0 <__aeabi_fcmplt>
 80109c8:	2800      	cmp	r0, #0
 80109ca:	d033      	beq.n	8010a34 <st_prep_buffer+0x464>
                        time_var = (mm_remaining - prep.decelerate_after) / prep.maximum_speed;
 80109cc:	4648      	mov	r0, r9
 80109ce:	f8dd 9018 	ldr.w	r9, [sp, #24]
                        prep.ramp_type = Ramp_Decel;
 80109d2:	2502      	movs	r5, #2
                        time_var = (mm_remaining - prep.decelerate_after) / prep.maximum_speed;
 80109d4:	4649      	mov	r1, r9
 80109d6:	f7ef fdd3 	bl	8000580 <__aeabi_fsub>
 80109da:	990a      	ldr	r1, [sp, #40]	; 0x28
 80109dc:	f7ef feda 	bl	8000794 <__aeabi_fmul>
 80109e0:	4683      	mov	fp, r0
                        prep.ramp_type = Ramp_Decel;
 80109e2:	e6a7      	b.n	8010734 <st_prep_buffer+0x164>
 80109e4:	392ec33e 	.word	0x392ec33e
 80109e8:	20002494 	.word	0x20002494
 80109ec:	20001b48 	.word	0x20001b48
 80109f0:	200024bc 	.word	0x200024bc
 80109f4:	20001b9c 	.word	0x20001b9c
 80109f8:	20001b44 	.word	0x20001b44
 80109fc:	20001b38 	.word	0x20001b38
 8010a00:	20001ce4 	.word	0x20001ce4
 8010a04:	20001cdc 	.word	0x20001cdc
                    time_var = 2.0f * (mm_remaining - prep.mm_complete) / (prep.current_speed + prep.exit_speed);
 8010a08:	4648      	mov	r0, r9
 8010a0a:	4641      	mov	r1, r8
 8010a0c:	f7ef fdb8 	bl	8000580 <__aeabi_fsub>
 8010a10:	4601      	mov	r1, r0
 8010a12:	f7ef fdb7 	bl	8000584 <__addsf3>
 8010a16:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 8010a1a:	4681      	mov	r9, r0
 8010a1c:	4651      	mov	r1, sl
 8010a1e:	4638      	mov	r0, r7
 8010a20:	f7ef fdb0 	bl	8000584 <__addsf3>
 8010a24:	4601      	mov	r1, r0
 8010a26:	4648      	mov	r0, r9
 8010a28:	f7ef ff68 	bl	80008fc <__aeabi_fdiv>
                    prep.current_speed = prep.exit_speed;
 8010a2c:	4657      	mov	r7, sl
                    time_var = 2.0f * (mm_remaining - prep.mm_complete) / (prep.current_speed + prep.exit_speed);
 8010a2e:	4683      	mov	fp, r0
                    mm_remaining = prep.mm_complete;
 8010a30:	46c1      	mov	r9, r8
 8010a32:	e67f      	b.n	8010734 <st_prep_buffer+0x164>
                        mm_remaining = mm_var;
 8010a34:	46d1      	mov	r9, sl
 8010a36:	e67d      	b.n	8010734 <st_prep_buffer+0x164>
                        prep.current_speed += speed_var;
 8010a38:	4638      	mov	r0, r7
 8010a3a:	4651      	mov	r1, sl
 8010a3c:	f7ef fda2 	bl	8000584 <__addsf3>
 8010a40:	4607      	mov	r7, r0
 8010a42:	e677      	b.n	8010734 <st_prep_buffer+0x164>
                        mm_remaining -= time_var * (prep.current_speed - 0.5f * speed_var);
 8010a44:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8010a48:	4650      	mov	r0, sl
 8010a4a:	f7ef fea3 	bl	8000794 <__aeabi_fmul>
 8010a4e:	4639      	mov	r1, r7
 8010a50:	f7ef fd96 	bl	8000580 <__aeabi_fsub>
 8010a54:	4659      	mov	r1, fp
 8010a56:	f7ef fe9d 	bl	8000794 <__aeabi_fmul>
 8010a5a:	4601      	mov	r1, r0
 8010a5c:	4648      	mov	r0, r9
 8010a5e:	f7ef fd91 	bl	8000584 <__addsf3>
                        prep.current_speed -= speed_var;
 8010a62:	4651      	mov	r1, sl
                        mm_remaining -= time_var * (prep.current_speed - 0.5f * speed_var);
 8010a64:	4681      	mov	r9, r0
                        prep.current_speed -= speed_var;
 8010a66:	4638      	mov	r0, r7
 8010a68:	f7ef fd8a 	bl	8000580 <__aeabi_fsub>
 8010a6c:	4607      	mov	r7, r0
 8010a6e:	e661      	b.n	8010734 <st_prep_buffer+0x164>
 8010a70:	f04f 0201 	mov.w	r2, #1
 8010a74:	e609      	b.n	801068a <st_prep_buffer+0xba>
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 8010a76:	685a      	ldr	r2, [r3, #4]
 8010a78:	42aa      	cmp	r2, r5
 8010a7a:	f200 80a3 	bhi.w	8010bc4 <st_prep_buffer+0x5f4>
 8010a7e:	689a      	ldr	r2, [r3, #8]
 8010a80:	42aa      	cmp	r2, r5
 8010a82:	bf8c      	ite	hi
 8010a84:	2202      	movhi	r2, #2
 8010a86:	2203      	movls	r2, #3
 8010a88:	9807      	ldr	r0, [sp, #28]
 8010a8a:	4990      	ldr	r1, [pc, #576]	; (8010ccc <st_prep_buffer+0x6fc>)
            prep_segment->n_step <<= prep_segment->amass_level;
 8010a8c:	fa08 f302 	lsl.w	r3, r8, r2
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 8010a90:	4401      	add	r1, r0
            prep_segment->n_step <<= prep_segment->amass_level;
 8010a92:	610b      	str	r3, [r1, #16]
            cycles >>= prep_segment->amass_level;
 8010a94:	40d5      	lsrs	r5, r2
 8010a96:	4603      	mov	r3, r0
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 8010a98:	61ca      	str	r2, [r1, #28]
            prep_segment->n_step <<= prep_segment->amass_level;
 8010a9a:	e710      	b.n	80108be <st_prep_buffer+0x2ee>
                sys.spindle_rpm = rpm = 0.0f;
 8010a9c:	2600      	movs	r6, #0
 8010a9e:	9b03      	ldr	r3, [sp, #12]
 8010aa0:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
 8010aa2:	4b8b      	ldr	r3, [pc, #556]	; (8010cd0 <st_prep_buffer+0x700>)
 8010aa4:	619e      	str	r6, [r3, #24]
 8010aa6:	e691      	b.n	80107cc <st_prep_buffer+0x1fc>
        segment_next_head = segment_next_head == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_next_head + 1;
 8010aa8:	2300      	movs	r3, #0
 8010aaa:	4a8a      	ldr	r2, [pc, #552]	; (8010cd4 <st_prep_buffer+0x704>)
        prep.steps_remaining = n_steps_remaining;
 8010aac:	9c03      	ldr	r4, [sp, #12]
        segment_next_head = segment_next_head == (SEGMENT_BUFFER_SIZE - 1) ? 0 : segment_next_head + 1;
 8010aae:	6013      	str	r3, [r2, #0]
        prep.steps_remaining = n_steps_remaining;
 8010ab0:	60a6      	str	r6, [r4, #8]
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 8010ab2:	4630      	mov	r0, r6
        pl_block->millimeters = mm_remaining;
 8010ab4:	f8cb 902c 	str.w	r9, [fp, #44]	; 0x2c
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 8010ab8:	f7ef fe14 	bl	80006e4 <__aeabi_ui2f>
 8010abc:	4639      	mov	r1, r7
 8010abe:	f7ef fd5f 	bl	8000580 <__aeabi_fsub>
 8010ac2:	4651      	mov	r1, sl
 8010ac4:	f7ef fe66 	bl	8000794 <__aeabi_fmul>
        if (mm_remaining <= prep.mm_complete) {
 8010ac8:	4649      	mov	r1, r9
        prep.dt_remainder = ((float)n_steps_remaining - step_dist_remaining) * inv_rate;
 8010aca:	6060      	str	r0, [r4, #4]
        if (mm_remaining <= prep.mm_complete) {
 8010acc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8010ace:	f7f0 f813 	bl	8000af8 <__aeabi_fcmpge>
 8010ad2:	4604      	mov	r4, r0
 8010ad4:	2800      	cmp	r0, #0
 8010ad6:	f47f af13 	bne.w	8010900 <st_prep_buffer+0x330>
    while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
 8010ada:	4b7f      	ldr	r3, [pc, #508]	; (8010cd8 <st_prep_buffer+0x708>)
 8010adc:	681b      	ldr	r3, [r3, #0]
 8010ade:	42a3      	cmp	r3, r4
 8010ae0:	f47f ad85 	bne.w	80105ee <st_prep_buffer+0x1e>
            }
        }
    }
}
 8010ae4:	b00f      	add	sp, #60	; 0x3c
 8010ae6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            pl_block = sys.step_control.execute_sys_motion ? plan_get_system_motion_block() : plan_get_current_block();
 8010aea:	4b79      	ldr	r3, [pc, #484]	; (8010cd0 <st_prep_buffer+0x700>)
 8010aec:	7a9b      	ldrb	r3, [r3, #10]
 8010aee:	075a      	lsls	r2, r3, #29
 8010af0:	d576      	bpl.n	8010be0 <st_prep_buffer+0x610>
 8010af2:	f7f9 fea1 	bl	800a838 <plan_get_system_motion_block>
 8010af6:	4602      	mov	r2, r0
 8010af8:	9001      	str	r0, [sp, #4]
 8010afa:	4b78      	ldr	r3, [pc, #480]	; (8010cdc <st_prep_buffer+0x70c>)
 8010afc:	601a      	str	r2, [r3, #0]
            if (pl_block == NULL)
 8010afe:	2a00      	cmp	r2, #0
 8010b00:	d0f0      	beq.n	8010ae4 <st_prep_buffer+0x514>
            if (prep.recalculate.velocity_profile) {
 8010b02:	4977      	ldr	r1, [pc, #476]	; (8010ce0 <st_prep_buffer+0x710>)
 8010b04:	780c      	ldrb	r4, [r1, #0]
 8010b06:	9103      	str	r1, [sp, #12]
 8010b08:	f014 0b01 	ands.w	fp, r4, #1
 8010b0c:	f000 80ee 	beq.w	8010cec <st_prep_buffer+0x71c>
                if(settings.parking.flags.enabled) {
 8010b10:	4b74      	ldr	r3, [pc, #464]	; (8010ce4 <st_prep_buffer+0x714>)
 8010b12:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
 8010b16:	f013 0301 	ands.w	r3, r3, #1
 8010b1a:	d055      	beq.n	8010bc8 <st_prep_buffer+0x5f8>
                    if (prep.recalculate.parking)
 8010b1c:	f014 0304 	ands.w	r3, r4, #4
 8010b20:	d052      	beq.n	8010bc8 <st_prep_buffer+0x5f8>
                        prep.recalculate.velocity_profile = Off;
 8010b22:	4b6b      	ldr	r3, [pc, #428]	; (8010cd0 <st_prep_buffer+0x700>)
 8010b24:	f36f 0400 	bfc	r4, #0, #1
 8010b28:	7a9d      	ldrb	r5, [r3, #10]
 8010b2a:	f8d2 902c 	ldr.w	r9, [r2, #44]	; 0x2c
 8010b2e:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 8010ce8 <st_prep_buffer+0x718>
 8010b32:	700c      	strb	r4, [r1, #0]
 8010b34:	f005 0702 	and.w	r7, r5, #2
            prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 8010b38:	2200      	movs	r2, #0
            float inv_2_accel = 0.5f / pl_block->acceleration;
 8010b3a:	9b01      	ldr	r3, [sp, #4]
 8010b3c:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
 8010b40:	6a9e      	ldr	r6, [r3, #40]	; 0x28
            prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 8010b42:	9b03      	ldr	r3, [sp, #12]
            float inv_2_accel = 0.5f / pl_block->acceleration;
 8010b44:	4631      	mov	r1, r6
            prep.mm_complete = 0.0f; // Default velocity profile complete at 0.0mm from end of block.
 8010b46:	629a      	str	r2, [r3, #40]	; 0x28
            float inv_2_accel = 0.5f / pl_block->acceleration;
 8010b48:	f7ef fed8 	bl	80008fc <__aeabi_fdiv>
 8010b4c:	4604      	mov	r4, r0
            if (sys.step_control.execute_hold) { // [Forced Deceleration to Zero Velocity]
 8010b4e:	2f00      	cmp	r7, #0
 8010b50:	d04b      	beq.n	8010bea <st_prep_buffer+0x61a>
                prep.ramp_type = Ramp_Decel;
 8010b52:	2502      	movs	r5, #2
 8010b54:	9a03      	ldr	r2, [sp, #12]
                float decel_dist = pl_block->millimeters - inv_2_accel * pl_block->entry_speed_sqr;
 8010b56:	9b01      	ldr	r3, [sp, #4]
                prep.ramp_type = Ramp_Decel;
 8010b58:	f882 5024 	strb.w	r5, [r2, #36]	; 0x24
                float decel_dist = pl_block->millimeters - inv_2_accel * pl_block->entry_speed_sqr;
 8010b5c:	6a1f      	ldr	r7, [r3, #32]
 8010b5e:	4601      	mov	r1, r0
 8010b60:	4638      	mov	r0, r7
 8010b62:	f7ef fe17 	bl	8000794 <__aeabi_fmul>
 8010b66:	4601      	mov	r1, r0
 8010b68:	4648      	mov	r0, r9
 8010b6a:	f7ef fd09 	bl	8000580 <__aeabi_fsub>
                if (decel_dist < 0.0f) {
 8010b6e:	2100      	movs	r1, #0
                float decel_dist = pl_block->millimeters - inv_2_accel * pl_block->entry_speed_sqr;
 8010b70:	4680      	mov	r8, r0
                if (decel_dist < 0.0f) {
 8010b72:	f7ef ffad 	bl	8000ad0 <__aeabi_fcmplt>
 8010b76:	2800      	cmp	r0, #0
 8010b78:	f040 8160 	bne.w	8010e3c <st_prep_buffer+0x86c>
                    prep.exit_speed = 0.0f;
 8010b7c:	2200      	movs	r2, #0
 8010b7e:	9c03      	ldr	r4, [sp, #12]
 8010b80:	4648      	mov	r0, r9
 8010b82:	6ba1      	ldr	r1, [r4, #56]	; 0x38
                    prep.mm_complete = decel_dist; // End of feed hold.
 8010b84:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
                    prep.exit_speed = 0.0f;
 8010b88:	6362      	str	r2, [r4, #52]	; 0x34
 8010b8a:	9104      	str	r1, [sp, #16]
 8010b8c:	f7ef fcf8 	bl	8000580 <__aeabi_fsub>
 8010b90:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8010b92:	4607      	mov	r7, r0
 8010b94:	9302      	str	r3, [sp, #8]
 8010b96:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8010b98:	9306      	str	r3, [sp, #24]
 8010b9a:	2300      	movs	r3, #0
 8010b9c:	9309      	str	r3, [sp, #36]	; 0x24
            if(sys.state != STATE_HOMING)
 8010b9e:	484c      	ldr	r0, [pc, #304]	; (8010cd0 <st_prep_buffer+0x700>)
 8010ba0:	6803      	ldr	r3, [r0, #0]
 8010ba2:	2b04      	cmp	r3, #4
 8010ba4:	f43f ad40 	beq.w	8010628 <st_prep_buffer+0x58>
                sys.step_control.update_spindle_rpm |= settings.flags.laser_mode; // Force update whenever updating block in laser mode.
 8010ba8:	7a83      	ldrb	r3, [r0, #10]
 8010baa:	4a4e      	ldr	r2, [pc, #312]	; (8010ce4 <st_prep_buffer+0x714>)
 8010bac:	4619      	mov	r1, r3
 8010bae:	f892 20bc 	ldrb.w	r2, [r2, #188]	; 0xbc
 8010bb2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010bb6:	f3c2 0240 	ubfx	r2, r2, #1, #1
 8010bba:	4313      	orrs	r3, r2
 8010bbc:	f363 01c3 	bfi	r1, r3, #3, #1
 8010bc0:	7281      	strb	r1, [r0, #10]
 8010bc2:	e531      	b.n	8010628 <st_prep_buffer+0x58>
            prep_segment->amass_level = cycles < amass.level_2 ? 1 : (cycles < amass.level_3 ? 2 : 3);
 8010bc4:	2201      	movs	r2, #1
 8010bc6:	e75f      	b.n	8010a88 <st_prep_buffer+0x4b8>
                    prep.recalculate.flags = 0;
 8010bc8:	4a41      	ldr	r2, [pc, #260]	; (8010cd0 <st_prep_buffer+0x700>)
 8010bca:	f8df a11c 	ldr.w	sl, [pc, #284]	; 8010ce8 <st_prep_buffer+0x718>
 8010bce:	7a95      	ldrb	r5, [r2, #10]
 8010bd0:	9a03      	ldr	r2, [sp, #12]
 8010bd2:	f005 0702 	and.w	r7, r5, #2
 8010bd6:	7013      	strb	r3, [r2, #0]
 8010bd8:	9b01      	ldr	r3, [sp, #4]
 8010bda:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
 8010bde:	e7ab      	b.n	8010b38 <st_prep_buffer+0x568>
            pl_block = sys.step_control.execute_sys_motion ? plan_get_system_motion_block() : plan_get_current_block();
 8010be0:	f7f9 fe36 	bl	800a850 <plan_get_current_block>
 8010be4:	4602      	mov	r2, r0
 8010be6:	9001      	str	r0, [sp, #4]
 8010be8:	e787      	b.n	8010afa <st_prep_buffer+0x52a>
                prep.ramp_type = Ramp_Accel; // Initialize as acceleration ramp.
 8010bea:	9b03      	ldr	r3, [sp, #12]
 8010bec:	f883 7024 	strb.w	r7, [r3, #36]	; 0x24
                if (sys.step_control.execute_sys_motion)
 8010bf0:	076f      	lsls	r7, r5, #29
                prep.accelerate_until = pl_block->millimeters;
 8010bf2:	f8c3 9038 	str.w	r9, [r3, #56]	; 0x38
                if (sys.step_control.execute_sys_motion)
 8010bf6:	f140 8156 	bpl.w	8010ea6 <st_prep_buffer+0x8d6>
                    prep.exit_speed = exit_speed_sqr = 0.0f; // Enforce stop at end of system motion.
 8010bfa:	2200      	movs	r2, #0
 8010bfc:	4690      	mov	r8, r2
 8010bfe:	635a      	str	r2, [r3, #52]	; 0x34
                float nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 8010c00:	9801      	ldr	r0, [sp, #4]
 8010c02:	f7f9 fe61 	bl	800a8c8 <plan_compute_profile_nominal_speed>
                float nominal_speed_sqr = nominal_speed * nominal_speed;
 8010c06:	4601      	mov	r1, r0
                float nominal_speed = plan_compute_profile_nominal_speed(pl_block);
 8010c08:	4683      	mov	fp, r0
 8010c0a:	9002      	str	r0, [sp, #8]
                float nominal_speed_sqr = nominal_speed * nominal_speed;
 8010c0c:	f7ef fdc2 	bl	8000794 <__aeabi_fmul>
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010c10:	4b32      	ldr	r3, [pc, #200]	; (8010cdc <st_prep_buffer+0x70c>)
                prep.target_feed = nominal_speed;
 8010c12:	9f03      	ldr	r7, [sp, #12]
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010c14:	681b      	ldr	r3, [r3, #0]
                float nominal_speed_sqr = nominal_speed * nominal_speed;
 8010c16:	4606      	mov	r6, r0
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010c18:	6a1d      	ldr	r5, [r3, #32]
                if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 8010c1a:	4601      	mov	r1, r0
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010c1c:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
                if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 8010c20:	4628      	mov	r0, r5
                prep.target_feed = nominal_speed;
 8010c22:	f8c7 b044 	str.w	fp, [r7, #68]	; 0x44
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010c26:	9301      	str	r3, [sp, #4]
                if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
 8010c28:	f7ef ff70 	bl	8000b0c <__aeabi_fcmpgt>
 8010c2c:	2800      	cmp	r0, #0
 8010c2e:	f000 80c2 	beq.w	8010db6 <st_prep_buffer+0x7e6>
                    prep.accelerate_until = pl_block->millimeters - inv_2_accel * (pl_block->entry_speed_sqr - nominal_speed_sqr);
 8010c32:	4629      	mov	r1, r5
 8010c34:	4630      	mov	r0, r6
 8010c36:	f7ef fca3 	bl	8000580 <__aeabi_fsub>
 8010c3a:	4621      	mov	r1, r4
 8010c3c:	f7ef fdaa 	bl	8000794 <__aeabi_fmul>
 8010c40:	4607      	mov	r7, r0
 8010c42:	4648      	mov	r0, r9
 8010c44:	4639      	mov	r1, r7
 8010c46:	f7ef fc9d 	bl	8000584 <__addsf3>
 8010c4a:	9a03      	ldr	r2, [sp, #12]
                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 8010c4c:	2100      	movs	r1, #0
                    prep.accelerate_until = pl_block->millimeters - inv_2_accel * (pl_block->entry_speed_sqr - nominal_speed_sqr);
 8010c4e:	6390      	str	r0, [r2, #56]	; 0x38
 8010c50:	9004      	str	r0, [sp, #16]
                    if (prep.accelerate_until <= 0.0f) { // Deceleration-only.
 8010c52:	f7ef ff47 	bl	8000ae4 <__aeabi_fcmple>
 8010c56:	2800      	cmp	r0, #0
 8010c58:	f040 815a 	bne.w	8010f10 <st_prep_buffer+0x940>
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
 8010c5c:	4641      	mov	r1, r8
 8010c5e:	4630      	mov	r0, r6
 8010c60:	f7ef fc8e 	bl	8000580 <__aeabi_fsub>
 8010c64:	4621      	mov	r1, r4
 8010c66:	f7ef fd95 	bl	8000794 <__aeabi_fmul>
                        prep.maximum_speed = nominal_speed;
 8010c6a:	9b03      	ldr	r3, [sp, #12]
 8010c6c:	9902      	ldr	r1, [sp, #8]
 8010c6e:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 8010c72:	6319      	str	r1, [r3, #48]	; 0x30
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
 8010c74:	63d8      	str	r0, [r3, #60]	; 0x3c
                        prep.ramp_type = Ramp_DecelOverride;
 8010c76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
                        prep.maximum_speed = nominal_speed;
 8010c78:	2503      	movs	r5, #3
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
 8010c7a:	9006      	str	r0, [sp, #24]
 8010c7c:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
 8010c80:	9309      	str	r3, [sp, #36]	; 0x24
 8010c82:	e78c      	b.n	8010b9e <st_prep_buffer+0x5ce>
                    float npos = (float)(pl_block->step_event_count - prep.steps_remaining) / (float)pl_block->step_event_count;
 8010c84:	9b03      	ldr	r3, [sp, #12]
 8010c86:	f8d5 800c 	ldr.w	r8, [r5, #12]
 8010c8a:	6898      	ldr	r0, [r3, #8]
 8010c8c:	eba8 0000 	sub.w	r0, r8, r0
 8010c90:	f7ef fd28 	bl	80006e4 <__aeabi_ui2f>
 8010c94:	4607      	mov	r7, r0
 8010c96:	4640      	mov	r0, r8
 8010c98:	f7ef fd24 	bl	80006e4 <__aeabi_ui2f>
 8010c9c:	4601      	mov	r1, r0
 8010c9e:	4638      	mov	r0, r7
 8010ca0:	f7ef fe2c 	bl	80008fc <__aeabi_fdiv>
 8010ca4:	4607      	mov	r7, r0
                    rpm += (spindle_set_rpm(pl_block->spindle.css.target_rpm, sys.override.spindle_rpm) - prep.current_spindle_rpm) * npos;
 8010ca6:	4a0a      	ldr	r2, [pc, #40]	; (8010cd0 <st_prep_buffer+0x700>)
 8010ca8:	6c68      	ldr	r0, [r5, #68]	; 0x44
 8010caa:	7c11      	ldrb	r1, [r2, #16]
 8010cac:	f7fe f862 	bl	800ed74 <spindle_set_rpm>
 8010cb0:	9b03      	ldr	r3, [sp, #12]
 8010cb2:	6cdd      	ldr	r5, [r3, #76]	; 0x4c
 8010cb4:	4629      	mov	r1, r5
 8010cb6:	f7ef fc63 	bl	8000580 <__aeabi_fsub>
 8010cba:	4639      	mov	r1, r7
 8010cbc:	f7ef fd6a 	bl	8000794 <__aeabi_fmul>
 8010cc0:	4601      	mov	r1, r0
 8010cc2:	4630      	mov	r0, r6
 8010cc4:	f7ef fc5e 	bl	8000584 <__addsf3>
 8010cc8:	4606      	mov	r6, r0
 8010cca:	e57f      	b.n	80107cc <st_prep_buffer+0x1fc>
 8010ccc:	20001b9c 	.word	0x20001b9c
 8010cd0:	20002494 	.word	0x20002494
 8010cd4:	20001ce4 	.word	0x20001ce4
 8010cd8:	20001ce0 	.word	0x20001ce0
 8010cdc:	20001b48 	.word	0x20001b48
 8010ce0:	20001b4c 	.word	0x20001b4c
 8010ce4:	20002620 	.word	0x20002620
 8010ce8:	20001eec 	.word	0x20001eec
                st_prep_block = st_prep_block->next;
 8010cec:	4617      	mov	r7, r2
 8010cee:	f8df a314 	ldr.w	sl, [pc, #788]	; 8011004 <st_prep_buffer+0xa34>
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010cf2:	683b      	ldr	r3, [r7, #0]
                st_prep_block = st_prep_block->next;
 8010cf4:	f8da 0000 	ldr.w	r0, [sl]
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010cf8:	6891      	ldr	r1, [r2, #8]
 8010cfa:	9301      	str	r3, [sp, #4]
                st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 8010cfc:	68fd      	ldr	r5, [r7, #12]
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010cfe:	6852      	ldr	r2, [r2, #4]
                st_prep_block = st_prep_block->next;
 8010d00:	6846      	ldr	r6, [r0, #4]
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010d02:	9b01      	ldr	r3, [sp, #4]
                st_prep_block->programmed_rate = pl_block->programmed_rate;
 8010d04:	f8d7 c038 	ldr.w	ip, [r7, #56]	; 0x38
                st_prep_block->direction_bits = pl_block->direction_bits;
 8010d08:	7c38      	ldrb	r0, [r7, #16]
                st_prep_block->millimeters = pl_block->millimeters;
 8010d0a:	f8d7 902c 	ldr.w	r9, [r7, #44]	; 0x2c
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010d0e:	00c9      	lsls	r1, r1, #3
 8010d10:	00d2      	lsls	r2, r2, #3
 8010d12:	00db      	lsls	r3, r3, #3
 8010d14:	6131      	str	r1, [r6, #16]
                st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 8010d16:	00e9      	lsls	r1, r5, #3
                    st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL;
 8010d18:	e9c6 3202 	strd	r3, r2, [r6, #8]
                st_prep_block->programmed_rate = pl_block->programmed_rate;
 8010d1c:	f8c6 c024 	str.w	ip, [r6, #36]	; 0x24
                st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
 8010d20:	6171      	str	r1, [r6, #20]
                st_prep_block->direction_bits = pl_block->direction_bits;
 8010d22:	7630      	strb	r0, [r6, #24]
                st_prep_block = st_prep_block->next;
 8010d24:	f8ca 6000 	str.w	r6, [sl]
                st_prep_block->steps_per_mm = (float)pl_block->step_event_count / pl_block->millimeters;
 8010d28:	4628      	mov	r0, r5
                st_prep_block->millimeters = pl_block->millimeters;
 8010d2a:	f8c6 9020 	str.w	r9, [r6, #32]
                st_prep_block->programmed_rate = pl_block->programmed_rate;
 8010d2e:	f8cd c008 	str.w	ip, [sp, #8]
                st_prep_block->steps_per_mm = (float)pl_block->step_event_count / pl_block->millimeters;
 8010d32:	f7ef fcd7 	bl	80006e4 <__aeabi_ui2f>
 8010d36:	4649      	mov	r1, r9
 8010d38:	f7ef fde0 	bl	80008fc <__aeabi_fdiv>
 8010d3c:	4601      	mov	r1, r0
 8010d3e:	61f0      	str	r0, [r6, #28]
                st_prep_block->message = pl_block->message;
 8010d40:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010d42:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
                prep.steps_per_mm = st_prep_block->steps_per_mm;
 8010d44:	9803      	ldr	r0, [sp, #12]
                st_prep_block->message = pl_block->message;
 8010d46:	e9c6 320a 	strd	r3, r2, [r6, #40]	; 0x28
                st_prep_block->backlash_motion = pl_block->condition.backlash_motion;
 8010d4a:	f897 8014 	ldrb.w	r8, [r7, #20]
                st_prep_block->overrides = pl_block->overrides;
 8010d4e:	7e3a      	ldrb	r2, [r7, #24]
                st_prep_block->backlash_motion = pl_block->condition.backlash_motion;
 8010d50:	f3c8 03c0 	ubfx	r3, r8, #3, #1
                prep.steps_per_mm = st_prep_block->steps_per_mm;
 8010d54:	60c1      	str	r1, [r0, #12]
                prep.steps_remaining = pl_block->step_event_count;
 8010d56:	6085      	str	r5, [r0, #8]
                st_prep_block->backlash_motion = pl_block->condition.backlash_motion;
 8010d58:	f886 3031 	strb.w	r3, [r6, #49]	; 0x31
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 8010d5c:	48a5      	ldr	r0, [pc, #660]	; (8010ff4 <st_prep_buffer+0xa24>)
                st_prep_block->overrides = pl_block->overrides;
 8010d5e:	7672      	strb	r2, [r6, #25]
 8010d60:	9701      	str	r7, [sp, #4]
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 8010d62:	f7ef fdcb 	bl	80008fc <__aeabi_fdiv>
                prep.dt_remainder = prep.target_position = 0.0f; // Reset for new segment block
 8010d66:	f04f 0c00 	mov.w	ip, #0
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 8010d6a:	4da3      	ldr	r5, [pc, #652]	; (8010ff8 <st_prep_buffer+0xa28>)
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 8010d6c:	9903      	ldr	r1, [sp, #12]
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 8010d6e:	7aad      	ldrb	r5, [r5, #10]
 8010d70:	f004 0308 	and.w	r3, r4, #8
 8010d74:	f005 0702 	and.w	r7, r5, #2
                prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR / prep.steps_per_mm;
 8010d78:	6108      	str	r0, [r1, #16]
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 8010d7a:	ea57 0003 	orrs.w	r0, r7, r3
                prep.dt_remainder = prep.target_position = 0.0f; // Reset for new segment block
 8010d7e:	f8c1 c040 	str.w	ip, [r1, #64]	; 0x40
 8010d82:	f8c1 c004 	str.w	ip, [r1, #4]
                if (sys.step_control.execute_hold || prep.recalculate.decel_override) {
 8010d86:	d176      	bne.n	8010e76 <st_prep_buffer+0x8a6>
                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 8010d88:	9b01      	ldr	r3, [sp, #4]
 8010d8a:	6a18      	ldr	r0, [r3, #32]
 8010d8c:	f002 f92e 	bl	8012fec <sqrtf>
 8010d90:	9b03      	ldr	r3, [sp, #12]
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted))
 8010d92:	f018 0f40 	tst.w	r8, #64	; 0x40
                    prep.current_speed = sqrtf(pl_block->entry_speed_sqr);
 8010d96:	62d8      	str	r0, [r3, #44]	; 0x2c
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted))
 8010d98:	f3c8 1380 	ubfx	r3, r8, #6, #1
 8010d9c:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 8010da0:	d07c      	beq.n	8010e9c <st_prep_buffer+0x8cc>
                    prep.inv_feedrate = pl_block->condition.is_laser_ppi_mode ? 1.0f : 1.0f / pl_block->programmed_rate;
 8010da2:	9b01      	ldr	r3, [sp, #4]
 8010da4:	7d5b      	ldrb	r3, [r3, #21]
 8010da6:	07db      	lsls	r3, r3, #31
 8010da8:	f140 809a 	bpl.w	8010ee0 <st_prep_buffer+0x910>
 8010dac:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8010db0:	9a03      	ldr	r2, [sp, #12]
 8010db2:	6493      	str	r3, [r2, #72]	; 0x48
 8010db4:	e6c0      	b.n	8010b38 <st_prep_buffer+0x568>
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010db6:	4641      	mov	r1, r8
 8010db8:	4628      	mov	r0, r5
 8010dba:	f7ef fbe1 	bl	8000580 <__aeabi_fsub>
 8010dbe:	4621      	mov	r1, r4
 8010dc0:	f7ef fce8 	bl	8000794 <__aeabi_fmul>
 8010dc4:	4649      	mov	r1, r9
 8010dc6:	f7ef fbdd 	bl	8000584 <__addsf3>
 8010dca:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8010dce:	f7ef fce1 	bl	8000794 <__aeabi_fmul>
                } else if (intersect_distance > 0.0f) {
 8010dd2:	2100      	movs	r1, #0
                float intersect_distance = 0.5f * (pl_block->millimeters + inv_2_accel * (pl_block->entry_speed_sqr - exit_speed_sqr));
 8010dd4:	4607      	mov	r7, r0
 8010dd6:	9004      	str	r0, [sp, #16]
                } else if (intersect_distance > 0.0f) {
 8010dd8:	f7ef fe98 	bl	8000b0c <__aeabi_fcmpgt>
 8010ddc:	2800      	cmp	r0, #0
 8010dde:	f000 8086 	beq.w	8010eee <st_prep_buffer+0x91e>
                    if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 8010de2:	4639      	mov	r1, r7
 8010de4:	4648      	mov	r0, r9
 8010de6:	f7ef fe91 	bl	8000b0c <__aeabi_fcmpgt>
 8010dea:	2800      	cmp	r0, #0
 8010dec:	d066      	beq.n	8010ebc <st_prep_buffer+0x8ec>
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr);
 8010dee:	4641      	mov	r1, r8
 8010df0:	4630      	mov	r0, r6
 8010df2:	f7ef fbc5 	bl	8000580 <__aeabi_fsub>
 8010df6:	4621      	mov	r1, r4
 8010df8:	f7ef fccc 	bl	8000794 <__aeabi_fmul>
                        if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 8010dfc:	4639      	mov	r1, r7
                        prep.decelerate_after = inv_2_accel * (nominal_speed_sqr - exit_speed_sqr);
 8010dfe:	9f03      	ldr	r7, [sp, #12]
 8010e00:	9006      	str	r0, [sp, #24]
 8010e02:	63f8      	str	r0, [r7, #60]	; 0x3c
                        if (prep.decelerate_after < intersect_distance) { // Trapezoid type
 8010e04:	f7ef fe64 	bl	8000ad0 <__aeabi_fcmplt>
 8010e08:	2800      	cmp	r0, #0
 8010e0a:	f000 80a2 	beq.w	8010f52 <st_prep_buffer+0x982>
                            prep.maximum_speed = nominal_speed;
 8010e0e:	9b02      	ldr	r3, [sp, #8]
                            if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 8010e10:	4631      	mov	r1, r6
 8010e12:	4628      	mov	r0, r5
                            prep.maximum_speed = nominal_speed;
 8010e14:	633b      	str	r3, [r7, #48]	; 0x30
                            if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
 8010e16:	f7ef fe51 	bl	8000abc <__aeabi_fcmpeq>
 8010e1a:	2800      	cmp	r0, #0
 8010e1c:	f000 80cf 	beq.w	8010fbe <st_prep_buffer+0x9ee>
                                prep.ramp_type = Ramp_Cruise;
 8010e20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010e22:	4648      	mov	r0, r9
 8010e24:	4619      	mov	r1, r3
 8010e26:	9304      	str	r3, [sp, #16]
 8010e28:	f7ef fbaa 	bl	8000580 <__aeabi_fsub>
 8010e2c:	463b      	mov	r3, r7
 8010e2e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010e30:	f8d7 8028 	ldr.w	r8, [r7, #40]	; 0x28
 8010e34:	2501      	movs	r5, #1
 8010e36:	4607      	mov	r7, r0
 8010e38:	9309      	str	r3, [sp, #36]	; 0x24
 8010e3a:	e6b0      	b.n	8010b9e <st_prep_buffer+0x5ce>
                    prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 8010e3c:	4631      	mov	r1, r6
 8010e3e:	4630      	mov	r0, r6
 8010e40:	f7ef fba0 	bl	8000584 <__addsf3>
 8010e44:	4649      	mov	r1, r9
 8010e46:	f7ef fca5 	bl	8000794 <__aeabi_fmul>
 8010e4a:	4601      	mov	r1, r0
 8010e4c:	4638      	mov	r0, r7
 8010e4e:	f7ef fb97 	bl	8000580 <__aeabi_fsub>
 8010e52:	f002 f8cb 	bl	8012fec <sqrtf>
 8010e56:	9c03      	ldr	r4, [sp, #12]
 8010e58:	9009      	str	r0, [sp, #36]	; 0x24
 8010e5a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8010e5c:	6360      	str	r0, [r4, #52]	; 0x34
 8010e5e:	4648      	mov	r0, r9
 8010e60:	9104      	str	r1, [sp, #16]
 8010e62:	f7ef fb8d 	bl	8000580 <__aeabi_fsub>
 8010e66:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8010e68:	4607      	mov	r7, r0
 8010e6a:	9302      	str	r3, [sp, #8]
 8010e6c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8010e6e:	f04f 0800 	mov.w	r8, #0
 8010e72:	9306      	str	r3, [sp, #24]
 8010e74:	e693      	b.n	8010b9e <st_prep_buffer+0x5ce>
                    prep.current_speed = prep.exit_speed;
 8010e76:	4608      	mov	r0, r1
 8010e78:	6b49      	ldr	r1, [r1, #52]	; 0x34
                    prep.recalculate.decel_override = Off;
 8010e7a:	f36b 04c3 	bfi	r4, fp, #3, #1
                    prep.current_speed = prep.exit_speed;
 8010e7e:	62c1      	str	r1, [r0, #44]	; 0x2c
                    pl_block->entry_speed_sqr = prep.exit_speed * prep.exit_speed;
 8010e80:	4608      	mov	r0, r1
 8010e82:	f7ef fc87 	bl	8000794 <__aeabi_fmul>
 8010e86:	9b01      	ldr	r3, [sp, #4]
                    prep.recalculate.decel_override = Off;
 8010e88:	9903      	ldr	r1, [sp, #12]
                    pl_block->entry_speed_sqr = prep.exit_speed * prep.exit_speed;
 8010e8a:	6218      	str	r0, [r3, #32]
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted))
 8010e8c:	f018 0f40 	tst.w	r8, #64	; 0x40
 8010e90:	f3c8 1380 	ubfx	r3, r8, #6, #1
                    prep.recalculate.decel_override = Off;
 8010e94:	700c      	strb	r4, [r1, #0]
                if ((st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_rate_adjusted))
 8010e96:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
 8010e9a:	d182      	bne.n	8010da2 <st_prep_buffer+0x7d2>
                    st_prep_block->dynamic_rpm = pl_block->condition.is_rpm_pos_adjusted;
 8010e9c:	f3c8 18c0 	ubfx	r8, r8, #7, #1
 8010ea0:	f886 8030 	strb.w	r8, [r6, #48]	; 0x30
 8010ea4:	e648      	b.n	8010b38 <st_prep_buffer+0x568>
                    exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
 8010ea6:	f7f9 fce7 	bl	800a878 <plan_get_exec_block_exit_speed_sqr>
 8010eaa:	4680      	mov	r8, r0
                    prep.exit_speed = sqrtf(exit_speed_sqr);
 8010eac:	f002 f89e 	bl	8012fec <sqrtf>
 8010eb0:	4b52      	ldr	r3, [pc, #328]	; (8010ffc <st_prep_buffer+0xa2c>)
 8010eb2:	681b      	ldr	r3, [r3, #0]
 8010eb4:	9301      	str	r3, [sp, #4]
 8010eb6:	9b03      	ldr	r3, [sp, #12]
 8010eb8:	6358      	str	r0, [r3, #52]	; 0x34
 8010eba:	e6a1      	b.n	8010c00 <st_prep_buffer+0x630>
                        prep.ramp_type = Ramp_Decel;
 8010ebc:	9c03      	ldr	r4, [sp, #12]
 8010ebe:	4648      	mov	r0, r9
 8010ec0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
                    if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
 8010ec2:	2502      	movs	r5, #2
 8010ec4:	4619      	mov	r1, r3
 8010ec6:	9304      	str	r3, [sp, #16]
 8010ec8:	f7ef fb5a 	bl	8000580 <__aeabi_fsub>
 8010ecc:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8010ece:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8010ed0:	9202      	str	r2, [sp, #8]
 8010ed2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8010ed4:	4607      	mov	r7, r0
 8010ed6:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
 8010eda:	9206      	str	r2, [sp, #24]
 8010edc:	9309      	str	r3, [sp, #36]	; 0x24
 8010ede:	e65e      	b.n	8010b9e <st_prep_buffer+0x5ce>
                    prep.inv_feedrate = pl_block->condition.is_laser_ppi_mode ? 1.0f : 1.0f / pl_block->programmed_rate;
 8010ee0:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8010ee4:	9902      	ldr	r1, [sp, #8]
 8010ee6:	f7ef fd09 	bl	80008fc <__aeabi_fdiv>
 8010eea:	4603      	mov	r3, r0
 8010eec:	e760      	b.n	8010db0 <st_prep_buffer+0x7e0>
                    prep.maximum_speed = prep.exit_speed;
 8010eee:	2200      	movs	r2, #0
 8010ef0:	9b03      	ldr	r3, [sp, #12]
 8010ef2:	9204      	str	r2, [sp, #16]
 8010ef4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8010ef6:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8010ef8:	9206      	str	r2, [sp, #24]
                    prep.accelerate_until = 0.0f;
 8010efa:	2200      	movs	r2, #0
                    prep.maximum_speed = prep.exit_speed;
 8010efc:	464f      	mov	r7, r9
 8010efe:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 8010f02:	f893 5024 	ldrb.w	r5, [r3, #36]	; 0x24
 8010f06:	9102      	str	r1, [sp, #8]
 8010f08:	9109      	str	r1, [sp, #36]	; 0x24
                    prep.accelerate_until = 0.0f;
 8010f0a:	639a      	str	r2, [r3, #56]	; 0x38
                    prep.maximum_speed = prep.exit_speed;
 8010f0c:	6319      	str	r1, [r3, #48]	; 0x30
 8010f0e:	e646      	b.n	8010b9e <st_prep_buffer+0x5ce>
                        prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 8010f10:	9b01      	ldr	r3, [sp, #4]
 8010f12:	4648      	mov	r0, r9
 8010f14:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8010f16:	f7ef fc3d 	bl	8000794 <__aeabi_fmul>
 8010f1a:	4601      	mov	r1, r0
 8010f1c:	f7ef fb32 	bl	8000584 <__addsf3>
 8010f20:	4601      	mov	r1, r0
 8010f22:	4628      	mov	r0, r5
 8010f24:	f7ef fb2c 	bl	8000580 <__aeabi_fsub>
 8010f28:	f002 f860 	bl	8012fec <sqrtf>
                        prep.recalculate.decel_override = On; // Flag to load next block as deceleration override.
 8010f2c:	9a03      	ldr	r2, [sp, #12]
 8010f2e:	2502      	movs	r5, #2
 8010f30:	7813      	ldrb	r3, [r2, #0]
                        prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 8010f32:	6350      	str	r0, [r2, #52]	; 0x34
                        prep.recalculate.decel_override = On; // Flag to load next block as deceleration override.
 8010f34:	f043 0308 	orr.w	r3, r3, #8
 8010f38:	7013      	strb	r3, [r2, #0]
 8010f3a:	4613      	mov	r3, r2
 8010f3c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8010f3e:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 8010f42:	9202      	str	r2, [sp, #8]
 8010f44:	6bda      	ldr	r2, [r3, #60]	; 0x3c
                        prep.exit_speed = sqrtf(pl_block->entry_speed_sqr - 2.0f * pl_block->acceleration * pl_block->millimeters);
 8010f46:	9009      	str	r0, [sp, #36]	; 0x24
 8010f48:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
 8010f4c:	9206      	str	r2, [sp, #24]
 8010f4e:	e626      	b.n	8010b9e <st_prep_buffer+0x5ce>
 8010f50:	4770      	bx	lr
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 8010f52:	9b01      	ldr	r3, [sp, #4]
                            prep.accelerate_until = prep.decelerate_after = intersect_distance;
 8010f54:	9e04      	ldr	r6, [sp, #16]
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 8010f56:	6a99      	ldr	r1, [r3, #40]	; 0x28
                            prep.accelerate_until = prep.decelerate_after = intersect_distance;
 8010f58:	9b03      	ldr	r3, [sp, #12]
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 8010f5a:	4608      	mov	r0, r1
                            prep.accelerate_until = prep.decelerate_after = intersect_distance;
 8010f5c:	63de      	str	r6, [r3, #60]	; 0x3c
 8010f5e:	639e      	str	r6, [r3, #56]	; 0x38
 8010f60:	461c      	mov	r4, r3
                            prep.maximum_speed = sqrtf(2.0f * pl_block->acceleration * intersect_distance + exit_speed_sqr);
 8010f62:	f7ef fb0f 	bl	8000584 <__addsf3>
 8010f66:	4631      	mov	r1, r6
 8010f68:	f7ef fc14 	bl	8000794 <__aeabi_fmul>
 8010f6c:	4641      	mov	r1, r8
 8010f6e:	f7ef fb09 	bl	8000584 <__addsf3>
 8010f72:	f002 f83b 	bl	8012fec <sqrtf>
 8010f76:	4631      	mov	r1, r6
 8010f78:	9002      	str	r0, [sp, #8]
 8010f7a:	6320      	str	r0, [r4, #48]	; 0x30
 8010f7c:	4648      	mov	r0, r9
 8010f7e:	f7ef faff 	bl	8000580 <__aeabi_fsub>
 8010f82:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8010f84:	4607      	mov	r7, r0
 8010f86:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
 8010f8a:	f894 5024 	ldrb.w	r5, [r4, #36]	; 0x24
 8010f8e:	9209      	str	r2, [sp, #36]	; 0x24
 8010f90:	9606      	str	r6, [sp, #24]
 8010f92:	e604      	b.n	8010b9e <st_prep_buffer+0x5ce>
            if (settings.parking.flags.enabled && !prep.recalculate.parking)
 8010f94:	4b1a      	ldr	r3, [pc, #104]	; (8011000 <st_prep_buffer+0xa30>)
            sys.step_control.end_motion = On;
 8010f96:	4918      	ldr	r1, [pc, #96]	; (8010ff8 <st_prep_buffer+0xa28>)
            if (settings.parking.flags.enabled && !prep.recalculate.parking)
 8010f98:	f893 30d8 	ldrb.w	r3, [r3, #216]	; 0xd8
            sys.step_control.end_motion = On;
 8010f9c:	f042 0201 	orr.w	r2, r2, #1
 8010fa0:	728a      	strb	r2, [r1, #10]
            if (settings.parking.flags.enabled && !prep.recalculate.parking)
 8010fa2:	07d9      	lsls	r1, r3, #31
 8010fa4:	f57f ad9e 	bpl.w	8010ae4 <st_prep_buffer+0x514>
 8010fa8:	9b03      	ldr	r3, [sp, #12]
 8010faa:	781b      	ldrb	r3, [r3, #0]
 8010fac:	075a      	lsls	r2, r3, #29
 8010fae:	f53f ad99 	bmi.w	8010ae4 <st_prep_buffer+0x514>
                prep.recalculate.hold_partial_block = On;
 8010fb2:	9a03      	ldr	r2, [sp, #12]
 8010fb4:	7813      	ldrb	r3, [r2, #0]
 8010fb6:	f043 0302 	orr.w	r3, r3, #2
 8010fba:	7013      	strb	r3, [r2, #0]
 8010fbc:	e592      	b.n	8010ae4 <st_prep_buffer+0x514>
                                prep.accelerate_until -= inv_2_accel * (nominal_speed_sqr - pl_block->entry_speed_sqr);
 8010fbe:	4631      	mov	r1, r6
 8010fc0:	4628      	mov	r0, r5
 8010fc2:	f7ef fadd 	bl	8000580 <__aeabi_fsub>
 8010fc6:	4621      	mov	r1, r4
 8010fc8:	f7ef fbe4 	bl	8000794 <__aeabi_fmul>
 8010fcc:	9c03      	ldr	r4, [sp, #12]
 8010fce:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8010fd0:	f7ef fad8 	bl	8000584 <__addsf3>
 8010fd4:	4602      	mov	r2, r0
 8010fd6:	9004      	str	r0, [sp, #16]
 8010fd8:	4611      	mov	r1, r2
 8010fda:	63a2      	str	r2, [r4, #56]	; 0x38
 8010fdc:	4648      	mov	r0, r9
 8010fde:	f7ef facf 	bl	8000580 <__aeabi_fsub>
 8010fe2:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8010fe4:	4607      	mov	r7, r0
 8010fe6:	f8d4 8028 	ldr.w	r8, [r4, #40]	; 0x28
 8010fea:	f894 5024 	ldrb.w	r5, [r4, #36]	; 0x24
 8010fee:	9209      	str	r2, [sp, #36]	; 0x24
 8010ff0:	e5d5      	b.n	8010b9e <st_prep_buffer+0x5ce>
 8010ff2:	bf00      	nop
 8010ff4:	3fa00000 	.word	0x3fa00000
 8010ff8:	20002494 	.word	0x20002494
 8010ffc:	20001b48 	.word	0x20001b48
 8011000:	20002620 	.word	0x20002620
 8011004:	20001eec 	.word	0x20001eec
                sys.step_control.end_motion = On;
 8011008:	4908      	ldr	r1, [pc, #32]	; (801102c <st_prep_buffer+0xa5c>)
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
 801100a:	4a09      	ldr	r2, [pc, #36]	; (8011030 <st_prep_buffer+0xa60>)
                sys.step_control.end_motion = On;
 801100c:	7a8b      	ldrb	r3, [r1, #10]
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
 801100e:	f892 20d8 	ldrb.w	r2, [r2, #216]	; 0xd8
                sys.step_control.end_motion = On;
 8011012:	f043 0301 	orr.w	r3, r3, #1
 8011016:	728b      	strb	r3, [r1, #10]
                if (settings.parking.flags.enabled && !prep.recalculate.parking)
 8011018:	07d3      	lsls	r3, r2, #31
 801101a:	f57f ad63 	bpl.w	8010ae4 <st_prep_buffer+0x514>
 801101e:	e7c3      	b.n	8010fa8 <st_prep_buffer+0x9d8>
                    sys.step_control.end_motion = On;
 8011020:	4b02      	ldr	r3, [pc, #8]	; (801102c <st_prep_buffer+0xa5c>)
 8011022:	f042 0201 	orr.w	r2, r2, #1
 8011026:	729a      	strb	r2, [r3, #10]
                    return;
 8011028:	e55c      	b.n	8010ae4 <st_prep_buffer+0x514>
 801102a:	bf00      	nop
 801102c:	20002494 	.word	0x20002494
 8011030:	20002620 	.word	0x20002620

08011034 <st_get_realtime_rate>:
// however is not exactly the current speed, but the speed computed in the last step segment
// in the segment buffer. It will always be behind by up to the number of segment blocks (-1)
// divided by the ACCELERATION TICKS PER SECOND in seconds.
float st_get_realtime_rate()
{
    return sys.state & (STATE_CYCLE|STATE_HOMING|STATE_HOLD|STATE_JOG|STATE_SAFETY_DOOR) ? prep.current_speed : 0.0f;
 8011034:	4b04      	ldr	r3, [pc, #16]	; (8011048 <st_get_realtime_rate+0x14>)
 8011036:	681b      	ldr	r3, [r3, #0]
 8011038:	f013 0f7c 	tst.w	r3, #124	; 0x7c
 801103c:	bf1a      	itte	ne
 801103e:	4b03      	ldrne	r3, [pc, #12]	; (801104c <st_get_realtime_rate+0x18>)
 8011040:	6ad8      	ldrne	r0, [r3, #44]	; 0x2c
 8011042:	2000      	moveq	r0, #0
}
 8011044:	4770      	bx	lr
 8011046:	bf00      	nop
 8011048:	20002494 	.word	0x20002494
 801104c:	20001b4c 	.word	0x20001b4c

08011050 <control_interrupt_handler>:
// only the realtime command execute variable to have the main program execute these when
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming data stream.
ISR_CODE void control_interrupt_handler (control_signals_t signals)
{
    if (signals.value) {
 8011050:	b2c0      	uxtb	r0, r0
 8011052:	b188      	cbz	r0, 8011078 <control_interrupt_handler+0x28>
        if ((signals.reset || signals.e_stop) && sys.state != STATE_ESTOP)
 8011054:	f010 0f41 	tst.w	r0, #65	; 0x41
 8011058:	d004      	beq.n	8011064 <control_interrupt_handler+0x14>
 801105a:	4b0c      	ldr	r3, [pc, #48]	; (801108c <control_interrupt_handler+0x3c>)
 801105c:	681b      	ldr	r3, [r3, #0]
 801105e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8011062:	d110      	bne.n	8011086 <control_interrupt_handler+0x36>
                    hal.spindle_set_state((spindle_state_t){0}, 0.0f); // TODO: stop spindle in laser mode only?
                } else
                    system_set_exec_state_flag(EXEC_SAFETY_DOOR);
            }
#endif
            if (signals.feed_hold)
 8011064:	0782      	lsls	r2, r0, #30
 8011066:	d408      	bmi.n	801107a <control_interrupt_handler+0x2a>
                system_set_exec_state_flag(EXEC_FEED_HOLD);
            else if (signals.cycle_start)
 8011068:	0743      	lsls	r3, r0, #29
 801106a:	d505      	bpl.n	8011078 <control_interrupt_handler+0x28>
                system_set_exec_state_flag(EXEC_CYCLE_START);
 801106c:	4b08      	ldr	r3, [pc, #32]	; (8011090 <control_interrupt_handler+0x40>)
 801106e:	2102      	movs	r1, #2
 8011070:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8011074:	4807      	ldr	r0, [pc, #28]	; (8011094 <control_interrupt_handler+0x44>)
 8011076:	4718      	bx	r3
        }
    }
}
 8011078:	4770      	bx	lr
                system_set_exec_state_flag(EXEC_FEED_HOLD);
 801107a:	4b05      	ldr	r3, [pc, #20]	; (8011090 <control_interrupt_handler+0x40>)
 801107c:	2108      	movs	r1, #8
 801107e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8011082:	4804      	ldr	r0, [pc, #16]	; (8011094 <control_interrupt_handler+0x44>)
 8011084:	4718      	bx	r3
            mc_reset();
 8011086:	f7f8 beb9 	b.w	8009dfc <mc_reset>
 801108a:	bf00      	nop
 801108c:	20002494 	.word	0x20002494
 8011090:	200024bc 	.word	0x200024bc
 8011094:	200024b4 	.word	0x200024b4

08011098 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup (char *line)
{
 8011098:	b538      	push	{r3, r4, r5, lr}
    if(hal.eeprom.type != EEPROM_None) {
 801109a:	4b12      	ldr	r3, [pc, #72]	; (80110e4 <system_execute_startup+0x4c>)
 801109c:	f893 30f4 	ldrb.w	r3, [r3, #244]	; 0xf4
 80110a0:	b1b3      	cbz	r3, 80110d0 <system_execute_startup+0x38>
 80110a2:	4604      	mov	r4, r0

        uint_fast8_t n;

        for (n = 0; n < N_STARTUP_LINE; n++) {
 80110a4:	2500      	movs	r5, #0
            if (!settings_read_startup_line(n, line))
 80110a6:	4621      	mov	r1, r4
 80110a8:	4628      	mov	r0, r5
 80110aa:	f7fc fff3 	bl	800e094 <settings_read_startup_line>
 80110ae:	b148      	cbz	r0, 80110c4 <system_execute_startup+0x2c>
                report_execute_startup_message(line, Status_SettingReadFail);
            else if (line[0] != '\0')
 80110b0:	7823      	ldrb	r3, [r4, #0]
 80110b2:	b973      	cbnz	r3, 80110d2 <system_execute_startup+0x3a>
        for (n = 0; n < N_STARTUP_LINE; n++) {
 80110b4:	b965      	cbnz	r5, 80110d0 <system_execute_startup+0x38>
 80110b6:	2501      	movs	r5, #1
            if (!settings_read_startup_line(n, line))
 80110b8:	4621      	mov	r1, r4
 80110ba:	4628      	mov	r0, r5
 80110bc:	f7fc ffea 	bl	800e094 <settings_read_startup_line>
 80110c0:	2800      	cmp	r0, #0
 80110c2:	d1f5      	bne.n	80110b0 <system_execute_startup+0x18>
                report_execute_startup_message(line, Status_SettingReadFail);
 80110c4:	2107      	movs	r1, #7
 80110c6:	4620      	mov	r0, r4
 80110c8:	f7fc f99e 	bl	800d408 <report_execute_startup_message>
        for (n = 0; n < N_STARTUP_LINE; n++) {
 80110cc:	2d00      	cmp	r5, #0
 80110ce:	d0f2      	beq.n	80110b6 <system_execute_startup+0x1e>
                report_execute_startup_message(line, gc_execute_block(line, NULL));
        }
    }
}
 80110d0:	bd38      	pop	{r3, r4, r5, pc}
                report_execute_startup_message(line, gc_execute_block(line, NULL));
 80110d2:	2100      	movs	r1, #0
 80110d4:	4620      	mov	r0, r4
 80110d6:	f7f4 fabb 	bl	8005650 <gc_execute_block>
 80110da:	4601      	mov	r1, r0
 80110dc:	4620      	mov	r0, r4
 80110de:	f7fc f993 	bl	800d408 <report_execute_startup_message>
 80110e2:	e7e7      	b.n	80110b4 <system_execute_startup+0x1c>
 80110e4:	200024bc 	.word	0x200024bc

080110e8 <system_execute_line>:
// be an issue, since these commands are not typically used during a cycle.

// NOTE: Code calling system_execute_line() needs to provide a line buffer of at least LINE_BUFFER_SIZE

status_code_t system_execute_line (char *line)
{
 80110e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80110ec:	b082      	sub	sp, #8
 80110ee:	4605      	mov	r5, r0
    status_code_t retval = Status_OK;
    char c, *org = line, *ucline = line, *lcline = line + (LINE_BUFFER_SIZE / 2);

    if(strlen(line) >= ((LINE_BUFFER_SIZE / 2) - 1))
 80110f0:	f7ef f82e 	bl	8000150 <strlen>
 80110f4:	287e      	cmp	r0, #126	; 0x7e
 80110f6:	d87e      	bhi.n	80111f6 <system_execute_line+0x10e>
 80110f8:	462a      	mov	r2, r5
 80110fa:	462b      	mov	r3, r5
 80110fc:	f105 0780 	add.w	r7, r5, #128	; 0x80
        return Status_Overflow;

    // Uppercase original and copy original out in the buffer
    // TODO: create a common function for stripping down uppercase version?
    do {
        c = *org++;
 8011100:	f813 4b01 	ldrb.w	r4, [r3], #1
        if(c != ' ') // Remove spaces from uppercase version
 8011104:	2c20      	cmp	r4, #32
            *ucline++ = CAPS(c);
 8011106:	f1a4 0161 	sub.w	r1, r4, #97	; 0x61
        if(c != ' ') // Remove spaces from uppercase version
 801110a:	d00d      	beq.n	8011128 <system_execute_line+0x40>
            *ucline++ = CAPS(c);
 801110c:	2919      	cmp	r1, #25
 801110e:	f004 005f 	and.w	r0, r4, #95	; 0x5f
 8011112:	d80c      	bhi.n	801112e <system_execute_line+0x46>
 8011114:	f802 0b01 	strb.w	r0, [r2], #1
        *lcline++ = c;
 8011118:	f883 407f 	strb.w	r4, [r3, #127]	; 0x7f
        c = *org++;
 801111c:	f813 4b01 	ldrb.w	r4, [r3], #1
        if(c != ' ') // Remove spaces from uppercase version
 8011120:	2c20      	cmp	r4, #32
            *ucline++ = CAPS(c);
 8011122:	f1a4 0161 	sub.w	r1, r4, #97	; 0x61
        if(c != ' ') // Remove spaces from uppercase version
 8011126:	d1f1      	bne.n	801110c <system_execute_line+0x24>
        *lcline++ = c;
 8011128:	f883 407f 	strb.w	r4, [r3, #127]	; 0x7f
    } while(c);
 801112c:	e7e8      	b.n	8011100 <system_execute_line+0x18>
            *ucline++ = CAPS(c);
 801112e:	7014      	strb	r4, [r2, #0]
        *lcline++ = c;
 8011130:	f883 407f 	strb.w	r4, [r3, #127]	; 0x7f
    } while(c);
 8011134:	b10c      	cbz	r4, 801113a <system_execute_line+0x52>
            *ucline++ = CAPS(c);
 8011136:	3201      	adds	r2, #1
 8011138:	e7e2      	b.n	8011100 <system_execute_line+0x18>

    lcline = line + (LINE_BUFFER_SIZE / 2);

    switch (line[1]) {
 801113a:	786e      	ldrb	r6, [r5, #1]
 801113c:	2e58      	cmp	r6, #88	; 0x58
 801113e:	d85f      	bhi.n	8011200 <system_execute_line+0x118>
 8011140:	e8df f016 	tbh	[pc, r6, lsl #1]
 8011144:	005e007d 	.word	0x005e007d
 8011148:	005e005e 	.word	0x005e005e
 801114c:	005e005e 	.word	0x005e005e
 8011150:	005e005e 	.word	0x005e005e
 8011154:	005e005e 	.word	0x005e005e
 8011158:	005e005e 	.word	0x005e005e
 801115c:	005e005e 	.word	0x005e005e
 8011160:	005e005e 	.word	0x005e005e
 8011164:	005e005e 	.word	0x005e005e
 8011168:	005e005e 	.word	0x005e005e
 801116c:	005e005e 	.word	0x005e005e
 8011170:	005e005e 	.word	0x005e005e
 8011174:	005e005e 	.word	0x005e005e
 8011178:	005e005e 	.word	0x005e005e
 801117c:	005e005e 	.word	0x005e005e
 8011180:	005e005e 	.word	0x005e005e
 8011184:	005e005e 	.word	0x005e005e
 8011188:	0081005e 	.word	0x0081005e
 801118c:	005e0096 	.word	0x005e0096
 8011190:	005e005e 	.word	0x005e005e
 8011194:	005e005e 	.word	0x005e005e
 8011198:	005e005e 	.word	0x005e005e
 801119c:	005e005e 	.word	0x005e005e
 80111a0:	005e005e 	.word	0x005e005e
 80111a4:	005e005e 	.word	0x005e005e
 80111a8:	005e005e 	.word	0x005e005e
 80111ac:	005e005e 	.word	0x005e005e
 80111b0:	005e005e 	.word	0x005e005e
 80111b4:	005e005e 	.word	0x005e005e
 80111b8:	005e005e 	.word	0x005e005e
 80111bc:	005e005e 	.word	0x005e005e
 80111c0:	005e005e 	.word	0x005e005e
 80111c4:	005e005e 	.word	0x005e005e
 80111c8:	00b900a2 	.word	0x00b900a2
 80111cc:	005e005e 	.word	0x005e005e
 80111d0:	00cd005e 	.word	0x00cd005e
 80111d4:	013100d8 	.word	0x013100d8
 80111d8:	005e0148 	.word	0x005e0148
 80111dc:	005e005e 	.word	0x005e005e
 80111e0:	005e0153 	.word	0x005e0153
 80111e4:	005e005e 	.word	0x005e005e
 80111e8:	01a40175 	.word	0x01a40175
 80111ec:	005e005e 	.word	0x005e005e
 80111f0:	005e005e 	.word	0x005e005e
 80111f4:	01ca      	.short	0x01ca
        return Status_Overflow;
 80111f6:	240b      	movs	r4, #11
                    retval = Status_IdleError;
            }
    }

    return retval;
}
 80111f8:	4620      	mov	r0, r4
 80111fa:	b002      	add	sp, #8
 80111fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if(hal.driver_sys_command_execute)
 8011200:	4bb1      	ldr	r3, [pc, #708]	; (80114c8 <system_execute_line+0x3e0>)
                retval = hal.driver_sys_command_execute(sys.state, line, lcline);
 8011202:	4eb2      	ldr	r6, [pc, #712]	; (80114cc <system_execute_line+0x3e4>)
            if(hal.driver_sys_command_execute)
 8011204:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8011208:	b133      	cbz	r3, 8011218 <system_execute_line+0x130>
                retval = hal.driver_sys_command_execute(sys.state, line, lcline);
 801120a:	463a      	mov	r2, r7
 801120c:	4629      	mov	r1, r5
 801120e:	6830      	ldr	r0, [r6, #0]
 8011210:	4798      	blx	r3
            if (retval == Status_Unhandled) {
 8011212:	283b      	cmp	r0, #59	; 0x3b
                retval = hal.driver_sys_command_execute(sys.state, line, lcline);
 8011214:	4604      	mov	r4, r0
            if (retval == Status_Unhandled) {
 8011216:	d1ef      	bne.n	80111f8 <system_execute_line+0x110>
                if(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 8011218:	6833      	ldr	r3, [r6, #0]
 801121a:	b123      	cbz	r3, 8011226 <system_execute_line+0x13e>
 801121c:	f240 1203 	movw	r2, #259	; 0x103
 8011220:	4213      	tst	r3, r2
 8011222:	f000 80e0 	beq.w	80113e6 <system_execute_line+0x2fe>
                    uint_fast8_t counter = 1;
 8011226:	2301      	movs	r3, #1
                    if(!read_float(line, &counter, &parameter))
 8011228:	4669      	mov	r1, sp
 801122a:	4628      	mov	r0, r5
 801122c:	aa01      	add	r2, sp, #4
                    uint_fast8_t counter = 1;
 801122e:	9300      	str	r3, [sp, #0]
                    if(!read_float(line, &counter, &parameter))
 8011230:	f7f8 ffce 	bl	800a1d0 <read_float>
 8011234:	2800      	cmp	r0, #0
 8011236:	f040 81e8 	bne.w	801160a <system_execute_line+0x522>
                        retval = Status_BadNumberFormat;
 801123a:	2402      	movs	r4, #2
                if(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))) {
 801123c:	e7dc      	b.n	80111f8 <system_execute_line+0x110>
            report_grbl_help();
 801123e:	f7fa ffa3 	bl	800c188 <report_grbl_help>
    status_code_t retval = Status_OK;
 8011242:	4634      	mov	r4, r6
            break;
 8011244:	e7d8      	b.n	80111f8 <system_execute_line+0x110>
            if (line[2] != '\0')
 8011246:	78ac      	ldrb	r4, [r5, #2]
 8011248:	b96c      	cbnz	r4, 8011266 <system_execute_line+0x17e>
            else if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 801124a:	4ba0      	ldr	r3, [pc, #640]	; (80114cc <system_execute_line+0x3e4>)
 801124c:	681b      	ldr	r3, [r3, #0]
 801124e:	b123      	cbz	r3, 801125a <system_execute_line+0x172>
 8011250:	f240 1203 	movw	r2, #259	; 0x103
 8011254:	4213      	tst	r3, r2
 8011256:	f000 80c6 	beq.w	80113e6 <system_execute_line+0x2fe>
                report_ngc_parameters();
 801125a:	f7fb fe03 	bl	800ce64 <report_ngc_parameters>
 801125e:	e7cb      	b.n	80111f8 <system_execute_line+0x110>
            if(retval != Status_InvalidStatement)
 8011260:	2f03      	cmp	r7, #3
 8011262:	f040 8224 	bne.w	80116ae <system_execute_line+0x5c6>
                        retval = Status_InvalidStatement;
 8011266:	2403      	movs	r4, #3
}
 8011268:	4620      	mov	r0, r4
 801126a:	b002      	add	sp, #8
 801126c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if (line[2] != '\0' )
 8011270:	78ac      	ldrb	r4, [r5, #2]
 8011272:	2c00      	cmp	r4, #0
 8011274:	d1f7      	bne.n	8011266 <system_execute_line+0x17e>
            else if (sys.state & (STATE_CYCLE|STATE_HOLD))
 8011276:	4b95      	ldr	r3, [pc, #596]	; (80114cc <system_execute_line+0x3e4>)
 8011278:	681b      	ldr	r3, [r3, #0]
 801127a:	f013 0f18 	tst.w	r3, #24
 801127e:	f040 80b2 	bne.w	80113e6 <system_execute_line+0x2fe>
                report_grbl_settings();
 8011282:	f7fa ff89 	bl	800c198 <report_grbl_settings>
 8011286:	e7b7      	b.n	80111f8 <system_execute_line+0x110>
            if (line[2] != '\0')
 8011288:	78ac      	ldrb	r4, [r5, #2]
 801128a:	2c00      	cmp	r4, #0
 801128c:	d1eb      	bne.n	8011266 <system_execute_line+0x17e>
                sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 801128e:	498f      	ldr	r1, [pc, #572]	; (80114cc <system_execute_line+0x3e4>)
                hal.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 8011290:	4a8d      	ldr	r2, [pc, #564]	; (80114c8 <system_execute_line+0x3e0>)
                sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 8011292:	7a4b      	ldrb	r3, [r1, #9]
                hal.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 8011294:	f8d2 5128 	ldr.w	r5, [r2, #296]	; 0x128
                sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 8011298:	461a      	mov	r2, r3
 801129a:	f083 0310 	eor.w	r3, r3, #16
 801129e:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80112a2:	f363 1204 	bfi	r2, r3, #4, #1
                hal.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 80112a6:	f012 0f10 	tst.w	r2, #16
 80112aa:	bf14      	ite	ne
 80112ac:	2004      	movne	r0, #4
 80112ae:	2005      	moveq	r0, #5
                sys.flags.block_delete_enabled = !sys.flags.block_delete_enabled;
 80112b0:	724a      	strb	r2, [r1, #9]
                hal.report.feedback_message(sys.flags.block_delete_enabled ? Message_Enabled : Message_Disabled);
 80112b2:	47a8      	blx	r5
 80112b4:	e7a0      	b.n	80111f8 <system_execute_line+0x110>
            if (line[2] != '\0')
 80112b6:	78ac      	ldrb	r4, [r5, #2]
 80112b8:	2c00      	cmp	r4, #0
 80112ba:	d1d4      	bne.n	8011266 <system_execute_line+0x17e>
            else if (sys.state == STATE_CHECK_MODE) {
 80112bc:	4b83      	ldr	r3, [pc, #524]	; (80114cc <system_execute_line+0x3e4>)
 80112be:	681b      	ldr	r3, [r3, #0]
 80112c0:	2b02      	cmp	r3, #2
 80112c2:	f000 81be 	beq.w	8011642 <system_execute_line+0x55a>
            } else if (sys.state == STATE_IDLE) { // Requires idle mode.
 80112c6:	2b00      	cmp	r3, #0
 80112c8:	f040 808d 	bne.w	80113e6 <system_execute_line+0x2fe>
                set_state(STATE_CHECK_MODE);
 80112cc:	2002      	movs	r0, #2
 80112ce:	f7fe fb8f 	bl	800f9f0 <set_state>
                hal.report.feedback_message(Message_Enabled);
 80112d2:	4b7d      	ldr	r3, [pc, #500]	; (80114c8 <system_execute_line+0x3e0>)
 80112d4:	2004      	movs	r0, #4
 80112d6:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 80112da:	4798      	blx	r3
 80112dc:	e78c      	b.n	80111f8 <system_execute_line+0x110>
            if (line[2] != '\0' )
 80112de:	78ac      	ldrb	r4, [r5, #2]
 80112e0:	2c00      	cmp	r4, #0
 80112e2:	d1c0      	bne.n	8011266 <system_execute_line+0x17e>
                report_gcode_modes();
 80112e4:	f7fb fe74 	bl	800cfd0 <report_gcode_modes>
                sys.report.homed = On; // Report homed state on next realtime report
 80112e8:	4a78      	ldr	r2, [pc, #480]	; (80114cc <system_execute_line+0x3e4>)
 80112ea:	7d13      	ldrb	r3, [r2, #20]
 80112ec:	f043 0304 	orr.w	r3, r3, #4
 80112f0:	7513      	strb	r3, [r2, #20]
 80112f2:	e781      	b.n	80111f8 <system_execute_line+0x110>
            if(!(sys.state == STATE_IDLE || sys.state == STATE_ALARM))
 80112f4:	4e75      	ldr	r6, [pc, #468]	; (80114cc <system_execute_line+0x3e4>)
 80112f6:	6833      	ldr	r3, [r6, #0]
 80112f8:	2b01      	cmp	r3, #1
 80112fa:	f63f af7d 	bhi.w	80111f8 <system_execute_line+0x110>
                control_signals_t control_signals = hal.system_control_get_state();
 80112fe:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 80114c8 <system_execute_line+0x3e0>
 8011302:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
 8011306:	4798      	blx	r3
                if (control_signals.e_stop)
 8011308:	0647      	lsls	r7, r0, #25
 801130a:	b2c3      	uxtb	r3, r0
 801130c:	f53f af74 	bmi.w	80111f8 <system_execute_line+0x110>
                else if (!settings.homing.flags.enabled)
 8011310:	496f      	ldr	r1, [pc, #444]	; (80114d0 <system_execute_line+0x3e8>)
 8011312:	f891 20d0 	ldrb.w	r2, [r1, #208]	; 0xd0
 8011316:	07d0      	lsls	r0, r2, #31
 8011318:	f57f af6e 	bpl.w	80111f8 <system_execute_line+0x110>
                else if (control_signals.safety_door_ajar && !settings.flags.safety_door_ignore_when_idle)
 801131c:	071f      	lsls	r7, r3, #28
 801131e:	d504      	bpl.n	801132a <system_execute_line+0x242>
 8011320:	f891 10bc 	ldrb.w	r1, [r1, #188]	; 0xbc
 8011324:	0688      	lsls	r0, r1, #26
 8011326:	f57f af67 	bpl.w	80111f8 <system_execute_line+0x110>
                else if(control_signals.reset)
 801132a:	07d9      	lsls	r1, r3, #31
 801132c:	f53f af64 	bmi.w	80111f8 <system_execute_line+0x110>
                if (line[2] == '\0')
 8011330:	78a8      	ldrb	r0, [r5, #2]
 8011332:	2800      	cmp	r0, #0
 8011334:	f000 81b1 	beq.w	801169a <system_execute_line+0x5b2>
                else if (settings.homing.flags.single_axis_commands && line[3] == '\0') {
 8011338:	0792      	lsls	r2, r2, #30
 801133a:	d594      	bpl.n	8011266 <system_execute_line+0x17e>
 801133c:	78eb      	ldrb	r3, [r5, #3]
 801133e:	2b00      	cmp	r3, #0
 8011340:	d191      	bne.n	8011266 <system_execute_line+0x17e>
                    switch (line[2]) {
 8011342:	2859      	cmp	r0, #89	; 0x59
 8011344:	f000 81ad 	beq.w	80116a2 <system_execute_line+0x5ba>
 8011348:	285a      	cmp	r0, #90	; 0x5a
 801134a:	f000 81a4 	beq.w	8011696 <system_execute_line+0x5ae>
 801134e:	2858      	cmp	r0, #88	; 0x58
 8011350:	d189      	bne.n	8011266 <system_execute_line+0x17e>
                            retval = mc_homing_cycle((axes_signals_t){X_AXIS_BIT});
 8011352:	f04f 0001 	mov.w	r0, #1
 8011356:	f7f8 fd99 	bl	8009e8c <mc_homing_cycle>
 801135a:	4607      	mov	r7, r0
            if (retval == Status_OK && !sys.abort) {  // Execute startup scripts after successful homing.
 801135c:	2f00      	cmp	r7, #0
 801135e:	f47f af7f 	bne.w	8011260 <system_execute_line+0x178>
 8011362:	7933      	ldrb	r3, [r6, #4]
 8011364:	2b00      	cmp	r3, #0
 8011366:	f47f af47 	bne.w	80111f8 <system_execute_line+0x110>
                set_state(STATE_IDLE); // Set to IDLE when complete.
 801136a:	4638      	mov	r0, r7
 801136c:	f7fe fb40 	bl	800f9f0 <set_state>
                st_go_idle(); // Set steppers to the settings idle state before returning.
 8011370:	f7fe feb0 	bl	80100d4 <st_go_idle>
                if (line[2] == '\0')
 8011374:	78ab      	ldrb	r3, [r5, #2]
 8011376:	2b00      	cmp	r3, #0
 8011378:	f47f af3e 	bne.w	80111f8 <system_execute_line+0x110>
    if(hal.eeprom.type != EEPROM_None) {
 801137c:	f898 30f4 	ldrb.w	r3, [r8, #244]	; 0xf4
 8011380:	2b00      	cmp	r3, #0
 8011382:	f43f af39 	beq.w	80111f8 <system_execute_line+0x110>
            if (!settings_read_startup_line(n, line))
 8011386:	4629      	mov	r1, r5
 8011388:	4638      	mov	r0, r7
 801138a:	f7fc fe83 	bl	800e094 <settings_read_startup_line>
 801138e:	2800      	cmp	r0, #0
 8011390:	f000 817c 	beq.w	801168c <system_execute_line+0x5a4>
            else if (line[0] != '\0')
 8011394:	782b      	ldrb	r3, [r5, #0]
 8011396:	2b00      	cmp	r3, #0
 8011398:	f040 816f 	bne.w	801167a <system_execute_line+0x592>
        for (n = 0; n < N_STARTUP_LINE; n++) {
 801139c:	2f00      	cmp	r7, #0
 801139e:	f47f af2b 	bne.w	80111f8 <system_execute_line+0x110>
 80113a2:	2701      	movs	r7, #1
 80113a4:	e7ef      	b.n	8011386 <system_execute_line+0x29e>
            if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 80113a6:	4b49      	ldr	r3, [pc, #292]	; (80114cc <system_execute_line+0x3e4>)
 80113a8:	681b      	ldr	r3, [r3, #0]
 80113aa:	2b00      	cmp	r3, #0
 80113ac:	f040 80d9 	bne.w	8011562 <system_execute_line+0x47a>
            else if (line[2] == '\0') {
 80113b0:	78ae      	ldrb	r6, [r5, #2]
 80113b2:	2e00      	cmp	r6, #0
 80113b4:	f000 80db 	beq.w	801156e <system_execute_line+0x486>
            else if (line[2] == '=' && strlen(&line[3]) < (MAX_STORED_LINE_LENGTH - 1))
 80113b8:	2e3d      	cmp	r6, #61	; 0x3d
 80113ba:	f47f af54 	bne.w	8011266 <system_execute_line+0x17e>
 80113be:	1ce8      	adds	r0, r5, #3
 80113c0:	f7ee fec6 	bl	8000150 <strlen>
 80113c4:	2844      	cmp	r0, #68	; 0x44
 80113c6:	f63f af4e 	bhi.w	8011266 <system_execute_line+0x17e>
                settings_write_build_info(&lcline[3]);
 80113ca:	f105 0083 	add.w	r0, r5, #131	; 0x83
 80113ce:	f7fc fe13 	bl	800dff8 <settings_write_build_info>
 80113d2:	e711      	b.n	80111f8 <system_execute_line+0x110>
            if (!(sys.state == STATE_IDLE || (sys.state & (STATE_JOG|STATE_TOOL_CHANGE))))
 80113d4:	4b3d      	ldr	r3, [pc, #244]	; (80114cc <system_execute_line+0x3e4>)
 80113d6:	681b      	ldr	r3, [r3, #0]
 80113d8:	2b00      	cmp	r3, #0
 80113da:	f000 80ae 	beq.w	801153a <system_execute_line+0x452>
 80113de:	f413 7f08 	tst.w	r3, #544	; 0x220
 80113e2:	f040 80aa 	bne.w	801153a <system_execute_line+0x452>
                retval = Status_IdleError;
 80113e6:	2408      	movs	r4, #8
 80113e8:	e706      	b.n	80111f8 <system_execute_line+0x110>
            if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 80113ea:	4b38      	ldr	r3, [pc, #224]	; (80114cc <system_execute_line+0x3e4>)
 80113ec:	681b      	ldr	r3, [r3, #0]
 80113ee:	2b00      	cmp	r3, #0
 80113f0:	f040 80ad 	bne.w	801154e <system_execute_line+0x466>
            else if (line[2] == '\0') { // Print startup lines
 80113f4:	78ab      	ldrb	r3, [r5, #2]
 80113f6:	2b00      	cmp	r3, #0
 80113f8:	f040 80c1 	bne.w	801157e <system_execute_line+0x496>
                    if (!(settings_read_startup_line(counter, line)))
 80113fc:	4629      	mov	r1, r5
 80113fe:	2000      	movs	r0, #0
 8011400:	f7fc fe48 	bl	800e094 <settings_read_startup_line>
 8011404:	2800      	cmp	r0, #0
 8011406:	f040 80fb 	bne.w	8011600 <system_execute_line+0x518>
                        hal.report.status_message(Status_SettingReadFail);
 801140a:	4b2f      	ldr	r3, [pc, #188]	; (80114c8 <system_execute_line+0x3e0>)
 801140c:	2007      	movs	r0, #7
 801140e:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8011412:	4798      	blx	r3
                    if (!(settings_read_startup_line(counter, line)))
 8011414:	4629      	mov	r1, r5
 8011416:	2001      	movs	r0, #1
 8011418:	f7fc fe3c 	bl	800e094 <settings_read_startup_line>
 801141c:	2800      	cmp	r0, #0
 801141e:	f040 810b 	bne.w	8011638 <system_execute_line+0x550>
                        hal.report.status_message(Status_SettingReadFail);
 8011422:	4b29      	ldr	r3, [pc, #164]	; (80114c8 <system_execute_line+0x3e0>)
 8011424:	2007      	movs	r0, #7
 8011426:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 801142a:	4798      	blx	r3
 801142c:	e6e4      	b.n	80111f8 <system_execute_line+0x110>
                if (!(line[2] == 'S' && line[3] == 'T' && line[4] == '=' && line[6] == '\0'))
 801142e:	78ab      	ldrb	r3, [r5, #2]
 8011430:	2b53      	cmp	r3, #83	; 0x53
 8011432:	f47f af18 	bne.w	8011266 <system_execute_line+0x17e>
 8011436:	78eb      	ldrb	r3, [r5, #3]
 8011438:	2b54      	cmp	r3, #84	; 0x54
 801143a:	f47f af14 	bne.w	8011266 <system_execute_line+0x17e>
 801143e:	792b      	ldrb	r3, [r5, #4]
 8011440:	2b3d      	cmp	r3, #61	; 0x3d
 8011442:	f47f af10 	bne.w	8011266 <system_execute_line+0x17e>
 8011446:	79ab      	ldrb	r3, [r5, #6]
 8011448:	2b00      	cmp	r3, #0
 801144a:	f47f af0c 	bne.w	8011266 <system_execute_line+0x17e>
                else if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP))))
 801144e:	4b1f      	ldr	r3, [pc, #124]	; (80114cc <system_execute_line+0x3e4>)
 8011450:	681b      	ldr	r3, [r3, #0]
 8011452:	b11b      	cbz	r3, 801145c <system_execute_line+0x374>
 8011454:	f240 1201 	movw	r2, #257	; 0x101
 8011458:	4213      	tst	r3, r2
 801145a:	d0c4      	beq.n	80113e6 <system_execute_line+0x2fe>
                else switch (line[5]) {
 801145c:	796b      	ldrb	r3, [r5, #5]
 801145e:	3b23      	subs	r3, #35	; 0x23
 8011460:	2b07      	cmp	r3, #7
 8011462:	f63f af00 	bhi.w	8011266 <system_execute_line+0x17e>
 8011466:	a201      	add	r2, pc, #4	; (adr r2, 801146c <system_execute_line+0x384>)
 8011468:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801146c:	080116e1 	.word	0x080116e1
 8011470:	080116db 	.word	0x080116db
 8011474:	08011267 	.word	0x08011267
 8011478:	080116d5 	.word	0x080116d5
 801147c:	08011267 	.word	0x08011267
 8011480:	08011267 	.word	0x08011267
 8011484:	08011267 	.word	0x08011267
 8011488:	080116b3 	.word	0x080116b3
            if(!settings.flags.sleep_enable || !(line[2] == 'L' && line[3] == 'P' && line[4] == '\0'))
 801148c:	4b10      	ldr	r3, [pc, #64]	; (80114d0 <system_execute_line+0x3e8>)
 801148e:	f893 30bc 	ldrb.w	r3, [r3, #188]	; 0xbc
 8011492:	065b      	lsls	r3, r3, #25
 8011494:	f57f aee7 	bpl.w	8011266 <system_execute_line+0x17e>
 8011498:	78ab      	ldrb	r3, [r5, #2]
 801149a:	2b4c      	cmp	r3, #76	; 0x4c
 801149c:	f47f aee3 	bne.w	8011266 <system_execute_line+0x17e>
 80114a0:	78eb      	ldrb	r3, [r5, #3]
 80114a2:	2b50      	cmp	r3, #80	; 0x50
 80114a4:	f47f aedf 	bne.w	8011266 <system_execute_line+0x17e>
 80114a8:	792c      	ldrb	r4, [r5, #4]
 80114aa:	2c00      	cmp	r4, #0
 80114ac:	f47f aedb 	bne.w	8011266 <system_execute_line+0x17e>
            else if(!(sys.state == STATE_IDLE || sys.state == STATE_ALARM))
 80114b0:	4b06      	ldr	r3, [pc, #24]	; (80114cc <system_execute_line+0x3e4>)
 80114b2:	681b      	ldr	r3, [r3, #0]
 80114b4:	2b01      	cmp	r3, #1
 80114b6:	d896      	bhi.n	80113e6 <system_execute_line+0x2fe>
                system_set_exec_state_flag(EXEC_SLEEP); // Set to execute sleep mode immediately
 80114b8:	4b03      	ldr	r3, [pc, #12]	; (80114c8 <system_execute_line+0x3e0>)
 80114ba:	f44f 7180 	mov.w	r1, #256	; 0x100
 80114be:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80114c2:	4804      	ldr	r0, [pc, #16]	; (80114d4 <system_execute_line+0x3ec>)
 80114c4:	4798      	blx	r3
 80114c6:	e697      	b.n	80111f8 <system_execute_line+0x110>
 80114c8:	200024bc 	.word	0x200024bc
 80114cc:	20002494 	.word	0x20002494
 80114d0:	20002620 	.word	0x20002620
 80114d4:	200024b4 	.word	0x200024b4
            if (line[2] != '\0')
 80114d8:	78ab      	ldrb	r3, [r5, #2]
 80114da:	2b00      	cmp	r3, #0
 80114dc:	f47f aec3 	bne.w	8011266 <system_execute_line+0x17e>
            else if (sys.state & (STATE_ALARM|STATE_ESTOP)) {
 80114e0:	f240 1201 	movw	r2, #257	; 0x101
 80114e4:	4e80      	ldr	r6, [pc, #512]	; (80116e8 <system_execute_line+0x600>)
 80114e6:	6833      	ldr	r3, [r6, #0]
 80114e8:	421a      	tst	r2, r3
 80114ea:	f43f ae85 	beq.w	80111f8 <system_execute_line+0x110>
                control_signals_t control_signals = hal.system_control_get_state();
 80114ee:	f8df 8200 	ldr.w	r8, [pc, #512]	; 80116f0 <system_execute_line+0x608>
 80114f2:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40
 80114f6:	4798      	blx	r3
                if (control_signals.e_stop)
 80114f8:	0642      	lsls	r2, r0, #25
 80114fa:	b2c4      	uxtb	r4, r0
 80114fc:	d47e      	bmi.n	80115fc <system_execute_line+0x514>
                else if (control_signals.safety_door_ajar)
 80114fe:	0723      	lsls	r3, r4, #28
 8011500:	f100 80a7 	bmi.w	8011652 <system_execute_line+0x56a>
                else if(control_signals.reset)
 8011504:	f014 0401 	ands.w	r4, r4, #1
 8011508:	f040 80a5 	bne.w	8011656 <system_execute_line+0x56e>
                else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value)
 801150c:	4d77      	ldr	r5, [pc, #476]	; (80116ec <system_execute_line+0x604>)
 801150e:	f895 30d4 	ldrb.w	r3, [r5, #212]	; 0xd4
 8011512:	f003 0305 	and.w	r3, r3, #5
 8011516:	2b05      	cmp	r3, #5
 8011518:	f000 80a6 	beq.w	8011668 <system_execute_line+0x580>
                else if (settings.homing.flags.enabled && settings.homing.flags.init_lock && sys.homed.mask != sys.homing.mask)
 801151c:	f895 30d0 	ldrb.w	r3, [r5, #208]	; 0xd0
 8011520:	f003 0305 	and.w	r3, r3, #5
 8011524:	2b05      	cmp	r3, #5
 8011526:	f000 8098 	beq.w	801165a <system_execute_line+0x572>
                    hal.report.feedback_message(Message_AlarmUnlock);
 801152a:	f8d8 3128 	ldr.w	r3, [r8, #296]	; 0x128
 801152e:	2003      	movs	r0, #3
 8011530:	4798      	blx	r3
                    set_state(STATE_IDLE);
 8011532:	2000      	movs	r0, #0
 8011534:	f7fe fa5c 	bl	800f9f0 <set_state>
 8011538:	e65e      	b.n	80111f8 <system_execute_line+0x110>
                retval = line[2] != '=' ? Status_InvalidStatement : gc_execute_block(line, NULL); // NOTE: $J= is ignored inside g-code parser and used to detect jog motions.
 801153a:	78ab      	ldrb	r3, [r5, #2]
 801153c:	2b3d      	cmp	r3, #61	; 0x3d
 801153e:	f47f ae92 	bne.w	8011266 <system_execute_line+0x17e>
 8011542:	4628      	mov	r0, r5
 8011544:	2100      	movs	r1, #0
 8011546:	f7f4 f883 	bl	8005650 <gc_execute_block>
 801154a:	4604      	mov	r4, r0
 801154c:	e654      	b.n	80111f8 <system_execute_line+0x110>
            if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 801154e:	f240 1203 	movw	r2, #259	; 0x103
 8011552:	4213      	tst	r3, r2
 8011554:	f43f af47 	beq.w	80113e6 <system_execute_line+0x2fe>
            else if (line[2] == '\0') { // Print startup lines
 8011558:	78ab      	ldrb	r3, [r5, #2]
 801155a:	2b00      	cmp	r3, #0
 801155c:	f47f af43 	bne.w	80113e6 <system_execute_line+0x2fe>
 8011560:	e74c      	b.n	80113fc <system_execute_line+0x314>
            if (!(sys.state == STATE_IDLE || (sys.state & (STATE_ALARM|STATE_ESTOP|STATE_CHECK_MODE))))
 8011562:	f240 1203 	movw	r2, #259	; 0x103
 8011566:	4213      	tst	r3, r2
 8011568:	f47f af22 	bne.w	80113b0 <system_execute_line+0x2c8>
 801156c:	e73b      	b.n	80113e6 <system_execute_line+0x2fe>
                settings_read_build_info(line);
 801156e:	4628      	mov	r0, r5
 8011570:	f7fc fd50 	bl	800e014 <settings_read_build_info>
                report_build_info(line);
 8011574:	4628      	mov	r0, r5
    status_code_t retval = Status_OK;
 8011576:	4634      	mov	r4, r6
                report_build_info(line);
 8011578:	f7fb ff60 	bl	800d43c <report_build_info>
 801157c:	e63c      	b.n	80111f8 <system_execute_line+0x110>
                uint_fast8_t counter = 2;
 801157e:	2402      	movs	r4, #2
                if(!read_float(line, &counter, &parameter))
 8011580:	4669      	mov	r1, sp
 8011582:	4628      	mov	r0, r5
 8011584:	aa01      	add	r2, sp, #4
                uint_fast8_t counter = 2;
 8011586:	9400      	str	r4, [sp, #0]
                if(!read_float(line, &counter, &parameter))
 8011588:	f7f8 fe22 	bl	800a1d0 <read_float>
 801158c:	2800      	cmp	r0, #0
 801158e:	f43f ae33 	beq.w	80111f8 <system_execute_line+0x110>
                else if(line[counter++] != '=' || parameter - truncf(parameter) != 0.0f)
 8011592:	9c00      	ldr	r4, [sp, #0]
 8011594:	5d2b      	ldrb	r3, [r5, r4]
 8011596:	3401      	adds	r4, #1
 8011598:	2b3d      	cmp	r3, #61	; 0x3d
 801159a:	9400      	str	r4, [sp, #0]
 801159c:	f47f ae63 	bne.w	8011266 <system_execute_line+0x17e>
 80115a0:	9e01      	ldr	r6, [sp, #4]
 80115a2:	4630      	mov	r0, r6
 80115a4:	f001 fc8a 	bl	8012ebc <truncf>
 80115a8:	4601      	mov	r1, r0
 80115aa:	4630      	mov	r0, r6
 80115ac:	f7ee ffe8 	bl	8000580 <__aeabi_fsub>
 80115b0:	2100      	movs	r1, #0
 80115b2:	f7ef fa83 	bl	8000abc <__aeabi_fcmpeq>
 80115b6:	2800      	cmp	r0, #0
 80115b8:	f43f ae55 	beq.w	8011266 <system_execute_line+0x17e>
                else if(parameter > (float)N_STARTUP_LINE)
 80115bc:	4630      	mov	r0, r6
 80115be:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80115c2:	f7ef faa3 	bl	8000b0c <__aeabi_fcmpgt>
 80115c6:	4606      	mov	r6, r0
 80115c8:	2800      	cmp	r0, #0
 80115ca:	f47f ae4c 	bne.w	8011266 <system_execute_line+0x17e>
                    line = &line[counter];
 80115ce:	4425      	add	r5, r4
                    if(strlen(line) >= (MAX_STORED_LINE_LENGTH - 1))
 80115d0:	4628      	mov	r0, r5
 80115d2:	f7ee fdbd 	bl	8000150 <strlen>
 80115d6:	2844      	cmp	r0, #68	; 0x44
 80115d8:	f63f ae0d 	bhi.w	80111f6 <system_execute_line+0x10e>
                    else if ((retval = gc_execute_block(line, NULL)) == Status_OK) // Execute gcode block to ensure block is valid.
 80115dc:	4631      	mov	r1, r6
 80115de:	4628      	mov	r0, r5
 80115e0:	f7f4 f836 	bl	8005650 <gc_execute_block>
 80115e4:	4604      	mov	r4, r0
 80115e6:	2800      	cmp	r0, #0
 80115e8:	f47f ae06 	bne.w	80111f8 <system_execute_line+0x110>
                        settings_write_startup_line((uint8_t)parameter, line);
 80115ec:	9801      	ldr	r0, [sp, #4]
 80115ee:	f7ef fad3 	bl	8000b98 <__aeabi_f2uiz>
 80115f2:	4629      	mov	r1, r5
 80115f4:	b2c0      	uxtb	r0, r0
 80115f6:	f7fc fd2d 	bl	800e054 <settings_write_startup_line>
 80115fa:	e5fd      	b.n	80111f8 <system_execute_line+0x110>
                    retval = Status_EStop;
 80115fc:	2432      	movs	r4, #50	; 0x32
 80115fe:	e5fb      	b.n	80111f8 <system_execute_line+0x110>
                        report_startup_line(counter, line);
 8011600:	4629      	mov	r1, r5
 8011602:	2000      	movs	r0, #0
 8011604:	f7fb fee2 	bl	800d3cc <report_startup_line>
 8011608:	e704      	b.n	8011414 <system_execute_line+0x32c>
                    else if(!(isintf(parameter) && line[counter++] == '='))
 801160a:	9801      	ldr	r0, [sp, #4]
 801160c:	f7f8 fe64 	bl	800a2d8 <isintf>
 8011610:	2800      	cmp	r0, #0
 8011612:	f43f ae28 	beq.w	8011266 <system_execute_line+0x17e>
 8011616:	9b00      	ldr	r3, [sp, #0]
 8011618:	5cea      	ldrb	r2, [r5, r3]
 801161a:	3301      	adds	r3, #1
 801161c:	2a3d      	cmp	r2, #61	; 0x3d
 801161e:	9300      	str	r3, [sp, #0]
 8011620:	f47f ae21 	bne.w	8011266 <system_execute_line+0x17e>
                        retval = settings_store_global_setting((setting_type_t)parameter, &lcline[counter]);
 8011624:	9801      	ldr	r0, [sp, #4]
 8011626:	441f      	add	r7, r3
 8011628:	f7ef fab6 	bl	8000b98 <__aeabi_f2uiz>
 801162c:	4639      	mov	r1, r7
 801162e:	b280      	uxth	r0, r0
 8011630:	f7fc fe6c 	bl	800e30c <settings_store_global_setting>
 8011634:	4604      	mov	r4, r0
 8011636:	e5df      	b.n	80111f8 <system_execute_line+0x110>
                        report_startup_line(counter, line);
 8011638:	4629      	mov	r1, r5
 801163a:	2001      	movs	r0, #1
 801163c:	f7fb fec6 	bl	800d3cc <report_startup_line>
                for (counter = 0; counter < N_STARTUP_LINE; counter++) {
 8011640:	e5da      	b.n	80111f8 <system_execute_line+0x110>
                mc_reset();
 8011642:	f7f8 fbdb 	bl	8009dfc <mc_reset>
                hal.report.feedback_message(Message_Disabled);
 8011646:	4b2a      	ldr	r3, [pc, #168]	; (80116f0 <system_execute_line+0x608>)
 8011648:	2005      	movs	r0, #5
 801164a:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 801164e:	4798      	blx	r3
 8011650:	e5d2      	b.n	80111f8 <system_execute_line+0x110>
                    retval = Status_CheckDoor;
 8011652:	240d      	movs	r4, #13
 8011654:	e5d0      	b.n	80111f8 <system_execute_line+0x110>
                    retval = Status_Reset;
 8011656:	2412      	movs	r4, #18
 8011658:	e5ce      	b.n	80111f8 <system_execute_line+0x110>
                else if (settings.homing.flags.enabled && settings.homing.flags.init_lock && sys.homed.mask != sys.homing.mask)
 801165a:	7b72      	ldrb	r2, [r6, #13]
 801165c:	7b33      	ldrb	r3, [r6, #12]
 801165e:	429a      	cmp	r2, r3
 8011660:	f43f af63 	beq.w	801152a <system_execute_line+0x442>
                    retval = Status_HomingRequired;
 8011664:	242e      	movs	r4, #46	; 0x2e
 8011666:	e5c7      	b.n	80111f8 <system_execute_line+0x110>
                else if (settings.limits.flags.hard_enabled && settings.limits.flags.check_at_init && hal.limits_get_state().value)
 8011668:	f8d8 3020 	ldr.w	r3, [r8, #32]
 801166c:	4798      	blx	r3
 801166e:	f010 0fff 	tst.w	r0, #255	; 0xff
 8011672:	f43f af53 	beq.w	801151c <system_execute_line+0x434>
                    retval = Status_LimitsEngaged;
 8011676:	242d      	movs	r4, #45	; 0x2d
 8011678:	e5be      	b.n	80111f8 <system_execute_line+0x110>
                report_execute_startup_message(line, gc_execute_block(line, NULL));
 801167a:	2100      	movs	r1, #0
 801167c:	4628      	mov	r0, r5
 801167e:	f7f3 ffe7 	bl	8005650 <gc_execute_block>
 8011682:	4601      	mov	r1, r0
 8011684:	4628      	mov	r0, r5
 8011686:	f7fb febf 	bl	800d408 <report_execute_startup_message>
 801168a:	e687      	b.n	801139c <system_execute_line+0x2b4>
                report_execute_startup_message(line, Status_SettingReadFail);
 801168c:	2107      	movs	r1, #7
 801168e:	4628      	mov	r0, r5
 8011690:	f7fb feba 	bl	800d408 <report_execute_startup_message>
 8011694:	e682      	b.n	801139c <system_execute_line+0x2b4>
                            retval = mc_homing_cycle((axes_signals_t){Z_AXIS_BIT});
 8011696:	f04f 0004 	mov.w	r0, #4
 801169a:	f7f8 fbf7 	bl	8009e8c <mc_homing_cycle>
 801169e:	4607      	mov	r7, r0
                    switch (line[2]) {
 80116a0:	e65c      	b.n	801135c <system_execute_line+0x274>
                            retval = mc_homing_cycle((axes_signals_t){Y_AXIS_BIT});
 80116a2:	f04f 0002 	mov.w	r0, #2
 80116a6:	f7f8 fbf1 	bl	8009e8c <mc_homing_cycle>
 80116aa:	4607      	mov	r7, r0
                            break;
 80116ac:	e656      	b.n	801135c <system_execute_line+0x274>
                retval = Status_OK;
 80116ae:	2400      	movs	r4, #0
 80116b0:	e5a2      	b.n	80111f8 <system_execute_line+0x110>
                        restore.mask = settings_all.mask;
 80116b2:	4b10      	ldr	r3, [pc, #64]	; (80116f4 <system_execute_line+0x60c>)
 80116b4:	7818      	ldrb	r0, [r3, #0]
                if(retval == Status_OK && restore.mask) {
 80116b6:	b2c4      	uxtb	r4, r0
 80116b8:	2c00      	cmp	r4, #0
 80116ba:	f43f ad9d 	beq.w	80111f8 <system_execute_line+0x110>
                    settings_restore(restore);
 80116be:	f7fc fd71 	bl	800e1a4 <settings_restore>
                    hal.report.feedback_message(Message_RestoreDefaults);
 80116c2:	4b0b      	ldr	r3, [pc, #44]	; (80116f0 <system_execute_line+0x608>)
 80116c4:	2009      	movs	r0, #9
 80116c6:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 80116ca:	4798      	blx	r3
                    mc_reset(); // Force reset to ensure settings are initialized correctly.
 80116cc:	2400      	movs	r4, #0
 80116ce:	f7f8 fb95 	bl	8009dfc <mc_reset>
 80116d2:	e591      	b.n	80111f8 <system_execute_line+0x110>
                        restore.driver_parameters = On;
 80116d4:	f04f 0010 	mov.w	r0, #16
                if(retval == Status_OK && restore.mask) {
 80116d8:	e7ed      	b.n	80116b6 <system_execute_line+0x5ce>
                        restore.defaults = On;
 80116da:	f04f 0001 	mov.w	r0, #1
                if(retval == Status_OK && restore.mask) {
 80116de:	e7ea      	b.n	80116b6 <system_execute_line+0x5ce>
                        restore.parameters = On;
 80116e0:	f04f 0002 	mov.w	r0, #2
                if(retval == Status_OK && restore.mask) {
 80116e4:	e7e7      	b.n	80116b6 <system_execute_line+0x5ce>
 80116e6:	bf00      	nop
 80116e8:	20002494 	.word	0x20002494
 80116ec:	20002620 	.word	0x20002620
 80116f0:	200024bc 	.word	0x200024bc
 80116f4:	08014f70 	.word	0x08014f70

080116f8 <system_flag_wco_change>:

void system_flag_wco_change ()
{
 80116f8:	b508      	push	{r3, lr}
    if(!settings.flags.force_buffer_sync_on_wco_change)
 80116fa:	4b09      	ldr	r3, [pc, #36]	; (8011720 <system_flag_wco_change+0x28>)
 80116fc:	f893 30bd 	ldrb.w	r3, [r3, #189]	; 0xbd
 8011700:	065b      	lsls	r3, r3, #25
 8011702:	d505      	bpl.n	8011710 <system_flag_wco_change+0x18>
        protocol_buffer_synchronize();

    sys.report.wco = On;
 8011704:	4a07      	ldr	r2, [pc, #28]	; (8011724 <system_flag_wco_change+0x2c>)
 8011706:	7d53      	ldrb	r3, [r2, #21]
 8011708:	f043 0301 	orr.w	r3, r3, #1
 801170c:	7553      	strb	r3, [r2, #21]
}
 801170e:	bd08      	pop	{r3, pc}
        protocol_buffer_synchronize();
 8011710:	f7fa f9d0 	bl	800bab4 <protocol_buffer_synchronize>
    sys.report.wco = On;
 8011714:	4a03      	ldr	r2, [pc, #12]	; (8011724 <system_flag_wco_change+0x2c>)
 8011716:	7d53      	ldrb	r3, [r2, #21]
 8011718:	f043 0301 	orr.w	r3, r3, #1
 801171c:	7553      	strb	r3, [r2, #21]
}
 801171e:	bd08      	pop	{r3, pc}
 8011720:	20002620 	.word	0x20002620
 8011724:	20002494 	.word	0x20002494

08011728 <system_convert_array_steps_to_mpos>:

// Sets machine position. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//       serves as a central place to compute the transformation.
void system_convert_array_steps_to_mpos (float *position, int32_t *steps)
{
 8011728:	b570      	push	{r4, r5, r6, lr}
    kinematics.convert_array_steps_to_mpos(position, steps);
#else
    uint_fast8_t idx = N_AXIS;
    do {
        idx--;
        position[idx] = steps[idx] / settings.steps_per_mm[idx];
 801172a:	4e0d      	ldr	r6, [pc, #52]	; (8011760 <system_convert_array_steps_to_mpos+0x38>)
{
 801172c:	4604      	mov	r4, r0
        position[idx] = steps[idx] / settings.steps_per_mm[idx];
 801172e:	6888      	ldr	r0, [r1, #8]
{
 8011730:	460d      	mov	r5, r1
        position[idx] = steps[idx] / settings.steps_per_mm[idx];
 8011732:	f7ee ffdb 	bl	80006ec <__aeabi_i2f>
 8011736:	68f1      	ldr	r1, [r6, #12]
 8011738:	f7ef f8e0 	bl	80008fc <__aeabi_fdiv>
 801173c:	4603      	mov	r3, r0
 801173e:	6868      	ldr	r0, [r5, #4]
 8011740:	60a3      	str	r3, [r4, #8]
 8011742:	f7ee ffd3 	bl	80006ec <__aeabi_i2f>
 8011746:	68b1      	ldr	r1, [r6, #8]
 8011748:	f7ef f8d8 	bl	80008fc <__aeabi_fdiv>
 801174c:	4603      	mov	r3, r0
 801174e:	6828      	ldr	r0, [r5, #0]
 8011750:	6063      	str	r3, [r4, #4]
 8011752:	f7ee ffcb 	bl	80006ec <__aeabi_i2f>
 8011756:	6871      	ldr	r1, [r6, #4]
 8011758:	f7ef f8d0 	bl	80008fc <__aeabi_fdiv>
 801175c:	6020      	str	r0, [r4, #0]
    } while(idx);
#endif
}
 801175e:	bd70      	pop	{r4, r5, r6, pc}
 8011760:	20002620 	.word	0x20002620

08011764 <system_check_travel_limits>:

// Checks and reports if target array exceeds machine travel limits. Returns false if check failed.
// NOTE: max_travel is stored as negative
// TODO: only check homed axes?
bool system_check_travel_limits (float *target)
{
 8011764:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    bool failed = false;
    uint_fast8_t idx = N_AXIS;

    if(settings.homing.flags.force_set_origin) {
 8011768:	4e64      	ldr	r6, [pc, #400]	; (80118fc <system_check_travel_limits+0x198>)
{
 801176a:	4605      	mov	r5, r0
    if(settings.homing.flags.force_set_origin) {
 801176c:	f896 30d0 	ldrb.w	r3, [r6, #208]	; 0xd0
 8011770:	f013 0408 	ands.w	r4, r3, #8
 8011774:	d02a      	beq.n	80117cc <system_check_travel_limits+0x68>
        do {
            idx--;
        // When homing forced set origin is enabled, soft limits checks need to account for directionality.
            failed = settings.max_travel[idx] < -0.0f &&
 8011776:	f8d6 9030 	ldr.w	r9, [r6, #48]	; 0x30
 801177a:	2100      	movs	r1, #0
 801177c:	4648      	mov	r0, r9
 801177e:	f7ef f9a7 	bl	8000ad0 <__aeabi_fcmplt>
                      (bit_istrue(settings.homing.dir_mask.value, bit(idx))
 8011782:	f896 80cc 	ldrb.w	r8, [r6, #204]	; 0xcc
            failed = settings.max_travel[idx] < -0.0f &&
 8011786:	2800      	cmp	r0, #0
 8011788:	d141      	bne.n	801180e <system_check_travel_limits+0xaa>
 801178a:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
 801178e:	2100      	movs	r1, #0
 8011790:	4648      	mov	r0, r9
 8011792:	f7ef f99d 	bl	8000ad0 <__aeabi_fcmplt>
 8011796:	2800      	cmp	r0, #0
 8011798:	d161      	bne.n	801185e <system_check_travel_limits+0xfa>
 801179a:	6ab6      	ldr	r6, [r6, #40]	; 0x28
 801179c:	2100      	movs	r1, #0
 801179e:	4630      	mov	r0, r6
 80117a0:	f7ef f996 	bl	8000ad0 <__aeabi_fcmplt>
 80117a4:	b330      	cbz	r0, 80117f4 <system_check_travel_limits+0x90>
 80117a6:	f018 0801 	ands.w	r8, r8, #1
 80117aa:	f000 8097 	beq.w	80118dc <system_check_travel_limits+0x178>
                        ? (target[idx] < 0.0f || target[idx] > -settings.max_travel[idx])
 80117ae:	682c      	ldr	r4, [r5, #0]
 80117b0:	2100      	movs	r1, #0
 80117b2:	4620      	mov	r0, r4
 80117b4:	f7ef f98c 	bl	8000ad0 <__aeabi_fcmplt>
 80117b8:	bb30      	cbnz	r0, 8011808 <system_check_travel_limits+0xa4>
 80117ba:	4620      	mov	r0, r4
 80117bc:	f106 4100 	add.w	r1, r6, #2147483648	; 0x80000000
 80117c0:	f7ef f9a4 	bl	8000b0c <__aeabi_fcmpgt>
 80117c4:	fab0 f080 	clz	r0, r0
 80117c8:	0940      	lsrs	r0, r0, #5
 80117ca:	e014      	b.n	80117f6 <system_check_travel_limits+0x92>
                        : (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]));
        } while(!failed && idx);
    } else do {
        idx--;
        failed = settings.max_travel[idx] < -0.0f && (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]);
 80117cc:	6b37      	ldr	r7, [r6, #48]	; 0x30
 80117ce:	2100      	movs	r1, #0
 80117d0:	4638      	mov	r0, r7
 80117d2:	f7ef f97d 	bl	8000ad0 <__aeabi_fcmplt>
 80117d6:	b980      	cbnz	r0, 80117fa <system_check_travel_limits+0x96>
 80117d8:	6af7      	ldr	r7, [r6, #44]	; 0x2c
 80117da:	2100      	movs	r1, #0
 80117dc:	4638      	mov	r0, r7
 80117de:	f7ef f977 	bl	8000ad0 <__aeabi_fcmplt>
 80117e2:	2800      	cmp	r0, #0
 80117e4:	d14d      	bne.n	8011882 <system_check_travel_limits+0x11e>
 80117e6:	6ab4      	ldr	r4, [r6, #40]	; 0x28
 80117e8:	2100      	movs	r1, #0
 80117ea:	4620      	mov	r0, r4
 80117ec:	f7ef f970 	bl	8000ad0 <__aeabi_fcmplt>
 80117f0:	2800      	cmp	r0, #0
 80117f2:	d155      	bne.n	80118a0 <system_check_travel_limits+0x13c>
 80117f4:	2001      	movs	r0, #1
    } while(!failed && idx);

    return !failed;
}
 80117f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        failed = settings.max_travel[idx] < -0.0f && (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]);
 80117fa:	f8d5 9008 	ldr.w	r9, [r5, #8]
 80117fe:	2100      	movs	r1, #0
 8011800:	4648      	mov	r0, r9
 8011802:	f7ef f983 	bl	8000b0c <__aeabi_fcmpgt>
 8011806:	b318      	cbz	r0, 8011850 <system_check_travel_limits+0xec>
 8011808:	2000      	movs	r0, #0
}
 801180a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            failed = settings.max_travel[idx] < -0.0f &&
 801180e:	f018 0f04 	tst.w	r8, #4
 8011812:	d00e      	beq.n	8011832 <system_check_travel_limits+0xce>
                        ? (target[idx] < 0.0f || target[idx] > -settings.max_travel[idx])
 8011814:	68ac      	ldr	r4, [r5, #8]
 8011816:	2100      	movs	r1, #0
 8011818:	4620      	mov	r0, r4
 801181a:	f7ef f959 	bl	8000ad0 <__aeabi_fcmplt>
 801181e:	2800      	cmp	r0, #0
 8011820:	d1f2      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011822:	4620      	mov	r0, r4
 8011824:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
 8011828:	f7ef f970 	bl	8000b0c <__aeabi_fcmpgt>
 801182c:	2800      	cmp	r0, #0
 801182e:	d1eb      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011830:	e7ab      	b.n	801178a <system_check_travel_limits+0x26>
                        : (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]));
 8011832:	f8d5 a008 	ldr.w	sl, [r5, #8]
 8011836:	2100      	movs	r1, #0
 8011838:	4650      	mov	r0, sl
 801183a:	f7ef f967 	bl	8000b0c <__aeabi_fcmpgt>
 801183e:	2800      	cmp	r0, #0
 8011840:	d1e2      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011842:	4651      	mov	r1, sl
 8011844:	4648      	mov	r0, r9
 8011846:	f7ef f961 	bl	8000b0c <__aeabi_fcmpgt>
 801184a:	2800      	cmp	r0, #0
 801184c:	d1dc      	bne.n	8011808 <system_check_travel_limits+0xa4>
 801184e:	e79c      	b.n	801178a <system_check_travel_limits+0x26>
        failed = settings.max_travel[idx] < -0.0f && (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]);
 8011850:	4649      	mov	r1, r9
 8011852:	4638      	mov	r0, r7
 8011854:	f7ef f95a 	bl	8000b0c <__aeabi_fcmpgt>
 8011858:	2800      	cmp	r0, #0
 801185a:	d1d5      	bne.n	8011808 <system_check_travel_limits+0xa4>
 801185c:	e7bc      	b.n	80117d8 <system_check_travel_limits+0x74>
            failed = settings.max_travel[idx] < -0.0f &&
 801185e:	f018 0f02 	tst.w	r8, #2
 8011862:	d12c      	bne.n	80118be <system_check_travel_limits+0x15a>
                        : (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]));
 8011864:	f8d5 a004 	ldr.w	sl, [r5, #4]
 8011868:	2100      	movs	r1, #0
 801186a:	4650      	mov	r0, sl
 801186c:	f7ef f94e 	bl	8000b0c <__aeabi_fcmpgt>
 8011870:	2800      	cmp	r0, #0
 8011872:	d1c9      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011874:	4651      	mov	r1, sl
 8011876:	4648      	mov	r0, r9
 8011878:	f7ef f948 	bl	8000b0c <__aeabi_fcmpgt>
 801187c:	2800      	cmp	r0, #0
 801187e:	d1c3      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011880:	e78b      	b.n	801179a <system_check_travel_limits+0x36>
        failed = settings.max_travel[idx] < -0.0f && (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]);
 8011882:	f8d5 8004 	ldr.w	r8, [r5, #4]
 8011886:	2100      	movs	r1, #0
 8011888:	4640      	mov	r0, r8
 801188a:	f7ef f93f 	bl	8000b0c <__aeabi_fcmpgt>
 801188e:	2800      	cmp	r0, #0
 8011890:	d1ba      	bne.n	8011808 <system_check_travel_limits+0xa4>
 8011892:	4641      	mov	r1, r8
 8011894:	4638      	mov	r0, r7
 8011896:	f7ef f939 	bl	8000b0c <__aeabi_fcmpgt>
 801189a:	2800      	cmp	r0, #0
 801189c:	d1b4      	bne.n	8011808 <system_check_travel_limits+0xa4>
 801189e:	e7a2      	b.n	80117e6 <system_check_travel_limits+0x82>
 80118a0:	682d      	ldr	r5, [r5, #0]
 80118a2:	2100      	movs	r1, #0
 80118a4:	4628      	mov	r0, r5
 80118a6:	f7ef f931 	bl	8000b0c <__aeabi_fcmpgt>
 80118aa:	2800      	cmp	r0, #0
 80118ac:	d1ac      	bne.n	8011808 <system_check_travel_limits+0xa4>
 80118ae:	4629      	mov	r1, r5
 80118b0:	4620      	mov	r0, r4
 80118b2:	f7ef f92b 	bl	8000b0c <__aeabi_fcmpgt>
 80118b6:	fab0 f080 	clz	r0, r0
 80118ba:	0940      	lsrs	r0, r0, #5
 80118bc:	e79b      	b.n	80117f6 <system_check_travel_limits+0x92>
                        ? (target[idx] < 0.0f || target[idx] > -settings.max_travel[idx])
 80118be:	686c      	ldr	r4, [r5, #4]
 80118c0:	2100      	movs	r1, #0
 80118c2:	4620      	mov	r0, r4
 80118c4:	f7ef f904 	bl	8000ad0 <__aeabi_fcmplt>
 80118c8:	2800      	cmp	r0, #0
 80118ca:	d19d      	bne.n	8011808 <system_check_travel_limits+0xa4>
 80118cc:	4620      	mov	r0, r4
 80118ce:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
 80118d2:	f7ef f91b 	bl	8000b0c <__aeabi_fcmpgt>
 80118d6:	2800      	cmp	r0, #0
 80118d8:	d196      	bne.n	8011808 <system_check_travel_limits+0xa4>
 80118da:	e75e      	b.n	801179a <system_check_travel_limits+0x36>
                        : (target[idx] > 0.0f || target[idx] < settings.max_travel[idx]));
 80118dc:	682d      	ldr	r5, [r5, #0]
 80118de:	2100      	movs	r1, #0
 80118e0:	4628      	mov	r0, r5
 80118e2:	f7ef f913 	bl	8000b0c <__aeabi_fcmpgt>
 80118e6:	2800      	cmp	r0, #0
 80118e8:	d18e      	bne.n	8011808 <system_check_travel_limits+0xa4>
 80118ea:	4629      	mov	r1, r5
 80118ec:	4630      	mov	r0, r6
 80118ee:	f7ef f90d 	bl	8000b0c <__aeabi_fcmpgt>
 80118f2:	fab0 f080 	clz	r0, r0
 80118f6:	0940      	lsrs	r0, r0, #5
 80118f8:	e77d      	b.n	80117f6 <system_check_travel_limits+0x92>
 80118fa:	bf00      	nop
 80118fc:	20002620 	.word	0x20002620

08011900 <system_apply_jog_limits>:

// Limits jog commands to be within machine limits, homed axes only.
// When hard limits are enabled pulloff distance is subtracted to avoid triggering limit switches.
// NOTE: max_travel is stored as negative
void system_apply_jog_limits (float *target)
{
 8011900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint_fast8_t idx = N_AXIS;

    if(sys.homed.mask) do {
 8011904:	4b9a      	ldr	r3, [pc, #616]	; (8011b70 <system_apply_jog_limits+0x270>)
{
 8011906:	b085      	sub	sp, #20
    if(sys.homed.mask) do {
 8011908:	7b5c      	ldrb	r4, [r3, #13]
 801190a:	2c00      	cmp	r4, #0
 801190c:	d037      	beq.n	801197e <system_apply_jog_limits+0x7e>
        idx--;
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801190e:	4d99      	ldr	r5, [pc, #612]	; (8011b74 <system_apply_jog_limits+0x274>)
 8011910:	f893 900c 	ldrb.w	r9, [r3, #12]
 8011914:	f895 30d4 	ldrb.w	r3, [r5, #212]	; 0xd4
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
            if(settings.homing.flags.force_set_origin) {
 8011918:	f895 20d0 	ldrb.w	r2, [r5, #208]	; 0xd0
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801191c:	f013 0701 	ands.w	r7, r3, #1
 8011920:	4606      	mov	r6, r0
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011922:	f895 a0cc 	ldrb.w	sl, [r5, #204]	; 0xcc
            if(settings.homing.flags.force_set_origin) {
 8011926:	f002 0808 	and.w	r8, r2, #8
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801192a:	d02b      	beq.n	8011984 <system_apply_jog_limits+0x84>
 801192c:	f019 0f04 	tst.w	r9, #4
 8011930:	f040 80a1 	bne.w	8011a76 <system_apply_jog_limits+0x176>
 8011934:	2300      	movs	r3, #0
 8011936:	9301      	str	r3, [sp, #4]
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011938:	0763      	lsls	r3, r4, #29
 801193a:	d506      	bpl.n	801194a <system_apply_jog_limits+0x4a>
 801193c:	f8d5 b030 	ldr.w	fp, [r5, #48]	; 0x30
 8011940:	2100      	movs	r1, #0
 8011942:	4658      	mov	r0, fp
 8011944:	f7ef f8c4 	bl	8000ad0 <__aeabi_fcmplt>
 8011948:	bb38      	cbnz	r0, 801199a <system_apply_jog_limits+0x9a>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801194a:	f019 0f02 	tst.w	r9, #2
 801194e:	f000 80b5 	beq.w	8011abc <system_apply_jog_limits+0x1bc>
 8011952:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 8011956:	9301      	str	r3, [sp, #4]
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011958:	07a1      	lsls	r1, r4, #30
 801195a:	d509      	bpl.n	8011970 <system_apply_jog_limits+0x70>
 801195c:	f8d5 b02c 	ldr.w	fp, [r5, #44]	; 0x2c
 8011960:	2100      	movs	r1, #0
 8011962:	4658      	mov	r0, fp
 8011964:	f7ef f8b4 	bl	8000ad0 <__aeabi_fcmplt>
 8011968:	2800      	cmp	r0, #0
 801196a:	d13f      	bne.n	80119ec <system_apply_jog_limits+0xec>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 801196c:	2f00      	cmp	r7, #0
 801196e:	d05b      	beq.n	8011a28 <system_apply_jog_limits+0x128>
 8011970:	f019 0f01 	tst.w	r9, #1
 8011974:	d058      	beq.n	8011a28 <system_apply_jog_limits+0x128>
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011976:	07e0      	lsls	r0, r4, #31
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011978:	f8d5 70c8 	ldr.w	r7, [r5, #200]	; 0xc8
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 801197c:	d458      	bmi.n	8011a30 <system_apply_jog_limits+0x130>
                else if(target[idx] < (settings.max_travel[idx] + pulloff))
                    target[idx] = (settings.max_travel[idx] + pulloff);
            }
        }
    } while(idx);
}
 801197e:	b005      	add	sp, #20
 8011980:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011984:	0763      	lsls	r3, r4, #29
 8011986:	d526      	bpl.n	80119d6 <system_apply_jog_limits+0xd6>
 8011988:	f8d5 b030 	ldr.w	fp, [r5, #48]	; 0x30
 801198c:	2100      	movs	r1, #0
 801198e:	4658      	mov	r0, fp
 8011990:	f7ef f89e 	bl	8000ad0 <__aeabi_fcmplt>
 8011994:	b1f8      	cbz	r0, 80119d6 <system_apply_jog_limits+0xd6>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011996:	2300      	movs	r3, #0
 8011998:	9301      	str	r3, [sp, #4]
                    if(target[idx] > 0.0f)
 801199a:	68b2      	ldr	r2, [r6, #8]
            if(settings.homing.flags.force_set_origin) {
 801199c:	f1b8 0f00 	cmp.w	r8, #0
 80119a0:	d17b      	bne.n	8011a9a <system_apply_jog_limits+0x19a>
                if(target[idx] > -pulloff)
 80119a2:	9b01      	ldr	r3, [sp, #4]
 80119a4:	4610      	mov	r0, r2
 80119a6:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 80119aa:	e9cd 1202 	strd	r1, r2, [sp, #8]
 80119ae:	f7ef f8ad 	bl	8000b0c <__aeabi_fcmpgt>
 80119b2:	9902      	ldr	r1, [sp, #8]
 80119b4:	2800      	cmp	r0, #0
 80119b6:	d17c      	bne.n	8011ab2 <system_apply_jog_limits+0x1b2>
                    else if(target[idx] < (settings.max_travel[idx] + pulloff))
 80119b8:	4658      	mov	r0, fp
 80119ba:	9901      	ldr	r1, [sp, #4]
 80119bc:	f7ee fde2 	bl	8000584 <__addsf3>
 80119c0:	4683      	mov	fp, r0
 80119c2:	9a03      	ldr	r2, [sp, #12]
 80119c4:	4659      	mov	r1, fp
 80119c6:	4610      	mov	r0, r2
 80119c8:	f7ef f882 	bl	8000ad0 <__aeabi_fcmplt>
 80119cc:	b108      	cbz	r0, 80119d2 <system_apply_jog_limits+0xd2>
                        target[idx] = (settings.max_travel[idx] + pulloff);
 80119ce:	f8c6 b008 	str.w	fp, [r6, #8]
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 80119d2:	2f00      	cmp	r7, #0
 80119d4:	d1b9      	bne.n	801194a <system_apply_jog_limits+0x4a>
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 80119d6:	07a2      	lsls	r2, r4, #30
 80119d8:	d526      	bpl.n	8011a28 <system_apply_jog_limits+0x128>
 80119da:	f8d5 b02c 	ldr.w	fp, [r5, #44]	; 0x2c
 80119de:	2100      	movs	r1, #0
 80119e0:	4658      	mov	r0, fp
 80119e2:	f7ef f875 	bl	8000ad0 <__aeabi_fcmplt>
 80119e6:	b1f8      	cbz	r0, 8011a28 <system_apply_jog_limits+0x128>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 80119e8:	2300      	movs	r3, #0
 80119ea:	9301      	str	r3, [sp, #4]
                    if(target[idx] > 0.0f)
 80119ec:	6872      	ldr	r2, [r6, #4]
            if(settings.homing.flags.force_set_origin) {
 80119ee:	f1b8 0f00 	cmp.w	r8, #0
 80119f2:	d144      	bne.n	8011a7e <system_apply_jog_limits+0x17e>
                if(target[idx] > -pulloff)
 80119f4:	9b01      	ldr	r3, [sp, #4]
 80119f6:	4610      	mov	r0, r2
 80119f8:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 80119fc:	e9cd 1202 	strd	r1, r2, [sp, #8]
 8011a00:	f7ef f884 	bl	8000b0c <__aeabi_fcmpgt>
 8011a04:	9902      	ldr	r1, [sp, #8]
 8011a06:	2800      	cmp	r0, #0
 8011a08:	d145      	bne.n	8011a96 <system_apply_jog_limits+0x196>
                    else if(target[idx] < (settings.max_travel[idx] + pulloff))
 8011a0a:	4658      	mov	r0, fp
 8011a0c:	9901      	ldr	r1, [sp, #4]
 8011a0e:	f7ee fdb9 	bl	8000584 <__addsf3>
 8011a12:	4683      	mov	fp, r0
 8011a14:	9a03      	ldr	r2, [sp, #12]
 8011a16:	4659      	mov	r1, fp
 8011a18:	4610      	mov	r0, r2
 8011a1a:	f7ef f859 	bl	8000ad0 <__aeabi_fcmplt>
 8011a1e:	2800      	cmp	r0, #0
 8011a20:	d0a4      	beq.n	801196c <system_apply_jog_limits+0x6c>
                        target[idx] = (settings.max_travel[idx] + pulloff);
 8011a22:	f8c6 b004 	str.w	fp, [r6, #4]
 8011a26:	e7a1      	b.n	801196c <system_apply_jog_limits+0x6c>
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011a28:	07e0      	lsls	r0, r4, #31
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011a2a:	f04f 0700 	mov.w	r7, #0
        if(bit_istrue(sys.homed.mask, bit(idx)) && settings.max_travel[idx] < -0.0f) {
 8011a2e:	d5a6      	bpl.n	801197e <system_apply_jog_limits+0x7e>
 8011a30:	2400      	movs	r4, #0
 8011a32:	6aad      	ldr	r5, [r5, #40]	; 0x28
 8011a34:	4621      	mov	r1, r4
 8011a36:	4628      	mov	r0, r5
 8011a38:	f7ef f84a 	bl	8000ad0 <__aeabi_fcmplt>
 8011a3c:	2800      	cmp	r0, #0
 8011a3e:	d09e      	beq.n	801197e <system_apply_jog_limits+0x7e>
            if(settings.homing.flags.force_set_origin) {
 8011a40:	f1b8 0f00 	cmp.w	r8, #0
 8011a44:	d03d      	beq.n	8011ac2 <system_apply_jog_limits+0x1c2>
                    if(target[idx] > 0.0f)
 8011a46:	f8d6 8000 	ldr.w	r8, [r6]
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011a4a:	f01a 0f01 	tst.w	sl, #1
                    if(target[idx] > 0.0f)
 8011a4e:	4621      	mov	r1, r4
 8011a50:	4640      	mov	r0, r8
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011a52:	d07b      	beq.n	8011b4c <system_apply_jog_limits+0x24c>
                    if(target[idx] < 0.0f)
 8011a54:	f7ef f83c 	bl	8000ad0 <__aeabi_fcmplt>
 8011a58:	b958      	cbnz	r0, 8011a72 <system_apply_jog_limits+0x172>
                    else if(target[idx] > -(settings.max_travel[idx] + pulloff))
 8011a5a:	4639      	mov	r1, r7
 8011a5c:	4628      	mov	r0, r5
 8011a5e:	f7ee fd91 	bl	8000584 <__addsf3>
 8011a62:	f100 4400 	add.w	r4, r0, #2147483648	; 0x80000000
 8011a66:	4621      	mov	r1, r4
 8011a68:	4640      	mov	r0, r8
 8011a6a:	f7ef f84f 	bl	8000b0c <__aeabi_fcmpgt>
 8011a6e:	2800      	cmp	r0, #0
 8011a70:	d085      	beq.n	801197e <system_apply_jog_limits+0x7e>
                        target[idx] = -(settings.max_travel[idx] + pulloff);
 8011a72:	6034      	str	r4, [r6, #0]
 8011a74:	e783      	b.n	801197e <system_apply_jog_limits+0x7e>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011a76:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
 8011a7a:	9301      	str	r3, [sp, #4]
 8011a7c:	e75c      	b.n	8011938 <system_apply_jog_limits+0x38>
                    if(target[idx] > 0.0f)
 8011a7e:	2100      	movs	r1, #0
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011a80:	f01a 0f02 	tst.w	sl, #2
                    if(target[idx] > 0.0f)
 8011a84:	4610      	mov	r0, r2
 8011a86:	e9cd 1202 	strd	r1, r2, [sp, #8]
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011a8a:	d148      	bne.n	8011b1e <system_apply_jog_limits+0x21e>
                    if(target[idx] > 0.0f)
 8011a8c:	f7ef f83e 	bl	8000b0c <__aeabi_fcmpgt>
 8011a90:	9902      	ldr	r1, [sp, #8]
 8011a92:	2800      	cmp	r0, #0
 8011a94:	d0b9      	beq.n	8011a0a <system_apply_jog_limits+0x10a>
                        target[idx] = 0.0f;
 8011a96:	6071      	str	r1, [r6, #4]
 8011a98:	e768      	b.n	801196c <system_apply_jog_limits+0x6c>
                    if(target[idx] > 0.0f)
 8011a9a:	2100      	movs	r1, #0
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011a9c:	f01a 0f04 	tst.w	sl, #4
                    if(target[idx] > 0.0f)
 8011aa0:	4610      	mov	r0, r2
 8011aa2:	e9cd 1202 	strd	r1, r2, [sp, #8]
                if(bit_isfalse(settings.homing.dir_mask.value, bit(idx))) {
 8011aa6:	d123      	bne.n	8011af0 <system_apply_jog_limits+0x1f0>
                    if(target[idx] > 0.0f)
 8011aa8:	f7ef f830 	bl	8000b0c <__aeabi_fcmpgt>
 8011aac:	9902      	ldr	r1, [sp, #8]
 8011aae:	2800      	cmp	r0, #0
 8011ab0:	d082      	beq.n	80119b8 <system_apply_jog_limits+0xb8>
                        target[idx] = 0.0f;
 8011ab2:	60b1      	str	r1, [r6, #8]
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011ab4:	2f00      	cmp	r7, #0
 8011ab6:	f47f af48 	bne.w	801194a <system_apply_jog_limits+0x4a>
 8011aba:	e78c      	b.n	80119d6 <system_apply_jog_limits+0xd6>
 8011abc:	2300      	movs	r3, #0
 8011abe:	9301      	str	r3, [sp, #4]
 8011ac0:	e74a      	b.n	8011958 <system_apply_jog_limits+0x58>
                if(target[idx] > -pulloff)
 8011ac2:	6834      	ldr	r4, [r6, #0]
 8011ac4:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
 8011ac8:	4620      	mov	r0, r4
 8011aca:	4641      	mov	r1, r8
 8011acc:	f7ef f81e 	bl	8000b0c <__aeabi_fcmpgt>
 8011ad0:	2800      	cmp	r0, #0
 8011ad2:	d138      	bne.n	8011b46 <system_apply_jog_limits+0x246>
                else if(target[idx] < (settings.max_travel[idx] + pulloff))
 8011ad4:	4639      	mov	r1, r7
 8011ad6:	4628      	mov	r0, r5
 8011ad8:	f7ee fd54 	bl	8000584 <__addsf3>
 8011adc:	4605      	mov	r5, r0
 8011ade:	4620      	mov	r0, r4
 8011ae0:	4629      	mov	r1, r5
 8011ae2:	f7ee fff5 	bl	8000ad0 <__aeabi_fcmplt>
 8011ae6:	2800      	cmp	r0, #0
 8011ae8:	f43f af49 	beq.w	801197e <system_apply_jog_limits+0x7e>
                    target[idx] = (settings.max_travel[idx] + pulloff);
 8011aec:	6035      	str	r5, [r6, #0]
    } while(idx);
 8011aee:	e746      	b.n	801197e <system_apply_jog_limits+0x7e>
                    if(target[idx] < 0.0f)
 8011af0:	f7ee ffee 	bl	8000ad0 <__aeabi_fcmplt>
 8011af4:	9902      	ldr	r1, [sp, #8]
 8011af6:	2800      	cmp	r0, #0
 8011af8:	d1db      	bne.n	8011ab2 <system_apply_jog_limits+0x1b2>
                    else if(target[idx] > -(settings.max_travel[idx] + pulloff))
 8011afa:	4658      	mov	r0, fp
 8011afc:	9901      	ldr	r1, [sp, #4]
 8011afe:	f7ee fd41 	bl	8000584 <__addsf3>
 8011b02:	9a03      	ldr	r2, [sp, #12]
 8011b04:	f100 4b00 	add.w	fp, r0, #2147483648	; 0x80000000
 8011b08:	4659      	mov	r1, fp
 8011b0a:	4610      	mov	r0, r2
 8011b0c:	f7ee fffe 	bl	8000b0c <__aeabi_fcmpgt>
 8011b10:	2800      	cmp	r0, #0
 8011b12:	f47f af5c 	bne.w	80119ce <system_apply_jog_limits+0xce>
        float pulloff = settings.limits.flags.hard_enabled && bit_istrue(sys.homing.mask, bit(idx)) ? settings.homing.pulloff : 0.0f;
 8011b16:	2f00      	cmp	r7, #0
 8011b18:	f47f af17 	bne.w	801194a <system_apply_jog_limits+0x4a>
 8011b1c:	e75b      	b.n	80119d6 <system_apply_jog_limits+0xd6>
                    if(target[idx] < 0.0f)
 8011b1e:	f7ee ffd7 	bl	8000ad0 <__aeabi_fcmplt>
 8011b22:	9902      	ldr	r1, [sp, #8]
 8011b24:	2800      	cmp	r0, #0
 8011b26:	d1b6      	bne.n	8011a96 <system_apply_jog_limits+0x196>
                    else if(target[idx] > -(settings.max_travel[idx] + pulloff))
 8011b28:	4658      	mov	r0, fp
 8011b2a:	9901      	ldr	r1, [sp, #4]
 8011b2c:	f7ee fd2a 	bl	8000584 <__addsf3>
 8011b30:	9a03      	ldr	r2, [sp, #12]
 8011b32:	f100 4b00 	add.w	fp, r0, #2147483648	; 0x80000000
 8011b36:	4659      	mov	r1, fp
 8011b38:	4610      	mov	r0, r2
 8011b3a:	f7ee ffe7 	bl	8000b0c <__aeabi_fcmpgt>
 8011b3e:	2800      	cmp	r0, #0
 8011b40:	f43f af14 	beq.w	801196c <system_apply_jog_limits+0x6c>
 8011b44:	e76d      	b.n	8011a22 <system_apply_jog_limits+0x122>
                    target[idx] = -pulloff;
 8011b46:	f8c6 8000 	str.w	r8, [r6]
 8011b4a:	e718      	b.n	801197e <system_apply_jog_limits+0x7e>
                    if(target[idx] > 0.0f)
 8011b4c:	f7ee ffde 	bl	8000b0c <__aeabi_fcmpgt>
 8011b50:	2800      	cmp	r0, #0
 8011b52:	d18e      	bne.n	8011a72 <system_apply_jog_limits+0x172>
                    else if(target[idx] < (settings.max_travel[idx] + pulloff))
 8011b54:	4639      	mov	r1, r7
 8011b56:	4628      	mov	r0, r5
 8011b58:	f7ee fd14 	bl	8000584 <__addsf3>
 8011b5c:	4604      	mov	r4, r0
 8011b5e:	4640      	mov	r0, r8
 8011b60:	4621      	mov	r1, r4
 8011b62:	f7ee ffb5 	bl	8000ad0 <__aeabi_fcmplt>
 8011b66:	2800      	cmp	r0, #0
 8011b68:	f43f af09 	beq.w	801197e <system_apply_jog_limits+0x7e>
 8011b6c:	e781      	b.n	8011a72 <system_apply_jog_limits+0x172>
 8011b6e:	bf00      	nop
 8011b70:	20002494 	.word	0x20002494
 8011b74:	20002620 	.word	0x20002620

08011b78 <__assert_func>:
 8011b78:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8011b7a:	4614      	mov	r4, r2
 8011b7c:	461a      	mov	r2, r3
 8011b7e:	4b09      	ldr	r3, [pc, #36]	; (8011ba4 <__assert_func+0x2c>)
 8011b80:	4605      	mov	r5, r0
 8011b82:	681b      	ldr	r3, [r3, #0]
 8011b84:	68d8      	ldr	r0, [r3, #12]
 8011b86:	b14c      	cbz	r4, 8011b9c <__assert_func+0x24>
 8011b88:	4b07      	ldr	r3, [pc, #28]	; (8011ba8 <__assert_func+0x30>)
 8011b8a:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8011b8e:	9100      	str	r1, [sp, #0]
 8011b90:	462b      	mov	r3, r5
 8011b92:	4906      	ldr	r1, [pc, #24]	; (8011bac <__assert_func+0x34>)
 8011b94:	f000 f814 	bl	8011bc0 <fiprintf>
 8011b98:	f000 fd00 	bl	801259c <abort>
 8011b9c:	4b04      	ldr	r3, [pc, #16]	; (8011bb0 <__assert_func+0x38>)
 8011b9e:	461c      	mov	r4, r3
 8011ba0:	e7f3      	b.n	8011b8a <__assert_func+0x12>
 8011ba2:	bf00      	nop
 8011ba4:	2000001c 	.word	0x2000001c
 8011ba8:	08014f71 	.word	0x08014f71
 8011bac:	08014f7e 	.word	0x08014f7e
 8011bb0:	08014fac 	.word	0x08014fac

08011bb4 <__errno>:
 8011bb4:	4b01      	ldr	r3, [pc, #4]	; (8011bbc <__errno+0x8>)
 8011bb6:	6818      	ldr	r0, [r3, #0]
 8011bb8:	4770      	bx	lr
 8011bba:	bf00      	nop
 8011bbc:	2000001c 	.word	0x2000001c

08011bc0 <fiprintf>:
 8011bc0:	b40e      	push	{r1, r2, r3}
 8011bc2:	b503      	push	{r0, r1, lr}
 8011bc4:	4601      	mov	r1, r0
 8011bc6:	ab03      	add	r3, sp, #12
 8011bc8:	4805      	ldr	r0, [pc, #20]	; (8011be0 <fiprintf+0x20>)
 8011bca:	f853 2b04 	ldr.w	r2, [r3], #4
 8011bce:	6800      	ldr	r0, [r0, #0]
 8011bd0:	9301      	str	r3, [sp, #4]
 8011bd2:	f000 f92d 	bl	8011e30 <_vfiprintf_r>
 8011bd6:	b002      	add	sp, #8
 8011bd8:	f85d eb04 	ldr.w	lr, [sp], #4
 8011bdc:	b003      	add	sp, #12
 8011bde:	4770      	bx	lr
 8011be0:	2000001c 	.word	0x2000001c

08011be4 <__libc_init_array>:
 8011be4:	b570      	push	{r4, r5, r6, lr}
 8011be6:	2600      	movs	r6, #0
 8011be8:	4d0c      	ldr	r5, [pc, #48]	; (8011c1c <__libc_init_array+0x38>)
 8011bea:	4c0d      	ldr	r4, [pc, #52]	; (8011c20 <__libc_init_array+0x3c>)
 8011bec:	1b64      	subs	r4, r4, r5
 8011bee:	10a4      	asrs	r4, r4, #2
 8011bf0:	42a6      	cmp	r6, r4
 8011bf2:	d109      	bne.n	8011c08 <__libc_init_array+0x24>
 8011bf4:	f002 fe3a 	bl	801486c <_init>
 8011bf8:	2600      	movs	r6, #0
 8011bfa:	4d0a      	ldr	r5, [pc, #40]	; (8011c24 <__libc_init_array+0x40>)
 8011bfc:	4c0a      	ldr	r4, [pc, #40]	; (8011c28 <__libc_init_array+0x44>)
 8011bfe:	1b64      	subs	r4, r4, r5
 8011c00:	10a4      	asrs	r4, r4, #2
 8011c02:	42a6      	cmp	r6, r4
 8011c04:	d105      	bne.n	8011c12 <__libc_init_array+0x2e>
 8011c06:	bd70      	pop	{r4, r5, r6, pc}
 8011c08:	f855 3b04 	ldr.w	r3, [r5], #4
 8011c0c:	4798      	blx	r3
 8011c0e:	3601      	adds	r6, #1
 8011c10:	e7ee      	b.n	8011bf0 <__libc_init_array+0xc>
 8011c12:	f855 3b04 	ldr.w	r3, [r5], #4
 8011c16:	4798      	blx	r3
 8011c18:	3601      	adds	r6, #1
 8011c1a:	e7f2      	b.n	8011c02 <__libc_init_array+0x1e>
 8011c1c:	08015470 	.word	0x08015470
 8011c20:	08015470 	.word	0x08015470
 8011c24:	08015470 	.word	0x08015470
 8011c28:	08015474 	.word	0x08015474

08011c2c <malloc>:
 8011c2c:	4b02      	ldr	r3, [pc, #8]	; (8011c38 <malloc+0xc>)
 8011c2e:	4601      	mov	r1, r0
 8011c30:	6818      	ldr	r0, [r3, #0]
 8011c32:	f000 b87b 	b.w	8011d2c <_malloc_r>
 8011c36:	bf00      	nop
 8011c38:	2000001c 	.word	0x2000001c

08011c3c <free>:
 8011c3c:	4b02      	ldr	r3, [pc, #8]	; (8011c48 <free+0xc>)
 8011c3e:	4601      	mov	r1, r0
 8011c40:	6818      	ldr	r0, [r3, #0]
 8011c42:	f000 b827 	b.w	8011c94 <_free_r>
 8011c46:	bf00      	nop
 8011c48:	2000001c 	.word	0x2000001c

08011c4c <memcmp>:
 8011c4c:	b530      	push	{r4, r5, lr}
 8011c4e:	2400      	movs	r4, #0
 8011c50:	3901      	subs	r1, #1
 8011c52:	42a2      	cmp	r2, r4
 8011c54:	d101      	bne.n	8011c5a <memcmp+0xe>
 8011c56:	2000      	movs	r0, #0
 8011c58:	e005      	b.n	8011c66 <memcmp+0x1a>
 8011c5a:	5d03      	ldrb	r3, [r0, r4]
 8011c5c:	3401      	adds	r4, #1
 8011c5e:	5d0d      	ldrb	r5, [r1, r4]
 8011c60:	42ab      	cmp	r3, r5
 8011c62:	d0f6      	beq.n	8011c52 <memcmp+0x6>
 8011c64:	1b58      	subs	r0, r3, r5
 8011c66:	bd30      	pop	{r4, r5, pc}

08011c68 <memcpy>:
 8011c68:	440a      	add	r2, r1
 8011c6a:	4291      	cmp	r1, r2
 8011c6c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8011c70:	d100      	bne.n	8011c74 <memcpy+0xc>
 8011c72:	4770      	bx	lr
 8011c74:	b510      	push	{r4, lr}
 8011c76:	f811 4b01 	ldrb.w	r4, [r1], #1
 8011c7a:	4291      	cmp	r1, r2
 8011c7c:	f803 4f01 	strb.w	r4, [r3, #1]!
 8011c80:	d1f9      	bne.n	8011c76 <memcpy+0xe>
 8011c82:	bd10      	pop	{r4, pc}

08011c84 <memset>:
 8011c84:	4603      	mov	r3, r0
 8011c86:	4402      	add	r2, r0
 8011c88:	4293      	cmp	r3, r2
 8011c8a:	d100      	bne.n	8011c8e <memset+0xa>
 8011c8c:	4770      	bx	lr
 8011c8e:	f803 1b01 	strb.w	r1, [r3], #1
 8011c92:	e7f9      	b.n	8011c88 <memset+0x4>

08011c94 <_free_r>:
 8011c94:	b538      	push	{r3, r4, r5, lr}
 8011c96:	4605      	mov	r5, r0
 8011c98:	2900      	cmp	r1, #0
 8011c9a:	d043      	beq.n	8011d24 <_free_r+0x90>
 8011c9c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8011ca0:	1f0c      	subs	r4, r1, #4
 8011ca2:	2b00      	cmp	r3, #0
 8011ca4:	bfb8      	it	lt
 8011ca6:	18e4      	addlt	r4, r4, r3
 8011ca8:	f000 feac 	bl	8012a04 <__malloc_lock>
 8011cac:	4a1e      	ldr	r2, [pc, #120]	; (8011d28 <_free_r+0x94>)
 8011cae:	6813      	ldr	r3, [r2, #0]
 8011cb0:	4610      	mov	r0, r2
 8011cb2:	b933      	cbnz	r3, 8011cc2 <_free_r+0x2e>
 8011cb4:	6063      	str	r3, [r4, #4]
 8011cb6:	6014      	str	r4, [r2, #0]
 8011cb8:	4628      	mov	r0, r5
 8011cba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8011cbe:	f000 bea7 	b.w	8012a10 <__malloc_unlock>
 8011cc2:	42a3      	cmp	r3, r4
 8011cc4:	d90a      	bls.n	8011cdc <_free_r+0x48>
 8011cc6:	6821      	ldr	r1, [r4, #0]
 8011cc8:	1862      	adds	r2, r4, r1
 8011cca:	4293      	cmp	r3, r2
 8011ccc:	bf01      	itttt	eq
 8011cce:	681a      	ldreq	r2, [r3, #0]
 8011cd0:	685b      	ldreq	r3, [r3, #4]
 8011cd2:	1852      	addeq	r2, r2, r1
 8011cd4:	6022      	streq	r2, [r4, #0]
 8011cd6:	6063      	str	r3, [r4, #4]
 8011cd8:	6004      	str	r4, [r0, #0]
 8011cda:	e7ed      	b.n	8011cb8 <_free_r+0x24>
 8011cdc:	461a      	mov	r2, r3
 8011cde:	685b      	ldr	r3, [r3, #4]
 8011ce0:	b10b      	cbz	r3, 8011ce6 <_free_r+0x52>
 8011ce2:	42a3      	cmp	r3, r4
 8011ce4:	d9fa      	bls.n	8011cdc <_free_r+0x48>
 8011ce6:	6811      	ldr	r1, [r2, #0]
 8011ce8:	1850      	adds	r0, r2, r1
 8011cea:	42a0      	cmp	r0, r4
 8011cec:	d10b      	bne.n	8011d06 <_free_r+0x72>
 8011cee:	6820      	ldr	r0, [r4, #0]
 8011cf0:	4401      	add	r1, r0
 8011cf2:	1850      	adds	r0, r2, r1
 8011cf4:	4283      	cmp	r3, r0
 8011cf6:	6011      	str	r1, [r2, #0]
 8011cf8:	d1de      	bne.n	8011cb8 <_free_r+0x24>
 8011cfa:	6818      	ldr	r0, [r3, #0]
 8011cfc:	685b      	ldr	r3, [r3, #4]
 8011cfe:	4401      	add	r1, r0
 8011d00:	6011      	str	r1, [r2, #0]
 8011d02:	6053      	str	r3, [r2, #4]
 8011d04:	e7d8      	b.n	8011cb8 <_free_r+0x24>
 8011d06:	d902      	bls.n	8011d0e <_free_r+0x7a>
 8011d08:	230c      	movs	r3, #12
 8011d0a:	602b      	str	r3, [r5, #0]
 8011d0c:	e7d4      	b.n	8011cb8 <_free_r+0x24>
 8011d0e:	6820      	ldr	r0, [r4, #0]
 8011d10:	1821      	adds	r1, r4, r0
 8011d12:	428b      	cmp	r3, r1
 8011d14:	bf01      	itttt	eq
 8011d16:	6819      	ldreq	r1, [r3, #0]
 8011d18:	685b      	ldreq	r3, [r3, #4]
 8011d1a:	1809      	addeq	r1, r1, r0
 8011d1c:	6021      	streq	r1, [r4, #0]
 8011d1e:	6063      	str	r3, [r4, #4]
 8011d20:	6054      	str	r4, [r2, #4]
 8011d22:	e7c9      	b.n	8011cb8 <_free_r+0x24>
 8011d24:	bd38      	pop	{r3, r4, r5, pc}
 8011d26:	bf00      	nop
 8011d28:	20001ef0 	.word	0x20001ef0

08011d2c <_malloc_r>:
 8011d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011d2e:	1ccd      	adds	r5, r1, #3
 8011d30:	f025 0503 	bic.w	r5, r5, #3
 8011d34:	3508      	adds	r5, #8
 8011d36:	2d0c      	cmp	r5, #12
 8011d38:	bf38      	it	cc
 8011d3a:	250c      	movcc	r5, #12
 8011d3c:	2d00      	cmp	r5, #0
 8011d3e:	4606      	mov	r6, r0
 8011d40:	db01      	blt.n	8011d46 <_malloc_r+0x1a>
 8011d42:	42a9      	cmp	r1, r5
 8011d44:	d903      	bls.n	8011d4e <_malloc_r+0x22>
 8011d46:	230c      	movs	r3, #12
 8011d48:	6033      	str	r3, [r6, #0]
 8011d4a:	2000      	movs	r0, #0
 8011d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011d4e:	f000 fe59 	bl	8012a04 <__malloc_lock>
 8011d52:	4921      	ldr	r1, [pc, #132]	; (8011dd8 <_malloc_r+0xac>)
 8011d54:	680a      	ldr	r2, [r1, #0]
 8011d56:	4614      	mov	r4, r2
 8011d58:	b99c      	cbnz	r4, 8011d82 <_malloc_r+0x56>
 8011d5a:	4f20      	ldr	r7, [pc, #128]	; (8011ddc <_malloc_r+0xb0>)
 8011d5c:	683b      	ldr	r3, [r7, #0]
 8011d5e:	b923      	cbnz	r3, 8011d6a <_malloc_r+0x3e>
 8011d60:	4621      	mov	r1, r4
 8011d62:	4630      	mov	r0, r6
 8011d64:	f000 fb2a 	bl	80123bc <_sbrk_r>
 8011d68:	6038      	str	r0, [r7, #0]
 8011d6a:	4629      	mov	r1, r5
 8011d6c:	4630      	mov	r0, r6
 8011d6e:	f000 fb25 	bl	80123bc <_sbrk_r>
 8011d72:	1c43      	adds	r3, r0, #1
 8011d74:	d123      	bne.n	8011dbe <_malloc_r+0x92>
 8011d76:	230c      	movs	r3, #12
 8011d78:	4630      	mov	r0, r6
 8011d7a:	6033      	str	r3, [r6, #0]
 8011d7c:	f000 fe48 	bl	8012a10 <__malloc_unlock>
 8011d80:	e7e3      	b.n	8011d4a <_malloc_r+0x1e>
 8011d82:	6823      	ldr	r3, [r4, #0]
 8011d84:	1b5b      	subs	r3, r3, r5
 8011d86:	d417      	bmi.n	8011db8 <_malloc_r+0x8c>
 8011d88:	2b0b      	cmp	r3, #11
 8011d8a:	d903      	bls.n	8011d94 <_malloc_r+0x68>
 8011d8c:	6023      	str	r3, [r4, #0]
 8011d8e:	441c      	add	r4, r3
 8011d90:	6025      	str	r5, [r4, #0]
 8011d92:	e004      	b.n	8011d9e <_malloc_r+0x72>
 8011d94:	6863      	ldr	r3, [r4, #4]
 8011d96:	42a2      	cmp	r2, r4
 8011d98:	bf0c      	ite	eq
 8011d9a:	600b      	streq	r3, [r1, #0]
 8011d9c:	6053      	strne	r3, [r2, #4]
 8011d9e:	4630      	mov	r0, r6
 8011da0:	f000 fe36 	bl	8012a10 <__malloc_unlock>
 8011da4:	f104 000b 	add.w	r0, r4, #11
 8011da8:	1d23      	adds	r3, r4, #4
 8011daa:	f020 0007 	bic.w	r0, r0, #7
 8011dae:	1ac2      	subs	r2, r0, r3
 8011db0:	d0cc      	beq.n	8011d4c <_malloc_r+0x20>
 8011db2:	1a1b      	subs	r3, r3, r0
 8011db4:	50a3      	str	r3, [r4, r2]
 8011db6:	e7c9      	b.n	8011d4c <_malloc_r+0x20>
 8011db8:	4622      	mov	r2, r4
 8011dba:	6864      	ldr	r4, [r4, #4]
 8011dbc:	e7cc      	b.n	8011d58 <_malloc_r+0x2c>
 8011dbe:	1cc4      	adds	r4, r0, #3
 8011dc0:	f024 0403 	bic.w	r4, r4, #3
 8011dc4:	42a0      	cmp	r0, r4
 8011dc6:	d0e3      	beq.n	8011d90 <_malloc_r+0x64>
 8011dc8:	1a21      	subs	r1, r4, r0
 8011dca:	4630      	mov	r0, r6
 8011dcc:	f000 faf6 	bl	80123bc <_sbrk_r>
 8011dd0:	3001      	adds	r0, #1
 8011dd2:	d1dd      	bne.n	8011d90 <_malloc_r+0x64>
 8011dd4:	e7cf      	b.n	8011d76 <_malloc_r+0x4a>
 8011dd6:	bf00      	nop
 8011dd8:	20001ef0 	.word	0x20001ef0
 8011ddc:	20001ef4 	.word	0x20001ef4

08011de0 <__sfputc_r>:
 8011de0:	6893      	ldr	r3, [r2, #8]
 8011de2:	b410      	push	{r4}
 8011de4:	3b01      	subs	r3, #1
 8011de6:	2b00      	cmp	r3, #0
 8011de8:	6093      	str	r3, [r2, #8]
 8011dea:	da07      	bge.n	8011dfc <__sfputc_r+0x1c>
 8011dec:	6994      	ldr	r4, [r2, #24]
 8011dee:	42a3      	cmp	r3, r4
 8011df0:	db01      	blt.n	8011df6 <__sfputc_r+0x16>
 8011df2:	290a      	cmp	r1, #10
 8011df4:	d102      	bne.n	8011dfc <__sfputc_r+0x1c>
 8011df6:	bc10      	pop	{r4}
 8011df8:	f000 bb10 	b.w	801241c <__swbuf_r>
 8011dfc:	6813      	ldr	r3, [r2, #0]
 8011dfe:	1c58      	adds	r0, r3, #1
 8011e00:	6010      	str	r0, [r2, #0]
 8011e02:	7019      	strb	r1, [r3, #0]
 8011e04:	4608      	mov	r0, r1
 8011e06:	bc10      	pop	{r4}
 8011e08:	4770      	bx	lr

08011e0a <__sfputs_r>:
 8011e0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011e0c:	4606      	mov	r6, r0
 8011e0e:	460f      	mov	r7, r1
 8011e10:	4614      	mov	r4, r2
 8011e12:	18d5      	adds	r5, r2, r3
 8011e14:	42ac      	cmp	r4, r5
 8011e16:	d101      	bne.n	8011e1c <__sfputs_r+0x12>
 8011e18:	2000      	movs	r0, #0
 8011e1a:	e007      	b.n	8011e2c <__sfputs_r+0x22>
 8011e1c:	463a      	mov	r2, r7
 8011e1e:	4630      	mov	r0, r6
 8011e20:	f814 1b01 	ldrb.w	r1, [r4], #1
 8011e24:	f7ff ffdc 	bl	8011de0 <__sfputc_r>
 8011e28:	1c43      	adds	r3, r0, #1
 8011e2a:	d1f3      	bne.n	8011e14 <__sfputs_r+0xa>
 8011e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08011e30 <_vfiprintf_r>:
 8011e30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011e34:	460d      	mov	r5, r1
 8011e36:	4614      	mov	r4, r2
 8011e38:	4698      	mov	r8, r3
 8011e3a:	4606      	mov	r6, r0
 8011e3c:	b09d      	sub	sp, #116	; 0x74
 8011e3e:	b118      	cbz	r0, 8011e48 <_vfiprintf_r+0x18>
 8011e40:	6983      	ldr	r3, [r0, #24]
 8011e42:	b90b      	cbnz	r3, 8011e48 <_vfiprintf_r+0x18>
 8011e44:	f000 fccc 	bl	80127e0 <__sinit>
 8011e48:	4b89      	ldr	r3, [pc, #548]	; (8012070 <_vfiprintf_r+0x240>)
 8011e4a:	429d      	cmp	r5, r3
 8011e4c:	d11b      	bne.n	8011e86 <_vfiprintf_r+0x56>
 8011e4e:	6875      	ldr	r5, [r6, #4]
 8011e50:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8011e52:	07d9      	lsls	r1, r3, #31
 8011e54:	d405      	bmi.n	8011e62 <_vfiprintf_r+0x32>
 8011e56:	89ab      	ldrh	r3, [r5, #12]
 8011e58:	059a      	lsls	r2, r3, #22
 8011e5a:	d402      	bmi.n	8011e62 <_vfiprintf_r+0x32>
 8011e5c:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8011e5e:	f000 fd5d 	bl	801291c <__retarget_lock_acquire_recursive>
 8011e62:	89ab      	ldrh	r3, [r5, #12]
 8011e64:	071b      	lsls	r3, r3, #28
 8011e66:	d501      	bpl.n	8011e6c <_vfiprintf_r+0x3c>
 8011e68:	692b      	ldr	r3, [r5, #16]
 8011e6a:	b9eb      	cbnz	r3, 8011ea8 <_vfiprintf_r+0x78>
 8011e6c:	4629      	mov	r1, r5
 8011e6e:	4630      	mov	r0, r6
 8011e70:	f000 fb26 	bl	80124c0 <__swsetup_r>
 8011e74:	b1c0      	cbz	r0, 8011ea8 <_vfiprintf_r+0x78>
 8011e76:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8011e78:	07dc      	lsls	r4, r3, #31
 8011e7a:	d50e      	bpl.n	8011e9a <_vfiprintf_r+0x6a>
 8011e7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8011e80:	b01d      	add	sp, #116	; 0x74
 8011e82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011e86:	4b7b      	ldr	r3, [pc, #492]	; (8012074 <_vfiprintf_r+0x244>)
 8011e88:	429d      	cmp	r5, r3
 8011e8a:	d101      	bne.n	8011e90 <_vfiprintf_r+0x60>
 8011e8c:	68b5      	ldr	r5, [r6, #8]
 8011e8e:	e7df      	b.n	8011e50 <_vfiprintf_r+0x20>
 8011e90:	4b79      	ldr	r3, [pc, #484]	; (8012078 <_vfiprintf_r+0x248>)
 8011e92:	429d      	cmp	r5, r3
 8011e94:	bf08      	it	eq
 8011e96:	68f5      	ldreq	r5, [r6, #12]
 8011e98:	e7da      	b.n	8011e50 <_vfiprintf_r+0x20>
 8011e9a:	89ab      	ldrh	r3, [r5, #12]
 8011e9c:	0598      	lsls	r0, r3, #22
 8011e9e:	d4ed      	bmi.n	8011e7c <_vfiprintf_r+0x4c>
 8011ea0:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8011ea2:	f000 fd3c 	bl	801291e <__retarget_lock_release_recursive>
 8011ea6:	e7e9      	b.n	8011e7c <_vfiprintf_r+0x4c>
 8011ea8:	2300      	movs	r3, #0
 8011eaa:	9309      	str	r3, [sp, #36]	; 0x24
 8011eac:	2320      	movs	r3, #32
 8011eae:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8011eb2:	2330      	movs	r3, #48	; 0x30
 8011eb4:	f04f 0901 	mov.w	r9, #1
 8011eb8:	f8cd 800c 	str.w	r8, [sp, #12]
 8011ebc:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 801207c <_vfiprintf_r+0x24c>
 8011ec0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8011ec4:	4623      	mov	r3, r4
 8011ec6:	469a      	mov	sl, r3
 8011ec8:	f813 2b01 	ldrb.w	r2, [r3], #1
 8011ecc:	b10a      	cbz	r2, 8011ed2 <_vfiprintf_r+0xa2>
 8011ece:	2a25      	cmp	r2, #37	; 0x25
 8011ed0:	d1f9      	bne.n	8011ec6 <_vfiprintf_r+0x96>
 8011ed2:	ebba 0b04 	subs.w	fp, sl, r4
 8011ed6:	d00b      	beq.n	8011ef0 <_vfiprintf_r+0xc0>
 8011ed8:	465b      	mov	r3, fp
 8011eda:	4622      	mov	r2, r4
 8011edc:	4629      	mov	r1, r5
 8011ede:	4630      	mov	r0, r6
 8011ee0:	f7ff ff93 	bl	8011e0a <__sfputs_r>
 8011ee4:	3001      	adds	r0, #1
 8011ee6:	f000 80aa 	beq.w	801203e <_vfiprintf_r+0x20e>
 8011eea:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011eec:	445a      	add	r2, fp
 8011eee:	9209      	str	r2, [sp, #36]	; 0x24
 8011ef0:	f89a 3000 	ldrb.w	r3, [sl]
 8011ef4:	2b00      	cmp	r3, #0
 8011ef6:	f000 80a2 	beq.w	801203e <_vfiprintf_r+0x20e>
 8011efa:	2300      	movs	r3, #0
 8011efc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8011f00:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8011f04:	f10a 0a01 	add.w	sl, sl, #1
 8011f08:	9304      	str	r3, [sp, #16]
 8011f0a:	9307      	str	r3, [sp, #28]
 8011f0c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8011f10:	931a      	str	r3, [sp, #104]	; 0x68
 8011f12:	4654      	mov	r4, sl
 8011f14:	2205      	movs	r2, #5
 8011f16:	f814 1b01 	ldrb.w	r1, [r4], #1
 8011f1a:	4858      	ldr	r0, [pc, #352]	; (801207c <_vfiprintf_r+0x24c>)
 8011f1c:	f000 fd64 	bl	80129e8 <memchr>
 8011f20:	9a04      	ldr	r2, [sp, #16]
 8011f22:	b9d8      	cbnz	r0, 8011f5c <_vfiprintf_r+0x12c>
 8011f24:	06d1      	lsls	r1, r2, #27
 8011f26:	bf44      	itt	mi
 8011f28:	2320      	movmi	r3, #32
 8011f2a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8011f2e:	0713      	lsls	r3, r2, #28
 8011f30:	bf44      	itt	mi
 8011f32:	232b      	movmi	r3, #43	; 0x2b
 8011f34:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8011f38:	f89a 3000 	ldrb.w	r3, [sl]
 8011f3c:	2b2a      	cmp	r3, #42	; 0x2a
 8011f3e:	d015      	beq.n	8011f6c <_vfiprintf_r+0x13c>
 8011f40:	4654      	mov	r4, sl
 8011f42:	2000      	movs	r0, #0
 8011f44:	f04f 0c0a 	mov.w	ip, #10
 8011f48:	9a07      	ldr	r2, [sp, #28]
 8011f4a:	4621      	mov	r1, r4
 8011f4c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8011f50:	3b30      	subs	r3, #48	; 0x30
 8011f52:	2b09      	cmp	r3, #9
 8011f54:	d94e      	bls.n	8011ff4 <_vfiprintf_r+0x1c4>
 8011f56:	b1b0      	cbz	r0, 8011f86 <_vfiprintf_r+0x156>
 8011f58:	9207      	str	r2, [sp, #28]
 8011f5a:	e014      	b.n	8011f86 <_vfiprintf_r+0x156>
 8011f5c:	eba0 0308 	sub.w	r3, r0, r8
 8011f60:	fa09 f303 	lsl.w	r3, r9, r3
 8011f64:	4313      	orrs	r3, r2
 8011f66:	46a2      	mov	sl, r4
 8011f68:	9304      	str	r3, [sp, #16]
 8011f6a:	e7d2      	b.n	8011f12 <_vfiprintf_r+0xe2>
 8011f6c:	9b03      	ldr	r3, [sp, #12]
 8011f6e:	1d19      	adds	r1, r3, #4
 8011f70:	681b      	ldr	r3, [r3, #0]
 8011f72:	9103      	str	r1, [sp, #12]
 8011f74:	2b00      	cmp	r3, #0
 8011f76:	bfbb      	ittet	lt
 8011f78:	425b      	neglt	r3, r3
 8011f7a:	f042 0202 	orrlt.w	r2, r2, #2
 8011f7e:	9307      	strge	r3, [sp, #28]
 8011f80:	9307      	strlt	r3, [sp, #28]
 8011f82:	bfb8      	it	lt
 8011f84:	9204      	strlt	r2, [sp, #16]
 8011f86:	7823      	ldrb	r3, [r4, #0]
 8011f88:	2b2e      	cmp	r3, #46	; 0x2e
 8011f8a:	d10c      	bne.n	8011fa6 <_vfiprintf_r+0x176>
 8011f8c:	7863      	ldrb	r3, [r4, #1]
 8011f8e:	2b2a      	cmp	r3, #42	; 0x2a
 8011f90:	d135      	bne.n	8011ffe <_vfiprintf_r+0x1ce>
 8011f92:	9b03      	ldr	r3, [sp, #12]
 8011f94:	3402      	adds	r4, #2
 8011f96:	1d1a      	adds	r2, r3, #4
 8011f98:	681b      	ldr	r3, [r3, #0]
 8011f9a:	9203      	str	r2, [sp, #12]
 8011f9c:	2b00      	cmp	r3, #0
 8011f9e:	bfb8      	it	lt
 8011fa0:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8011fa4:	9305      	str	r3, [sp, #20]
 8011fa6:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 801208c <_vfiprintf_r+0x25c>
 8011faa:	2203      	movs	r2, #3
 8011fac:	4650      	mov	r0, sl
 8011fae:	7821      	ldrb	r1, [r4, #0]
 8011fb0:	f000 fd1a 	bl	80129e8 <memchr>
 8011fb4:	b140      	cbz	r0, 8011fc8 <_vfiprintf_r+0x198>
 8011fb6:	2340      	movs	r3, #64	; 0x40
 8011fb8:	eba0 000a 	sub.w	r0, r0, sl
 8011fbc:	fa03 f000 	lsl.w	r0, r3, r0
 8011fc0:	9b04      	ldr	r3, [sp, #16]
 8011fc2:	3401      	adds	r4, #1
 8011fc4:	4303      	orrs	r3, r0
 8011fc6:	9304      	str	r3, [sp, #16]
 8011fc8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8011fcc:	2206      	movs	r2, #6
 8011fce:	482c      	ldr	r0, [pc, #176]	; (8012080 <_vfiprintf_r+0x250>)
 8011fd0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8011fd4:	f000 fd08 	bl	80129e8 <memchr>
 8011fd8:	2800      	cmp	r0, #0
 8011fda:	d03f      	beq.n	801205c <_vfiprintf_r+0x22c>
 8011fdc:	4b29      	ldr	r3, [pc, #164]	; (8012084 <_vfiprintf_r+0x254>)
 8011fde:	bb1b      	cbnz	r3, 8012028 <_vfiprintf_r+0x1f8>
 8011fe0:	9b03      	ldr	r3, [sp, #12]
 8011fe2:	3307      	adds	r3, #7
 8011fe4:	f023 0307 	bic.w	r3, r3, #7
 8011fe8:	3308      	adds	r3, #8
 8011fea:	9303      	str	r3, [sp, #12]
 8011fec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011fee:	443b      	add	r3, r7
 8011ff0:	9309      	str	r3, [sp, #36]	; 0x24
 8011ff2:	e767      	b.n	8011ec4 <_vfiprintf_r+0x94>
 8011ff4:	460c      	mov	r4, r1
 8011ff6:	2001      	movs	r0, #1
 8011ff8:	fb0c 3202 	mla	r2, ip, r2, r3
 8011ffc:	e7a5      	b.n	8011f4a <_vfiprintf_r+0x11a>
 8011ffe:	2300      	movs	r3, #0
 8012000:	f04f 0c0a 	mov.w	ip, #10
 8012004:	4619      	mov	r1, r3
 8012006:	3401      	adds	r4, #1
 8012008:	9305      	str	r3, [sp, #20]
 801200a:	4620      	mov	r0, r4
 801200c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8012010:	3a30      	subs	r2, #48	; 0x30
 8012012:	2a09      	cmp	r2, #9
 8012014:	d903      	bls.n	801201e <_vfiprintf_r+0x1ee>
 8012016:	2b00      	cmp	r3, #0
 8012018:	d0c5      	beq.n	8011fa6 <_vfiprintf_r+0x176>
 801201a:	9105      	str	r1, [sp, #20]
 801201c:	e7c3      	b.n	8011fa6 <_vfiprintf_r+0x176>
 801201e:	4604      	mov	r4, r0
 8012020:	2301      	movs	r3, #1
 8012022:	fb0c 2101 	mla	r1, ip, r1, r2
 8012026:	e7f0      	b.n	801200a <_vfiprintf_r+0x1da>
 8012028:	ab03      	add	r3, sp, #12
 801202a:	9300      	str	r3, [sp, #0]
 801202c:	462a      	mov	r2, r5
 801202e:	4630      	mov	r0, r6
 8012030:	4b15      	ldr	r3, [pc, #84]	; (8012088 <_vfiprintf_r+0x258>)
 8012032:	a904      	add	r1, sp, #16
 8012034:	f3af 8000 	nop.w
 8012038:	4607      	mov	r7, r0
 801203a:	1c78      	adds	r0, r7, #1
 801203c:	d1d6      	bne.n	8011fec <_vfiprintf_r+0x1bc>
 801203e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 8012040:	07d9      	lsls	r1, r3, #31
 8012042:	d405      	bmi.n	8012050 <_vfiprintf_r+0x220>
 8012044:	89ab      	ldrh	r3, [r5, #12]
 8012046:	059a      	lsls	r2, r3, #22
 8012048:	d402      	bmi.n	8012050 <_vfiprintf_r+0x220>
 801204a:	6da8      	ldr	r0, [r5, #88]	; 0x58
 801204c:	f000 fc67 	bl	801291e <__retarget_lock_release_recursive>
 8012050:	89ab      	ldrh	r3, [r5, #12]
 8012052:	065b      	lsls	r3, r3, #25
 8012054:	f53f af12 	bmi.w	8011e7c <_vfiprintf_r+0x4c>
 8012058:	9809      	ldr	r0, [sp, #36]	; 0x24
 801205a:	e711      	b.n	8011e80 <_vfiprintf_r+0x50>
 801205c:	ab03      	add	r3, sp, #12
 801205e:	9300      	str	r3, [sp, #0]
 8012060:	462a      	mov	r2, r5
 8012062:	4630      	mov	r0, r6
 8012064:	4b08      	ldr	r3, [pc, #32]	; (8012088 <_vfiprintf_r+0x258>)
 8012066:	a904      	add	r1, sp, #16
 8012068:	f000 f882 	bl	8012170 <_printf_i>
 801206c:	e7e4      	b.n	8012038 <_vfiprintf_r+0x208>
 801206e:	bf00      	nop
 8012070:	08015008 	.word	0x08015008
 8012074:	08015028 	.word	0x08015028
 8012078:	08014fe8 	.word	0x08014fe8
 801207c:	08014fb4 	.word	0x08014fb4
 8012080:	08014fbe 	.word	0x08014fbe
 8012084:	00000000 	.word	0x00000000
 8012088:	08011e0b 	.word	0x08011e0b
 801208c:	08014fba 	.word	0x08014fba

08012090 <_printf_common>:
 8012090:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8012094:	4616      	mov	r6, r2
 8012096:	4699      	mov	r9, r3
 8012098:	688a      	ldr	r2, [r1, #8]
 801209a:	690b      	ldr	r3, [r1, #16]
 801209c:	4607      	mov	r7, r0
 801209e:	4293      	cmp	r3, r2
 80120a0:	bfb8      	it	lt
 80120a2:	4613      	movlt	r3, r2
 80120a4:	6033      	str	r3, [r6, #0]
 80120a6:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 80120aa:	460c      	mov	r4, r1
 80120ac:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80120b0:	b10a      	cbz	r2, 80120b6 <_printf_common+0x26>
 80120b2:	3301      	adds	r3, #1
 80120b4:	6033      	str	r3, [r6, #0]
 80120b6:	6823      	ldr	r3, [r4, #0]
 80120b8:	0699      	lsls	r1, r3, #26
 80120ba:	bf42      	ittt	mi
 80120bc:	6833      	ldrmi	r3, [r6, #0]
 80120be:	3302      	addmi	r3, #2
 80120c0:	6033      	strmi	r3, [r6, #0]
 80120c2:	6825      	ldr	r5, [r4, #0]
 80120c4:	f015 0506 	ands.w	r5, r5, #6
 80120c8:	d106      	bne.n	80120d8 <_printf_common+0x48>
 80120ca:	f104 0a19 	add.w	sl, r4, #25
 80120ce:	68e3      	ldr	r3, [r4, #12]
 80120d0:	6832      	ldr	r2, [r6, #0]
 80120d2:	1a9b      	subs	r3, r3, r2
 80120d4:	42ab      	cmp	r3, r5
 80120d6:	dc28      	bgt.n	801212a <_printf_common+0x9a>
 80120d8:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 80120dc:	1e13      	subs	r3, r2, #0
 80120de:	6822      	ldr	r2, [r4, #0]
 80120e0:	bf18      	it	ne
 80120e2:	2301      	movne	r3, #1
 80120e4:	0692      	lsls	r2, r2, #26
 80120e6:	d42d      	bmi.n	8012144 <_printf_common+0xb4>
 80120e8:	4649      	mov	r1, r9
 80120ea:	4638      	mov	r0, r7
 80120ec:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80120f0:	47c0      	blx	r8
 80120f2:	3001      	adds	r0, #1
 80120f4:	d020      	beq.n	8012138 <_printf_common+0xa8>
 80120f6:	6823      	ldr	r3, [r4, #0]
 80120f8:	68e5      	ldr	r5, [r4, #12]
 80120fa:	f003 0306 	and.w	r3, r3, #6
 80120fe:	2b04      	cmp	r3, #4
 8012100:	bf18      	it	ne
 8012102:	2500      	movne	r5, #0
 8012104:	6832      	ldr	r2, [r6, #0]
 8012106:	f04f 0600 	mov.w	r6, #0
 801210a:	68a3      	ldr	r3, [r4, #8]
 801210c:	bf08      	it	eq
 801210e:	1aad      	subeq	r5, r5, r2
 8012110:	6922      	ldr	r2, [r4, #16]
 8012112:	bf08      	it	eq
 8012114:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8012118:	4293      	cmp	r3, r2
 801211a:	bfc4      	itt	gt
 801211c:	1a9b      	subgt	r3, r3, r2
 801211e:	18ed      	addgt	r5, r5, r3
 8012120:	341a      	adds	r4, #26
 8012122:	42b5      	cmp	r5, r6
 8012124:	d11a      	bne.n	801215c <_printf_common+0xcc>
 8012126:	2000      	movs	r0, #0
 8012128:	e008      	b.n	801213c <_printf_common+0xac>
 801212a:	2301      	movs	r3, #1
 801212c:	4652      	mov	r2, sl
 801212e:	4649      	mov	r1, r9
 8012130:	4638      	mov	r0, r7
 8012132:	47c0      	blx	r8
 8012134:	3001      	adds	r0, #1
 8012136:	d103      	bne.n	8012140 <_printf_common+0xb0>
 8012138:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 801213c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8012140:	3501      	adds	r5, #1
 8012142:	e7c4      	b.n	80120ce <_printf_common+0x3e>
 8012144:	2030      	movs	r0, #48	; 0x30
 8012146:	18e1      	adds	r1, r4, r3
 8012148:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 801214c:	1c5a      	adds	r2, r3, #1
 801214e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8012152:	4422      	add	r2, r4
 8012154:	3302      	adds	r3, #2
 8012156:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 801215a:	e7c5      	b.n	80120e8 <_printf_common+0x58>
 801215c:	2301      	movs	r3, #1
 801215e:	4622      	mov	r2, r4
 8012160:	4649      	mov	r1, r9
 8012162:	4638      	mov	r0, r7
 8012164:	47c0      	blx	r8
 8012166:	3001      	adds	r0, #1
 8012168:	d0e6      	beq.n	8012138 <_printf_common+0xa8>
 801216a:	3601      	adds	r6, #1
 801216c:	e7d9      	b.n	8012122 <_printf_common+0x92>
	...

08012170 <_printf_i>:
 8012170:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8012174:	460c      	mov	r4, r1
 8012176:	7e27      	ldrb	r7, [r4, #24]
 8012178:	4691      	mov	r9, r2
 801217a:	2f78      	cmp	r7, #120	; 0x78
 801217c:	4680      	mov	r8, r0
 801217e:	469a      	mov	sl, r3
 8012180:	990c      	ldr	r1, [sp, #48]	; 0x30
 8012182:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8012186:	d807      	bhi.n	8012198 <_printf_i+0x28>
 8012188:	2f62      	cmp	r7, #98	; 0x62
 801218a:	d80a      	bhi.n	80121a2 <_printf_i+0x32>
 801218c:	2f00      	cmp	r7, #0
 801218e:	f000 80d9 	beq.w	8012344 <_printf_i+0x1d4>
 8012192:	2f58      	cmp	r7, #88	; 0x58
 8012194:	f000 80a4 	beq.w	80122e0 <_printf_i+0x170>
 8012198:	f104 0642 	add.w	r6, r4, #66	; 0x42
 801219c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 80121a0:	e03a      	b.n	8012218 <_printf_i+0xa8>
 80121a2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 80121a6:	2b15      	cmp	r3, #21
 80121a8:	d8f6      	bhi.n	8012198 <_printf_i+0x28>
 80121aa:	a001      	add	r0, pc, #4	; (adr r0, 80121b0 <_printf_i+0x40>)
 80121ac:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 80121b0:	08012209 	.word	0x08012209
 80121b4:	0801221d 	.word	0x0801221d
 80121b8:	08012199 	.word	0x08012199
 80121bc:	08012199 	.word	0x08012199
 80121c0:	08012199 	.word	0x08012199
 80121c4:	08012199 	.word	0x08012199
 80121c8:	0801221d 	.word	0x0801221d
 80121cc:	08012199 	.word	0x08012199
 80121d0:	08012199 	.word	0x08012199
 80121d4:	08012199 	.word	0x08012199
 80121d8:	08012199 	.word	0x08012199
 80121dc:	0801232b 	.word	0x0801232b
 80121e0:	0801224d 	.word	0x0801224d
 80121e4:	0801230d 	.word	0x0801230d
 80121e8:	08012199 	.word	0x08012199
 80121ec:	08012199 	.word	0x08012199
 80121f0:	0801234d 	.word	0x0801234d
 80121f4:	08012199 	.word	0x08012199
 80121f8:	0801224d 	.word	0x0801224d
 80121fc:	08012199 	.word	0x08012199
 8012200:	08012199 	.word	0x08012199
 8012204:	08012315 	.word	0x08012315
 8012208:	680b      	ldr	r3, [r1, #0]
 801220a:	f104 0642 	add.w	r6, r4, #66	; 0x42
 801220e:	1d1a      	adds	r2, r3, #4
 8012210:	681b      	ldr	r3, [r3, #0]
 8012212:	600a      	str	r2, [r1, #0]
 8012214:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8012218:	2301      	movs	r3, #1
 801221a:	e0a4      	b.n	8012366 <_printf_i+0x1f6>
 801221c:	6825      	ldr	r5, [r4, #0]
 801221e:	6808      	ldr	r0, [r1, #0]
 8012220:	062e      	lsls	r6, r5, #24
 8012222:	f100 0304 	add.w	r3, r0, #4
 8012226:	d50a      	bpl.n	801223e <_printf_i+0xce>
 8012228:	6805      	ldr	r5, [r0, #0]
 801222a:	600b      	str	r3, [r1, #0]
 801222c:	2d00      	cmp	r5, #0
 801222e:	da03      	bge.n	8012238 <_printf_i+0xc8>
 8012230:	232d      	movs	r3, #45	; 0x2d
 8012232:	426d      	negs	r5, r5
 8012234:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8012238:	230a      	movs	r3, #10
 801223a:	485e      	ldr	r0, [pc, #376]	; (80123b4 <_printf_i+0x244>)
 801223c:	e019      	b.n	8012272 <_printf_i+0x102>
 801223e:	f015 0f40 	tst.w	r5, #64	; 0x40
 8012242:	6805      	ldr	r5, [r0, #0]
 8012244:	600b      	str	r3, [r1, #0]
 8012246:	bf18      	it	ne
 8012248:	b22d      	sxthne	r5, r5
 801224a:	e7ef      	b.n	801222c <_printf_i+0xbc>
 801224c:	680b      	ldr	r3, [r1, #0]
 801224e:	6825      	ldr	r5, [r4, #0]
 8012250:	1d18      	adds	r0, r3, #4
 8012252:	6008      	str	r0, [r1, #0]
 8012254:	0628      	lsls	r0, r5, #24
 8012256:	d501      	bpl.n	801225c <_printf_i+0xec>
 8012258:	681d      	ldr	r5, [r3, #0]
 801225a:	e002      	b.n	8012262 <_printf_i+0xf2>
 801225c:	0669      	lsls	r1, r5, #25
 801225e:	d5fb      	bpl.n	8012258 <_printf_i+0xe8>
 8012260:	881d      	ldrh	r5, [r3, #0]
 8012262:	2f6f      	cmp	r7, #111	; 0x6f
 8012264:	bf0c      	ite	eq
 8012266:	2308      	moveq	r3, #8
 8012268:	230a      	movne	r3, #10
 801226a:	4852      	ldr	r0, [pc, #328]	; (80123b4 <_printf_i+0x244>)
 801226c:	2100      	movs	r1, #0
 801226e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8012272:	6866      	ldr	r6, [r4, #4]
 8012274:	2e00      	cmp	r6, #0
 8012276:	bfa8      	it	ge
 8012278:	6821      	ldrge	r1, [r4, #0]
 801227a:	60a6      	str	r6, [r4, #8]
 801227c:	bfa4      	itt	ge
 801227e:	f021 0104 	bicge.w	r1, r1, #4
 8012282:	6021      	strge	r1, [r4, #0]
 8012284:	b90d      	cbnz	r5, 801228a <_printf_i+0x11a>
 8012286:	2e00      	cmp	r6, #0
 8012288:	d04d      	beq.n	8012326 <_printf_i+0x1b6>
 801228a:	4616      	mov	r6, r2
 801228c:	fbb5 f1f3 	udiv	r1, r5, r3
 8012290:	fb03 5711 	mls	r7, r3, r1, r5
 8012294:	5dc7      	ldrb	r7, [r0, r7]
 8012296:	f806 7d01 	strb.w	r7, [r6, #-1]!
 801229a:	462f      	mov	r7, r5
 801229c:	42bb      	cmp	r3, r7
 801229e:	460d      	mov	r5, r1
 80122a0:	d9f4      	bls.n	801228c <_printf_i+0x11c>
 80122a2:	2b08      	cmp	r3, #8
 80122a4:	d10b      	bne.n	80122be <_printf_i+0x14e>
 80122a6:	6823      	ldr	r3, [r4, #0]
 80122a8:	07df      	lsls	r7, r3, #31
 80122aa:	d508      	bpl.n	80122be <_printf_i+0x14e>
 80122ac:	6923      	ldr	r3, [r4, #16]
 80122ae:	6861      	ldr	r1, [r4, #4]
 80122b0:	4299      	cmp	r1, r3
 80122b2:	bfde      	ittt	le
 80122b4:	2330      	movle	r3, #48	; 0x30
 80122b6:	f806 3c01 	strble.w	r3, [r6, #-1]
 80122ba:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
 80122be:	1b92      	subs	r2, r2, r6
 80122c0:	6122      	str	r2, [r4, #16]
 80122c2:	464b      	mov	r3, r9
 80122c4:	4621      	mov	r1, r4
 80122c6:	4640      	mov	r0, r8
 80122c8:	f8cd a000 	str.w	sl, [sp]
 80122cc:	aa03      	add	r2, sp, #12
 80122ce:	f7ff fedf 	bl	8012090 <_printf_common>
 80122d2:	3001      	adds	r0, #1
 80122d4:	d14c      	bne.n	8012370 <_printf_i+0x200>
 80122d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80122da:	b004      	add	sp, #16
 80122dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80122e0:	4834      	ldr	r0, [pc, #208]	; (80123b4 <_printf_i+0x244>)
 80122e2:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 80122e6:	680e      	ldr	r6, [r1, #0]
 80122e8:	6823      	ldr	r3, [r4, #0]
 80122ea:	f856 5b04 	ldr.w	r5, [r6], #4
 80122ee:	061f      	lsls	r7, r3, #24
 80122f0:	600e      	str	r6, [r1, #0]
 80122f2:	d514      	bpl.n	801231e <_printf_i+0x1ae>
 80122f4:	07d9      	lsls	r1, r3, #31
 80122f6:	bf44      	itt	mi
 80122f8:	f043 0320 	orrmi.w	r3, r3, #32
 80122fc:	6023      	strmi	r3, [r4, #0]
 80122fe:	b91d      	cbnz	r5, 8012308 <_printf_i+0x198>
 8012300:	6823      	ldr	r3, [r4, #0]
 8012302:	f023 0320 	bic.w	r3, r3, #32
 8012306:	6023      	str	r3, [r4, #0]
 8012308:	2310      	movs	r3, #16
 801230a:	e7af      	b.n	801226c <_printf_i+0xfc>
 801230c:	6823      	ldr	r3, [r4, #0]
 801230e:	f043 0320 	orr.w	r3, r3, #32
 8012312:	6023      	str	r3, [r4, #0]
 8012314:	2378      	movs	r3, #120	; 0x78
 8012316:	4828      	ldr	r0, [pc, #160]	; (80123b8 <_printf_i+0x248>)
 8012318:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 801231c:	e7e3      	b.n	80122e6 <_printf_i+0x176>
 801231e:	065e      	lsls	r6, r3, #25
 8012320:	bf48      	it	mi
 8012322:	b2ad      	uxthmi	r5, r5
 8012324:	e7e6      	b.n	80122f4 <_printf_i+0x184>
 8012326:	4616      	mov	r6, r2
 8012328:	e7bb      	b.n	80122a2 <_printf_i+0x132>
 801232a:	680b      	ldr	r3, [r1, #0]
 801232c:	6826      	ldr	r6, [r4, #0]
 801232e:	1d1d      	adds	r5, r3, #4
 8012330:	6960      	ldr	r0, [r4, #20]
 8012332:	600d      	str	r5, [r1, #0]
 8012334:	0635      	lsls	r5, r6, #24
 8012336:	681b      	ldr	r3, [r3, #0]
 8012338:	d501      	bpl.n	801233e <_printf_i+0x1ce>
 801233a:	6018      	str	r0, [r3, #0]
 801233c:	e002      	b.n	8012344 <_printf_i+0x1d4>
 801233e:	0671      	lsls	r1, r6, #25
 8012340:	d5fb      	bpl.n	801233a <_printf_i+0x1ca>
 8012342:	8018      	strh	r0, [r3, #0]
 8012344:	2300      	movs	r3, #0
 8012346:	4616      	mov	r6, r2
 8012348:	6123      	str	r3, [r4, #16]
 801234a:	e7ba      	b.n	80122c2 <_printf_i+0x152>
 801234c:	680b      	ldr	r3, [r1, #0]
 801234e:	1d1a      	adds	r2, r3, #4
 8012350:	600a      	str	r2, [r1, #0]
 8012352:	681e      	ldr	r6, [r3, #0]
 8012354:	2100      	movs	r1, #0
 8012356:	4630      	mov	r0, r6
 8012358:	6862      	ldr	r2, [r4, #4]
 801235a:	f000 fb45 	bl	80129e8 <memchr>
 801235e:	b108      	cbz	r0, 8012364 <_printf_i+0x1f4>
 8012360:	1b80      	subs	r0, r0, r6
 8012362:	6060      	str	r0, [r4, #4]
 8012364:	6863      	ldr	r3, [r4, #4]
 8012366:	6123      	str	r3, [r4, #16]
 8012368:	2300      	movs	r3, #0
 801236a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 801236e:	e7a8      	b.n	80122c2 <_printf_i+0x152>
 8012370:	4632      	mov	r2, r6
 8012372:	4649      	mov	r1, r9
 8012374:	4640      	mov	r0, r8
 8012376:	6923      	ldr	r3, [r4, #16]
 8012378:	47d0      	blx	sl
 801237a:	3001      	adds	r0, #1
 801237c:	d0ab      	beq.n	80122d6 <_printf_i+0x166>
 801237e:	6823      	ldr	r3, [r4, #0]
 8012380:	079b      	lsls	r3, r3, #30
 8012382:	d413      	bmi.n	80123ac <_printf_i+0x23c>
 8012384:	68e0      	ldr	r0, [r4, #12]
 8012386:	9b03      	ldr	r3, [sp, #12]
 8012388:	4298      	cmp	r0, r3
 801238a:	bfb8      	it	lt
 801238c:	4618      	movlt	r0, r3
 801238e:	e7a4      	b.n	80122da <_printf_i+0x16a>
 8012390:	2301      	movs	r3, #1
 8012392:	4632      	mov	r2, r6
 8012394:	4649      	mov	r1, r9
 8012396:	4640      	mov	r0, r8
 8012398:	47d0      	blx	sl
 801239a:	3001      	adds	r0, #1
 801239c:	d09b      	beq.n	80122d6 <_printf_i+0x166>
 801239e:	3501      	adds	r5, #1
 80123a0:	68e3      	ldr	r3, [r4, #12]
 80123a2:	9903      	ldr	r1, [sp, #12]
 80123a4:	1a5b      	subs	r3, r3, r1
 80123a6:	42ab      	cmp	r3, r5
 80123a8:	dcf2      	bgt.n	8012390 <_printf_i+0x220>
 80123aa:	e7eb      	b.n	8012384 <_printf_i+0x214>
 80123ac:	2500      	movs	r5, #0
 80123ae:	f104 0619 	add.w	r6, r4, #25
 80123b2:	e7f5      	b.n	80123a0 <_printf_i+0x230>
 80123b4:	08014fc5 	.word	0x08014fc5
 80123b8:	08014fd6 	.word	0x08014fd6

080123bc <_sbrk_r>:
 80123bc:	b538      	push	{r3, r4, r5, lr}
 80123be:	2300      	movs	r3, #0
 80123c0:	4d05      	ldr	r5, [pc, #20]	; (80123d8 <_sbrk_r+0x1c>)
 80123c2:	4604      	mov	r4, r0
 80123c4:	4608      	mov	r0, r1
 80123c6:	602b      	str	r3, [r5, #0]
 80123c8:	f7f2 fcd8 	bl	8004d7c <_sbrk>
 80123cc:	1c43      	adds	r3, r0, #1
 80123ce:	d102      	bne.n	80123d6 <_sbrk_r+0x1a>
 80123d0:	682b      	ldr	r3, [r5, #0]
 80123d2:	b103      	cbz	r3, 80123d6 <_sbrk_r+0x1a>
 80123d4:	6023      	str	r3, [r4, #0]
 80123d6:	bd38      	pop	{r3, r4, r5, pc}
 80123d8:	20002738 	.word	0x20002738

080123dc <stpcpy>:
 80123dc:	4603      	mov	r3, r0
 80123de:	f811 2b01 	ldrb.w	r2, [r1], #1
 80123e2:	4618      	mov	r0, r3
 80123e4:	f803 2b01 	strb.w	r2, [r3], #1
 80123e8:	2a00      	cmp	r2, #0
 80123ea:	d1f8      	bne.n	80123de <stpcpy+0x2>
 80123ec:	4770      	bx	lr

080123ee <strcat>:
 80123ee:	4602      	mov	r2, r0
 80123f0:	b510      	push	{r4, lr}
 80123f2:	7814      	ldrb	r4, [r2, #0]
 80123f4:	4613      	mov	r3, r2
 80123f6:	3201      	adds	r2, #1
 80123f8:	2c00      	cmp	r4, #0
 80123fa:	d1fa      	bne.n	80123f2 <strcat+0x4>
 80123fc:	3b01      	subs	r3, #1
 80123fe:	f811 2b01 	ldrb.w	r2, [r1], #1
 8012402:	f803 2f01 	strb.w	r2, [r3, #1]!
 8012406:	2a00      	cmp	r2, #0
 8012408:	d1f9      	bne.n	80123fe <strcat+0x10>
 801240a:	bd10      	pop	{r4, pc}

0801240c <strcpy>:
 801240c:	4603      	mov	r3, r0
 801240e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8012412:	f803 2b01 	strb.w	r2, [r3], #1
 8012416:	2a00      	cmp	r2, #0
 8012418:	d1f9      	bne.n	801240e <strcpy+0x2>
 801241a:	4770      	bx	lr

0801241c <__swbuf_r>:
 801241c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801241e:	460e      	mov	r6, r1
 8012420:	4614      	mov	r4, r2
 8012422:	4605      	mov	r5, r0
 8012424:	b118      	cbz	r0, 801242e <__swbuf_r+0x12>
 8012426:	6983      	ldr	r3, [r0, #24]
 8012428:	b90b      	cbnz	r3, 801242e <__swbuf_r+0x12>
 801242a:	f000 f9d9 	bl	80127e0 <__sinit>
 801242e:	4b21      	ldr	r3, [pc, #132]	; (80124b4 <__swbuf_r+0x98>)
 8012430:	429c      	cmp	r4, r3
 8012432:	d12b      	bne.n	801248c <__swbuf_r+0x70>
 8012434:	686c      	ldr	r4, [r5, #4]
 8012436:	69a3      	ldr	r3, [r4, #24]
 8012438:	60a3      	str	r3, [r4, #8]
 801243a:	89a3      	ldrh	r3, [r4, #12]
 801243c:	071a      	lsls	r2, r3, #28
 801243e:	d52f      	bpl.n	80124a0 <__swbuf_r+0x84>
 8012440:	6923      	ldr	r3, [r4, #16]
 8012442:	b36b      	cbz	r3, 80124a0 <__swbuf_r+0x84>
 8012444:	6923      	ldr	r3, [r4, #16]
 8012446:	6820      	ldr	r0, [r4, #0]
 8012448:	b2f6      	uxtb	r6, r6
 801244a:	1ac0      	subs	r0, r0, r3
 801244c:	6963      	ldr	r3, [r4, #20]
 801244e:	4637      	mov	r7, r6
 8012450:	4283      	cmp	r3, r0
 8012452:	dc04      	bgt.n	801245e <__swbuf_r+0x42>
 8012454:	4621      	mov	r1, r4
 8012456:	4628      	mov	r0, r5
 8012458:	f000 f92e 	bl	80126b8 <_fflush_r>
 801245c:	bb30      	cbnz	r0, 80124ac <__swbuf_r+0x90>
 801245e:	68a3      	ldr	r3, [r4, #8]
 8012460:	3001      	adds	r0, #1
 8012462:	3b01      	subs	r3, #1
 8012464:	60a3      	str	r3, [r4, #8]
 8012466:	6823      	ldr	r3, [r4, #0]
 8012468:	1c5a      	adds	r2, r3, #1
 801246a:	6022      	str	r2, [r4, #0]
 801246c:	701e      	strb	r6, [r3, #0]
 801246e:	6963      	ldr	r3, [r4, #20]
 8012470:	4283      	cmp	r3, r0
 8012472:	d004      	beq.n	801247e <__swbuf_r+0x62>
 8012474:	89a3      	ldrh	r3, [r4, #12]
 8012476:	07db      	lsls	r3, r3, #31
 8012478:	d506      	bpl.n	8012488 <__swbuf_r+0x6c>
 801247a:	2e0a      	cmp	r6, #10
 801247c:	d104      	bne.n	8012488 <__swbuf_r+0x6c>
 801247e:	4621      	mov	r1, r4
 8012480:	4628      	mov	r0, r5
 8012482:	f000 f919 	bl	80126b8 <_fflush_r>
 8012486:	b988      	cbnz	r0, 80124ac <__swbuf_r+0x90>
 8012488:	4638      	mov	r0, r7
 801248a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801248c:	4b0a      	ldr	r3, [pc, #40]	; (80124b8 <__swbuf_r+0x9c>)
 801248e:	429c      	cmp	r4, r3
 8012490:	d101      	bne.n	8012496 <__swbuf_r+0x7a>
 8012492:	68ac      	ldr	r4, [r5, #8]
 8012494:	e7cf      	b.n	8012436 <__swbuf_r+0x1a>
 8012496:	4b09      	ldr	r3, [pc, #36]	; (80124bc <__swbuf_r+0xa0>)
 8012498:	429c      	cmp	r4, r3
 801249a:	bf08      	it	eq
 801249c:	68ec      	ldreq	r4, [r5, #12]
 801249e:	e7ca      	b.n	8012436 <__swbuf_r+0x1a>
 80124a0:	4621      	mov	r1, r4
 80124a2:	4628      	mov	r0, r5
 80124a4:	f000 f80c 	bl	80124c0 <__swsetup_r>
 80124a8:	2800      	cmp	r0, #0
 80124aa:	d0cb      	beq.n	8012444 <__swbuf_r+0x28>
 80124ac:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80124b0:	e7ea      	b.n	8012488 <__swbuf_r+0x6c>
 80124b2:	bf00      	nop
 80124b4:	08015008 	.word	0x08015008
 80124b8:	08015028 	.word	0x08015028
 80124bc:	08014fe8 	.word	0x08014fe8

080124c0 <__swsetup_r>:
 80124c0:	4b32      	ldr	r3, [pc, #200]	; (801258c <__swsetup_r+0xcc>)
 80124c2:	b570      	push	{r4, r5, r6, lr}
 80124c4:	681d      	ldr	r5, [r3, #0]
 80124c6:	4606      	mov	r6, r0
 80124c8:	460c      	mov	r4, r1
 80124ca:	b125      	cbz	r5, 80124d6 <__swsetup_r+0x16>
 80124cc:	69ab      	ldr	r3, [r5, #24]
 80124ce:	b913      	cbnz	r3, 80124d6 <__swsetup_r+0x16>
 80124d0:	4628      	mov	r0, r5
 80124d2:	f000 f985 	bl	80127e0 <__sinit>
 80124d6:	4b2e      	ldr	r3, [pc, #184]	; (8012590 <__swsetup_r+0xd0>)
 80124d8:	429c      	cmp	r4, r3
 80124da:	d10f      	bne.n	80124fc <__swsetup_r+0x3c>
 80124dc:	686c      	ldr	r4, [r5, #4]
 80124de:	89a3      	ldrh	r3, [r4, #12]
 80124e0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80124e4:	0719      	lsls	r1, r3, #28
 80124e6:	d42c      	bmi.n	8012542 <__swsetup_r+0x82>
 80124e8:	06dd      	lsls	r5, r3, #27
 80124ea:	d411      	bmi.n	8012510 <__swsetup_r+0x50>
 80124ec:	2309      	movs	r3, #9
 80124ee:	6033      	str	r3, [r6, #0]
 80124f0:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80124f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80124f8:	81a3      	strh	r3, [r4, #12]
 80124fa:	e03e      	b.n	801257a <__swsetup_r+0xba>
 80124fc:	4b25      	ldr	r3, [pc, #148]	; (8012594 <__swsetup_r+0xd4>)
 80124fe:	429c      	cmp	r4, r3
 8012500:	d101      	bne.n	8012506 <__swsetup_r+0x46>
 8012502:	68ac      	ldr	r4, [r5, #8]
 8012504:	e7eb      	b.n	80124de <__swsetup_r+0x1e>
 8012506:	4b24      	ldr	r3, [pc, #144]	; (8012598 <__swsetup_r+0xd8>)
 8012508:	429c      	cmp	r4, r3
 801250a:	bf08      	it	eq
 801250c:	68ec      	ldreq	r4, [r5, #12]
 801250e:	e7e6      	b.n	80124de <__swsetup_r+0x1e>
 8012510:	0758      	lsls	r0, r3, #29
 8012512:	d512      	bpl.n	801253a <__swsetup_r+0x7a>
 8012514:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8012516:	b141      	cbz	r1, 801252a <__swsetup_r+0x6a>
 8012518:	f104 0344 	add.w	r3, r4, #68	; 0x44
 801251c:	4299      	cmp	r1, r3
 801251e:	d002      	beq.n	8012526 <__swsetup_r+0x66>
 8012520:	4630      	mov	r0, r6
 8012522:	f7ff fbb7 	bl	8011c94 <_free_r>
 8012526:	2300      	movs	r3, #0
 8012528:	6363      	str	r3, [r4, #52]	; 0x34
 801252a:	89a3      	ldrh	r3, [r4, #12]
 801252c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8012530:	81a3      	strh	r3, [r4, #12]
 8012532:	2300      	movs	r3, #0
 8012534:	6063      	str	r3, [r4, #4]
 8012536:	6923      	ldr	r3, [r4, #16]
 8012538:	6023      	str	r3, [r4, #0]
 801253a:	89a3      	ldrh	r3, [r4, #12]
 801253c:	f043 0308 	orr.w	r3, r3, #8
 8012540:	81a3      	strh	r3, [r4, #12]
 8012542:	6923      	ldr	r3, [r4, #16]
 8012544:	b94b      	cbnz	r3, 801255a <__swsetup_r+0x9a>
 8012546:	89a3      	ldrh	r3, [r4, #12]
 8012548:	f403 7320 	and.w	r3, r3, #640	; 0x280
 801254c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8012550:	d003      	beq.n	801255a <__swsetup_r+0x9a>
 8012552:	4621      	mov	r1, r4
 8012554:	4630      	mov	r0, r6
 8012556:	f000 fa07 	bl	8012968 <__smakebuf_r>
 801255a:	89a0      	ldrh	r0, [r4, #12]
 801255c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8012560:	f010 0301 	ands.w	r3, r0, #1
 8012564:	d00a      	beq.n	801257c <__swsetup_r+0xbc>
 8012566:	2300      	movs	r3, #0
 8012568:	60a3      	str	r3, [r4, #8]
 801256a:	6963      	ldr	r3, [r4, #20]
 801256c:	425b      	negs	r3, r3
 801256e:	61a3      	str	r3, [r4, #24]
 8012570:	6923      	ldr	r3, [r4, #16]
 8012572:	b943      	cbnz	r3, 8012586 <__swsetup_r+0xc6>
 8012574:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8012578:	d1ba      	bne.n	80124f0 <__swsetup_r+0x30>
 801257a:	bd70      	pop	{r4, r5, r6, pc}
 801257c:	0781      	lsls	r1, r0, #30
 801257e:	bf58      	it	pl
 8012580:	6963      	ldrpl	r3, [r4, #20]
 8012582:	60a3      	str	r3, [r4, #8]
 8012584:	e7f4      	b.n	8012570 <__swsetup_r+0xb0>
 8012586:	2000      	movs	r0, #0
 8012588:	e7f7      	b.n	801257a <__swsetup_r+0xba>
 801258a:	bf00      	nop
 801258c:	2000001c 	.word	0x2000001c
 8012590:	08015008 	.word	0x08015008
 8012594:	08015028 	.word	0x08015028
 8012598:	08014fe8 	.word	0x08014fe8

0801259c <abort>:
 801259c:	2006      	movs	r0, #6
 801259e:	b508      	push	{r3, lr}
 80125a0:	f000 fa64 	bl	8012a6c <raise>
 80125a4:	2001      	movs	r0, #1
 80125a6:	f7f2 fbb9 	bl	8004d1c <_exit>
	...

080125ac <__sflush_r>:
 80125ac:	898a      	ldrh	r2, [r1, #12]
 80125ae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80125b2:	4605      	mov	r5, r0
 80125b4:	0710      	lsls	r0, r2, #28
 80125b6:	460c      	mov	r4, r1
 80125b8:	d458      	bmi.n	801266c <__sflush_r+0xc0>
 80125ba:	684b      	ldr	r3, [r1, #4]
 80125bc:	2b00      	cmp	r3, #0
 80125be:	dc05      	bgt.n	80125cc <__sflush_r+0x20>
 80125c0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80125c2:	2b00      	cmp	r3, #0
 80125c4:	dc02      	bgt.n	80125cc <__sflush_r+0x20>
 80125c6:	2000      	movs	r0, #0
 80125c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80125cc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80125ce:	2e00      	cmp	r6, #0
 80125d0:	d0f9      	beq.n	80125c6 <__sflush_r+0x1a>
 80125d2:	2300      	movs	r3, #0
 80125d4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 80125d8:	682f      	ldr	r7, [r5, #0]
 80125da:	602b      	str	r3, [r5, #0]
 80125dc:	d032      	beq.n	8012644 <__sflush_r+0x98>
 80125de:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80125e0:	89a3      	ldrh	r3, [r4, #12]
 80125e2:	075a      	lsls	r2, r3, #29
 80125e4:	d505      	bpl.n	80125f2 <__sflush_r+0x46>
 80125e6:	6863      	ldr	r3, [r4, #4]
 80125e8:	1ac0      	subs	r0, r0, r3
 80125ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80125ec:	b10b      	cbz	r3, 80125f2 <__sflush_r+0x46>
 80125ee:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80125f0:	1ac0      	subs	r0, r0, r3
 80125f2:	2300      	movs	r3, #0
 80125f4:	4602      	mov	r2, r0
 80125f6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80125f8:	4628      	mov	r0, r5
 80125fa:	6a21      	ldr	r1, [r4, #32]
 80125fc:	47b0      	blx	r6
 80125fe:	1c43      	adds	r3, r0, #1
 8012600:	89a3      	ldrh	r3, [r4, #12]
 8012602:	d106      	bne.n	8012612 <__sflush_r+0x66>
 8012604:	6829      	ldr	r1, [r5, #0]
 8012606:	291d      	cmp	r1, #29
 8012608:	d82c      	bhi.n	8012664 <__sflush_r+0xb8>
 801260a:	4a2a      	ldr	r2, [pc, #168]	; (80126b4 <__sflush_r+0x108>)
 801260c:	40ca      	lsrs	r2, r1
 801260e:	07d6      	lsls	r6, r2, #31
 8012610:	d528      	bpl.n	8012664 <__sflush_r+0xb8>
 8012612:	2200      	movs	r2, #0
 8012614:	6062      	str	r2, [r4, #4]
 8012616:	6922      	ldr	r2, [r4, #16]
 8012618:	04d9      	lsls	r1, r3, #19
 801261a:	6022      	str	r2, [r4, #0]
 801261c:	d504      	bpl.n	8012628 <__sflush_r+0x7c>
 801261e:	1c42      	adds	r2, r0, #1
 8012620:	d101      	bne.n	8012626 <__sflush_r+0x7a>
 8012622:	682b      	ldr	r3, [r5, #0]
 8012624:	b903      	cbnz	r3, 8012628 <__sflush_r+0x7c>
 8012626:	6560      	str	r0, [r4, #84]	; 0x54
 8012628:	6b61      	ldr	r1, [r4, #52]	; 0x34
 801262a:	602f      	str	r7, [r5, #0]
 801262c:	2900      	cmp	r1, #0
 801262e:	d0ca      	beq.n	80125c6 <__sflush_r+0x1a>
 8012630:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8012634:	4299      	cmp	r1, r3
 8012636:	d002      	beq.n	801263e <__sflush_r+0x92>
 8012638:	4628      	mov	r0, r5
 801263a:	f7ff fb2b 	bl	8011c94 <_free_r>
 801263e:	2000      	movs	r0, #0
 8012640:	6360      	str	r0, [r4, #52]	; 0x34
 8012642:	e7c1      	b.n	80125c8 <__sflush_r+0x1c>
 8012644:	6a21      	ldr	r1, [r4, #32]
 8012646:	2301      	movs	r3, #1
 8012648:	4628      	mov	r0, r5
 801264a:	47b0      	blx	r6
 801264c:	1c41      	adds	r1, r0, #1
 801264e:	d1c7      	bne.n	80125e0 <__sflush_r+0x34>
 8012650:	682b      	ldr	r3, [r5, #0]
 8012652:	2b00      	cmp	r3, #0
 8012654:	d0c4      	beq.n	80125e0 <__sflush_r+0x34>
 8012656:	2b1d      	cmp	r3, #29
 8012658:	d001      	beq.n	801265e <__sflush_r+0xb2>
 801265a:	2b16      	cmp	r3, #22
 801265c:	d101      	bne.n	8012662 <__sflush_r+0xb6>
 801265e:	602f      	str	r7, [r5, #0]
 8012660:	e7b1      	b.n	80125c6 <__sflush_r+0x1a>
 8012662:	89a3      	ldrh	r3, [r4, #12]
 8012664:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8012668:	81a3      	strh	r3, [r4, #12]
 801266a:	e7ad      	b.n	80125c8 <__sflush_r+0x1c>
 801266c:	690f      	ldr	r7, [r1, #16]
 801266e:	2f00      	cmp	r7, #0
 8012670:	d0a9      	beq.n	80125c6 <__sflush_r+0x1a>
 8012672:	0793      	lsls	r3, r2, #30
 8012674:	bf18      	it	ne
 8012676:	2300      	movne	r3, #0
 8012678:	680e      	ldr	r6, [r1, #0]
 801267a:	bf08      	it	eq
 801267c:	694b      	ldreq	r3, [r1, #20]
 801267e:	eba6 0807 	sub.w	r8, r6, r7
 8012682:	600f      	str	r7, [r1, #0]
 8012684:	608b      	str	r3, [r1, #8]
 8012686:	f1b8 0f00 	cmp.w	r8, #0
 801268a:	dd9c      	ble.n	80125c6 <__sflush_r+0x1a>
 801268c:	4643      	mov	r3, r8
 801268e:	463a      	mov	r2, r7
 8012690:	4628      	mov	r0, r5
 8012692:	6a21      	ldr	r1, [r4, #32]
 8012694:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8012696:	47b0      	blx	r6
 8012698:	2800      	cmp	r0, #0
 801269a:	dc06      	bgt.n	80126aa <__sflush_r+0xfe>
 801269c:	89a3      	ldrh	r3, [r4, #12]
 801269e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80126a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80126a6:	81a3      	strh	r3, [r4, #12]
 80126a8:	e78e      	b.n	80125c8 <__sflush_r+0x1c>
 80126aa:	4407      	add	r7, r0
 80126ac:	eba8 0800 	sub.w	r8, r8, r0
 80126b0:	e7e9      	b.n	8012686 <__sflush_r+0xda>
 80126b2:	bf00      	nop
 80126b4:	20400001 	.word	0x20400001

080126b8 <_fflush_r>:
 80126b8:	b538      	push	{r3, r4, r5, lr}
 80126ba:	690b      	ldr	r3, [r1, #16]
 80126bc:	4605      	mov	r5, r0
 80126be:	460c      	mov	r4, r1
 80126c0:	b913      	cbnz	r3, 80126c8 <_fflush_r+0x10>
 80126c2:	2500      	movs	r5, #0
 80126c4:	4628      	mov	r0, r5
 80126c6:	bd38      	pop	{r3, r4, r5, pc}
 80126c8:	b118      	cbz	r0, 80126d2 <_fflush_r+0x1a>
 80126ca:	6983      	ldr	r3, [r0, #24]
 80126cc:	b90b      	cbnz	r3, 80126d2 <_fflush_r+0x1a>
 80126ce:	f000 f887 	bl	80127e0 <__sinit>
 80126d2:	4b14      	ldr	r3, [pc, #80]	; (8012724 <_fflush_r+0x6c>)
 80126d4:	429c      	cmp	r4, r3
 80126d6:	d11b      	bne.n	8012710 <_fflush_r+0x58>
 80126d8:	686c      	ldr	r4, [r5, #4]
 80126da:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80126de:	2b00      	cmp	r3, #0
 80126e0:	d0ef      	beq.n	80126c2 <_fflush_r+0xa>
 80126e2:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80126e4:	07d0      	lsls	r0, r2, #31
 80126e6:	d404      	bmi.n	80126f2 <_fflush_r+0x3a>
 80126e8:	0599      	lsls	r1, r3, #22
 80126ea:	d402      	bmi.n	80126f2 <_fflush_r+0x3a>
 80126ec:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80126ee:	f000 f915 	bl	801291c <__retarget_lock_acquire_recursive>
 80126f2:	4628      	mov	r0, r5
 80126f4:	4621      	mov	r1, r4
 80126f6:	f7ff ff59 	bl	80125ac <__sflush_r>
 80126fa:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80126fc:	4605      	mov	r5, r0
 80126fe:	07da      	lsls	r2, r3, #31
 8012700:	d4e0      	bmi.n	80126c4 <_fflush_r+0xc>
 8012702:	89a3      	ldrh	r3, [r4, #12]
 8012704:	059b      	lsls	r3, r3, #22
 8012706:	d4dd      	bmi.n	80126c4 <_fflush_r+0xc>
 8012708:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801270a:	f000 f908 	bl	801291e <__retarget_lock_release_recursive>
 801270e:	e7d9      	b.n	80126c4 <_fflush_r+0xc>
 8012710:	4b05      	ldr	r3, [pc, #20]	; (8012728 <_fflush_r+0x70>)
 8012712:	429c      	cmp	r4, r3
 8012714:	d101      	bne.n	801271a <_fflush_r+0x62>
 8012716:	68ac      	ldr	r4, [r5, #8]
 8012718:	e7df      	b.n	80126da <_fflush_r+0x22>
 801271a:	4b04      	ldr	r3, [pc, #16]	; (801272c <_fflush_r+0x74>)
 801271c:	429c      	cmp	r4, r3
 801271e:	bf08      	it	eq
 8012720:	68ec      	ldreq	r4, [r5, #12]
 8012722:	e7da      	b.n	80126da <_fflush_r+0x22>
 8012724:	08015008 	.word	0x08015008
 8012728:	08015028 	.word	0x08015028
 801272c:	08014fe8 	.word	0x08014fe8

08012730 <std>:
 8012730:	2300      	movs	r3, #0
 8012732:	b510      	push	{r4, lr}
 8012734:	4604      	mov	r4, r0
 8012736:	e9c0 3300 	strd	r3, r3, [r0]
 801273a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801273e:	6083      	str	r3, [r0, #8]
 8012740:	8181      	strh	r1, [r0, #12]
 8012742:	6643      	str	r3, [r0, #100]	; 0x64
 8012744:	81c2      	strh	r2, [r0, #14]
 8012746:	6183      	str	r3, [r0, #24]
 8012748:	4619      	mov	r1, r3
 801274a:	2208      	movs	r2, #8
 801274c:	305c      	adds	r0, #92	; 0x5c
 801274e:	f7ff fa99 	bl	8011c84 <memset>
 8012752:	4b05      	ldr	r3, [pc, #20]	; (8012768 <std+0x38>)
 8012754:	6224      	str	r4, [r4, #32]
 8012756:	6263      	str	r3, [r4, #36]	; 0x24
 8012758:	4b04      	ldr	r3, [pc, #16]	; (801276c <std+0x3c>)
 801275a:	62a3      	str	r3, [r4, #40]	; 0x28
 801275c:	4b04      	ldr	r3, [pc, #16]	; (8012770 <std+0x40>)
 801275e:	62e3      	str	r3, [r4, #44]	; 0x2c
 8012760:	4b04      	ldr	r3, [pc, #16]	; (8012774 <std+0x44>)
 8012762:	6323      	str	r3, [r4, #48]	; 0x30
 8012764:	bd10      	pop	{r4, pc}
 8012766:	bf00      	nop
 8012768:	08012aa5 	.word	0x08012aa5
 801276c:	08012ac7 	.word	0x08012ac7
 8012770:	08012aff 	.word	0x08012aff
 8012774:	08012b23 	.word	0x08012b23

08012778 <_cleanup_r>:
 8012778:	4901      	ldr	r1, [pc, #4]	; (8012780 <_cleanup_r+0x8>)
 801277a:	f000 b8af 	b.w	80128dc <_fwalk_reent>
 801277e:	bf00      	nop
 8012780:	080126b9 	.word	0x080126b9

08012784 <__sfmoreglue>:
 8012784:	b570      	push	{r4, r5, r6, lr}
 8012786:	2568      	movs	r5, #104	; 0x68
 8012788:	1e4a      	subs	r2, r1, #1
 801278a:	4355      	muls	r5, r2
 801278c:	460e      	mov	r6, r1
 801278e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8012792:	f7ff facb 	bl	8011d2c <_malloc_r>
 8012796:	4604      	mov	r4, r0
 8012798:	b140      	cbz	r0, 80127ac <__sfmoreglue+0x28>
 801279a:	2100      	movs	r1, #0
 801279c:	e9c0 1600 	strd	r1, r6, [r0]
 80127a0:	300c      	adds	r0, #12
 80127a2:	60a0      	str	r0, [r4, #8]
 80127a4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 80127a8:	f7ff fa6c 	bl	8011c84 <memset>
 80127ac:	4620      	mov	r0, r4
 80127ae:	bd70      	pop	{r4, r5, r6, pc}

080127b0 <__sfp_lock_acquire>:
 80127b0:	4801      	ldr	r0, [pc, #4]	; (80127b8 <__sfp_lock_acquire+0x8>)
 80127b2:	f000 b8b3 	b.w	801291c <__retarget_lock_acquire_recursive>
 80127b6:	bf00      	nop
 80127b8:	20002735 	.word	0x20002735

080127bc <__sfp_lock_release>:
 80127bc:	4801      	ldr	r0, [pc, #4]	; (80127c4 <__sfp_lock_release+0x8>)
 80127be:	f000 b8ae 	b.w	801291e <__retarget_lock_release_recursive>
 80127c2:	bf00      	nop
 80127c4:	20002735 	.word	0x20002735

080127c8 <__sinit_lock_acquire>:
 80127c8:	4801      	ldr	r0, [pc, #4]	; (80127d0 <__sinit_lock_acquire+0x8>)
 80127ca:	f000 b8a7 	b.w	801291c <__retarget_lock_acquire_recursive>
 80127ce:	bf00      	nop
 80127d0:	20002730 	.word	0x20002730

080127d4 <__sinit_lock_release>:
 80127d4:	4801      	ldr	r0, [pc, #4]	; (80127dc <__sinit_lock_release+0x8>)
 80127d6:	f000 b8a2 	b.w	801291e <__retarget_lock_release_recursive>
 80127da:	bf00      	nop
 80127dc:	20002730 	.word	0x20002730

080127e0 <__sinit>:
 80127e0:	b510      	push	{r4, lr}
 80127e2:	4604      	mov	r4, r0
 80127e4:	f7ff fff0 	bl	80127c8 <__sinit_lock_acquire>
 80127e8:	69a3      	ldr	r3, [r4, #24]
 80127ea:	b11b      	cbz	r3, 80127f4 <__sinit+0x14>
 80127ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80127f0:	f7ff bff0 	b.w	80127d4 <__sinit_lock_release>
 80127f4:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 80127f8:	6523      	str	r3, [r4, #80]	; 0x50
 80127fa:	4b13      	ldr	r3, [pc, #76]	; (8012848 <__sinit+0x68>)
 80127fc:	4a13      	ldr	r2, [pc, #76]	; (801284c <__sinit+0x6c>)
 80127fe:	681b      	ldr	r3, [r3, #0]
 8012800:	62a2      	str	r2, [r4, #40]	; 0x28
 8012802:	42a3      	cmp	r3, r4
 8012804:	bf08      	it	eq
 8012806:	2301      	moveq	r3, #1
 8012808:	4620      	mov	r0, r4
 801280a:	bf08      	it	eq
 801280c:	61a3      	streq	r3, [r4, #24]
 801280e:	f000 f81f 	bl	8012850 <__sfp>
 8012812:	6060      	str	r0, [r4, #4]
 8012814:	4620      	mov	r0, r4
 8012816:	f000 f81b 	bl	8012850 <__sfp>
 801281a:	60a0      	str	r0, [r4, #8]
 801281c:	4620      	mov	r0, r4
 801281e:	f000 f817 	bl	8012850 <__sfp>
 8012822:	2200      	movs	r2, #0
 8012824:	2104      	movs	r1, #4
 8012826:	60e0      	str	r0, [r4, #12]
 8012828:	6860      	ldr	r0, [r4, #4]
 801282a:	f7ff ff81 	bl	8012730 <std>
 801282e:	2201      	movs	r2, #1
 8012830:	2109      	movs	r1, #9
 8012832:	68a0      	ldr	r0, [r4, #8]
 8012834:	f7ff ff7c 	bl	8012730 <std>
 8012838:	2202      	movs	r2, #2
 801283a:	2112      	movs	r1, #18
 801283c:	68e0      	ldr	r0, [r4, #12]
 801283e:	f7ff ff77 	bl	8012730 <std>
 8012842:	2301      	movs	r3, #1
 8012844:	61a3      	str	r3, [r4, #24]
 8012846:	e7d1      	b.n	80127ec <__sinit+0xc>
 8012848:	08014fb0 	.word	0x08014fb0
 801284c:	08012779 	.word	0x08012779

08012850 <__sfp>:
 8012850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012852:	4607      	mov	r7, r0
 8012854:	f7ff ffac 	bl	80127b0 <__sfp_lock_acquire>
 8012858:	4b1e      	ldr	r3, [pc, #120]	; (80128d4 <__sfp+0x84>)
 801285a:	681e      	ldr	r6, [r3, #0]
 801285c:	69b3      	ldr	r3, [r6, #24]
 801285e:	b913      	cbnz	r3, 8012866 <__sfp+0x16>
 8012860:	4630      	mov	r0, r6
 8012862:	f7ff ffbd 	bl	80127e0 <__sinit>
 8012866:	3648      	adds	r6, #72	; 0x48
 8012868:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 801286c:	3b01      	subs	r3, #1
 801286e:	d503      	bpl.n	8012878 <__sfp+0x28>
 8012870:	6833      	ldr	r3, [r6, #0]
 8012872:	b30b      	cbz	r3, 80128b8 <__sfp+0x68>
 8012874:	6836      	ldr	r6, [r6, #0]
 8012876:	e7f7      	b.n	8012868 <__sfp+0x18>
 8012878:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 801287c:	b9d5      	cbnz	r5, 80128b4 <__sfp+0x64>
 801287e:	4b16      	ldr	r3, [pc, #88]	; (80128d8 <__sfp+0x88>)
 8012880:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8012884:	60e3      	str	r3, [r4, #12]
 8012886:	6665      	str	r5, [r4, #100]	; 0x64
 8012888:	f000 f847 	bl	801291a <__retarget_lock_init_recursive>
 801288c:	f7ff ff96 	bl	80127bc <__sfp_lock_release>
 8012890:	2208      	movs	r2, #8
 8012892:	4629      	mov	r1, r5
 8012894:	e9c4 5501 	strd	r5, r5, [r4, #4]
 8012898:	e9c4 5504 	strd	r5, r5, [r4, #16]
 801289c:	6025      	str	r5, [r4, #0]
 801289e:	61a5      	str	r5, [r4, #24]
 80128a0:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80128a4:	f7ff f9ee 	bl	8011c84 <memset>
 80128a8:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 80128ac:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 80128b0:	4620      	mov	r0, r4
 80128b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80128b4:	3468      	adds	r4, #104	; 0x68
 80128b6:	e7d9      	b.n	801286c <__sfp+0x1c>
 80128b8:	2104      	movs	r1, #4
 80128ba:	4638      	mov	r0, r7
 80128bc:	f7ff ff62 	bl	8012784 <__sfmoreglue>
 80128c0:	4604      	mov	r4, r0
 80128c2:	6030      	str	r0, [r6, #0]
 80128c4:	2800      	cmp	r0, #0
 80128c6:	d1d5      	bne.n	8012874 <__sfp+0x24>
 80128c8:	f7ff ff78 	bl	80127bc <__sfp_lock_release>
 80128cc:	230c      	movs	r3, #12
 80128ce:	603b      	str	r3, [r7, #0]
 80128d0:	e7ee      	b.n	80128b0 <__sfp+0x60>
 80128d2:	bf00      	nop
 80128d4:	08014fb0 	.word	0x08014fb0
 80128d8:	ffff0001 	.word	0xffff0001

080128dc <_fwalk_reent>:
 80128dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80128e0:	4606      	mov	r6, r0
 80128e2:	4688      	mov	r8, r1
 80128e4:	2700      	movs	r7, #0
 80128e6:	f100 0448 	add.w	r4, r0, #72	; 0x48
 80128ea:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80128ee:	f1b9 0901 	subs.w	r9, r9, #1
 80128f2:	d505      	bpl.n	8012900 <_fwalk_reent+0x24>
 80128f4:	6824      	ldr	r4, [r4, #0]
 80128f6:	2c00      	cmp	r4, #0
 80128f8:	d1f7      	bne.n	80128ea <_fwalk_reent+0xe>
 80128fa:	4638      	mov	r0, r7
 80128fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8012900:	89ab      	ldrh	r3, [r5, #12]
 8012902:	2b01      	cmp	r3, #1
 8012904:	d907      	bls.n	8012916 <_fwalk_reent+0x3a>
 8012906:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801290a:	3301      	adds	r3, #1
 801290c:	d003      	beq.n	8012916 <_fwalk_reent+0x3a>
 801290e:	4629      	mov	r1, r5
 8012910:	4630      	mov	r0, r6
 8012912:	47c0      	blx	r8
 8012914:	4307      	orrs	r7, r0
 8012916:	3568      	adds	r5, #104	; 0x68
 8012918:	e7e9      	b.n	80128ee <_fwalk_reent+0x12>

0801291a <__retarget_lock_init_recursive>:
 801291a:	4770      	bx	lr

0801291c <__retarget_lock_acquire_recursive>:
 801291c:	4770      	bx	lr

0801291e <__retarget_lock_release_recursive>:
 801291e:	4770      	bx	lr

08012920 <__swhatbuf_r>:
 8012920:	b570      	push	{r4, r5, r6, lr}
 8012922:	460e      	mov	r6, r1
 8012924:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8012928:	4614      	mov	r4, r2
 801292a:	2900      	cmp	r1, #0
 801292c:	461d      	mov	r5, r3
 801292e:	b096      	sub	sp, #88	; 0x58
 8012930:	da07      	bge.n	8012942 <__swhatbuf_r+0x22>
 8012932:	2300      	movs	r3, #0
 8012934:	602b      	str	r3, [r5, #0]
 8012936:	89b3      	ldrh	r3, [r6, #12]
 8012938:	061a      	lsls	r2, r3, #24
 801293a:	d410      	bmi.n	801295e <__swhatbuf_r+0x3e>
 801293c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8012940:	e00e      	b.n	8012960 <__swhatbuf_r+0x40>
 8012942:	466a      	mov	r2, sp
 8012944:	f000 f914 	bl	8012b70 <_fstat_r>
 8012948:	2800      	cmp	r0, #0
 801294a:	dbf2      	blt.n	8012932 <__swhatbuf_r+0x12>
 801294c:	9a01      	ldr	r2, [sp, #4]
 801294e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8012952:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8012956:	425a      	negs	r2, r3
 8012958:	415a      	adcs	r2, r3
 801295a:	602a      	str	r2, [r5, #0]
 801295c:	e7ee      	b.n	801293c <__swhatbuf_r+0x1c>
 801295e:	2340      	movs	r3, #64	; 0x40
 8012960:	2000      	movs	r0, #0
 8012962:	6023      	str	r3, [r4, #0]
 8012964:	b016      	add	sp, #88	; 0x58
 8012966:	bd70      	pop	{r4, r5, r6, pc}

08012968 <__smakebuf_r>:
 8012968:	898b      	ldrh	r3, [r1, #12]
 801296a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 801296c:	079d      	lsls	r5, r3, #30
 801296e:	4606      	mov	r6, r0
 8012970:	460c      	mov	r4, r1
 8012972:	d507      	bpl.n	8012984 <__smakebuf_r+0x1c>
 8012974:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8012978:	6023      	str	r3, [r4, #0]
 801297a:	6123      	str	r3, [r4, #16]
 801297c:	2301      	movs	r3, #1
 801297e:	6163      	str	r3, [r4, #20]
 8012980:	b002      	add	sp, #8
 8012982:	bd70      	pop	{r4, r5, r6, pc}
 8012984:	466a      	mov	r2, sp
 8012986:	ab01      	add	r3, sp, #4
 8012988:	f7ff ffca 	bl	8012920 <__swhatbuf_r>
 801298c:	9900      	ldr	r1, [sp, #0]
 801298e:	4605      	mov	r5, r0
 8012990:	4630      	mov	r0, r6
 8012992:	f7ff f9cb 	bl	8011d2c <_malloc_r>
 8012996:	b948      	cbnz	r0, 80129ac <__smakebuf_r+0x44>
 8012998:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801299c:	059a      	lsls	r2, r3, #22
 801299e:	d4ef      	bmi.n	8012980 <__smakebuf_r+0x18>
 80129a0:	f023 0303 	bic.w	r3, r3, #3
 80129a4:	f043 0302 	orr.w	r3, r3, #2
 80129a8:	81a3      	strh	r3, [r4, #12]
 80129aa:	e7e3      	b.n	8012974 <__smakebuf_r+0xc>
 80129ac:	4b0d      	ldr	r3, [pc, #52]	; (80129e4 <__smakebuf_r+0x7c>)
 80129ae:	62b3      	str	r3, [r6, #40]	; 0x28
 80129b0:	89a3      	ldrh	r3, [r4, #12]
 80129b2:	6020      	str	r0, [r4, #0]
 80129b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80129b8:	81a3      	strh	r3, [r4, #12]
 80129ba:	9b00      	ldr	r3, [sp, #0]
 80129bc:	6120      	str	r0, [r4, #16]
 80129be:	6163      	str	r3, [r4, #20]
 80129c0:	9b01      	ldr	r3, [sp, #4]
 80129c2:	b15b      	cbz	r3, 80129dc <__smakebuf_r+0x74>
 80129c4:	4630      	mov	r0, r6
 80129c6:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80129ca:	f000 f8e3 	bl	8012b94 <_isatty_r>
 80129ce:	b128      	cbz	r0, 80129dc <__smakebuf_r+0x74>
 80129d0:	89a3      	ldrh	r3, [r4, #12]
 80129d2:	f023 0303 	bic.w	r3, r3, #3
 80129d6:	f043 0301 	orr.w	r3, r3, #1
 80129da:	81a3      	strh	r3, [r4, #12]
 80129dc:	89a0      	ldrh	r0, [r4, #12]
 80129de:	4305      	orrs	r5, r0
 80129e0:	81a5      	strh	r5, [r4, #12]
 80129e2:	e7cd      	b.n	8012980 <__smakebuf_r+0x18>
 80129e4:	08012779 	.word	0x08012779

080129e8 <memchr>:
 80129e8:	4603      	mov	r3, r0
 80129ea:	b510      	push	{r4, lr}
 80129ec:	b2c9      	uxtb	r1, r1
 80129ee:	4402      	add	r2, r0
 80129f0:	4293      	cmp	r3, r2
 80129f2:	4618      	mov	r0, r3
 80129f4:	d101      	bne.n	80129fa <memchr+0x12>
 80129f6:	2000      	movs	r0, #0
 80129f8:	e003      	b.n	8012a02 <memchr+0x1a>
 80129fa:	7804      	ldrb	r4, [r0, #0]
 80129fc:	3301      	adds	r3, #1
 80129fe:	428c      	cmp	r4, r1
 8012a00:	d1f6      	bne.n	80129f0 <memchr+0x8>
 8012a02:	bd10      	pop	{r4, pc}

08012a04 <__malloc_lock>:
 8012a04:	4801      	ldr	r0, [pc, #4]	; (8012a0c <__malloc_lock+0x8>)
 8012a06:	f7ff bf89 	b.w	801291c <__retarget_lock_acquire_recursive>
 8012a0a:	bf00      	nop
 8012a0c:	20002731 	.word	0x20002731

08012a10 <__malloc_unlock>:
 8012a10:	4801      	ldr	r0, [pc, #4]	; (8012a18 <__malloc_unlock+0x8>)
 8012a12:	f7ff bf84 	b.w	801291e <__retarget_lock_release_recursive>
 8012a16:	bf00      	nop
 8012a18:	20002731 	.word	0x20002731

08012a1c <_raise_r>:
 8012a1c:	291f      	cmp	r1, #31
 8012a1e:	b538      	push	{r3, r4, r5, lr}
 8012a20:	4604      	mov	r4, r0
 8012a22:	460d      	mov	r5, r1
 8012a24:	d904      	bls.n	8012a30 <_raise_r+0x14>
 8012a26:	2316      	movs	r3, #22
 8012a28:	6003      	str	r3, [r0, #0]
 8012a2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8012a2e:	bd38      	pop	{r3, r4, r5, pc}
 8012a30:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8012a32:	b112      	cbz	r2, 8012a3a <_raise_r+0x1e>
 8012a34:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8012a38:	b94b      	cbnz	r3, 8012a4e <_raise_r+0x32>
 8012a3a:	4620      	mov	r0, r4
 8012a3c:	f000 f830 	bl	8012aa0 <_getpid_r>
 8012a40:	462a      	mov	r2, r5
 8012a42:	4601      	mov	r1, r0
 8012a44:	4620      	mov	r0, r4
 8012a46:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8012a4a:	f000 b817 	b.w	8012a7c <_kill_r>
 8012a4e:	2b01      	cmp	r3, #1
 8012a50:	d00a      	beq.n	8012a68 <_raise_r+0x4c>
 8012a52:	1c59      	adds	r1, r3, #1
 8012a54:	d103      	bne.n	8012a5e <_raise_r+0x42>
 8012a56:	2316      	movs	r3, #22
 8012a58:	6003      	str	r3, [r0, #0]
 8012a5a:	2001      	movs	r0, #1
 8012a5c:	e7e7      	b.n	8012a2e <_raise_r+0x12>
 8012a5e:	2400      	movs	r4, #0
 8012a60:	4628      	mov	r0, r5
 8012a62:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8012a66:	4798      	blx	r3
 8012a68:	2000      	movs	r0, #0
 8012a6a:	e7e0      	b.n	8012a2e <_raise_r+0x12>

08012a6c <raise>:
 8012a6c:	4b02      	ldr	r3, [pc, #8]	; (8012a78 <raise+0xc>)
 8012a6e:	4601      	mov	r1, r0
 8012a70:	6818      	ldr	r0, [r3, #0]
 8012a72:	f7ff bfd3 	b.w	8012a1c <_raise_r>
 8012a76:	bf00      	nop
 8012a78:	2000001c 	.word	0x2000001c

08012a7c <_kill_r>:
 8012a7c:	b538      	push	{r3, r4, r5, lr}
 8012a7e:	2300      	movs	r3, #0
 8012a80:	4d06      	ldr	r5, [pc, #24]	; (8012a9c <_kill_r+0x20>)
 8012a82:	4604      	mov	r4, r0
 8012a84:	4608      	mov	r0, r1
 8012a86:	4611      	mov	r1, r2
 8012a88:	602b      	str	r3, [r5, #0]
 8012a8a:	f7f2 f93d 	bl	8004d08 <_kill>
 8012a8e:	1c43      	adds	r3, r0, #1
 8012a90:	d102      	bne.n	8012a98 <_kill_r+0x1c>
 8012a92:	682b      	ldr	r3, [r5, #0]
 8012a94:	b103      	cbz	r3, 8012a98 <_kill_r+0x1c>
 8012a96:	6023      	str	r3, [r4, #0]
 8012a98:	bd38      	pop	{r3, r4, r5, pc}
 8012a9a:	bf00      	nop
 8012a9c:	20002738 	.word	0x20002738

08012aa0 <_getpid_r>:
 8012aa0:	f7f2 b930 	b.w	8004d04 <_getpid>

08012aa4 <__sread>:
 8012aa4:	b510      	push	{r4, lr}
 8012aa6:	460c      	mov	r4, r1
 8012aa8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8012aac:	f000 f894 	bl	8012bd8 <_read_r>
 8012ab0:	2800      	cmp	r0, #0
 8012ab2:	bfab      	itete	ge
 8012ab4:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8012ab6:	89a3      	ldrhlt	r3, [r4, #12]
 8012ab8:	181b      	addge	r3, r3, r0
 8012aba:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8012abe:	bfac      	ite	ge
 8012ac0:	6563      	strge	r3, [r4, #84]	; 0x54
 8012ac2:	81a3      	strhlt	r3, [r4, #12]
 8012ac4:	bd10      	pop	{r4, pc}

08012ac6 <__swrite>:
 8012ac6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8012aca:	461f      	mov	r7, r3
 8012acc:	898b      	ldrh	r3, [r1, #12]
 8012ace:	4605      	mov	r5, r0
 8012ad0:	05db      	lsls	r3, r3, #23
 8012ad2:	460c      	mov	r4, r1
 8012ad4:	4616      	mov	r6, r2
 8012ad6:	d505      	bpl.n	8012ae4 <__swrite+0x1e>
 8012ad8:	2302      	movs	r3, #2
 8012ada:	2200      	movs	r2, #0
 8012adc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8012ae0:	f000 f868 	bl	8012bb4 <_lseek_r>
 8012ae4:	89a3      	ldrh	r3, [r4, #12]
 8012ae6:	4632      	mov	r2, r6
 8012ae8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8012aec:	81a3      	strh	r3, [r4, #12]
 8012aee:	4628      	mov	r0, r5
 8012af0:	463b      	mov	r3, r7
 8012af2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8012af6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8012afa:	f000 b817 	b.w	8012b2c <_write_r>

08012afe <__sseek>:
 8012afe:	b510      	push	{r4, lr}
 8012b00:	460c      	mov	r4, r1
 8012b02:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8012b06:	f000 f855 	bl	8012bb4 <_lseek_r>
 8012b0a:	1c43      	adds	r3, r0, #1
 8012b0c:	89a3      	ldrh	r3, [r4, #12]
 8012b0e:	bf15      	itete	ne
 8012b10:	6560      	strne	r0, [r4, #84]	; 0x54
 8012b12:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8012b16:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8012b1a:	81a3      	strheq	r3, [r4, #12]
 8012b1c:	bf18      	it	ne
 8012b1e:	81a3      	strhne	r3, [r4, #12]
 8012b20:	bd10      	pop	{r4, pc}

08012b22 <__sclose>:
 8012b22:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8012b26:	f000 b813 	b.w	8012b50 <_close_r>
	...

08012b2c <_write_r>:
 8012b2c:	b538      	push	{r3, r4, r5, lr}
 8012b2e:	4604      	mov	r4, r0
 8012b30:	4608      	mov	r0, r1
 8012b32:	4611      	mov	r1, r2
 8012b34:	2200      	movs	r2, #0
 8012b36:	4d05      	ldr	r5, [pc, #20]	; (8012b4c <_write_r+0x20>)
 8012b38:	602a      	str	r2, [r5, #0]
 8012b3a:	461a      	mov	r2, r3
 8012b3c:	f7f2 f902 	bl	8004d44 <_write>
 8012b40:	1c43      	adds	r3, r0, #1
 8012b42:	d102      	bne.n	8012b4a <_write_r+0x1e>
 8012b44:	682b      	ldr	r3, [r5, #0]
 8012b46:	b103      	cbz	r3, 8012b4a <_write_r+0x1e>
 8012b48:	6023      	str	r3, [r4, #0]
 8012b4a:	bd38      	pop	{r3, r4, r5, pc}
 8012b4c:	20002738 	.word	0x20002738

08012b50 <_close_r>:
 8012b50:	b538      	push	{r3, r4, r5, lr}
 8012b52:	2300      	movs	r3, #0
 8012b54:	4d05      	ldr	r5, [pc, #20]	; (8012b6c <_close_r+0x1c>)
 8012b56:	4604      	mov	r4, r0
 8012b58:	4608      	mov	r0, r1
 8012b5a:	602b      	str	r3, [r5, #0]
 8012b5c:	f7f2 f900 	bl	8004d60 <_close>
 8012b60:	1c43      	adds	r3, r0, #1
 8012b62:	d102      	bne.n	8012b6a <_close_r+0x1a>
 8012b64:	682b      	ldr	r3, [r5, #0]
 8012b66:	b103      	cbz	r3, 8012b6a <_close_r+0x1a>
 8012b68:	6023      	str	r3, [r4, #0]
 8012b6a:	bd38      	pop	{r3, r4, r5, pc}
 8012b6c:	20002738 	.word	0x20002738

08012b70 <_fstat_r>:
 8012b70:	b538      	push	{r3, r4, r5, lr}
 8012b72:	2300      	movs	r3, #0
 8012b74:	4d06      	ldr	r5, [pc, #24]	; (8012b90 <_fstat_r+0x20>)
 8012b76:	4604      	mov	r4, r0
 8012b78:	4608      	mov	r0, r1
 8012b7a:	4611      	mov	r1, r2
 8012b7c:	602b      	str	r3, [r5, #0]
 8012b7e:	f7f2 f8f3 	bl	8004d68 <_fstat>
 8012b82:	1c43      	adds	r3, r0, #1
 8012b84:	d102      	bne.n	8012b8c <_fstat_r+0x1c>
 8012b86:	682b      	ldr	r3, [r5, #0]
 8012b88:	b103      	cbz	r3, 8012b8c <_fstat_r+0x1c>
 8012b8a:	6023      	str	r3, [r4, #0]
 8012b8c:	bd38      	pop	{r3, r4, r5, pc}
 8012b8e:	bf00      	nop
 8012b90:	20002738 	.word	0x20002738

08012b94 <_isatty_r>:
 8012b94:	b538      	push	{r3, r4, r5, lr}
 8012b96:	2300      	movs	r3, #0
 8012b98:	4d05      	ldr	r5, [pc, #20]	; (8012bb0 <_isatty_r+0x1c>)
 8012b9a:	4604      	mov	r4, r0
 8012b9c:	4608      	mov	r0, r1
 8012b9e:	602b      	str	r3, [r5, #0]
 8012ba0:	f7f2 f8e8 	bl	8004d74 <_isatty>
 8012ba4:	1c43      	adds	r3, r0, #1
 8012ba6:	d102      	bne.n	8012bae <_isatty_r+0x1a>
 8012ba8:	682b      	ldr	r3, [r5, #0]
 8012baa:	b103      	cbz	r3, 8012bae <_isatty_r+0x1a>
 8012bac:	6023      	str	r3, [r4, #0]
 8012bae:	bd38      	pop	{r3, r4, r5, pc}
 8012bb0:	20002738 	.word	0x20002738

08012bb4 <_lseek_r>:
 8012bb4:	b538      	push	{r3, r4, r5, lr}
 8012bb6:	4604      	mov	r4, r0
 8012bb8:	4608      	mov	r0, r1
 8012bba:	4611      	mov	r1, r2
 8012bbc:	2200      	movs	r2, #0
 8012bbe:	4d05      	ldr	r5, [pc, #20]	; (8012bd4 <_lseek_r+0x20>)
 8012bc0:	602a      	str	r2, [r5, #0]
 8012bc2:	461a      	mov	r2, r3
 8012bc4:	f7f2 f8d8 	bl	8004d78 <_lseek>
 8012bc8:	1c43      	adds	r3, r0, #1
 8012bca:	d102      	bne.n	8012bd2 <_lseek_r+0x1e>
 8012bcc:	682b      	ldr	r3, [r5, #0]
 8012bce:	b103      	cbz	r3, 8012bd2 <_lseek_r+0x1e>
 8012bd0:	6023      	str	r3, [r4, #0]
 8012bd2:	bd38      	pop	{r3, r4, r5, pc}
 8012bd4:	20002738 	.word	0x20002738

08012bd8 <_read_r>:
 8012bd8:	b538      	push	{r3, r4, r5, lr}
 8012bda:	4604      	mov	r4, r0
 8012bdc:	4608      	mov	r0, r1
 8012bde:	4611      	mov	r1, r2
 8012be0:	2200      	movs	r2, #0
 8012be2:	4d05      	ldr	r5, [pc, #20]	; (8012bf8 <_read_r+0x20>)
 8012be4:	602a      	str	r2, [r5, #0]
 8012be6:	461a      	mov	r2, r3
 8012be8:	f7f2 f89e 	bl	8004d28 <_read>
 8012bec:	1c43      	adds	r3, r0, #1
 8012bee:	d102      	bne.n	8012bf6 <_read_r+0x1e>
 8012bf0:	682b      	ldr	r3, [r5, #0]
 8012bf2:	b103      	cbz	r3, 8012bf6 <_read_r+0x1e>
 8012bf4:	6023      	str	r3, [r4, #0]
 8012bf6:	bd38      	pop	{r3, r4, r5, pc}
 8012bf8:	20002738 	.word	0x20002738

08012bfc <ceilf>:
 8012bfc:	b570      	push	{r4, r5, r6, lr}
 8012bfe:	f3c0 55c7 	ubfx	r5, r0, #23, #8
 8012c02:	3d7f      	subs	r5, #127	; 0x7f
 8012c04:	2d16      	cmp	r5, #22
 8012c06:	4601      	mov	r1, r0
 8012c08:	4604      	mov	r4, r0
 8012c0a:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8012c0e:	dc26      	bgt.n	8012c5e <ceilf+0x62>
 8012c10:	2d00      	cmp	r5, #0
 8012c12:	da0e      	bge.n	8012c32 <ceilf+0x36>
 8012c14:	4917      	ldr	r1, [pc, #92]	; (8012c74 <ceilf+0x78>)
 8012c16:	f7ed fcb5 	bl	8000584 <__addsf3>
 8012c1a:	2100      	movs	r1, #0
 8012c1c:	f7ed ff76 	bl	8000b0c <__aeabi_fcmpgt>
 8012c20:	b128      	cbz	r0, 8012c2e <ceilf+0x32>
 8012c22:	2c00      	cmp	r4, #0
 8012c24:	db23      	blt.n	8012c6e <ceilf+0x72>
 8012c26:	2e00      	cmp	r6, #0
 8012c28:	bf18      	it	ne
 8012c2a:	f04f 547e 	movne.w	r4, #1065353216	; 0x3f800000
 8012c2e:	4621      	mov	r1, r4
 8012c30:	e01b      	b.n	8012c6a <ceilf+0x6e>
 8012c32:	4e11      	ldr	r6, [pc, #68]	; (8012c78 <ceilf+0x7c>)
 8012c34:	412e      	asrs	r6, r5
 8012c36:	4230      	tst	r0, r6
 8012c38:	d017      	beq.n	8012c6a <ceilf+0x6e>
 8012c3a:	490e      	ldr	r1, [pc, #56]	; (8012c74 <ceilf+0x78>)
 8012c3c:	f7ed fca2 	bl	8000584 <__addsf3>
 8012c40:	2100      	movs	r1, #0
 8012c42:	f7ed ff63 	bl	8000b0c <__aeabi_fcmpgt>
 8012c46:	2800      	cmp	r0, #0
 8012c48:	d0f1      	beq.n	8012c2e <ceilf+0x32>
 8012c4a:	2c00      	cmp	r4, #0
 8012c4c:	bfc2      	ittt	gt
 8012c4e:	f44f 0300 	movgt.w	r3, #8388608	; 0x800000
 8012c52:	fa43 f505 	asrgt.w	r5, r3, r5
 8012c56:	1964      	addgt	r4, r4, r5
 8012c58:	ea24 0406 	bic.w	r4, r4, r6
 8012c5c:	e7e7      	b.n	8012c2e <ceilf+0x32>
 8012c5e:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8012c62:	d302      	bcc.n	8012c6a <ceilf+0x6e>
 8012c64:	f7ed fc8e 	bl	8000584 <__addsf3>
 8012c68:	4601      	mov	r1, r0
 8012c6a:	4608      	mov	r0, r1
 8012c6c:	bd70      	pop	{r4, r5, r6, pc}
 8012c6e:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8012c72:	e7dc      	b.n	8012c2e <ceilf+0x32>
 8012c74:	7149f2ca 	.word	0x7149f2ca
 8012c78:	007fffff 	.word	0x007fffff

08012c7c <cosf>:
 8012c7c:	b507      	push	{r0, r1, r2, lr}
 8012c7e:	4a18      	ldr	r2, [pc, #96]	; (8012ce0 <cosf+0x64>)
 8012c80:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8012c84:	4293      	cmp	r3, r2
 8012c86:	4601      	mov	r1, r0
 8012c88:	dc03      	bgt.n	8012c92 <cosf+0x16>
 8012c8a:	2100      	movs	r1, #0
 8012c8c:	f000 ff5a 	bl	8013b44 <__kernel_cosf>
 8012c90:	e004      	b.n	8012c9c <cosf+0x20>
 8012c92:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8012c96:	db04      	blt.n	8012ca2 <cosf+0x26>
 8012c98:	f7ed fc72 	bl	8000580 <__aeabi_fsub>
 8012c9c:	b003      	add	sp, #12
 8012c9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ca2:	4669      	mov	r1, sp
 8012ca4:	f000 fd9e 	bl	80137e4 <__ieee754_rem_pio2f>
 8012ca8:	f000 0203 	and.w	r2, r0, #3
 8012cac:	2a01      	cmp	r2, #1
 8012cae:	d005      	beq.n	8012cbc <cosf+0x40>
 8012cb0:	2a02      	cmp	r2, #2
 8012cb2:	d00a      	beq.n	8012cca <cosf+0x4e>
 8012cb4:	b972      	cbnz	r2, 8012cd4 <cosf+0x58>
 8012cb6:	9901      	ldr	r1, [sp, #4]
 8012cb8:	9800      	ldr	r0, [sp, #0]
 8012cba:	e7e7      	b.n	8012c8c <cosf+0x10>
 8012cbc:	9901      	ldr	r1, [sp, #4]
 8012cbe:	9800      	ldr	r0, [sp, #0]
 8012cc0:	f001 fa76 	bl	80141b0 <__kernel_sinf>
 8012cc4:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8012cc8:	e7e8      	b.n	8012c9c <cosf+0x20>
 8012cca:	9901      	ldr	r1, [sp, #4]
 8012ccc:	9800      	ldr	r0, [sp, #0]
 8012cce:	f000 ff39 	bl	8013b44 <__kernel_cosf>
 8012cd2:	e7f7      	b.n	8012cc4 <cosf+0x48>
 8012cd4:	2201      	movs	r2, #1
 8012cd6:	9901      	ldr	r1, [sp, #4]
 8012cd8:	9800      	ldr	r0, [sp, #0]
 8012cda:	f001 fa69 	bl	80141b0 <__kernel_sinf>
 8012cde:	e7dd      	b.n	8012c9c <cosf+0x20>
 8012ce0:	3f490fd8 	.word	0x3f490fd8

08012ce4 <floorf>:
 8012ce4:	b570      	push	{r4, r5, r6, lr}
 8012ce6:	f3c0 55c7 	ubfx	r5, r0, #23, #8
 8012cea:	3d7f      	subs	r5, #127	; 0x7f
 8012cec:	2d16      	cmp	r5, #22
 8012cee:	4601      	mov	r1, r0
 8012cf0:	4604      	mov	r4, r0
 8012cf2:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8012cf6:	dc26      	bgt.n	8012d46 <floorf+0x62>
 8012cf8:	2d00      	cmp	r5, #0
 8012cfa:	da0e      	bge.n	8012d1a <floorf+0x36>
 8012cfc:	4917      	ldr	r1, [pc, #92]	; (8012d5c <floorf+0x78>)
 8012cfe:	f7ed fc41 	bl	8000584 <__addsf3>
 8012d02:	2100      	movs	r1, #0
 8012d04:	f7ed ff02 	bl	8000b0c <__aeabi_fcmpgt>
 8012d08:	b128      	cbz	r0, 8012d16 <floorf+0x32>
 8012d0a:	2c00      	cmp	r4, #0
 8012d0c:	da23      	bge.n	8012d56 <floorf+0x72>
 8012d0e:	4b14      	ldr	r3, [pc, #80]	; (8012d60 <floorf+0x7c>)
 8012d10:	2e00      	cmp	r6, #0
 8012d12:	bf18      	it	ne
 8012d14:	461c      	movne	r4, r3
 8012d16:	4621      	mov	r1, r4
 8012d18:	e01b      	b.n	8012d52 <floorf+0x6e>
 8012d1a:	4e12      	ldr	r6, [pc, #72]	; (8012d64 <floorf+0x80>)
 8012d1c:	412e      	asrs	r6, r5
 8012d1e:	4230      	tst	r0, r6
 8012d20:	d017      	beq.n	8012d52 <floorf+0x6e>
 8012d22:	490e      	ldr	r1, [pc, #56]	; (8012d5c <floorf+0x78>)
 8012d24:	f7ed fc2e 	bl	8000584 <__addsf3>
 8012d28:	2100      	movs	r1, #0
 8012d2a:	f7ed feef 	bl	8000b0c <__aeabi_fcmpgt>
 8012d2e:	2800      	cmp	r0, #0
 8012d30:	d0f1      	beq.n	8012d16 <floorf+0x32>
 8012d32:	2c00      	cmp	r4, #0
 8012d34:	bfbe      	ittt	lt
 8012d36:	f44f 0300 	movlt.w	r3, #8388608	; 0x800000
 8012d3a:	fa43 f505 	asrlt.w	r5, r3, r5
 8012d3e:	1964      	addlt	r4, r4, r5
 8012d40:	ea24 0406 	bic.w	r4, r4, r6
 8012d44:	e7e7      	b.n	8012d16 <floorf+0x32>
 8012d46:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8012d4a:	d302      	bcc.n	8012d52 <floorf+0x6e>
 8012d4c:	f7ed fc1a 	bl	8000584 <__addsf3>
 8012d50:	4601      	mov	r1, r0
 8012d52:	4608      	mov	r0, r1
 8012d54:	bd70      	pop	{r4, r5, r6, pc}
 8012d56:	2400      	movs	r4, #0
 8012d58:	e7dd      	b.n	8012d16 <floorf+0x32>
 8012d5a:	bf00      	nop
 8012d5c:	7149f2ca 	.word	0x7149f2ca
 8012d60:	bf800000 	.word	0xbf800000
 8012d64:	007fffff 	.word	0x007fffff

08012d68 <lroundf>:
 8012d68:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8012d6c:	2800      	cmp	r0, #0
 8012d6e:	b510      	push	{r4, lr}
 8012d70:	f1a3 047f 	sub.w	r4, r3, #127	; 0x7f
 8012d74:	bfb4      	ite	lt
 8012d76:	f04f 31ff 	movlt.w	r1, #4294967295	; 0xffffffff
 8012d7a:	2101      	movge	r1, #1
 8012d7c:	2c1e      	cmp	r4, #30
 8012d7e:	dc1b      	bgt.n	8012db8 <lroundf+0x50>
 8012d80:	2c00      	cmp	r4, #0
 8012d82:	da04      	bge.n	8012d8e <lroundf+0x26>
 8012d84:	3401      	adds	r4, #1
 8012d86:	bf18      	it	ne
 8012d88:	2100      	movne	r1, #0
 8012d8a:	4608      	mov	r0, r1
 8012d8c:	bd10      	pop	{r4, pc}
 8012d8e:	2c16      	cmp	r4, #22
 8012d90:	bfd8      	it	le
 8012d92:	f44f 0380 	movle.w	r3, #4194304	; 0x400000
 8012d96:	f3c0 0216 	ubfx	r2, r0, #0, #23
 8012d9a:	bfd8      	it	le
 8012d9c:	4123      	asrle	r3, r4
 8012d9e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8012da2:	bfcd      	iteet	gt
 8012da4:	3b96      	subgt	r3, #150	; 0x96
 8012da6:	189b      	addle	r3, r3, r2
 8012da8:	f1c4 0417 	rsble	r4, r4, #23
 8012dac:	fa02 f303 	lslgt.w	r3, r2, r3
 8012db0:	bfd8      	it	le
 8012db2:	40e3      	lsrle	r3, r4
 8012db4:	4359      	muls	r1, r3
 8012db6:	e7e8      	b.n	8012d8a <lroundf+0x22>
 8012db8:	f7ed fec8 	bl	8000b4c <__aeabi_f2iz>
 8012dbc:	4601      	mov	r1, r0
 8012dbe:	e7e4      	b.n	8012d8a <lroundf+0x22>

08012dc0 <roundf>:
 8012dc0:	b508      	push	{r3, lr}
 8012dc2:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8012dc6:	3b7f      	subs	r3, #127	; 0x7f
 8012dc8:	2b16      	cmp	r3, #22
 8012dca:	4601      	mov	r1, r0
 8012dcc:	4602      	mov	r2, r0
 8012dce:	dc14      	bgt.n	8012dfa <roundf+0x3a>
 8012dd0:	2b00      	cmp	r3, #0
 8012dd2:	da07      	bge.n	8012de4 <roundf+0x24>
 8012dd4:	3301      	adds	r3, #1
 8012dd6:	f000 4100 	and.w	r1, r0, #2147483648	; 0x80000000
 8012dda:	d101      	bne.n	8012de0 <roundf+0x20>
 8012ddc:	f041 517e 	orr.w	r1, r1, #1065353216	; 0x3f800000
 8012de0:	4608      	mov	r0, r1
 8012de2:	bd08      	pop	{r3, pc}
 8012de4:	4808      	ldr	r0, [pc, #32]	; (8012e08 <roundf+0x48>)
 8012de6:	4118      	asrs	r0, r3
 8012de8:	4201      	tst	r1, r0
 8012dea:	d0f9      	beq.n	8012de0 <roundf+0x20>
 8012dec:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8012df0:	4119      	asrs	r1, r3
 8012df2:	4411      	add	r1, r2
 8012df4:	ea21 0100 	bic.w	r1, r1, r0
 8012df8:	e7f2      	b.n	8012de0 <roundf+0x20>
 8012dfa:	2b80      	cmp	r3, #128	; 0x80
 8012dfc:	d1f0      	bne.n	8012de0 <roundf+0x20>
 8012dfe:	f7ed fbc1 	bl	8000584 <__addsf3>
 8012e02:	4601      	mov	r1, r0
 8012e04:	e7ec      	b.n	8012de0 <roundf+0x20>
 8012e06:	bf00      	nop
 8012e08:	007fffff 	.word	0x007fffff

08012e0c <sinf>:
 8012e0c:	b507      	push	{r0, r1, r2, lr}
 8012e0e:	4a19      	ldr	r2, [pc, #100]	; (8012e74 <sinf+0x68>)
 8012e10:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8012e14:	4293      	cmp	r3, r2
 8012e16:	4601      	mov	r1, r0
 8012e18:	dc04      	bgt.n	8012e24 <sinf+0x18>
 8012e1a:	2200      	movs	r2, #0
 8012e1c:	2100      	movs	r1, #0
 8012e1e:	f001 f9c7 	bl	80141b0 <__kernel_sinf>
 8012e22:	e004      	b.n	8012e2e <sinf+0x22>
 8012e24:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8012e28:	db04      	blt.n	8012e34 <sinf+0x28>
 8012e2a:	f7ed fba9 	bl	8000580 <__aeabi_fsub>
 8012e2e:	b003      	add	sp, #12
 8012e30:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e34:	4669      	mov	r1, sp
 8012e36:	f000 fcd5 	bl	80137e4 <__ieee754_rem_pio2f>
 8012e3a:	f000 0003 	and.w	r0, r0, #3
 8012e3e:	2801      	cmp	r0, #1
 8012e40:	d006      	beq.n	8012e50 <sinf+0x44>
 8012e42:	2802      	cmp	r0, #2
 8012e44:	d009      	beq.n	8012e5a <sinf+0x4e>
 8012e46:	b980      	cbnz	r0, 8012e6a <sinf+0x5e>
 8012e48:	2201      	movs	r2, #1
 8012e4a:	9901      	ldr	r1, [sp, #4]
 8012e4c:	9800      	ldr	r0, [sp, #0]
 8012e4e:	e7e6      	b.n	8012e1e <sinf+0x12>
 8012e50:	9901      	ldr	r1, [sp, #4]
 8012e52:	9800      	ldr	r0, [sp, #0]
 8012e54:	f000 fe76 	bl	8013b44 <__kernel_cosf>
 8012e58:	e7e9      	b.n	8012e2e <sinf+0x22>
 8012e5a:	2201      	movs	r2, #1
 8012e5c:	9901      	ldr	r1, [sp, #4]
 8012e5e:	9800      	ldr	r0, [sp, #0]
 8012e60:	f001 f9a6 	bl	80141b0 <__kernel_sinf>
 8012e64:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8012e68:	e7e1      	b.n	8012e2e <sinf+0x22>
 8012e6a:	9901      	ldr	r1, [sp, #4]
 8012e6c:	9800      	ldr	r0, [sp, #0]
 8012e6e:	f000 fe69 	bl	8013b44 <__kernel_cosf>
 8012e72:	e7f7      	b.n	8012e64 <sinf+0x58>
 8012e74:	3f490fd8 	.word	0x3f490fd8

08012e78 <tanf>:
 8012e78:	b507      	push	{r0, r1, r2, lr}
 8012e7a:	4a0f      	ldr	r2, [pc, #60]	; (8012eb8 <tanf+0x40>)
 8012e7c:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 8012e80:	4293      	cmp	r3, r2
 8012e82:	4601      	mov	r1, r0
 8012e84:	dc04      	bgt.n	8012e90 <tanf+0x18>
 8012e86:	2201      	movs	r2, #1
 8012e88:	2100      	movs	r1, #0
 8012e8a:	f001 fa07 	bl	801429c <__kernel_tanf>
 8012e8e:	e004      	b.n	8012e9a <tanf+0x22>
 8012e90:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 8012e94:	db04      	blt.n	8012ea0 <tanf+0x28>
 8012e96:	f7ed fb73 	bl	8000580 <__aeabi_fsub>
 8012e9a:	b003      	add	sp, #12
 8012e9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ea0:	4669      	mov	r1, sp
 8012ea2:	f000 fc9f 	bl	80137e4 <__ieee754_rem_pio2f>
 8012ea6:	0042      	lsls	r2, r0, #1
 8012ea8:	f002 0202 	and.w	r2, r2, #2
 8012eac:	9901      	ldr	r1, [sp, #4]
 8012eae:	9800      	ldr	r0, [sp, #0]
 8012eb0:	f1c2 0201 	rsb	r2, r2, #1
 8012eb4:	e7e9      	b.n	8012e8a <tanf+0x12>
 8012eb6:	bf00      	nop
 8012eb8:	3f490fda 	.word	0x3f490fda

08012ebc <truncf>:
 8012ebc:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 8012ec0:	3b7f      	subs	r3, #127	; 0x7f
 8012ec2:	2b16      	cmp	r3, #22
 8012ec4:	4602      	mov	r2, r0
 8012ec6:	dc08      	bgt.n	8012eda <truncf+0x1e>
 8012ec8:	2b00      	cmp	r3, #0
 8012eca:	da02      	bge.n	8012ed2 <truncf+0x16>
 8012ecc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8012ed0:	4770      	bx	lr
 8012ed2:	4802      	ldr	r0, [pc, #8]	; (8012edc <truncf+0x20>)
 8012ed4:	4118      	asrs	r0, r3
 8012ed6:	ea22 0000 	bic.w	r0, r2, r0
 8012eda:	4770      	bx	lr
 8012edc:	007fffff 	.word	0x007fffff

08012ee0 <atan2f>:
 8012ee0:	f000 b8a6 	b.w	8013030 <__ieee754_atan2f>

08012ee4 <powf>:
 8012ee4:	b570      	push	{r4, r5, r6, lr}
 8012ee6:	4606      	mov	r6, r0
 8012ee8:	460d      	mov	r5, r1
 8012eea:	f000 f927 	bl	801313c <__ieee754_powf>
 8012eee:	4b3d      	ldr	r3, [pc, #244]	; (8012fe4 <powf+0x100>)
 8012ef0:	4604      	mov	r4, r0
 8012ef2:	f993 3000 	ldrsb.w	r3, [r3]
 8012ef6:	3301      	adds	r3, #1
 8012ef8:	d00f      	beq.n	8012f1a <powf+0x36>
 8012efa:	4629      	mov	r1, r5
 8012efc:	4628      	mov	r0, r5
 8012efe:	f7ed fe0f 	bl	8000b20 <__aeabi_fcmpun>
 8012f02:	b950      	cbnz	r0, 8012f1a <powf+0x36>
 8012f04:	4631      	mov	r1, r6
 8012f06:	4630      	mov	r0, r6
 8012f08:	f7ed fe0a 	bl	8000b20 <__aeabi_fcmpun>
 8012f0c:	2100      	movs	r1, #0
 8012f0e:	b130      	cbz	r0, 8012f1e <powf+0x3a>
 8012f10:	4628      	mov	r0, r5
 8012f12:	f7ed fdd3 	bl	8000abc <__aeabi_fcmpeq>
 8012f16:	2800      	cmp	r0, #0
 8012f18:	d161      	bne.n	8012fde <powf+0xfa>
 8012f1a:	4620      	mov	r0, r4
 8012f1c:	bd70      	pop	{r4, r5, r6, pc}
 8012f1e:	4630      	mov	r0, r6
 8012f20:	f7ed fdcc 	bl	8000abc <__aeabi_fcmpeq>
 8012f24:	b1b0      	cbz	r0, 8012f54 <powf+0x70>
 8012f26:	2100      	movs	r1, #0
 8012f28:	4628      	mov	r0, r5
 8012f2a:	f7ed fdc7 	bl	8000abc <__aeabi_fcmpeq>
 8012f2e:	2800      	cmp	r0, #0
 8012f30:	d155      	bne.n	8012fde <powf+0xfa>
 8012f32:	4628      	mov	r0, r5
 8012f34:	f001 fbef 	bl	8014716 <finitef>
 8012f38:	2800      	cmp	r0, #0
 8012f3a:	d0ee      	beq.n	8012f1a <powf+0x36>
 8012f3c:	2100      	movs	r1, #0
 8012f3e:	4628      	mov	r0, r5
 8012f40:	f7ed fdc6 	bl	8000ad0 <__aeabi_fcmplt>
 8012f44:	2800      	cmp	r0, #0
 8012f46:	d0e8      	beq.n	8012f1a <powf+0x36>
 8012f48:	f7fe fe34 	bl	8011bb4 <__errno>
 8012f4c:	2321      	movs	r3, #33	; 0x21
 8012f4e:	6003      	str	r3, [r0, #0]
 8012f50:	4c25      	ldr	r4, [pc, #148]	; (8012fe8 <powf+0x104>)
 8012f52:	e7e2      	b.n	8012f1a <powf+0x36>
 8012f54:	4620      	mov	r0, r4
 8012f56:	f001 fbde 	bl	8014716 <finitef>
 8012f5a:	bb50      	cbnz	r0, 8012fb2 <powf+0xce>
 8012f5c:	4630      	mov	r0, r6
 8012f5e:	f001 fbda 	bl	8014716 <finitef>
 8012f62:	b330      	cbz	r0, 8012fb2 <powf+0xce>
 8012f64:	4628      	mov	r0, r5
 8012f66:	f001 fbd6 	bl	8014716 <finitef>
 8012f6a:	b310      	cbz	r0, 8012fb2 <powf+0xce>
 8012f6c:	4621      	mov	r1, r4
 8012f6e:	4620      	mov	r0, r4
 8012f70:	f7ed fdd6 	bl	8000b20 <__aeabi_fcmpun>
 8012f74:	b148      	cbz	r0, 8012f8a <powf+0xa6>
 8012f76:	f7fe fe1d 	bl	8011bb4 <__errno>
 8012f7a:	2321      	movs	r3, #33	; 0x21
 8012f7c:	2100      	movs	r1, #0
 8012f7e:	6003      	str	r3, [r0, #0]
 8012f80:	4608      	mov	r0, r1
 8012f82:	f7ed fcbb 	bl	80008fc <__aeabi_fdiv>
 8012f86:	4604      	mov	r4, r0
 8012f88:	e7c7      	b.n	8012f1a <powf+0x36>
 8012f8a:	f7fe fe13 	bl	8011bb4 <__errno>
 8012f8e:	2322      	movs	r3, #34	; 0x22
 8012f90:	2100      	movs	r1, #0
 8012f92:	6003      	str	r3, [r0, #0]
 8012f94:	4630      	mov	r0, r6
 8012f96:	f7ed fd9b 	bl	8000ad0 <__aeabi_fcmplt>
 8012f9a:	b138      	cbz	r0, 8012fac <powf+0xc8>
 8012f9c:	4628      	mov	r0, r5
 8012f9e:	f001 fbc7 	bl	8014730 <rintf>
 8012fa2:	4629      	mov	r1, r5
 8012fa4:	f7ed fd8a 	bl	8000abc <__aeabi_fcmpeq>
 8012fa8:	2800      	cmp	r0, #0
 8012faa:	d0d1      	beq.n	8012f50 <powf+0x6c>
 8012fac:	f04f 44ff 	mov.w	r4, #2139095040	; 0x7f800000
 8012fb0:	e7b3      	b.n	8012f1a <powf+0x36>
 8012fb2:	2100      	movs	r1, #0
 8012fb4:	4620      	mov	r0, r4
 8012fb6:	f7ed fd81 	bl	8000abc <__aeabi_fcmpeq>
 8012fba:	2800      	cmp	r0, #0
 8012fbc:	d0ad      	beq.n	8012f1a <powf+0x36>
 8012fbe:	4630      	mov	r0, r6
 8012fc0:	f001 fba9 	bl	8014716 <finitef>
 8012fc4:	2800      	cmp	r0, #0
 8012fc6:	d0a8      	beq.n	8012f1a <powf+0x36>
 8012fc8:	4628      	mov	r0, r5
 8012fca:	f001 fba4 	bl	8014716 <finitef>
 8012fce:	2800      	cmp	r0, #0
 8012fd0:	d0a3      	beq.n	8012f1a <powf+0x36>
 8012fd2:	f7fe fdef 	bl	8011bb4 <__errno>
 8012fd6:	2322      	movs	r3, #34	; 0x22
 8012fd8:	2400      	movs	r4, #0
 8012fda:	6003      	str	r3, [r0, #0]
 8012fdc:	e79d      	b.n	8012f1a <powf+0x36>
 8012fde:	f04f 547e 	mov.w	r4, #1065353216	; 0x3f800000
 8012fe2:	e79a      	b.n	8012f1a <powf+0x36>
 8012fe4:	20000080 	.word	0x20000080
 8012fe8:	ff800000 	.word	0xff800000

08012fec <sqrtf>:
 8012fec:	b538      	push	{r3, r4, r5, lr}
 8012fee:	4605      	mov	r5, r0
 8012ff0:	f000 fd56 	bl	8013aa0 <__ieee754_sqrtf>
 8012ff4:	4b0d      	ldr	r3, [pc, #52]	; (801302c <sqrtf+0x40>)
 8012ff6:	4604      	mov	r4, r0
 8012ff8:	f993 3000 	ldrsb.w	r3, [r3]
 8012ffc:	3301      	adds	r3, #1
 8012ffe:	d012      	beq.n	8013026 <sqrtf+0x3a>
 8013000:	4629      	mov	r1, r5
 8013002:	4628      	mov	r0, r5
 8013004:	f7ed fd8c 	bl	8000b20 <__aeabi_fcmpun>
 8013008:	b968      	cbnz	r0, 8013026 <sqrtf+0x3a>
 801300a:	2100      	movs	r1, #0
 801300c:	4628      	mov	r0, r5
 801300e:	f7ed fd5f 	bl	8000ad0 <__aeabi_fcmplt>
 8013012:	b140      	cbz	r0, 8013026 <sqrtf+0x3a>
 8013014:	f7fe fdce 	bl	8011bb4 <__errno>
 8013018:	2321      	movs	r3, #33	; 0x21
 801301a:	2100      	movs	r1, #0
 801301c:	6003      	str	r3, [r0, #0]
 801301e:	4608      	mov	r0, r1
 8013020:	f7ed fc6c 	bl	80008fc <__aeabi_fdiv>
 8013024:	4604      	mov	r4, r0
 8013026:	4620      	mov	r0, r4
 8013028:	bd38      	pop	{r3, r4, r5, pc}
 801302a:	bf00      	nop
 801302c:	20000080 	.word	0x20000080

08013030 <__ieee754_atan2f>:
 8013030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013032:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 8013036:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 801303a:	4603      	mov	r3, r0
 801303c:	dc05      	bgt.n	801304a <__ieee754_atan2f+0x1a>
 801303e:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8013042:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8013046:	4607      	mov	r7, r0
 8013048:	dd04      	ble.n	8013054 <__ieee754_atan2f+0x24>
 801304a:	4618      	mov	r0, r3
 801304c:	f7ed fa9a 	bl	8000584 <__addsf3>
 8013050:	4603      	mov	r3, r0
 8013052:	e011      	b.n	8013078 <__ieee754_atan2f+0x48>
 8013054:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 8013058:	d103      	bne.n	8013062 <__ieee754_atan2f+0x32>
 801305a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 801305e:	f001 ba4b 	b.w	80144f8 <atanf>
 8013062:	178c      	asrs	r4, r1, #30
 8013064:	f004 0402 	and.w	r4, r4, #2
 8013068:	ea44 74d0 	orr.w	r4, r4, r0, lsr #31
 801306c:	b932      	cbnz	r2, 801307c <__ieee754_atan2f+0x4c>
 801306e:	2c02      	cmp	r4, #2
 8013070:	d04c      	beq.n	801310c <__ieee754_atan2f+0xdc>
 8013072:	2c03      	cmp	r4, #3
 8013074:	d100      	bne.n	8013078 <__ieee754_atan2f+0x48>
 8013076:	4b29      	ldr	r3, [pc, #164]	; (801311c <__ieee754_atan2f+0xec>)
 8013078:	4618      	mov	r0, r3
 801307a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801307c:	b91e      	cbnz	r6, 8013086 <__ieee754_atan2f+0x56>
 801307e:	2f00      	cmp	r7, #0
 8013080:	da4a      	bge.n	8013118 <__ieee754_atan2f+0xe8>
 8013082:	4b27      	ldr	r3, [pc, #156]	; (8013120 <__ieee754_atan2f+0xf0>)
 8013084:	e7f8      	b.n	8013078 <__ieee754_atan2f+0x48>
 8013086:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 801308a:	d10e      	bne.n	80130aa <__ieee754_atan2f+0x7a>
 801308c:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8013090:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8013094:	d105      	bne.n	80130a2 <__ieee754_atan2f+0x72>
 8013096:	2c02      	cmp	r4, #2
 8013098:	d83a      	bhi.n	8013110 <__ieee754_atan2f+0xe0>
 801309a:	4b22      	ldr	r3, [pc, #136]	; (8013124 <__ieee754_atan2f+0xf4>)
 801309c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 80130a0:	e7ea      	b.n	8013078 <__ieee754_atan2f+0x48>
 80130a2:	2c02      	cmp	r4, #2
 80130a4:	d836      	bhi.n	8013114 <__ieee754_atan2f+0xe4>
 80130a6:	4b20      	ldr	r3, [pc, #128]	; (8013128 <__ieee754_atan2f+0xf8>)
 80130a8:	e7f8      	b.n	801309c <__ieee754_atan2f+0x6c>
 80130aa:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80130ae:	d0e6      	beq.n	801307e <__ieee754_atan2f+0x4e>
 80130b0:	1b92      	subs	r2, r2, r6
 80130b2:	f1b2 5ff4 	cmp.w	r2, #511705088	; 0x1e800000
 80130b6:	ea4f 50e2 	mov.w	r0, r2, asr #23
 80130ba:	da17      	bge.n	80130ec <__ieee754_atan2f+0xbc>
 80130bc:	2900      	cmp	r1, #0
 80130be:	da01      	bge.n	80130c4 <__ieee754_atan2f+0x94>
 80130c0:	303c      	adds	r0, #60	; 0x3c
 80130c2:	db15      	blt.n	80130f0 <__ieee754_atan2f+0xc0>
 80130c4:	4618      	mov	r0, r3
 80130c6:	f7ed fc19 	bl	80008fc <__aeabi_fdiv>
 80130ca:	f001 fb21 	bl	8014710 <fabsf>
 80130ce:	f001 fa13 	bl	80144f8 <atanf>
 80130d2:	4603      	mov	r3, r0
 80130d4:	2c01      	cmp	r4, #1
 80130d6:	d00d      	beq.n	80130f4 <__ieee754_atan2f+0xc4>
 80130d8:	2c02      	cmp	r4, #2
 80130da:	d00e      	beq.n	80130fa <__ieee754_atan2f+0xca>
 80130dc:	2c00      	cmp	r4, #0
 80130de:	d0cb      	beq.n	8013078 <__ieee754_atan2f+0x48>
 80130e0:	4912      	ldr	r1, [pc, #72]	; (801312c <__ieee754_atan2f+0xfc>)
 80130e2:	4618      	mov	r0, r3
 80130e4:	f7ed fa4e 	bl	8000584 <__addsf3>
 80130e8:	4911      	ldr	r1, [pc, #68]	; (8013130 <__ieee754_atan2f+0x100>)
 80130ea:	e00c      	b.n	8013106 <__ieee754_atan2f+0xd6>
 80130ec:	4b11      	ldr	r3, [pc, #68]	; (8013134 <__ieee754_atan2f+0x104>)
 80130ee:	e7f1      	b.n	80130d4 <__ieee754_atan2f+0xa4>
 80130f0:	2300      	movs	r3, #0
 80130f2:	e7ef      	b.n	80130d4 <__ieee754_atan2f+0xa4>
 80130f4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80130f8:	e7be      	b.n	8013078 <__ieee754_atan2f+0x48>
 80130fa:	490c      	ldr	r1, [pc, #48]	; (801312c <__ieee754_atan2f+0xfc>)
 80130fc:	4618      	mov	r0, r3
 80130fe:	f7ed fa41 	bl	8000584 <__addsf3>
 8013102:	4601      	mov	r1, r0
 8013104:	480a      	ldr	r0, [pc, #40]	; (8013130 <__ieee754_atan2f+0x100>)
 8013106:	f7ed fa3b 	bl	8000580 <__aeabi_fsub>
 801310a:	e7a1      	b.n	8013050 <__ieee754_atan2f+0x20>
 801310c:	4b08      	ldr	r3, [pc, #32]	; (8013130 <__ieee754_atan2f+0x100>)
 801310e:	e7b3      	b.n	8013078 <__ieee754_atan2f+0x48>
 8013110:	4b09      	ldr	r3, [pc, #36]	; (8013138 <__ieee754_atan2f+0x108>)
 8013112:	e7b1      	b.n	8013078 <__ieee754_atan2f+0x48>
 8013114:	2300      	movs	r3, #0
 8013116:	e7af      	b.n	8013078 <__ieee754_atan2f+0x48>
 8013118:	4b06      	ldr	r3, [pc, #24]	; (8013134 <__ieee754_atan2f+0x104>)
 801311a:	e7ad      	b.n	8013078 <__ieee754_atan2f+0x48>
 801311c:	c0490fdb 	.word	0xc0490fdb
 8013120:	bfc90fdb 	.word	0xbfc90fdb
 8013124:	08015048 	.word	0x08015048
 8013128:	08015054 	.word	0x08015054
 801312c:	33bbbd2e 	.word	0x33bbbd2e
 8013130:	40490fdb 	.word	0x40490fdb
 8013134:	3fc90fdb 	.word	0x3fc90fdb
 8013138:	3f490fdb 	.word	0x3f490fdb

0801313c <__ieee754_powf>:
 801313c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013140:	f031 4800 	bics.w	r8, r1, #2147483648	; 0x80000000
 8013144:	4682      	mov	sl, r0
 8013146:	460f      	mov	r7, r1
 8013148:	460c      	mov	r4, r1
 801314a:	b087      	sub	sp, #28
 801314c:	f000 832a 	beq.w	80137a4 <__ieee754_powf+0x668>
 8013150:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8013154:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8013158:	4681      	mov	r9, r0
 801315a:	dc06      	bgt.n	801316a <__ieee754_powf+0x2e>
 801315c:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 8013160:	dd09      	ble.n	8013176 <__ieee754_powf+0x3a>
 8013162:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 8013166:	f000 831d 	beq.w	80137a4 <__ieee754_powf+0x668>
 801316a:	4884      	ldr	r0, [pc, #528]	; (801337c <__ieee754_powf+0x240>)
 801316c:	b007      	add	sp, #28
 801316e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013172:	f001 bad9 	b.w	8014728 <nanf>
 8013176:	2800      	cmp	r0, #0
 8013178:	da20      	bge.n	80131bc <__ieee754_powf+0x80>
 801317a:	f1b8 4f97 	cmp.w	r8, #1266679808	; 0x4b800000
 801317e:	da2e      	bge.n	80131de <__ieee754_powf+0xa2>
 8013180:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 8013184:	f2c0 8313 	blt.w	80137ae <__ieee754_powf+0x672>
 8013188:	ea4f 53e8 	mov.w	r3, r8, asr #23
 801318c:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 8013190:	fa48 f503 	asr.w	r5, r8, r3
 8013194:	fa05 f303 	lsl.w	r3, r5, r3
 8013198:	4543      	cmp	r3, r8
 801319a:	f040 8308 	bne.w	80137ae <__ieee754_powf+0x672>
 801319e:	f005 0501 	and.w	r5, r5, #1
 80131a2:	f1c5 0502 	rsb	r5, r5, #2
 80131a6:	f1b8 5f7e 	cmp.w	r8, #1065353216	; 0x3f800000
 80131aa:	d11f      	bne.n	80131ec <__ieee754_powf+0xb0>
 80131ac:	2c00      	cmp	r4, #0
 80131ae:	4651      	mov	r1, sl
 80131b0:	da11      	bge.n	80131d6 <__ieee754_powf+0x9a>
 80131b2:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80131b6:	f7ed fba1 	bl	80008fc <__aeabi_fdiv>
 80131ba:	e01e      	b.n	80131fa <__ieee754_powf+0xbe>
 80131bc:	2500      	movs	r5, #0
 80131be:	f1b8 4fff 	cmp.w	r8, #2139095040	; 0x7f800000
 80131c2:	d1f0      	bne.n	80131a6 <__ieee754_powf+0x6a>
 80131c4:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 80131c8:	f000 82ec 	beq.w	80137a4 <__ieee754_powf+0x668>
 80131cc:	dd09      	ble.n	80131e2 <__ieee754_powf+0xa6>
 80131ce:	2c00      	cmp	r4, #0
 80131d0:	f280 82eb 	bge.w	80137aa <__ieee754_powf+0x66e>
 80131d4:	2100      	movs	r1, #0
 80131d6:	4608      	mov	r0, r1
 80131d8:	b007      	add	sp, #28
 80131da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80131de:	2502      	movs	r5, #2
 80131e0:	e7ed      	b.n	80131be <__ieee754_powf+0x82>
 80131e2:	2c00      	cmp	r4, #0
 80131e4:	daf6      	bge.n	80131d4 <__ieee754_powf+0x98>
 80131e6:	f107 4100 	add.w	r1, r7, #2147483648	; 0x80000000
 80131ea:	e7f4      	b.n	80131d6 <__ieee754_powf+0x9a>
 80131ec:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 80131f0:	d105      	bne.n	80131fe <__ieee754_powf+0xc2>
 80131f2:	4651      	mov	r1, sl
 80131f4:	4608      	mov	r0, r1
 80131f6:	f7ed facd 	bl	8000794 <__aeabi_fmul>
 80131fa:	4601      	mov	r1, r0
 80131fc:	e7eb      	b.n	80131d6 <__ieee754_powf+0x9a>
 80131fe:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 8013202:	4650      	mov	r0, sl
 8013204:	d107      	bne.n	8013216 <__ieee754_powf+0xda>
 8013206:	f1b9 0f00 	cmp.w	r9, #0
 801320a:	db04      	blt.n	8013216 <__ieee754_powf+0xda>
 801320c:	b007      	add	sp, #28
 801320e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013212:	f000 bc45 	b.w	8013aa0 <__ieee754_sqrtf>
 8013216:	f001 fa7b 	bl	8014710 <fabsf>
 801321a:	4601      	mov	r1, r0
 801321c:	b126      	cbz	r6, 8013228 <__ieee754_powf+0xec>
 801321e:	f029 4340 	bic.w	r3, r9, #3221225472	; 0xc0000000
 8013222:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 8013226:	d118      	bne.n	801325a <__ieee754_powf+0x11e>
 8013228:	2c00      	cmp	r4, #0
 801322a:	da04      	bge.n	8013236 <__ieee754_powf+0xfa>
 801322c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013230:	f7ed fb64 	bl	80008fc <__aeabi_fdiv>
 8013234:	4601      	mov	r1, r0
 8013236:	f1b9 0f00 	cmp.w	r9, #0
 801323a:	dacc      	bge.n	80131d6 <__ieee754_powf+0x9a>
 801323c:	f1a6 567e 	sub.w	r6, r6, #1065353216	; 0x3f800000
 8013240:	ea56 0305 	orrs.w	r3, r6, r5
 8013244:	d104      	bne.n	8013250 <__ieee754_powf+0x114>
 8013246:	4608      	mov	r0, r1
 8013248:	f7ed f99a 	bl	8000580 <__aeabi_fsub>
 801324c:	4601      	mov	r1, r0
 801324e:	e7b2      	b.n	80131b6 <__ieee754_powf+0x7a>
 8013250:	2d01      	cmp	r5, #1
 8013252:	d1c0      	bne.n	80131d6 <__ieee754_powf+0x9a>
 8013254:	f101 4000 	add.w	r0, r1, #2147483648	; 0x80000000
 8013258:	e7cf      	b.n	80131fa <__ieee754_powf+0xbe>
 801325a:	ea4f 73d9 	mov.w	r3, r9, lsr #31
 801325e:	3b01      	subs	r3, #1
 8013260:	9302      	str	r3, [sp, #8]
 8013262:	432b      	orrs	r3, r5
 8013264:	d101      	bne.n	801326a <__ieee754_powf+0x12e>
 8013266:	4651      	mov	r1, sl
 8013268:	e7ed      	b.n	8013246 <__ieee754_powf+0x10a>
 801326a:	f1b8 4f9a 	cmp.w	r8, #1291845632	; 0x4d000000
 801326e:	f340 8097 	ble.w	80133a0 <__ieee754_powf+0x264>
 8013272:	4b43      	ldr	r3, [pc, #268]	; (8013380 <__ieee754_powf+0x244>)
 8013274:	429e      	cmp	r6, r3
 8013276:	dc03      	bgt.n	8013280 <__ieee754_powf+0x144>
 8013278:	2c00      	cmp	r4, #0
 801327a:	daab      	bge.n	80131d4 <__ieee754_powf+0x98>
 801327c:	4941      	ldr	r1, [pc, #260]	; (8013384 <__ieee754_powf+0x248>)
 801327e:	e7b9      	b.n	80131f4 <__ieee754_powf+0xb8>
 8013280:	4b41      	ldr	r3, [pc, #260]	; (8013388 <__ieee754_powf+0x24c>)
 8013282:	429e      	cmp	r6, r3
 8013284:	dd02      	ble.n	801328c <__ieee754_powf+0x150>
 8013286:	2c00      	cmp	r4, #0
 8013288:	dcf8      	bgt.n	801327c <__ieee754_powf+0x140>
 801328a:	e7a3      	b.n	80131d4 <__ieee754_powf+0x98>
 801328c:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8013290:	f7ed f976 	bl	8000580 <__aeabi_fsub>
 8013294:	493d      	ldr	r1, [pc, #244]	; (801338c <__ieee754_powf+0x250>)
 8013296:	4606      	mov	r6, r0
 8013298:	f7ed fa7c 	bl	8000794 <__aeabi_fmul>
 801329c:	493c      	ldr	r1, [pc, #240]	; (8013390 <__ieee754_powf+0x254>)
 801329e:	4680      	mov	r8, r0
 80132a0:	4630      	mov	r0, r6
 80132a2:	f7ed fa77 	bl	8000794 <__aeabi_fmul>
 80132a6:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
 80132aa:	4681      	mov	r9, r0
 80132ac:	4630      	mov	r0, r6
 80132ae:	f7ed fa71 	bl	8000794 <__aeabi_fmul>
 80132b2:	4601      	mov	r1, r0
 80132b4:	4837      	ldr	r0, [pc, #220]	; (8013394 <__ieee754_powf+0x258>)
 80132b6:	f7ed f963 	bl	8000580 <__aeabi_fsub>
 80132ba:	4631      	mov	r1, r6
 80132bc:	f7ed fa6a 	bl	8000794 <__aeabi_fmul>
 80132c0:	4601      	mov	r1, r0
 80132c2:	f04f 507c 	mov.w	r0, #1056964608	; 0x3f000000
 80132c6:	f7ed f95b 	bl	8000580 <__aeabi_fsub>
 80132ca:	4631      	mov	r1, r6
 80132cc:	4682      	mov	sl, r0
 80132ce:	4630      	mov	r0, r6
 80132d0:	f7ed fa60 	bl	8000794 <__aeabi_fmul>
 80132d4:	4601      	mov	r1, r0
 80132d6:	4650      	mov	r0, sl
 80132d8:	f7ed fa5c 	bl	8000794 <__aeabi_fmul>
 80132dc:	492e      	ldr	r1, [pc, #184]	; (8013398 <__ieee754_powf+0x25c>)
 80132de:	f7ed fa59 	bl	8000794 <__aeabi_fmul>
 80132e2:	4601      	mov	r1, r0
 80132e4:	4648      	mov	r0, r9
 80132e6:	f7ed f94b 	bl	8000580 <__aeabi_fsub>
 80132ea:	4601      	mov	r1, r0
 80132ec:	4606      	mov	r6, r0
 80132ee:	4640      	mov	r0, r8
 80132f0:	f7ed f948 	bl	8000584 <__addsf3>
 80132f4:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 80132f8:	f029 090f 	bic.w	r9, r9, #15
 80132fc:	4641      	mov	r1, r8
 80132fe:	4648      	mov	r0, r9
 8013300:	f7ed f93e 	bl	8000580 <__aeabi_fsub>
 8013304:	4601      	mov	r1, r0
 8013306:	4630      	mov	r0, r6
 8013308:	f7ed f93a 	bl	8000580 <__aeabi_fsub>
 801330c:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 8013310:	9b02      	ldr	r3, [sp, #8]
 8013312:	3d01      	subs	r5, #1
 8013314:	f024 040f 	bic.w	r4, r4, #15
 8013318:	432b      	orrs	r3, r5
 801331a:	4606      	mov	r6, r0
 801331c:	4621      	mov	r1, r4
 801331e:	4638      	mov	r0, r7
 8013320:	bf14      	ite	ne
 8013322:	f04f 557e 	movne.w	r5, #1065353216	; 0x3f800000
 8013326:	4d1d      	ldreq	r5, [pc, #116]	; (801339c <__ieee754_powf+0x260>)
 8013328:	f7ed f92a 	bl	8000580 <__aeabi_fsub>
 801332c:	4649      	mov	r1, r9
 801332e:	f7ed fa31 	bl	8000794 <__aeabi_fmul>
 8013332:	4639      	mov	r1, r7
 8013334:	4680      	mov	r8, r0
 8013336:	4630      	mov	r0, r6
 8013338:	f7ed fa2c 	bl	8000794 <__aeabi_fmul>
 801333c:	4601      	mov	r1, r0
 801333e:	4640      	mov	r0, r8
 8013340:	f7ed f920 	bl	8000584 <__addsf3>
 8013344:	4621      	mov	r1, r4
 8013346:	4606      	mov	r6, r0
 8013348:	4648      	mov	r0, r9
 801334a:	f7ed fa23 	bl	8000794 <__aeabi_fmul>
 801334e:	4601      	mov	r1, r0
 8013350:	4607      	mov	r7, r0
 8013352:	4681      	mov	r9, r0
 8013354:	4630      	mov	r0, r6
 8013356:	f7ed f915 	bl	8000584 <__addsf3>
 801335a:	2800      	cmp	r0, #0
 801335c:	4682      	mov	sl, r0
 801335e:	4680      	mov	r8, r0
 8013360:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8013364:	f340 8202 	ble.w	801376c <__ieee754_powf+0x630>
 8013368:	f1b4 4f86 	cmp.w	r4, #1124073472	; 0x43000000
 801336c:	f340 8150 	ble.w	8013610 <__ieee754_powf+0x4d4>
 8013370:	4904      	ldr	r1, [pc, #16]	; (8013384 <__ieee754_powf+0x248>)
 8013372:	4628      	mov	r0, r5
 8013374:	f7ed fa0e 	bl	8000794 <__aeabi_fmul>
 8013378:	4902      	ldr	r1, [pc, #8]	; (8013384 <__ieee754_powf+0x248>)
 801337a:	e73c      	b.n	80131f6 <__ieee754_powf+0xba>
 801337c:	08014fac 	.word	0x08014fac
 8013380:	3f7ffff7 	.word	0x3f7ffff7
 8013384:	7149f2ca 	.word	0x7149f2ca
 8013388:	3f800007 	.word	0x3f800007
 801338c:	3fb8aa00 	.word	0x3fb8aa00
 8013390:	36eca570 	.word	0x36eca570
 8013394:	3eaaaaab 	.word	0x3eaaaaab
 8013398:	3fb8aa3b 	.word	0x3fb8aa3b
 801339c:	bf800000 	.word	0xbf800000
 80133a0:	f019 4fff 	tst.w	r9, #2139095040	; 0x7f800000
 80133a4:	f040 8111 	bne.w	80135ca <__ieee754_powf+0x48e>
 80133a8:	f04f 4197 	mov.w	r1, #1266679808	; 0x4b800000
 80133ac:	f7ed f9f2 	bl	8000794 <__aeabi_fmul>
 80133b0:	f06f 0217 	mvn.w	r2, #23
 80133b4:	4606      	mov	r6, r0
 80133b6:	15f3      	asrs	r3, r6, #23
 80133b8:	3b7f      	subs	r3, #127	; 0x7f
 80133ba:	4413      	add	r3, r2
 80133bc:	9301      	str	r3, [sp, #4]
 80133be:	4b85      	ldr	r3, [pc, #532]	; (80135d4 <__ieee754_powf+0x498>)
 80133c0:	f3c6 0016 	ubfx	r0, r6, #0, #23
 80133c4:	4298      	cmp	r0, r3
 80133c6:	f040 567e 	orr.w	r6, r0, #1065353216	; 0x3f800000
 80133ca:	dd08      	ble.n	80133de <__ieee754_powf+0x2a2>
 80133cc:	4b82      	ldr	r3, [pc, #520]	; (80135d8 <__ieee754_powf+0x49c>)
 80133ce:	4298      	cmp	r0, r3
 80133d0:	f340 80fd 	ble.w	80135ce <__ieee754_powf+0x492>
 80133d4:	9b01      	ldr	r3, [sp, #4]
 80133d6:	f5a6 0600 	sub.w	r6, r6, #8388608	; 0x800000
 80133da:	3301      	adds	r3, #1
 80133dc:	9301      	str	r3, [sp, #4]
 80133de:	2300      	movs	r3, #0
 80133e0:	9300      	str	r3, [sp, #0]
 80133e2:	9900      	ldr	r1, [sp, #0]
 80133e4:	4a7d      	ldr	r2, [pc, #500]	; (80135dc <__ieee754_powf+0x4a0>)
 80133e6:	4630      	mov	r0, r6
 80133e8:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80133ec:	9603      	str	r6, [sp, #12]
 80133ee:	4611      	mov	r1, r2
 80133f0:	9205      	str	r2, [sp, #20]
 80133f2:	f7ed f8c5 	bl	8000580 <__aeabi_fsub>
 80133f6:	9a05      	ldr	r2, [sp, #20]
 80133f8:	9b03      	ldr	r3, [sp, #12]
 80133fa:	4683      	mov	fp, r0
 80133fc:	4619      	mov	r1, r3
 80133fe:	4610      	mov	r0, r2
 8013400:	9203      	str	r2, [sp, #12]
 8013402:	9304      	str	r3, [sp, #16]
 8013404:	f7ed f8be 	bl	8000584 <__addsf3>
 8013408:	4601      	mov	r1, r0
 801340a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 801340e:	f7ed fa75 	bl	80008fc <__aeabi_fdiv>
 8013412:	4682      	mov	sl, r0
 8013414:	4601      	mov	r1, r0
 8013416:	4658      	mov	r0, fp
 8013418:	f7ed f9bc 	bl	8000794 <__aeabi_fmul>
 801341c:	1076      	asrs	r6, r6, #1
 801341e:	9b00      	ldr	r3, [sp, #0]
 8013420:	f046 5600 	orr.w	r6, r6, #536870912	; 0x20000000
 8013424:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 8013428:	f506 2680 	add.w	r6, r6, #262144	; 0x40000
 801342c:	f029 090f 	bic.w	r9, r9, #15
 8013430:	eb06 5643 	add.w	r6, r6, r3, lsl #21
 8013434:	4680      	mov	r8, r0
 8013436:	4631      	mov	r1, r6
 8013438:	4648      	mov	r0, r9
 801343a:	f7ed f9ab 	bl	8000794 <__aeabi_fmul>
 801343e:	4601      	mov	r1, r0
 8013440:	4658      	mov	r0, fp
 8013442:	f7ed f89d 	bl	8000580 <__aeabi_fsub>
 8013446:	9a03      	ldr	r2, [sp, #12]
 8013448:	4683      	mov	fp, r0
 801344a:	4611      	mov	r1, r2
 801344c:	4630      	mov	r0, r6
 801344e:	f7ed f897 	bl	8000580 <__aeabi_fsub>
 8013452:	9b04      	ldr	r3, [sp, #16]
 8013454:	4601      	mov	r1, r0
 8013456:	4618      	mov	r0, r3
 8013458:	f7ed f892 	bl	8000580 <__aeabi_fsub>
 801345c:	4649      	mov	r1, r9
 801345e:	f7ed f999 	bl	8000794 <__aeabi_fmul>
 8013462:	4601      	mov	r1, r0
 8013464:	4658      	mov	r0, fp
 8013466:	f7ed f88b 	bl	8000580 <__aeabi_fsub>
 801346a:	4651      	mov	r1, sl
 801346c:	f7ed f992 	bl	8000794 <__aeabi_fmul>
 8013470:	4641      	mov	r1, r8
 8013472:	4682      	mov	sl, r0
 8013474:	4640      	mov	r0, r8
 8013476:	f7ed f98d 	bl	8000794 <__aeabi_fmul>
 801347a:	4606      	mov	r6, r0
 801347c:	4958      	ldr	r1, [pc, #352]	; (80135e0 <__ieee754_powf+0x4a4>)
 801347e:	f7ed f989 	bl	8000794 <__aeabi_fmul>
 8013482:	4958      	ldr	r1, [pc, #352]	; (80135e4 <__ieee754_powf+0x4a8>)
 8013484:	f7ed f87e 	bl	8000584 <__addsf3>
 8013488:	4631      	mov	r1, r6
 801348a:	f7ed f983 	bl	8000794 <__aeabi_fmul>
 801348e:	4956      	ldr	r1, [pc, #344]	; (80135e8 <__ieee754_powf+0x4ac>)
 8013490:	f7ed f878 	bl	8000584 <__addsf3>
 8013494:	4631      	mov	r1, r6
 8013496:	f7ed f97d 	bl	8000794 <__aeabi_fmul>
 801349a:	4954      	ldr	r1, [pc, #336]	; (80135ec <__ieee754_powf+0x4b0>)
 801349c:	f7ed f872 	bl	8000584 <__addsf3>
 80134a0:	4631      	mov	r1, r6
 80134a2:	f7ed f977 	bl	8000794 <__aeabi_fmul>
 80134a6:	4952      	ldr	r1, [pc, #328]	; (80135f0 <__ieee754_powf+0x4b4>)
 80134a8:	f7ed f86c 	bl	8000584 <__addsf3>
 80134ac:	4631      	mov	r1, r6
 80134ae:	f7ed f971 	bl	8000794 <__aeabi_fmul>
 80134b2:	4950      	ldr	r1, [pc, #320]	; (80135f4 <__ieee754_powf+0x4b8>)
 80134b4:	f7ed f866 	bl	8000584 <__addsf3>
 80134b8:	4631      	mov	r1, r6
 80134ba:	4683      	mov	fp, r0
 80134bc:	4630      	mov	r0, r6
 80134be:	f7ed f969 	bl	8000794 <__aeabi_fmul>
 80134c2:	4601      	mov	r1, r0
 80134c4:	4658      	mov	r0, fp
 80134c6:	f7ed f965 	bl	8000794 <__aeabi_fmul>
 80134ca:	4606      	mov	r6, r0
 80134cc:	4649      	mov	r1, r9
 80134ce:	4640      	mov	r0, r8
 80134d0:	f7ed f858 	bl	8000584 <__addsf3>
 80134d4:	4651      	mov	r1, sl
 80134d6:	f7ed f95d 	bl	8000794 <__aeabi_fmul>
 80134da:	4631      	mov	r1, r6
 80134dc:	f7ed f852 	bl	8000584 <__addsf3>
 80134e0:	4649      	mov	r1, r9
 80134e2:	4683      	mov	fp, r0
 80134e4:	4648      	mov	r0, r9
 80134e6:	f7ed f955 	bl	8000794 <__aeabi_fmul>
 80134ea:	4943      	ldr	r1, [pc, #268]	; (80135f8 <__ieee754_powf+0x4bc>)
 80134ec:	9003      	str	r0, [sp, #12]
 80134ee:	f7ed f849 	bl	8000584 <__addsf3>
 80134f2:	4659      	mov	r1, fp
 80134f4:	f7ed f846 	bl	8000584 <__addsf3>
 80134f8:	f420 667f 	bic.w	r6, r0, #4080	; 0xff0
 80134fc:	f026 060f 	bic.w	r6, r6, #15
 8013500:	4631      	mov	r1, r6
 8013502:	4648      	mov	r0, r9
 8013504:	f7ed f946 	bl	8000794 <__aeabi_fmul>
 8013508:	493b      	ldr	r1, [pc, #236]	; (80135f8 <__ieee754_powf+0x4bc>)
 801350a:	4681      	mov	r9, r0
 801350c:	4630      	mov	r0, r6
 801350e:	f7ed f837 	bl	8000580 <__aeabi_fsub>
 8013512:	9b03      	ldr	r3, [sp, #12]
 8013514:	4619      	mov	r1, r3
 8013516:	f7ed f833 	bl	8000580 <__aeabi_fsub>
 801351a:	4601      	mov	r1, r0
 801351c:	4658      	mov	r0, fp
 801351e:	f7ed f82f 	bl	8000580 <__aeabi_fsub>
 8013522:	4641      	mov	r1, r8
 8013524:	f7ed f936 	bl	8000794 <__aeabi_fmul>
 8013528:	4631      	mov	r1, r6
 801352a:	4680      	mov	r8, r0
 801352c:	4650      	mov	r0, sl
 801352e:	f7ed f931 	bl	8000794 <__aeabi_fmul>
 8013532:	4601      	mov	r1, r0
 8013534:	4640      	mov	r0, r8
 8013536:	f7ed f825 	bl	8000584 <__addsf3>
 801353a:	4682      	mov	sl, r0
 801353c:	4601      	mov	r1, r0
 801353e:	4648      	mov	r0, r9
 8013540:	f7ed f820 	bl	8000584 <__addsf3>
 8013544:	f420 667f 	bic.w	r6, r0, #4080	; 0xff0
 8013548:	f026 060f 	bic.w	r6, r6, #15
 801354c:	4630      	mov	r0, r6
 801354e:	492b      	ldr	r1, [pc, #172]	; (80135fc <__ieee754_powf+0x4c0>)
 8013550:	f7ed f920 	bl	8000794 <__aeabi_fmul>
 8013554:	4649      	mov	r1, r9
 8013556:	4680      	mov	r8, r0
 8013558:	4630      	mov	r0, r6
 801355a:	f7ed f811 	bl	8000580 <__aeabi_fsub>
 801355e:	4601      	mov	r1, r0
 8013560:	4650      	mov	r0, sl
 8013562:	f7ed f80d 	bl	8000580 <__aeabi_fsub>
 8013566:	4926      	ldr	r1, [pc, #152]	; (8013600 <__ieee754_powf+0x4c4>)
 8013568:	f7ed f914 	bl	8000794 <__aeabi_fmul>
 801356c:	4925      	ldr	r1, [pc, #148]	; (8013604 <__ieee754_powf+0x4c8>)
 801356e:	4681      	mov	r9, r0
 8013570:	4630      	mov	r0, r6
 8013572:	f7ed f90f 	bl	8000794 <__aeabi_fmul>
 8013576:	4601      	mov	r1, r0
 8013578:	4648      	mov	r0, r9
 801357a:	f7ed f803 	bl	8000584 <__addsf3>
 801357e:	4b22      	ldr	r3, [pc, #136]	; (8013608 <__ieee754_powf+0x4cc>)
 8013580:	9a00      	ldr	r2, [sp, #0]
 8013582:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8013586:	f7ec fffd 	bl	8000584 <__addsf3>
 801358a:	4606      	mov	r6, r0
 801358c:	9801      	ldr	r0, [sp, #4]
 801358e:	f7ed f8ad 	bl	80006ec <__aeabi_i2f>
 8013592:	4682      	mov	sl, r0
 8013594:	4b1d      	ldr	r3, [pc, #116]	; (801360c <__ieee754_powf+0x4d0>)
 8013596:	9a00      	ldr	r2, [sp, #0]
 8013598:	4631      	mov	r1, r6
 801359a:	f853 b022 	ldr.w	fp, [r3, r2, lsl #2]
 801359e:	4640      	mov	r0, r8
 80135a0:	f7ec fff0 	bl	8000584 <__addsf3>
 80135a4:	4659      	mov	r1, fp
 80135a6:	f7ec ffed 	bl	8000584 <__addsf3>
 80135aa:	4651      	mov	r1, sl
 80135ac:	f7ec ffea 	bl	8000584 <__addsf3>
 80135b0:	f420 697f 	bic.w	r9, r0, #4080	; 0xff0
 80135b4:	f029 090f 	bic.w	r9, r9, #15
 80135b8:	4651      	mov	r1, sl
 80135ba:	4648      	mov	r0, r9
 80135bc:	f7ec ffe0 	bl	8000580 <__aeabi_fsub>
 80135c0:	4659      	mov	r1, fp
 80135c2:	f7ec ffdd 	bl	8000580 <__aeabi_fsub>
 80135c6:	4641      	mov	r1, r8
 80135c8:	e69a      	b.n	8013300 <__ieee754_powf+0x1c4>
 80135ca:	2200      	movs	r2, #0
 80135cc:	e6f3      	b.n	80133b6 <__ieee754_powf+0x27a>
 80135ce:	2301      	movs	r3, #1
 80135d0:	e706      	b.n	80133e0 <__ieee754_powf+0x2a4>
 80135d2:	bf00      	nop
 80135d4:	001cc471 	.word	0x001cc471
 80135d8:	005db3d6 	.word	0x005db3d6
 80135dc:	08015060 	.word	0x08015060
 80135e0:	3e53f142 	.word	0x3e53f142
 80135e4:	3e6c3255 	.word	0x3e6c3255
 80135e8:	3e8ba305 	.word	0x3e8ba305
 80135ec:	3eaaaaab 	.word	0x3eaaaaab
 80135f0:	3edb6db7 	.word	0x3edb6db7
 80135f4:	3f19999a 	.word	0x3f19999a
 80135f8:	40400000 	.word	0x40400000
 80135fc:	3f763800 	.word	0x3f763800
 8013600:	3f76384f 	.word	0x3f76384f
 8013604:	369dc3a0 	.word	0x369dc3a0
 8013608:	08015070 	.word	0x08015070
 801360c:	08015068 	.word	0x08015068
 8013610:	f040 80c0 	bne.w	8013794 <__ieee754_powf+0x658>
 8013614:	4967      	ldr	r1, [pc, #412]	; (80137b4 <__ieee754_powf+0x678>)
 8013616:	4630      	mov	r0, r6
 8013618:	f7ec ffb4 	bl	8000584 <__addsf3>
 801361c:	4639      	mov	r1, r7
 801361e:	4681      	mov	r9, r0
 8013620:	4650      	mov	r0, sl
 8013622:	f7ec ffad 	bl	8000580 <__aeabi_fsub>
 8013626:	4601      	mov	r1, r0
 8013628:	4648      	mov	r0, r9
 801362a:	f7ed fa6f 	bl	8000b0c <__aeabi_fcmpgt>
 801362e:	2800      	cmp	r0, #0
 8013630:	f47f ae9e 	bne.w	8013370 <__ieee754_powf+0x234>
 8013634:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8013638:	15e4      	asrs	r4, r4, #23
 801363a:	3c7e      	subs	r4, #126	; 0x7e
 801363c:	4123      	asrs	r3, r4
 801363e:	4443      	add	r3, r8
 8013640:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8013644:	495c      	ldr	r1, [pc, #368]	; (80137b8 <__ieee754_powf+0x67c>)
 8013646:	3a7f      	subs	r2, #127	; 0x7f
 8013648:	f3c3 0416 	ubfx	r4, r3, #0, #23
 801364c:	4111      	asrs	r1, r2
 801364e:	f444 0400 	orr.w	r4, r4, #8388608	; 0x800000
 8013652:	f1c2 0217 	rsb	r2, r2, #23
 8013656:	4114      	asrs	r4, r2
 8013658:	f1b8 0f00 	cmp.w	r8, #0
 801365c:	4638      	mov	r0, r7
 801365e:	ea23 0101 	bic.w	r1, r3, r1
 8013662:	bfb8      	it	lt
 8013664:	4264      	neglt	r4, r4
 8013666:	f7ec ff8b 	bl	8000580 <__aeabi_fsub>
 801366a:	4681      	mov	r9, r0
 801366c:	4631      	mov	r1, r6
 801366e:	4648      	mov	r0, r9
 8013670:	f7ec ff88 	bl	8000584 <__addsf3>
 8013674:	f420 677f 	bic.w	r7, r0, #4080	; 0xff0
 8013678:	f027 070f 	bic.w	r7, r7, #15
 801367c:	4638      	mov	r0, r7
 801367e:	494f      	ldr	r1, [pc, #316]	; (80137bc <__ieee754_powf+0x680>)
 8013680:	f7ed f888 	bl	8000794 <__aeabi_fmul>
 8013684:	4649      	mov	r1, r9
 8013686:	4680      	mov	r8, r0
 8013688:	4638      	mov	r0, r7
 801368a:	f7ec ff79 	bl	8000580 <__aeabi_fsub>
 801368e:	4601      	mov	r1, r0
 8013690:	4630      	mov	r0, r6
 8013692:	f7ec ff75 	bl	8000580 <__aeabi_fsub>
 8013696:	494a      	ldr	r1, [pc, #296]	; (80137c0 <__ieee754_powf+0x684>)
 8013698:	f7ed f87c 	bl	8000794 <__aeabi_fmul>
 801369c:	4949      	ldr	r1, [pc, #292]	; (80137c4 <__ieee754_powf+0x688>)
 801369e:	4606      	mov	r6, r0
 80136a0:	4638      	mov	r0, r7
 80136a2:	f7ed f877 	bl	8000794 <__aeabi_fmul>
 80136a6:	4601      	mov	r1, r0
 80136a8:	4630      	mov	r0, r6
 80136aa:	f7ec ff6b 	bl	8000584 <__addsf3>
 80136ae:	4607      	mov	r7, r0
 80136b0:	4601      	mov	r1, r0
 80136b2:	4640      	mov	r0, r8
 80136b4:	f7ec ff66 	bl	8000584 <__addsf3>
 80136b8:	4641      	mov	r1, r8
 80136ba:	4606      	mov	r6, r0
 80136bc:	f7ec ff60 	bl	8000580 <__aeabi_fsub>
 80136c0:	4601      	mov	r1, r0
 80136c2:	4638      	mov	r0, r7
 80136c4:	f7ec ff5c 	bl	8000580 <__aeabi_fsub>
 80136c8:	4631      	mov	r1, r6
 80136ca:	4680      	mov	r8, r0
 80136cc:	4630      	mov	r0, r6
 80136ce:	f7ed f861 	bl	8000794 <__aeabi_fmul>
 80136d2:	4607      	mov	r7, r0
 80136d4:	493c      	ldr	r1, [pc, #240]	; (80137c8 <__ieee754_powf+0x68c>)
 80136d6:	f7ed f85d 	bl	8000794 <__aeabi_fmul>
 80136da:	493c      	ldr	r1, [pc, #240]	; (80137cc <__ieee754_powf+0x690>)
 80136dc:	f7ec ff50 	bl	8000580 <__aeabi_fsub>
 80136e0:	4639      	mov	r1, r7
 80136e2:	f7ed f857 	bl	8000794 <__aeabi_fmul>
 80136e6:	493a      	ldr	r1, [pc, #232]	; (80137d0 <__ieee754_powf+0x694>)
 80136e8:	f7ec ff4c 	bl	8000584 <__addsf3>
 80136ec:	4639      	mov	r1, r7
 80136ee:	f7ed f851 	bl	8000794 <__aeabi_fmul>
 80136f2:	4938      	ldr	r1, [pc, #224]	; (80137d4 <__ieee754_powf+0x698>)
 80136f4:	f7ec ff44 	bl	8000580 <__aeabi_fsub>
 80136f8:	4639      	mov	r1, r7
 80136fa:	f7ed f84b 	bl	8000794 <__aeabi_fmul>
 80136fe:	4936      	ldr	r1, [pc, #216]	; (80137d8 <__ieee754_powf+0x69c>)
 8013700:	f7ec ff40 	bl	8000584 <__addsf3>
 8013704:	4639      	mov	r1, r7
 8013706:	f7ed f845 	bl	8000794 <__aeabi_fmul>
 801370a:	4601      	mov	r1, r0
 801370c:	4630      	mov	r0, r6
 801370e:	f7ec ff37 	bl	8000580 <__aeabi_fsub>
 8013712:	4607      	mov	r7, r0
 8013714:	4601      	mov	r1, r0
 8013716:	4630      	mov	r0, r6
 8013718:	f7ed f83c 	bl	8000794 <__aeabi_fmul>
 801371c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8013720:	4681      	mov	r9, r0
 8013722:	4638      	mov	r0, r7
 8013724:	f7ec ff2c 	bl	8000580 <__aeabi_fsub>
 8013728:	4601      	mov	r1, r0
 801372a:	4648      	mov	r0, r9
 801372c:	f7ed f8e6 	bl	80008fc <__aeabi_fdiv>
 8013730:	4641      	mov	r1, r8
 8013732:	4607      	mov	r7, r0
 8013734:	4630      	mov	r0, r6
 8013736:	f7ed f82d 	bl	8000794 <__aeabi_fmul>
 801373a:	4641      	mov	r1, r8
 801373c:	f7ec ff22 	bl	8000584 <__addsf3>
 8013740:	4601      	mov	r1, r0
 8013742:	4638      	mov	r0, r7
 8013744:	f7ec ff1c 	bl	8000580 <__aeabi_fsub>
 8013748:	4631      	mov	r1, r6
 801374a:	f7ec ff19 	bl	8000580 <__aeabi_fsub>
 801374e:	4601      	mov	r1, r0
 8013750:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013754:	f7ec ff14 	bl	8000580 <__aeabi_fsub>
 8013758:	eb00 53c4 	add.w	r3, r0, r4, lsl #23
 801375c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8013760:	da1e      	bge.n	80137a0 <__ieee754_powf+0x664>
 8013762:	4621      	mov	r1, r4
 8013764:	f001 f836 	bl	80147d4 <scalbnf>
 8013768:	4629      	mov	r1, r5
 801376a:	e544      	b.n	80131f6 <__ieee754_powf+0xba>
 801376c:	4b1b      	ldr	r3, [pc, #108]	; (80137dc <__ieee754_powf+0x6a0>)
 801376e:	429c      	cmp	r4, r3
 8013770:	dd05      	ble.n	801377e <__ieee754_powf+0x642>
 8013772:	491b      	ldr	r1, [pc, #108]	; (80137e0 <__ieee754_powf+0x6a4>)
 8013774:	4628      	mov	r0, r5
 8013776:	f7ed f80d 	bl	8000794 <__aeabi_fmul>
 801377a:	4919      	ldr	r1, [pc, #100]	; (80137e0 <__ieee754_powf+0x6a4>)
 801377c:	e53b      	b.n	80131f6 <__ieee754_powf+0xba>
 801377e:	d109      	bne.n	8013794 <__ieee754_powf+0x658>
 8013780:	4639      	mov	r1, r7
 8013782:	f7ec fefd 	bl	8000580 <__aeabi_fsub>
 8013786:	4631      	mov	r1, r6
 8013788:	f7ed f9b6 	bl	8000af8 <__aeabi_fcmpge>
 801378c:	2800      	cmp	r0, #0
 801378e:	f43f af51 	beq.w	8013634 <__ieee754_powf+0x4f8>
 8013792:	e7ee      	b.n	8013772 <__ieee754_powf+0x636>
 8013794:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 8013798:	f73f af4c 	bgt.w	8013634 <__ieee754_powf+0x4f8>
 801379c:	2400      	movs	r4, #0
 801379e:	e765      	b.n	801366c <__ieee754_powf+0x530>
 80137a0:	4618      	mov	r0, r3
 80137a2:	e7e1      	b.n	8013768 <__ieee754_powf+0x62c>
 80137a4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 80137a8:	e515      	b.n	80131d6 <__ieee754_powf+0x9a>
 80137aa:	4639      	mov	r1, r7
 80137ac:	e513      	b.n	80131d6 <__ieee754_powf+0x9a>
 80137ae:	2500      	movs	r5, #0
 80137b0:	e4f9      	b.n	80131a6 <__ieee754_powf+0x6a>
 80137b2:	bf00      	nop
 80137b4:	3338aa3c 	.word	0x3338aa3c
 80137b8:	007fffff 	.word	0x007fffff
 80137bc:	3f317200 	.word	0x3f317200
 80137c0:	3f317218 	.word	0x3f317218
 80137c4:	35bfbe8c 	.word	0x35bfbe8c
 80137c8:	3331bb4c 	.word	0x3331bb4c
 80137cc:	35ddea0e 	.word	0x35ddea0e
 80137d0:	388ab355 	.word	0x388ab355
 80137d4:	3b360b61 	.word	0x3b360b61
 80137d8:	3e2aaaab 	.word	0x3e2aaaab
 80137dc:	43160000 	.word	0x43160000
 80137e0:	0da24260 	.word	0x0da24260

080137e4 <__ieee754_rem_pio2f>:
 80137e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80137e8:	4aa0      	ldr	r2, [pc, #640]	; (8013a6c <__ieee754_rem_pio2f+0x288>)
 80137ea:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 80137ee:	4296      	cmp	r6, r2
 80137f0:	460c      	mov	r4, r1
 80137f2:	4682      	mov	sl, r0
 80137f4:	b087      	sub	sp, #28
 80137f6:	dc04      	bgt.n	8013802 <__ieee754_rem_pio2f+0x1e>
 80137f8:	2300      	movs	r3, #0
 80137fa:	6008      	str	r0, [r1, #0]
 80137fc:	604b      	str	r3, [r1, #4]
 80137fe:	2500      	movs	r5, #0
 8013800:	e01a      	b.n	8013838 <__ieee754_rem_pio2f+0x54>
 8013802:	4a9b      	ldr	r2, [pc, #620]	; (8013a70 <__ieee754_rem_pio2f+0x28c>)
 8013804:	4296      	cmp	r6, r2
 8013806:	dc4b      	bgt.n	80138a0 <__ieee754_rem_pio2f+0xbc>
 8013808:	2800      	cmp	r0, #0
 801380a:	499a      	ldr	r1, [pc, #616]	; (8013a74 <__ieee754_rem_pio2f+0x290>)
 801380c:	4f9a      	ldr	r7, [pc, #616]	; (8013a78 <__ieee754_rem_pio2f+0x294>)
 801380e:	f026 060f 	bic.w	r6, r6, #15
 8013812:	dd23      	ble.n	801385c <__ieee754_rem_pio2f+0x78>
 8013814:	f7ec feb4 	bl	8000580 <__aeabi_fsub>
 8013818:	42be      	cmp	r6, r7
 801381a:	4605      	mov	r5, r0
 801381c:	d010      	beq.n	8013840 <__ieee754_rem_pio2f+0x5c>
 801381e:	4997      	ldr	r1, [pc, #604]	; (8013a7c <__ieee754_rem_pio2f+0x298>)
 8013820:	f7ec feae 	bl	8000580 <__aeabi_fsub>
 8013824:	4601      	mov	r1, r0
 8013826:	6020      	str	r0, [r4, #0]
 8013828:	4628      	mov	r0, r5
 801382a:	f7ec fea9 	bl	8000580 <__aeabi_fsub>
 801382e:	4993      	ldr	r1, [pc, #588]	; (8013a7c <__ieee754_rem_pio2f+0x298>)
 8013830:	f7ec fea6 	bl	8000580 <__aeabi_fsub>
 8013834:	2501      	movs	r5, #1
 8013836:	6060      	str	r0, [r4, #4]
 8013838:	4628      	mov	r0, r5
 801383a:	b007      	add	sp, #28
 801383c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013840:	498f      	ldr	r1, [pc, #572]	; (8013a80 <__ieee754_rem_pio2f+0x29c>)
 8013842:	f7ec fe9d 	bl	8000580 <__aeabi_fsub>
 8013846:	498f      	ldr	r1, [pc, #572]	; (8013a84 <__ieee754_rem_pio2f+0x2a0>)
 8013848:	4605      	mov	r5, r0
 801384a:	f7ec fe99 	bl	8000580 <__aeabi_fsub>
 801384e:	4601      	mov	r1, r0
 8013850:	6020      	str	r0, [r4, #0]
 8013852:	4628      	mov	r0, r5
 8013854:	f7ec fe94 	bl	8000580 <__aeabi_fsub>
 8013858:	498a      	ldr	r1, [pc, #552]	; (8013a84 <__ieee754_rem_pio2f+0x2a0>)
 801385a:	e7e9      	b.n	8013830 <__ieee754_rem_pio2f+0x4c>
 801385c:	f7ec fe92 	bl	8000584 <__addsf3>
 8013860:	42be      	cmp	r6, r7
 8013862:	4605      	mov	r5, r0
 8013864:	d00e      	beq.n	8013884 <__ieee754_rem_pio2f+0xa0>
 8013866:	4985      	ldr	r1, [pc, #532]	; (8013a7c <__ieee754_rem_pio2f+0x298>)
 8013868:	f7ec fe8c 	bl	8000584 <__addsf3>
 801386c:	4601      	mov	r1, r0
 801386e:	6020      	str	r0, [r4, #0]
 8013870:	4628      	mov	r0, r5
 8013872:	f7ec fe85 	bl	8000580 <__aeabi_fsub>
 8013876:	4981      	ldr	r1, [pc, #516]	; (8013a7c <__ieee754_rem_pio2f+0x298>)
 8013878:	f7ec fe84 	bl	8000584 <__addsf3>
 801387c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 8013880:	6060      	str	r0, [r4, #4]
 8013882:	e7d9      	b.n	8013838 <__ieee754_rem_pio2f+0x54>
 8013884:	497e      	ldr	r1, [pc, #504]	; (8013a80 <__ieee754_rem_pio2f+0x29c>)
 8013886:	f7ec fe7d 	bl	8000584 <__addsf3>
 801388a:	497e      	ldr	r1, [pc, #504]	; (8013a84 <__ieee754_rem_pio2f+0x2a0>)
 801388c:	4605      	mov	r5, r0
 801388e:	f7ec fe79 	bl	8000584 <__addsf3>
 8013892:	4601      	mov	r1, r0
 8013894:	6020      	str	r0, [r4, #0]
 8013896:	4628      	mov	r0, r5
 8013898:	f7ec fe72 	bl	8000580 <__aeabi_fsub>
 801389c:	4979      	ldr	r1, [pc, #484]	; (8013a84 <__ieee754_rem_pio2f+0x2a0>)
 801389e:	e7eb      	b.n	8013878 <__ieee754_rem_pio2f+0x94>
 80138a0:	4a79      	ldr	r2, [pc, #484]	; (8013a88 <__ieee754_rem_pio2f+0x2a4>)
 80138a2:	4296      	cmp	r6, r2
 80138a4:	f300 8091 	bgt.w	80139ca <__ieee754_rem_pio2f+0x1e6>
 80138a8:	f000 ff32 	bl	8014710 <fabsf>
 80138ac:	4977      	ldr	r1, [pc, #476]	; (8013a8c <__ieee754_rem_pio2f+0x2a8>)
 80138ae:	4607      	mov	r7, r0
 80138b0:	f7ec ff70 	bl	8000794 <__aeabi_fmul>
 80138b4:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80138b8:	f7ec fe64 	bl	8000584 <__addsf3>
 80138bc:	f7ed f946 	bl	8000b4c <__aeabi_f2iz>
 80138c0:	4605      	mov	r5, r0
 80138c2:	f7ec ff13 	bl	80006ec <__aeabi_i2f>
 80138c6:	496b      	ldr	r1, [pc, #428]	; (8013a74 <__ieee754_rem_pio2f+0x290>)
 80138c8:	4681      	mov	r9, r0
 80138ca:	f7ec ff63 	bl	8000794 <__aeabi_fmul>
 80138ce:	4601      	mov	r1, r0
 80138d0:	4638      	mov	r0, r7
 80138d2:	f7ec fe55 	bl	8000580 <__aeabi_fsub>
 80138d6:	4969      	ldr	r1, [pc, #420]	; (8013a7c <__ieee754_rem_pio2f+0x298>)
 80138d8:	4680      	mov	r8, r0
 80138da:	4648      	mov	r0, r9
 80138dc:	f7ec ff5a 	bl	8000794 <__aeabi_fmul>
 80138e0:	2d1f      	cmp	r5, #31
 80138e2:	4607      	mov	r7, r0
 80138e4:	dc0c      	bgt.n	8013900 <__ieee754_rem_pio2f+0x11c>
 80138e6:	4a6a      	ldr	r2, [pc, #424]	; (8013a90 <__ieee754_rem_pio2f+0x2ac>)
 80138e8:	1e69      	subs	r1, r5, #1
 80138ea:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 80138ee:	f026 03ff 	bic.w	r3, r6, #255	; 0xff
 80138f2:	4293      	cmp	r3, r2
 80138f4:	d004      	beq.n	8013900 <__ieee754_rem_pio2f+0x11c>
 80138f6:	4639      	mov	r1, r7
 80138f8:	4640      	mov	r0, r8
 80138fa:	f7ec fe41 	bl	8000580 <__aeabi_fsub>
 80138fe:	e00b      	b.n	8013918 <__ieee754_rem_pio2f+0x134>
 8013900:	4639      	mov	r1, r7
 8013902:	4640      	mov	r0, r8
 8013904:	f7ec fe3c 	bl	8000580 <__aeabi_fsub>
 8013908:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 801390c:	ea4f 5be6 	mov.w	fp, r6, asr #23
 8013910:	ebc3 56d6 	rsb	r6, r3, r6, lsr #23
 8013914:	2e08      	cmp	r6, #8
 8013916:	dc01      	bgt.n	801391c <__ieee754_rem_pio2f+0x138>
 8013918:	6020      	str	r0, [r4, #0]
 801391a:	e026      	b.n	801396a <__ieee754_rem_pio2f+0x186>
 801391c:	4958      	ldr	r1, [pc, #352]	; (8013a80 <__ieee754_rem_pio2f+0x29c>)
 801391e:	4648      	mov	r0, r9
 8013920:	f7ec ff38 	bl	8000794 <__aeabi_fmul>
 8013924:	4607      	mov	r7, r0
 8013926:	4601      	mov	r1, r0
 8013928:	4640      	mov	r0, r8
 801392a:	f7ec fe29 	bl	8000580 <__aeabi_fsub>
 801392e:	4601      	mov	r1, r0
 8013930:	4606      	mov	r6, r0
 8013932:	4640      	mov	r0, r8
 8013934:	f7ec fe24 	bl	8000580 <__aeabi_fsub>
 8013938:	4639      	mov	r1, r7
 801393a:	f7ec fe21 	bl	8000580 <__aeabi_fsub>
 801393e:	4607      	mov	r7, r0
 8013940:	4950      	ldr	r1, [pc, #320]	; (8013a84 <__ieee754_rem_pio2f+0x2a0>)
 8013942:	4648      	mov	r0, r9
 8013944:	f7ec ff26 	bl	8000794 <__aeabi_fmul>
 8013948:	4639      	mov	r1, r7
 801394a:	f7ec fe19 	bl	8000580 <__aeabi_fsub>
 801394e:	4601      	mov	r1, r0
 8013950:	4607      	mov	r7, r0
 8013952:	4630      	mov	r0, r6
 8013954:	f7ec fe14 	bl	8000580 <__aeabi_fsub>
 8013958:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 801395c:	ebab 0b03 	sub.w	fp, fp, r3
 8013960:	f1bb 0f19 	cmp.w	fp, #25
 8013964:	dc16      	bgt.n	8013994 <__ieee754_rem_pio2f+0x1b0>
 8013966:	46b0      	mov	r8, r6
 8013968:	6020      	str	r0, [r4, #0]
 801396a:	6826      	ldr	r6, [r4, #0]
 801396c:	4640      	mov	r0, r8
 801396e:	4631      	mov	r1, r6
 8013970:	f7ec fe06 	bl	8000580 <__aeabi_fsub>
 8013974:	4639      	mov	r1, r7
 8013976:	f7ec fe03 	bl	8000580 <__aeabi_fsub>
 801397a:	f1ba 0f00 	cmp.w	sl, #0
 801397e:	6060      	str	r0, [r4, #4]
 8013980:	f6bf af5a 	bge.w	8013838 <__ieee754_rem_pio2f+0x54>
 8013984:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
 8013988:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 801398c:	6026      	str	r6, [r4, #0]
 801398e:	6060      	str	r0, [r4, #4]
 8013990:	426d      	negs	r5, r5
 8013992:	e751      	b.n	8013838 <__ieee754_rem_pio2f+0x54>
 8013994:	493f      	ldr	r1, [pc, #252]	; (8013a94 <__ieee754_rem_pio2f+0x2b0>)
 8013996:	4648      	mov	r0, r9
 8013998:	f7ec fefc 	bl	8000794 <__aeabi_fmul>
 801399c:	4607      	mov	r7, r0
 801399e:	4601      	mov	r1, r0
 80139a0:	4630      	mov	r0, r6
 80139a2:	f7ec fded 	bl	8000580 <__aeabi_fsub>
 80139a6:	4601      	mov	r1, r0
 80139a8:	4680      	mov	r8, r0
 80139aa:	4630      	mov	r0, r6
 80139ac:	f7ec fde8 	bl	8000580 <__aeabi_fsub>
 80139b0:	4639      	mov	r1, r7
 80139b2:	f7ec fde5 	bl	8000580 <__aeabi_fsub>
 80139b6:	4606      	mov	r6, r0
 80139b8:	4937      	ldr	r1, [pc, #220]	; (8013a98 <__ieee754_rem_pio2f+0x2b4>)
 80139ba:	4648      	mov	r0, r9
 80139bc:	f7ec feea 	bl	8000794 <__aeabi_fmul>
 80139c0:	4631      	mov	r1, r6
 80139c2:	f7ec fddd 	bl	8000580 <__aeabi_fsub>
 80139c6:	4607      	mov	r7, r0
 80139c8:	e795      	b.n	80138f6 <__ieee754_rem_pio2f+0x112>
 80139ca:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 80139ce:	db05      	blt.n	80139dc <__ieee754_rem_pio2f+0x1f8>
 80139d0:	4601      	mov	r1, r0
 80139d2:	f7ec fdd5 	bl	8000580 <__aeabi_fsub>
 80139d6:	6060      	str	r0, [r4, #4]
 80139d8:	6020      	str	r0, [r4, #0]
 80139da:	e710      	b.n	80137fe <__ieee754_rem_pio2f+0x1a>
 80139dc:	15f7      	asrs	r7, r6, #23
 80139de:	3f86      	subs	r7, #134	; 0x86
 80139e0:	eba6 56c7 	sub.w	r6, r6, r7, lsl #23
 80139e4:	4630      	mov	r0, r6
 80139e6:	f7ed f8b1 	bl	8000b4c <__aeabi_f2iz>
 80139ea:	f7ec fe7f 	bl	80006ec <__aeabi_i2f>
 80139ee:	4601      	mov	r1, r0
 80139f0:	9003      	str	r0, [sp, #12]
 80139f2:	4630      	mov	r0, r6
 80139f4:	f7ec fdc4 	bl	8000580 <__aeabi_fsub>
 80139f8:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 80139fc:	f7ec feca 	bl	8000794 <__aeabi_fmul>
 8013a00:	4606      	mov	r6, r0
 8013a02:	f7ed f8a3 	bl	8000b4c <__aeabi_f2iz>
 8013a06:	f7ec fe71 	bl	80006ec <__aeabi_i2f>
 8013a0a:	4601      	mov	r1, r0
 8013a0c:	9004      	str	r0, [sp, #16]
 8013a0e:	4605      	mov	r5, r0
 8013a10:	4630      	mov	r0, r6
 8013a12:	f7ec fdb5 	bl	8000580 <__aeabi_fsub>
 8013a16:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8013a1a:	f7ec febb 	bl	8000794 <__aeabi_fmul>
 8013a1e:	2100      	movs	r1, #0
 8013a20:	9005      	str	r0, [sp, #20]
 8013a22:	f7ed f84b 	bl	8000abc <__aeabi_fcmpeq>
 8013a26:	b1f0      	cbz	r0, 8013a66 <__ieee754_rem_pio2f+0x282>
 8013a28:	2100      	movs	r1, #0
 8013a2a:	4628      	mov	r0, r5
 8013a2c:	f7ed f846 	bl	8000abc <__aeabi_fcmpeq>
 8013a30:	2800      	cmp	r0, #0
 8013a32:	bf14      	ite	ne
 8013a34:	2301      	movne	r3, #1
 8013a36:	2302      	moveq	r3, #2
 8013a38:	4a18      	ldr	r2, [pc, #96]	; (8013a9c <__ieee754_rem_pio2f+0x2b8>)
 8013a3a:	4621      	mov	r1, r4
 8013a3c:	9201      	str	r2, [sp, #4]
 8013a3e:	2202      	movs	r2, #2
 8013a40:	a803      	add	r0, sp, #12
 8013a42:	9200      	str	r2, [sp, #0]
 8013a44:	463a      	mov	r2, r7
 8013a46:	f000 f8fd 	bl	8013c44 <__kernel_rem_pio2f>
 8013a4a:	f1ba 0f00 	cmp.w	sl, #0
 8013a4e:	4605      	mov	r5, r0
 8013a50:	f6bf aef2 	bge.w	8013838 <__ieee754_rem_pio2f+0x54>
 8013a54:	6823      	ldr	r3, [r4, #0]
 8013a56:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8013a5a:	6023      	str	r3, [r4, #0]
 8013a5c:	6863      	ldr	r3, [r4, #4]
 8013a5e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8013a62:	6063      	str	r3, [r4, #4]
 8013a64:	e794      	b.n	8013990 <__ieee754_rem_pio2f+0x1ac>
 8013a66:	2303      	movs	r3, #3
 8013a68:	e7e6      	b.n	8013a38 <__ieee754_rem_pio2f+0x254>
 8013a6a:	bf00      	nop
 8013a6c:	3f490fd8 	.word	0x3f490fd8
 8013a70:	4016cbe3 	.word	0x4016cbe3
 8013a74:	3fc90f80 	.word	0x3fc90f80
 8013a78:	3fc90fd0 	.word	0x3fc90fd0
 8013a7c:	37354443 	.word	0x37354443
 8013a80:	37354400 	.word	0x37354400
 8013a84:	2e85a308 	.word	0x2e85a308
 8013a88:	43490f80 	.word	0x43490f80
 8013a8c:	3f22f984 	.word	0x3f22f984
 8013a90:	08015078 	.word	0x08015078
 8013a94:	2e85a300 	.word	0x2e85a300
 8013a98:	248d3132 	.word	0x248d3132
 8013a9c:	080150f8 	.word	0x080150f8

08013aa0 <__ieee754_sqrtf>:
 8013aa0:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8013aa4:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8013aa8:	b570      	push	{r4, r5, r6, lr}
 8013aaa:	4603      	mov	r3, r0
 8013aac:	4604      	mov	r4, r0
 8013aae:	d309      	bcc.n	8013ac4 <__ieee754_sqrtf+0x24>
 8013ab0:	4601      	mov	r1, r0
 8013ab2:	f7ec fe6f 	bl	8000794 <__aeabi_fmul>
 8013ab6:	4601      	mov	r1, r0
 8013ab8:	4620      	mov	r0, r4
 8013aba:	f7ec fd63 	bl	8000584 <__addsf3>
 8013abe:	4604      	mov	r4, r0
 8013ac0:	4620      	mov	r0, r4
 8013ac2:	bd70      	pop	{r4, r5, r6, pc}
 8013ac4:	2a00      	cmp	r2, #0
 8013ac6:	d0fb      	beq.n	8013ac0 <__ieee754_sqrtf+0x20>
 8013ac8:	2800      	cmp	r0, #0
 8013aca:	da06      	bge.n	8013ada <__ieee754_sqrtf+0x3a>
 8013acc:	4601      	mov	r1, r0
 8013ace:	f7ec fd57 	bl	8000580 <__aeabi_fsub>
 8013ad2:	4601      	mov	r1, r0
 8013ad4:	f7ec ff12 	bl	80008fc <__aeabi_fdiv>
 8013ad8:	e7f1      	b.n	8013abe <__ieee754_sqrtf+0x1e>
 8013ada:	f010 42ff 	ands.w	r2, r0, #2139095040	; 0x7f800000
 8013ade:	ea4f 51e0 	mov.w	r1, r0, asr #23
 8013ae2:	d029      	beq.n	8013b38 <__ieee754_sqrtf+0x98>
 8013ae4:	f3c3 0216 	ubfx	r2, r3, #0, #23
 8013ae8:	07cb      	lsls	r3, r1, #31
 8013aea:	f04f 0300 	mov.w	r3, #0
 8013aee:	f1a1 007f 	sub.w	r0, r1, #127	; 0x7f
 8013af2:	f04f 0419 	mov.w	r4, #25
 8013af6:	461e      	mov	r6, r3
 8013af8:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8013afc:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8013b00:	bf58      	it	pl
 8013b02:	0052      	lslpl	r2, r2, #1
 8013b04:	1040      	asrs	r0, r0, #1
 8013b06:	0052      	lsls	r2, r2, #1
 8013b08:	1875      	adds	r5, r6, r1
 8013b0a:	4295      	cmp	r5, r2
 8013b0c:	bfde      	ittt	le
 8013b0e:	186e      	addle	r6, r5, r1
 8013b10:	1b52      	suble	r2, r2, r5
 8013b12:	185b      	addle	r3, r3, r1
 8013b14:	3c01      	subs	r4, #1
 8013b16:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8013b1a:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8013b1e:	d1f3      	bne.n	8013b08 <__ieee754_sqrtf+0x68>
 8013b20:	b112      	cbz	r2, 8013b28 <__ieee754_sqrtf+0x88>
 8013b22:	3301      	adds	r3, #1
 8013b24:	f023 0301 	bic.w	r3, r3, #1
 8013b28:	105c      	asrs	r4, r3, #1
 8013b2a:	f104 547c 	add.w	r4, r4, #1056964608	; 0x3f000000
 8013b2e:	eb04 54c0 	add.w	r4, r4, r0, lsl #23
 8013b32:	e7c5      	b.n	8013ac0 <__ieee754_sqrtf+0x20>
 8013b34:	005b      	lsls	r3, r3, #1
 8013b36:	3201      	adds	r2, #1
 8013b38:	0218      	lsls	r0, r3, #8
 8013b3a:	d5fb      	bpl.n	8013b34 <__ieee754_sqrtf+0x94>
 8013b3c:	3a01      	subs	r2, #1
 8013b3e:	1a89      	subs	r1, r1, r2
 8013b40:	e7d0      	b.n	8013ae4 <__ieee754_sqrtf+0x44>
	...

08013b44 <__kernel_cosf>:
 8013b44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013b48:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8013b4c:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 8013b50:	4606      	mov	r6, r0
 8013b52:	4688      	mov	r8, r1
 8013b54:	da03      	bge.n	8013b5e <__kernel_cosf+0x1a>
 8013b56:	f7ec fff9 	bl	8000b4c <__aeabi_f2iz>
 8013b5a:	2800      	cmp	r0, #0
 8013b5c:	d05c      	beq.n	8013c18 <__kernel_cosf+0xd4>
 8013b5e:	4631      	mov	r1, r6
 8013b60:	4630      	mov	r0, r6
 8013b62:	f7ec fe17 	bl	8000794 <__aeabi_fmul>
 8013b66:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8013b6a:	4605      	mov	r5, r0
 8013b6c:	f7ec fe12 	bl	8000794 <__aeabi_fmul>
 8013b70:	492b      	ldr	r1, [pc, #172]	; (8013c20 <__kernel_cosf+0xdc>)
 8013b72:	4607      	mov	r7, r0
 8013b74:	4628      	mov	r0, r5
 8013b76:	f7ec fe0d 	bl	8000794 <__aeabi_fmul>
 8013b7a:	492a      	ldr	r1, [pc, #168]	; (8013c24 <__kernel_cosf+0xe0>)
 8013b7c:	f7ec fd02 	bl	8000584 <__addsf3>
 8013b80:	4629      	mov	r1, r5
 8013b82:	f7ec fe07 	bl	8000794 <__aeabi_fmul>
 8013b86:	4928      	ldr	r1, [pc, #160]	; (8013c28 <__kernel_cosf+0xe4>)
 8013b88:	f7ec fcfa 	bl	8000580 <__aeabi_fsub>
 8013b8c:	4629      	mov	r1, r5
 8013b8e:	f7ec fe01 	bl	8000794 <__aeabi_fmul>
 8013b92:	4926      	ldr	r1, [pc, #152]	; (8013c2c <__kernel_cosf+0xe8>)
 8013b94:	f7ec fcf6 	bl	8000584 <__addsf3>
 8013b98:	4629      	mov	r1, r5
 8013b9a:	f7ec fdfb 	bl	8000794 <__aeabi_fmul>
 8013b9e:	4924      	ldr	r1, [pc, #144]	; (8013c30 <__kernel_cosf+0xec>)
 8013ba0:	f7ec fcee 	bl	8000580 <__aeabi_fsub>
 8013ba4:	4629      	mov	r1, r5
 8013ba6:	f7ec fdf5 	bl	8000794 <__aeabi_fmul>
 8013baa:	4922      	ldr	r1, [pc, #136]	; (8013c34 <__kernel_cosf+0xf0>)
 8013bac:	f7ec fcea 	bl	8000584 <__addsf3>
 8013bb0:	4629      	mov	r1, r5
 8013bb2:	f7ec fdef 	bl	8000794 <__aeabi_fmul>
 8013bb6:	4629      	mov	r1, r5
 8013bb8:	f7ec fdec 	bl	8000794 <__aeabi_fmul>
 8013bbc:	4641      	mov	r1, r8
 8013bbe:	4605      	mov	r5, r0
 8013bc0:	4630      	mov	r0, r6
 8013bc2:	f7ec fde7 	bl	8000794 <__aeabi_fmul>
 8013bc6:	4601      	mov	r1, r0
 8013bc8:	4628      	mov	r0, r5
 8013bca:	f7ec fcd9 	bl	8000580 <__aeabi_fsub>
 8013bce:	4b1a      	ldr	r3, [pc, #104]	; (8013c38 <__kernel_cosf+0xf4>)
 8013bd0:	4605      	mov	r5, r0
 8013bd2:	429c      	cmp	r4, r3
 8013bd4:	dc0a      	bgt.n	8013bec <__kernel_cosf+0xa8>
 8013bd6:	4601      	mov	r1, r0
 8013bd8:	4638      	mov	r0, r7
 8013bda:	f7ec fcd1 	bl	8000580 <__aeabi_fsub>
 8013bde:	4601      	mov	r1, r0
 8013be0:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013be4:	f7ec fccc 	bl	8000580 <__aeabi_fsub>
 8013be8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8013bec:	4b13      	ldr	r3, [pc, #76]	; (8013c3c <__kernel_cosf+0xf8>)
 8013bee:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013bf2:	429c      	cmp	r4, r3
 8013bf4:	bfcc      	ite	gt
 8013bf6:	4c12      	ldrgt	r4, [pc, #72]	; (8013c40 <__kernel_cosf+0xfc>)
 8013bf8:	f104 447f 	addle.w	r4, r4, #4278190080	; 0xff000000
 8013bfc:	4621      	mov	r1, r4
 8013bfe:	f7ec fcbf 	bl	8000580 <__aeabi_fsub>
 8013c02:	4621      	mov	r1, r4
 8013c04:	4606      	mov	r6, r0
 8013c06:	4638      	mov	r0, r7
 8013c08:	f7ec fcba 	bl	8000580 <__aeabi_fsub>
 8013c0c:	4629      	mov	r1, r5
 8013c0e:	f7ec fcb7 	bl	8000580 <__aeabi_fsub>
 8013c12:	4601      	mov	r1, r0
 8013c14:	4630      	mov	r0, r6
 8013c16:	e7e5      	b.n	8013be4 <__kernel_cosf+0xa0>
 8013c18:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013c1c:	e7e4      	b.n	8013be8 <__kernel_cosf+0xa4>
 8013c1e:	bf00      	nop
 8013c20:	ad47d74e 	.word	0xad47d74e
 8013c24:	310f74f6 	.word	0x310f74f6
 8013c28:	3493f27c 	.word	0x3493f27c
 8013c2c:	37d00d01 	.word	0x37d00d01
 8013c30:	3ab60b61 	.word	0x3ab60b61
 8013c34:	3d2aaaab 	.word	0x3d2aaaab
 8013c38:	3e999999 	.word	0x3e999999
 8013c3c:	3f480000 	.word	0x3f480000
 8013c40:	3e900000 	.word	0x3e900000

08013c44 <__kernel_rem_pio2f>:
 8013c44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c48:	b0db      	sub	sp, #364	; 0x16c
 8013c4a:	9202      	str	r2, [sp, #8]
 8013c4c:	9304      	str	r3, [sp, #16]
 8013c4e:	9a64      	ldr	r2, [sp, #400]	; 0x190
 8013c50:	4bc5      	ldr	r3, [pc, #788]	; (8013f68 <__kernel_rem_pio2f+0x324>)
 8013c52:	9005      	str	r0, [sp, #20]
 8013c54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013c58:	9100      	str	r1, [sp, #0]
 8013c5a:	9301      	str	r3, [sp, #4]
 8013c5c:	9b04      	ldr	r3, [sp, #16]
 8013c5e:	3b01      	subs	r3, #1
 8013c60:	9303      	str	r3, [sp, #12]
 8013c62:	9b02      	ldr	r3, [sp, #8]
 8013c64:	1d1a      	adds	r2, r3, #4
 8013c66:	f2c0 809b 	blt.w	8013da0 <__kernel_rem_pio2f+0x15c>
 8013c6a:	1edc      	subs	r4, r3, #3
 8013c6c:	bf48      	it	mi
 8013c6e:	1d1c      	addmi	r4, r3, #4
 8013c70:	10e4      	asrs	r4, r4, #3
 8013c72:	2500      	movs	r5, #0
 8013c74:	f04f 0a00 	mov.w	sl, #0
 8013c78:	1c67      	adds	r7, r4, #1
 8013c7a:	00fb      	lsls	r3, r7, #3
 8013c7c:	9306      	str	r3, [sp, #24]
 8013c7e:	9b02      	ldr	r3, [sp, #8]
 8013c80:	9a03      	ldr	r2, [sp, #12]
 8013c82:	eba3 07c7 	sub.w	r7, r3, r7, lsl #3
 8013c86:	9b01      	ldr	r3, [sp, #4]
 8013c88:	1aa6      	subs	r6, r4, r2
 8013c8a:	eb03 0802 	add.w	r8, r3, r2
 8013c8e:	9b65      	ldr	r3, [sp, #404]	; 0x194
 8013c90:	f10d 0b78 	add.w	fp, sp, #120	; 0x78
 8013c94:	eb03 0986 	add.w	r9, r3, r6, lsl #2
 8013c98:	4545      	cmp	r5, r8
 8013c9a:	f340 8083 	ble.w	8013da4 <__kernel_rem_pio2f+0x160>
 8013c9e:	f04f 0800 	mov.w	r8, #0
 8013ca2:	f04f 0b00 	mov.w	fp, #0
 8013ca6:	9b04      	ldr	r3, [sp, #16]
 8013ca8:	aa1e      	add	r2, sp, #120	; 0x78
 8013caa:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 8013cae:	ab46      	add	r3, sp, #280	; 0x118
 8013cb0:	9a01      	ldr	r2, [sp, #4]
 8013cb2:	4590      	cmp	r8, r2
 8013cb4:	f340 809c 	ble.w	8013df0 <__kernel_rem_pio2f+0x1ac>
 8013cb8:	4613      	mov	r3, r2
 8013cba:	aa0a      	add	r2, sp, #40	; 0x28
 8013cbc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8013cc0:	9308      	str	r3, [sp, #32]
 8013cc2:	9b65      	ldr	r3, [sp, #404]	; 0x194
 8013cc4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8013cc8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8013ccc:	9307      	str	r3, [sp, #28]
 8013cce:	ad0a      	add	r5, sp, #40	; 0x28
 8013cd0:	462e      	mov	r6, r5
 8013cd2:	46c3      	mov	fp, r8
 8013cd4:	f04f 4987 	mov.w	r9, #1132462080	; 0x43800000
 8013cd8:	ab5a      	add	r3, sp, #360	; 0x168
 8013cda:	eb03 0388 	add.w	r3, r3, r8, lsl #2
 8013cde:	f853 4c50 	ldr.w	r4, [r3, #-80]
 8013ce2:	f50d 7a8c 	add.w	sl, sp, #280	; 0x118
 8013ce6:	f1bb 0f00 	cmp.w	fp, #0
 8013cea:	f300 8086 	bgt.w	8013dfa <__kernel_rem_pio2f+0x1b6>
 8013cee:	4639      	mov	r1, r7
 8013cf0:	4620      	mov	r0, r4
 8013cf2:	f000 fd6f 	bl	80147d4 <scalbnf>
 8013cf6:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
 8013cfa:	4604      	mov	r4, r0
 8013cfc:	f7ec fd4a 	bl	8000794 <__aeabi_fmul>
 8013d00:	f7fe fff0 	bl	8012ce4 <floorf>
 8013d04:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
 8013d08:	f7ec fd44 	bl	8000794 <__aeabi_fmul>
 8013d0c:	4601      	mov	r1, r0
 8013d0e:	4620      	mov	r0, r4
 8013d10:	f7ec fc36 	bl	8000580 <__aeabi_fsub>
 8013d14:	4604      	mov	r4, r0
 8013d16:	f7ec ff19 	bl	8000b4c <__aeabi_f2iz>
 8013d1a:	4606      	mov	r6, r0
 8013d1c:	f7ec fce6 	bl	80006ec <__aeabi_i2f>
 8013d20:	4601      	mov	r1, r0
 8013d22:	4620      	mov	r0, r4
 8013d24:	f7ec fc2c 	bl	8000580 <__aeabi_fsub>
 8013d28:	2f00      	cmp	r7, #0
 8013d2a:	4681      	mov	r9, r0
 8013d2c:	f340 8084 	ble.w	8013e38 <__kernel_rem_pio2f+0x1f4>
 8013d30:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 8013d34:	ab0a      	add	r3, sp, #40	; 0x28
 8013d36:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8013d3a:	f1c7 0108 	rsb	r1, r7, #8
 8013d3e:	fa44 f301 	asr.w	r3, r4, r1
 8013d42:	441e      	add	r6, r3
 8013d44:	408b      	lsls	r3, r1
 8013d46:	1ae4      	subs	r4, r4, r3
 8013d48:	f1c7 0007 	rsb	r0, r7, #7
 8013d4c:	ab0a      	add	r3, sp, #40	; 0x28
 8013d4e:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8013d52:	4104      	asrs	r4, r0
 8013d54:	2c00      	cmp	r4, #0
 8013d56:	dd7e      	ble.n	8013e56 <__kernel_rem_pio2f+0x212>
 8013d58:	2200      	movs	r2, #0
 8013d5a:	4692      	mov	sl, r2
 8013d5c:	3601      	adds	r6, #1
 8013d5e:	4590      	cmp	r8, r2
 8013d60:	f300 80b0 	bgt.w	8013ec4 <__kernel_rem_pio2f+0x280>
 8013d64:	2f00      	cmp	r7, #0
 8013d66:	dd05      	ble.n	8013d74 <__kernel_rem_pio2f+0x130>
 8013d68:	2f01      	cmp	r7, #1
 8013d6a:	f000 80bd 	beq.w	8013ee8 <__kernel_rem_pio2f+0x2a4>
 8013d6e:	2f02      	cmp	r7, #2
 8013d70:	f000 80c5 	beq.w	8013efe <__kernel_rem_pio2f+0x2ba>
 8013d74:	2c02      	cmp	r4, #2
 8013d76:	d16e      	bne.n	8013e56 <__kernel_rem_pio2f+0x212>
 8013d78:	4649      	mov	r1, r9
 8013d7a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013d7e:	f7ec fbff 	bl	8000580 <__aeabi_fsub>
 8013d82:	4681      	mov	r9, r0
 8013d84:	f1ba 0f00 	cmp.w	sl, #0
 8013d88:	d065      	beq.n	8013e56 <__kernel_rem_pio2f+0x212>
 8013d8a:	4639      	mov	r1, r7
 8013d8c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013d90:	f000 fd20 	bl	80147d4 <scalbnf>
 8013d94:	4601      	mov	r1, r0
 8013d96:	4648      	mov	r0, r9
 8013d98:	f7ec fbf2 	bl	8000580 <__aeabi_fsub>
 8013d9c:	4681      	mov	r9, r0
 8013d9e:	e05a      	b.n	8013e56 <__kernel_rem_pio2f+0x212>
 8013da0:	2400      	movs	r4, #0
 8013da2:	e766      	b.n	8013c72 <__kernel_rem_pio2f+0x2e>
 8013da4:	42ee      	cmn	r6, r5
 8013da6:	d407      	bmi.n	8013db8 <__kernel_rem_pio2f+0x174>
 8013da8:	f859 0025 	ldr.w	r0, [r9, r5, lsl #2]
 8013dac:	f7ec fc9e 	bl	80006ec <__aeabi_i2f>
 8013db0:	f84b 0025 	str.w	r0, [fp, r5, lsl #2]
 8013db4:	3501      	adds	r5, #1
 8013db6:	e76f      	b.n	8013c98 <__kernel_rem_pio2f+0x54>
 8013db8:	4650      	mov	r0, sl
 8013dba:	e7f9      	b.n	8013db0 <__kernel_rem_pio2f+0x16c>
 8013dbc:	9b05      	ldr	r3, [sp, #20]
 8013dbe:	f8da 1000 	ldr.w	r1, [sl]
 8013dc2:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
 8013dc6:	f7ec fce5 	bl	8000794 <__aeabi_fmul>
 8013dca:	4601      	mov	r1, r0
 8013dcc:	4630      	mov	r0, r6
 8013dce:	f7ec fbd9 	bl	8000584 <__addsf3>
 8013dd2:	4606      	mov	r6, r0
 8013dd4:	f109 0901 	add.w	r9, r9, #1
 8013dd8:	ab46      	add	r3, sp, #280	; 0x118
 8013dda:	9a03      	ldr	r2, [sp, #12]
 8013ddc:	f1aa 0a04 	sub.w	sl, sl, #4
 8013de0:	4591      	cmp	r9, r2
 8013de2:	ddeb      	ble.n	8013dbc <__kernel_rem_pio2f+0x178>
 8013de4:	f843 6028 	str.w	r6, [r3, r8, lsl #2]
 8013de8:	3504      	adds	r5, #4
 8013dea:	f108 0801 	add.w	r8, r8, #1
 8013dee:	e75f      	b.n	8013cb0 <__kernel_rem_pio2f+0x6c>
 8013df0:	46aa      	mov	sl, r5
 8013df2:	465e      	mov	r6, fp
 8013df4:	f04f 0900 	mov.w	r9, #0
 8013df8:	e7ef      	b.n	8013dda <__kernel_rem_pio2f+0x196>
 8013dfa:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 8013dfe:	4620      	mov	r0, r4
 8013e00:	f7ec fcc8 	bl	8000794 <__aeabi_fmul>
 8013e04:	f7ec fea2 	bl	8000b4c <__aeabi_f2iz>
 8013e08:	f7ec fc70 	bl	80006ec <__aeabi_i2f>
 8013e0c:	4649      	mov	r1, r9
 8013e0e:	9009      	str	r0, [sp, #36]	; 0x24
 8013e10:	f7ec fcc0 	bl	8000794 <__aeabi_fmul>
 8013e14:	4601      	mov	r1, r0
 8013e16:	4620      	mov	r0, r4
 8013e18:	f7ec fbb2 	bl	8000580 <__aeabi_fsub>
 8013e1c:	f7ec fe96 	bl	8000b4c <__aeabi_f2iz>
 8013e20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013e22:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 8013e26:	f846 0b04 	str.w	r0, [r6], #4
 8013e2a:	f85a 102b 	ldr.w	r1, [sl, fp, lsl #2]
 8013e2e:	4618      	mov	r0, r3
 8013e30:	f7ec fba8 	bl	8000584 <__addsf3>
 8013e34:	4604      	mov	r4, r0
 8013e36:	e756      	b.n	8013ce6 <__kernel_rem_pio2f+0xa2>
 8013e38:	d106      	bne.n	8013e48 <__kernel_rem_pio2f+0x204>
 8013e3a:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
 8013e3e:	aa0a      	add	r2, sp, #40	; 0x28
 8013e40:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 8013e44:	1224      	asrs	r4, r4, #8
 8013e46:	e785      	b.n	8013d54 <__kernel_rem_pio2f+0x110>
 8013e48:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8013e4c:	f7ec fe54 	bl	8000af8 <__aeabi_fcmpge>
 8013e50:	4604      	mov	r4, r0
 8013e52:	2800      	cmp	r0, #0
 8013e54:	d134      	bne.n	8013ec0 <__kernel_rem_pio2f+0x27c>
 8013e56:	2100      	movs	r1, #0
 8013e58:	4648      	mov	r0, r9
 8013e5a:	f7ec fe2f 	bl	8000abc <__aeabi_fcmpeq>
 8013e5e:	2800      	cmp	r0, #0
 8013e60:	f000 809a 	beq.w	8013f98 <__kernel_rem_pio2f+0x354>
 8013e64:	f108 35ff 	add.w	r5, r8, #4294967295	; 0xffffffff
 8013e68:	462b      	mov	r3, r5
 8013e6a:	2200      	movs	r2, #0
 8013e6c:	9901      	ldr	r1, [sp, #4]
 8013e6e:	428b      	cmp	r3, r1
 8013e70:	da4d      	bge.n	8013f0e <__kernel_rem_pio2f+0x2ca>
 8013e72:	2a00      	cmp	r2, #0
 8013e74:	d07c      	beq.n	8013f70 <__kernel_rem_pio2f+0x32c>
 8013e76:	ab0a      	add	r3, sp, #40	; 0x28
 8013e78:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8013e7c:	3f08      	subs	r7, #8
 8013e7e:	2b00      	cmp	r3, #0
 8013e80:	f000 8088 	beq.w	8013f94 <__kernel_rem_pio2f+0x350>
 8013e84:	4639      	mov	r1, r7
 8013e86:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8013e8a:	f000 fca3 	bl	80147d4 <scalbnf>
 8013e8e:	46aa      	mov	sl, r5
 8013e90:	4681      	mov	r9, r0
 8013e92:	f04f 586e 	mov.w	r8, #998244352	; 0x3b800000
 8013e96:	af46      	add	r7, sp, #280	; 0x118
 8013e98:	f1ba 0f00 	cmp.w	sl, #0
 8013e9c:	f280 80b1 	bge.w	8014002 <__kernel_rem_pio2f+0x3be>
 8013ea0:	46a9      	mov	r9, r5
 8013ea2:	f04f 0a00 	mov.w	sl, #0
 8013ea6:	2200      	movs	r2, #0
 8013ea8:	f1b9 0f00 	cmp.w	r9, #0
 8013eac:	f2c0 80db 	blt.w	8014066 <__kernel_rem_pio2f+0x422>
 8013eb0:	a946      	add	r1, sp, #280	; 0x118
 8013eb2:	4617      	mov	r7, r2
 8013eb4:	f04f 0800 	mov.w	r8, #0
 8013eb8:	4b2c      	ldr	r3, [pc, #176]	; (8013f6c <__kernel_rem_pio2f+0x328>)
 8013eba:	eb01 0b89 	add.w	fp, r1, r9, lsl #2
 8013ebe:	e0c3      	b.n	8014048 <__kernel_rem_pio2f+0x404>
 8013ec0:	2402      	movs	r4, #2
 8013ec2:	e749      	b.n	8013d58 <__kernel_rem_pio2f+0x114>
 8013ec4:	682b      	ldr	r3, [r5, #0]
 8013ec6:	f1ba 0f00 	cmp.w	sl, #0
 8013eca:	d108      	bne.n	8013ede <__kernel_rem_pio2f+0x29a>
 8013ecc:	b11b      	cbz	r3, 8013ed6 <__kernel_rem_pio2f+0x292>
 8013ece:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 8013ed2:	602b      	str	r3, [r5, #0]
 8013ed4:	2301      	movs	r3, #1
 8013ed6:	469a      	mov	sl, r3
 8013ed8:	3201      	adds	r2, #1
 8013eda:	3504      	adds	r5, #4
 8013edc:	e73f      	b.n	8013d5e <__kernel_rem_pio2f+0x11a>
 8013ede:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8013ee2:	602b      	str	r3, [r5, #0]
 8013ee4:	4653      	mov	r3, sl
 8013ee6:	e7f6      	b.n	8013ed6 <__kernel_rem_pio2f+0x292>
 8013ee8:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 8013eec:	ab0a      	add	r3, sp, #40	; 0x28
 8013eee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013ef2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013ef6:	a90a      	add	r1, sp, #40	; 0x28
 8013ef8:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8013efc:	e73a      	b.n	8013d74 <__kernel_rem_pio2f+0x130>
 8013efe:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 8013f02:	ab0a      	add	r3, sp, #40	; 0x28
 8013f04:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8013f08:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013f0c:	e7f3      	b.n	8013ef6 <__kernel_rem_pio2f+0x2b2>
 8013f0e:	a90a      	add	r1, sp, #40	; 0x28
 8013f10:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 8013f14:	3b01      	subs	r3, #1
 8013f16:	430a      	orrs	r2, r1
 8013f18:	e7a8      	b.n	8013e6c <__kernel_rem_pio2f+0x228>
 8013f1a:	3301      	adds	r3, #1
 8013f1c:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 8013f20:	2900      	cmp	r1, #0
 8013f22:	d0fa      	beq.n	8013f1a <__kernel_rem_pio2f+0x2d6>
 8013f24:	9a04      	ldr	r2, [sp, #16]
 8013f26:	f108 0501 	add.w	r5, r8, #1
 8013f2a:	eb08 0402 	add.w	r4, r8, r2
 8013f2e:	aa1e      	add	r2, sp, #120	; 0x78
 8013f30:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 8013f34:	4498      	add	r8, r3
 8013f36:	f50d 798c 	add.w	r9, sp, #280	; 0x118
 8013f3a:	45a8      	cmp	r8, r5
 8013f3c:	f6ff aec7 	blt.w	8013cce <__kernel_rem_pio2f+0x8a>
 8013f40:	9b07      	ldr	r3, [sp, #28]
 8013f42:	46a3      	mov	fp, r4
 8013f44:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8013f48:	f7ec fbd0 	bl	80006ec <__aeabi_i2f>
 8013f4c:	f04f 0a00 	mov.w	sl, #0
 8013f50:	2600      	movs	r6, #0
 8013f52:	f84b 0b04 	str.w	r0, [fp], #4
 8013f56:	9b03      	ldr	r3, [sp, #12]
 8013f58:	459a      	cmp	sl, r3
 8013f5a:	dd0c      	ble.n	8013f76 <__kernel_rem_pio2f+0x332>
 8013f5c:	f849 6025 	str.w	r6, [r9, r5, lsl #2]
 8013f60:	465c      	mov	r4, fp
 8013f62:	3501      	adds	r5, #1
 8013f64:	e7e9      	b.n	8013f3a <__kernel_rem_pio2f+0x2f6>
 8013f66:	bf00      	nop
 8013f68:	0801543c 	.word	0x0801543c
 8013f6c:	08015410 	.word	0x08015410
 8013f70:	2301      	movs	r3, #1
 8013f72:	9a08      	ldr	r2, [sp, #32]
 8013f74:	e7d2      	b.n	8013f1c <__kernel_rem_pio2f+0x2d8>
 8013f76:	9b05      	ldr	r3, [sp, #20]
 8013f78:	f854 0904 	ldr.w	r0, [r4], #-4
 8013f7c:	f853 102a 	ldr.w	r1, [r3, sl, lsl #2]
 8013f80:	f7ec fc08 	bl	8000794 <__aeabi_fmul>
 8013f84:	4601      	mov	r1, r0
 8013f86:	4630      	mov	r0, r6
 8013f88:	f7ec fafc 	bl	8000584 <__addsf3>
 8013f8c:	f10a 0a01 	add.w	sl, sl, #1
 8013f90:	4606      	mov	r6, r0
 8013f92:	e7e0      	b.n	8013f56 <__kernel_rem_pio2f+0x312>
 8013f94:	3d01      	subs	r5, #1
 8013f96:	e76e      	b.n	8013e76 <__kernel_rem_pio2f+0x232>
 8013f98:	9b06      	ldr	r3, [sp, #24]
 8013f9a:	9a02      	ldr	r2, [sp, #8]
 8013f9c:	4648      	mov	r0, r9
 8013f9e:	1a99      	subs	r1, r3, r2
 8013fa0:	f000 fc18 	bl	80147d4 <scalbnf>
 8013fa4:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8013fa8:	4605      	mov	r5, r0
 8013faa:	f7ec fda5 	bl	8000af8 <__aeabi_fcmpge>
 8013fae:	b300      	cbz	r0, 8013ff2 <__kernel_rem_pio2f+0x3ae>
 8013fb0:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 8013fb4:	4628      	mov	r0, r5
 8013fb6:	f7ec fbed 	bl	8000794 <__aeabi_fmul>
 8013fba:	f7ec fdc7 	bl	8000b4c <__aeabi_f2iz>
 8013fbe:	f7ec fb95 	bl	80006ec <__aeabi_i2f>
 8013fc2:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8013fc6:	4681      	mov	r9, r0
 8013fc8:	f7ec fbe4 	bl	8000794 <__aeabi_fmul>
 8013fcc:	4601      	mov	r1, r0
 8013fce:	4628      	mov	r0, r5
 8013fd0:	f7ec fad6 	bl	8000580 <__aeabi_fsub>
 8013fd4:	f7ec fdba 	bl	8000b4c <__aeabi_f2iz>
 8013fd8:	ab0a      	add	r3, sp, #40	; 0x28
 8013fda:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8013fde:	4648      	mov	r0, r9
 8013fe0:	f7ec fdb4 	bl	8000b4c <__aeabi_f2iz>
 8013fe4:	f108 0501 	add.w	r5, r8, #1
 8013fe8:	ab0a      	add	r3, sp, #40	; 0x28
 8013fea:	3708      	adds	r7, #8
 8013fec:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
 8013ff0:	e748      	b.n	8013e84 <__kernel_rem_pio2f+0x240>
 8013ff2:	4628      	mov	r0, r5
 8013ff4:	f7ec fdaa 	bl	8000b4c <__aeabi_f2iz>
 8013ff8:	ab0a      	add	r3, sp, #40	; 0x28
 8013ffa:	4645      	mov	r5, r8
 8013ffc:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8014000:	e740      	b.n	8013e84 <__kernel_rem_pio2f+0x240>
 8014002:	ab0a      	add	r3, sp, #40	; 0x28
 8014004:	f853 002a 	ldr.w	r0, [r3, sl, lsl #2]
 8014008:	f7ec fb70 	bl	80006ec <__aeabi_i2f>
 801400c:	4649      	mov	r1, r9
 801400e:	f7ec fbc1 	bl	8000794 <__aeabi_fmul>
 8014012:	4641      	mov	r1, r8
 8014014:	f847 002a 	str.w	r0, [r7, sl, lsl #2]
 8014018:	4648      	mov	r0, r9
 801401a:	f7ec fbbb 	bl	8000794 <__aeabi_fmul>
 801401e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8014022:	4681      	mov	r9, r0
 8014024:	e738      	b.n	8013e98 <__kernel_rem_pio2f+0x254>
 8014026:	f853 0b04 	ldr.w	r0, [r3], #4
 801402a:	f85b 1b04 	ldr.w	r1, [fp], #4
 801402e:	9203      	str	r2, [sp, #12]
 8014030:	9302      	str	r3, [sp, #8]
 8014032:	f7ec fbaf 	bl	8000794 <__aeabi_fmul>
 8014036:	4601      	mov	r1, r0
 8014038:	4638      	mov	r0, r7
 801403a:	f7ec faa3 	bl	8000584 <__addsf3>
 801403e:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 8014042:	4607      	mov	r7, r0
 8014044:	f108 0801 	add.w	r8, r8, #1
 8014048:	9901      	ldr	r1, [sp, #4]
 801404a:	4588      	cmp	r8, r1
 801404c:	dc01      	bgt.n	8014052 <__kernel_rem_pio2f+0x40e>
 801404e:	45c2      	cmp	sl, r8
 8014050:	dae9      	bge.n	8014026 <__kernel_rem_pio2f+0x3e2>
 8014052:	ab5a      	add	r3, sp, #360	; 0x168
 8014054:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 8014058:	f843 7ca0 	str.w	r7, [r3, #-160]
 801405c:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
 8014060:	f10a 0a01 	add.w	sl, sl, #1
 8014064:	e720      	b.n	8013ea8 <__kernel_rem_pio2f+0x264>
 8014066:	9b64      	ldr	r3, [sp, #400]	; 0x190
 8014068:	2b02      	cmp	r3, #2
 801406a:	dc07      	bgt.n	801407c <__kernel_rem_pio2f+0x438>
 801406c:	2b00      	cmp	r3, #0
 801406e:	dc4d      	bgt.n	801410c <__kernel_rem_pio2f+0x4c8>
 8014070:	d02e      	beq.n	80140d0 <__kernel_rem_pio2f+0x48c>
 8014072:	f006 0007 	and.w	r0, r6, #7
 8014076:	b05b      	add	sp, #364	; 0x16c
 8014078:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801407c:	9b64      	ldr	r3, [sp, #400]	; 0x190
 801407e:	2b03      	cmp	r3, #3
 8014080:	d1f7      	bne.n	8014072 <__kernel_rem_pio2f+0x42e>
 8014082:	f10d 0bc8 	add.w	fp, sp, #200	; 0xc8
 8014086:	eb0b 0785 	add.w	r7, fp, r5, lsl #2
 801408a:	46b8      	mov	r8, r7
 801408c:	46aa      	mov	sl, r5
 801408e:	f1ba 0f00 	cmp.w	sl, #0
 8014092:	dc48      	bgt.n	8014126 <__kernel_rem_pio2f+0x4e2>
 8014094:	46a9      	mov	r9, r5
 8014096:	f1b9 0f01 	cmp.w	r9, #1
 801409a:	dc5f      	bgt.n	801415c <__kernel_rem_pio2f+0x518>
 801409c:	2000      	movs	r0, #0
 801409e:	2d01      	cmp	r5, #1
 80140a0:	dc75      	bgt.n	801418e <__kernel_rem_pio2f+0x54a>
 80140a2:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 80140a4:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 80140a6:	2c00      	cmp	r4, #0
 80140a8:	d177      	bne.n	801419a <__kernel_rem_pio2f+0x556>
 80140aa:	9900      	ldr	r1, [sp, #0]
 80140ac:	600a      	str	r2, [r1, #0]
 80140ae:	460a      	mov	r2, r1
 80140b0:	604b      	str	r3, [r1, #4]
 80140b2:	6090      	str	r0, [r2, #8]
 80140b4:	e7dd      	b.n	8014072 <__kernel_rem_pio2f+0x42e>
 80140b6:	f857 1025 	ldr.w	r1, [r7, r5, lsl #2]
 80140ba:	f7ec fa63 	bl	8000584 <__addsf3>
 80140be:	3d01      	subs	r5, #1
 80140c0:	2d00      	cmp	r5, #0
 80140c2:	daf8      	bge.n	80140b6 <__kernel_rem_pio2f+0x472>
 80140c4:	b10c      	cbz	r4, 80140ca <__kernel_rem_pio2f+0x486>
 80140c6:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80140ca:	9b00      	ldr	r3, [sp, #0]
 80140cc:	6018      	str	r0, [r3, #0]
 80140ce:	e7d0      	b.n	8014072 <__kernel_rem_pio2f+0x42e>
 80140d0:	2000      	movs	r0, #0
 80140d2:	af32      	add	r7, sp, #200	; 0xc8
 80140d4:	e7f4      	b.n	80140c0 <__kernel_rem_pio2f+0x47c>
 80140d6:	f858 1027 	ldr.w	r1, [r8, r7, lsl #2]
 80140da:	f7ec fa53 	bl	8000584 <__addsf3>
 80140de:	3f01      	subs	r7, #1
 80140e0:	2f00      	cmp	r7, #0
 80140e2:	daf8      	bge.n	80140d6 <__kernel_rem_pio2f+0x492>
 80140e4:	b1bc      	cbz	r4, 8014116 <__kernel_rem_pio2f+0x4d2>
 80140e6:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
 80140ea:	9a00      	ldr	r2, [sp, #0]
 80140ec:	4601      	mov	r1, r0
 80140ee:	6013      	str	r3, [r2, #0]
 80140f0:	9832      	ldr	r0, [sp, #200]	; 0xc8
 80140f2:	f7ec fa45 	bl	8000580 <__aeabi_fsub>
 80140f6:	2701      	movs	r7, #1
 80140f8:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 80140fc:	42bd      	cmp	r5, r7
 80140fe:	da0c      	bge.n	801411a <__kernel_rem_pio2f+0x4d6>
 8014100:	b10c      	cbz	r4, 8014106 <__kernel_rem_pio2f+0x4c2>
 8014102:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8014106:	9b00      	ldr	r3, [sp, #0]
 8014108:	6058      	str	r0, [r3, #4]
 801410a:	e7b2      	b.n	8014072 <__kernel_rem_pio2f+0x42e>
 801410c:	462f      	mov	r7, r5
 801410e:	2000      	movs	r0, #0
 8014110:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
 8014114:	e7e4      	b.n	80140e0 <__kernel_rem_pio2f+0x49c>
 8014116:	4603      	mov	r3, r0
 8014118:	e7e7      	b.n	80140ea <__kernel_rem_pio2f+0x4a6>
 801411a:	f858 1027 	ldr.w	r1, [r8, r7, lsl #2]
 801411e:	f7ec fa31 	bl	8000584 <__addsf3>
 8014122:	3701      	adds	r7, #1
 8014124:	e7ea      	b.n	80140fc <__kernel_rem_pio2f+0x4b8>
 8014126:	f8d8 3000 	ldr.w	r3, [r8]
 801412a:	f858 2c04 	ldr.w	r2, [r8, #-4]
 801412e:	4619      	mov	r1, r3
 8014130:	4610      	mov	r0, r2
 8014132:	9302      	str	r3, [sp, #8]
 8014134:	9201      	str	r2, [sp, #4]
 8014136:	f7ec fa25 	bl	8000584 <__addsf3>
 801413a:	9a01      	ldr	r2, [sp, #4]
 801413c:	4601      	mov	r1, r0
 801413e:	4681      	mov	r9, r0
 8014140:	4610      	mov	r0, r2
 8014142:	f7ec fa1d 	bl	8000580 <__aeabi_fsub>
 8014146:	9b02      	ldr	r3, [sp, #8]
 8014148:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 801414c:	4619      	mov	r1, r3
 801414e:	f7ec fa19 	bl	8000584 <__addsf3>
 8014152:	f848 0904 	str.w	r0, [r8], #-4
 8014156:	f8c8 9000 	str.w	r9, [r8]
 801415a:	e798      	b.n	801408e <__kernel_rem_pio2f+0x44a>
 801415c:	f857 3c04 	ldr.w	r3, [r7, #-4]
 8014160:	f8d7 a000 	ldr.w	sl, [r7]
 8014164:	4618      	mov	r0, r3
 8014166:	4651      	mov	r1, sl
 8014168:	9301      	str	r3, [sp, #4]
 801416a:	f7ec fa0b 	bl	8000584 <__addsf3>
 801416e:	9b01      	ldr	r3, [sp, #4]
 8014170:	4601      	mov	r1, r0
 8014172:	4680      	mov	r8, r0
 8014174:	4618      	mov	r0, r3
 8014176:	f7ec fa03 	bl	8000580 <__aeabi_fsub>
 801417a:	4651      	mov	r1, sl
 801417c:	f7ec fa02 	bl	8000584 <__addsf3>
 8014180:	f847 0904 	str.w	r0, [r7], #-4
 8014184:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
 8014188:	f8c7 8000 	str.w	r8, [r7]
 801418c:	e783      	b.n	8014096 <__kernel_rem_pio2f+0x452>
 801418e:	f85b 1025 	ldr.w	r1, [fp, r5, lsl #2]
 8014192:	f7ec f9f7 	bl	8000584 <__addsf3>
 8014196:	3d01      	subs	r5, #1
 8014198:	e781      	b.n	801409e <__kernel_rem_pio2f+0x45a>
 801419a:	9900      	ldr	r1, [sp, #0]
 801419c:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 80141a0:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 80141a4:	600a      	str	r2, [r1, #0]
 80141a6:	604b      	str	r3, [r1, #4]
 80141a8:	460a      	mov	r2, r1
 80141aa:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80141ae:	e780      	b.n	80140b2 <__kernel_rem_pio2f+0x46e>

080141b0 <__kernel_sinf>:
 80141b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80141b4:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 80141b8:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80141bc:	4604      	mov	r4, r0
 80141be:	460f      	mov	r7, r1
 80141c0:	4691      	mov	r9, r2
 80141c2:	da03      	bge.n	80141cc <__kernel_sinf+0x1c>
 80141c4:	f7ec fcc2 	bl	8000b4c <__aeabi_f2iz>
 80141c8:	2800      	cmp	r0, #0
 80141ca:	d035      	beq.n	8014238 <__kernel_sinf+0x88>
 80141cc:	4621      	mov	r1, r4
 80141ce:	4620      	mov	r0, r4
 80141d0:	f7ec fae0 	bl	8000794 <__aeabi_fmul>
 80141d4:	4605      	mov	r5, r0
 80141d6:	4601      	mov	r1, r0
 80141d8:	4620      	mov	r0, r4
 80141da:	f7ec fadb 	bl	8000794 <__aeabi_fmul>
 80141de:	4929      	ldr	r1, [pc, #164]	; (8014284 <__kernel_sinf+0xd4>)
 80141e0:	4606      	mov	r6, r0
 80141e2:	4628      	mov	r0, r5
 80141e4:	f7ec fad6 	bl	8000794 <__aeabi_fmul>
 80141e8:	4927      	ldr	r1, [pc, #156]	; (8014288 <__kernel_sinf+0xd8>)
 80141ea:	f7ec f9c9 	bl	8000580 <__aeabi_fsub>
 80141ee:	4629      	mov	r1, r5
 80141f0:	f7ec fad0 	bl	8000794 <__aeabi_fmul>
 80141f4:	4925      	ldr	r1, [pc, #148]	; (801428c <__kernel_sinf+0xdc>)
 80141f6:	f7ec f9c5 	bl	8000584 <__addsf3>
 80141fa:	4629      	mov	r1, r5
 80141fc:	f7ec faca 	bl	8000794 <__aeabi_fmul>
 8014200:	4923      	ldr	r1, [pc, #140]	; (8014290 <__kernel_sinf+0xe0>)
 8014202:	f7ec f9bd 	bl	8000580 <__aeabi_fsub>
 8014206:	4629      	mov	r1, r5
 8014208:	f7ec fac4 	bl	8000794 <__aeabi_fmul>
 801420c:	4921      	ldr	r1, [pc, #132]	; (8014294 <__kernel_sinf+0xe4>)
 801420e:	f7ec f9b9 	bl	8000584 <__addsf3>
 8014212:	4680      	mov	r8, r0
 8014214:	f1b9 0f00 	cmp.w	r9, #0
 8014218:	d111      	bne.n	801423e <__kernel_sinf+0x8e>
 801421a:	4601      	mov	r1, r0
 801421c:	4628      	mov	r0, r5
 801421e:	f7ec fab9 	bl	8000794 <__aeabi_fmul>
 8014222:	491d      	ldr	r1, [pc, #116]	; (8014298 <__kernel_sinf+0xe8>)
 8014224:	f7ec f9ac 	bl	8000580 <__aeabi_fsub>
 8014228:	4631      	mov	r1, r6
 801422a:	f7ec fab3 	bl	8000794 <__aeabi_fmul>
 801422e:	4601      	mov	r1, r0
 8014230:	4620      	mov	r0, r4
 8014232:	f7ec f9a7 	bl	8000584 <__addsf3>
 8014236:	4604      	mov	r4, r0
 8014238:	4620      	mov	r0, r4
 801423a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801423e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8014242:	4638      	mov	r0, r7
 8014244:	f7ec faa6 	bl	8000794 <__aeabi_fmul>
 8014248:	4641      	mov	r1, r8
 801424a:	4681      	mov	r9, r0
 801424c:	4630      	mov	r0, r6
 801424e:	f7ec faa1 	bl	8000794 <__aeabi_fmul>
 8014252:	4601      	mov	r1, r0
 8014254:	4648      	mov	r0, r9
 8014256:	f7ec f993 	bl	8000580 <__aeabi_fsub>
 801425a:	4629      	mov	r1, r5
 801425c:	f7ec fa9a 	bl	8000794 <__aeabi_fmul>
 8014260:	4639      	mov	r1, r7
 8014262:	f7ec f98d 	bl	8000580 <__aeabi_fsub>
 8014266:	490c      	ldr	r1, [pc, #48]	; (8014298 <__kernel_sinf+0xe8>)
 8014268:	4605      	mov	r5, r0
 801426a:	4630      	mov	r0, r6
 801426c:	f7ec fa92 	bl	8000794 <__aeabi_fmul>
 8014270:	4601      	mov	r1, r0
 8014272:	4628      	mov	r0, r5
 8014274:	f7ec f986 	bl	8000584 <__addsf3>
 8014278:	4601      	mov	r1, r0
 801427a:	4620      	mov	r0, r4
 801427c:	f7ec f980 	bl	8000580 <__aeabi_fsub>
 8014280:	e7d9      	b.n	8014236 <__kernel_sinf+0x86>
 8014282:	bf00      	nop
 8014284:	2f2ec9d3 	.word	0x2f2ec9d3
 8014288:	32d72f34 	.word	0x32d72f34
 801428c:	3638ef1b 	.word	0x3638ef1b
 8014290:	39500d01 	.word	0x39500d01
 8014294:	3c088889 	.word	0x3c088889
 8014298:	3e2aaaab 	.word	0x3e2aaaab

0801429c <__kernel_tanf>:
 801429c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80142a0:	f020 4a00 	bic.w	sl, r0, #2147483648	; 0x80000000
 80142a4:	f1ba 5f46 	cmp.w	sl, #830472192	; 0x31800000
 80142a8:	4604      	mov	r4, r0
 80142aa:	460e      	mov	r6, r1
 80142ac:	4690      	mov	r8, r2
 80142ae:	4607      	mov	r7, r0
 80142b0:	da1b      	bge.n	80142ea <__kernel_tanf+0x4e>
 80142b2:	f7ec fc4b 	bl	8000b4c <__aeabi_f2iz>
 80142b6:	2800      	cmp	r0, #0
 80142b8:	d12f      	bne.n	801431a <__kernel_tanf+0x7e>
 80142ba:	f108 0301 	add.w	r3, r8, #1
 80142be:	ea53 030a 	orrs.w	r3, r3, sl
 80142c2:	d10c      	bne.n	80142de <__kernel_tanf+0x42>
 80142c4:	4620      	mov	r0, r4
 80142c6:	f000 fa23 	bl	8014710 <fabsf>
 80142ca:	4601      	mov	r1, r0
 80142cc:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80142d0:	f7ec fb14 	bl	80008fc <__aeabi_fdiv>
 80142d4:	4604      	mov	r4, r0
 80142d6:	4620      	mov	r0, r4
 80142d8:	b003      	add	sp, #12
 80142da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80142de:	f1b8 0f01 	cmp.w	r8, #1
 80142e2:	d0f8      	beq.n	80142d6 <__kernel_tanf+0x3a>
 80142e4:	4621      	mov	r1, r4
 80142e6:	4872      	ldr	r0, [pc, #456]	; (80144b0 <__kernel_tanf+0x214>)
 80142e8:	e7f2      	b.n	80142d0 <__kernel_tanf+0x34>
 80142ea:	4b72      	ldr	r3, [pc, #456]	; (80144b4 <__kernel_tanf+0x218>)
 80142ec:	459a      	cmp	sl, r3
 80142ee:	db14      	blt.n	801431a <__kernel_tanf+0x7e>
 80142f0:	2800      	cmp	r0, #0
 80142f2:	bfbe      	ittt	lt
 80142f4:	f100 4000 	addlt.w	r0, r0, #2147483648	; 0x80000000
 80142f8:	4604      	movlt	r4, r0
 80142fa:	f101 4600 	addlt.w	r6, r1, #2147483648	; 0x80000000
 80142fe:	486e      	ldr	r0, [pc, #440]	; (80144b8 <__kernel_tanf+0x21c>)
 8014300:	4621      	mov	r1, r4
 8014302:	f7ec f93d 	bl	8000580 <__aeabi_fsub>
 8014306:	4604      	mov	r4, r0
 8014308:	4631      	mov	r1, r6
 801430a:	486c      	ldr	r0, [pc, #432]	; (80144bc <__kernel_tanf+0x220>)
 801430c:	f7ec f938 	bl	8000580 <__aeabi_fsub>
 8014310:	4621      	mov	r1, r4
 8014312:	f7ec f937 	bl	8000584 <__addsf3>
 8014316:	2600      	movs	r6, #0
 8014318:	4604      	mov	r4, r0
 801431a:	4621      	mov	r1, r4
 801431c:	4620      	mov	r0, r4
 801431e:	f7ec fa39 	bl	8000794 <__aeabi_fmul>
 8014322:	4601      	mov	r1, r0
 8014324:	4681      	mov	r9, r0
 8014326:	f7ec fa35 	bl	8000794 <__aeabi_fmul>
 801432a:	4649      	mov	r1, r9
 801432c:	4605      	mov	r5, r0
 801432e:	4620      	mov	r0, r4
 8014330:	f7ec fa30 	bl	8000794 <__aeabi_fmul>
 8014334:	4962      	ldr	r1, [pc, #392]	; (80144c0 <__kernel_tanf+0x224>)
 8014336:	4683      	mov	fp, r0
 8014338:	4628      	mov	r0, r5
 801433a:	f7ec fa2b 	bl	8000794 <__aeabi_fmul>
 801433e:	4961      	ldr	r1, [pc, #388]	; (80144c4 <__kernel_tanf+0x228>)
 8014340:	f7ec f920 	bl	8000584 <__addsf3>
 8014344:	4629      	mov	r1, r5
 8014346:	f7ec fa25 	bl	8000794 <__aeabi_fmul>
 801434a:	495f      	ldr	r1, [pc, #380]	; (80144c8 <__kernel_tanf+0x22c>)
 801434c:	f7ec f91a 	bl	8000584 <__addsf3>
 8014350:	4629      	mov	r1, r5
 8014352:	f7ec fa1f 	bl	8000794 <__aeabi_fmul>
 8014356:	495d      	ldr	r1, [pc, #372]	; (80144cc <__kernel_tanf+0x230>)
 8014358:	f7ec f914 	bl	8000584 <__addsf3>
 801435c:	4629      	mov	r1, r5
 801435e:	f7ec fa19 	bl	8000794 <__aeabi_fmul>
 8014362:	495b      	ldr	r1, [pc, #364]	; (80144d0 <__kernel_tanf+0x234>)
 8014364:	f7ec f90e 	bl	8000584 <__addsf3>
 8014368:	4629      	mov	r1, r5
 801436a:	f7ec fa13 	bl	8000794 <__aeabi_fmul>
 801436e:	4959      	ldr	r1, [pc, #356]	; (80144d4 <__kernel_tanf+0x238>)
 8014370:	f7ec f908 	bl	8000584 <__addsf3>
 8014374:	4649      	mov	r1, r9
 8014376:	f7ec fa0d 	bl	8000794 <__aeabi_fmul>
 801437a:	4957      	ldr	r1, [pc, #348]	; (80144d8 <__kernel_tanf+0x23c>)
 801437c:	9001      	str	r0, [sp, #4]
 801437e:	4628      	mov	r0, r5
 8014380:	f7ec fa08 	bl	8000794 <__aeabi_fmul>
 8014384:	4955      	ldr	r1, [pc, #340]	; (80144dc <__kernel_tanf+0x240>)
 8014386:	f7ec f8fd 	bl	8000584 <__addsf3>
 801438a:	4629      	mov	r1, r5
 801438c:	f7ec fa02 	bl	8000794 <__aeabi_fmul>
 8014390:	4953      	ldr	r1, [pc, #332]	; (80144e0 <__kernel_tanf+0x244>)
 8014392:	f7ec f8f7 	bl	8000584 <__addsf3>
 8014396:	4629      	mov	r1, r5
 8014398:	f7ec f9fc 	bl	8000794 <__aeabi_fmul>
 801439c:	4951      	ldr	r1, [pc, #324]	; (80144e4 <__kernel_tanf+0x248>)
 801439e:	f7ec f8f1 	bl	8000584 <__addsf3>
 80143a2:	4629      	mov	r1, r5
 80143a4:	f7ec f9f6 	bl	8000794 <__aeabi_fmul>
 80143a8:	494f      	ldr	r1, [pc, #316]	; (80144e8 <__kernel_tanf+0x24c>)
 80143aa:	f7ec f8eb 	bl	8000584 <__addsf3>
 80143ae:	4629      	mov	r1, r5
 80143b0:	f7ec f9f0 	bl	8000794 <__aeabi_fmul>
 80143b4:	494d      	ldr	r1, [pc, #308]	; (80144ec <__kernel_tanf+0x250>)
 80143b6:	f7ec f8e5 	bl	8000584 <__addsf3>
 80143ba:	9b01      	ldr	r3, [sp, #4]
 80143bc:	4601      	mov	r1, r0
 80143be:	4618      	mov	r0, r3
 80143c0:	f7ec f8e0 	bl	8000584 <__addsf3>
 80143c4:	4659      	mov	r1, fp
 80143c6:	f7ec f9e5 	bl	8000794 <__aeabi_fmul>
 80143ca:	4631      	mov	r1, r6
 80143cc:	f7ec f8da 	bl	8000584 <__addsf3>
 80143d0:	4649      	mov	r1, r9
 80143d2:	f7ec f9df 	bl	8000794 <__aeabi_fmul>
 80143d6:	4631      	mov	r1, r6
 80143d8:	f7ec f8d4 	bl	8000584 <__addsf3>
 80143dc:	4605      	mov	r5, r0
 80143de:	4944      	ldr	r1, [pc, #272]	; (80144f0 <__kernel_tanf+0x254>)
 80143e0:	4658      	mov	r0, fp
 80143e2:	f7ec f9d7 	bl	8000794 <__aeabi_fmul>
 80143e6:	4629      	mov	r1, r5
 80143e8:	f7ec f8cc 	bl	8000584 <__addsf3>
 80143ec:	4601      	mov	r1, r0
 80143ee:	4681      	mov	r9, r0
 80143f0:	4620      	mov	r0, r4
 80143f2:	f7ec f8c7 	bl	8000584 <__addsf3>
 80143f6:	4b2f      	ldr	r3, [pc, #188]	; (80144b4 <__kernel_tanf+0x218>)
 80143f8:	4605      	mov	r5, r0
 80143fa:	459a      	cmp	sl, r3
 80143fc:	db2b      	blt.n	8014456 <__kernel_tanf+0x1ba>
 80143fe:	4640      	mov	r0, r8
 8014400:	f7ec f974 	bl	80006ec <__aeabi_i2f>
 8014404:	4629      	mov	r1, r5
 8014406:	4606      	mov	r6, r0
 8014408:	4628      	mov	r0, r5
 801440a:	f7ec f9c3 	bl	8000794 <__aeabi_fmul>
 801440e:	4631      	mov	r1, r6
 8014410:	4680      	mov	r8, r0
 8014412:	4628      	mov	r0, r5
 8014414:	f7ec f8b6 	bl	8000584 <__addsf3>
 8014418:	4601      	mov	r1, r0
 801441a:	4640      	mov	r0, r8
 801441c:	f7ec fa6e 	bl	80008fc <__aeabi_fdiv>
 8014420:	4649      	mov	r1, r9
 8014422:	f7ec f8ad 	bl	8000580 <__aeabi_fsub>
 8014426:	4601      	mov	r1, r0
 8014428:	4620      	mov	r0, r4
 801442a:	f7ec f8a9 	bl	8000580 <__aeabi_fsub>
 801442e:	4601      	mov	r1, r0
 8014430:	f7ec f8a8 	bl	8000584 <__addsf3>
 8014434:	4601      	mov	r1, r0
 8014436:	4630      	mov	r0, r6
 8014438:	f7ec f8a2 	bl	8000580 <__aeabi_fsub>
 801443c:	17bf      	asrs	r7, r7, #30
 801443e:	f007 0702 	and.w	r7, r7, #2
 8014442:	4604      	mov	r4, r0
 8014444:	f1c7 0001 	rsb	r0, r7, #1
 8014448:	f7ec f950 	bl	80006ec <__aeabi_i2f>
 801444c:	4601      	mov	r1, r0
 801444e:	4620      	mov	r0, r4
 8014450:	f7ec f9a0 	bl	8000794 <__aeabi_fmul>
 8014454:	e73e      	b.n	80142d4 <__kernel_tanf+0x38>
 8014456:	f1b8 0f01 	cmp.w	r8, #1
 801445a:	d027      	beq.n	80144ac <__kernel_tanf+0x210>
 801445c:	4e25      	ldr	r6, [pc, #148]	; (80144f4 <__kernel_tanf+0x258>)
 801445e:	4601      	mov	r1, r0
 8014460:	ea06 0800 	and.w	r8, r6, r0
 8014464:	4812      	ldr	r0, [pc, #72]	; (80144b0 <__kernel_tanf+0x214>)
 8014466:	f7ec fa49 	bl	80008fc <__aeabi_fdiv>
 801446a:	4621      	mov	r1, r4
 801446c:	4006      	ands	r6, r0
 801446e:	4607      	mov	r7, r0
 8014470:	4640      	mov	r0, r8
 8014472:	f7ec f885 	bl	8000580 <__aeabi_fsub>
 8014476:	4601      	mov	r1, r0
 8014478:	4648      	mov	r0, r9
 801447a:	f7ec f881 	bl	8000580 <__aeabi_fsub>
 801447e:	4631      	mov	r1, r6
 8014480:	f7ec f988 	bl	8000794 <__aeabi_fmul>
 8014484:	4631      	mov	r1, r6
 8014486:	4604      	mov	r4, r0
 8014488:	4640      	mov	r0, r8
 801448a:	f7ec f983 	bl	8000794 <__aeabi_fmul>
 801448e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8014492:	f7ec f877 	bl	8000584 <__addsf3>
 8014496:	4601      	mov	r1, r0
 8014498:	4620      	mov	r0, r4
 801449a:	f7ec f873 	bl	8000584 <__addsf3>
 801449e:	4639      	mov	r1, r7
 80144a0:	f7ec f978 	bl	8000794 <__aeabi_fmul>
 80144a4:	4631      	mov	r1, r6
 80144a6:	f7ec f86d 	bl	8000584 <__addsf3>
 80144aa:	e713      	b.n	80142d4 <__kernel_tanf+0x38>
 80144ac:	4604      	mov	r4, r0
 80144ae:	e712      	b.n	80142d6 <__kernel_tanf+0x3a>
 80144b0:	bf800000 	.word	0xbf800000
 80144b4:	3f2ca140 	.word	0x3f2ca140
 80144b8:	3f490fda 	.word	0x3f490fda
 80144bc:	33222168 	.word	0x33222168
 80144c0:	37d95384 	.word	0x37d95384
 80144c4:	3895c07a 	.word	0x3895c07a
 80144c8:	398137b9 	.word	0x398137b9
 80144cc:	3abede48 	.word	0x3abede48
 80144d0:	3c11371f 	.word	0x3c11371f
 80144d4:	3d5d0dd1 	.word	0x3d5d0dd1
 80144d8:	b79bae5f 	.word	0xb79bae5f
 80144dc:	38a3f445 	.word	0x38a3f445
 80144e0:	3a1a26c8 	.word	0x3a1a26c8
 80144e4:	3b6b6916 	.word	0x3b6b6916
 80144e8:	3cb327a4 	.word	0x3cb327a4
 80144ec:	3e088889 	.word	0x3e088889
 80144f0:	3eaaaaab 	.word	0x3eaaaaab
 80144f4:	fffff000 	.word	0xfffff000

080144f8 <atanf>:
 80144f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80144fc:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 8014500:	f1b5 4fa1 	cmp.w	r5, #1350565888	; 0x50800000
 8014504:	4604      	mov	r4, r0
 8014506:	4680      	mov	r8, r0
 8014508:	db0e      	blt.n	8014528 <atanf+0x30>
 801450a:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 801450e:	dd04      	ble.n	801451a <atanf+0x22>
 8014510:	4601      	mov	r1, r0
 8014512:	f7ec f837 	bl	8000584 <__addsf3>
 8014516:	4604      	mov	r4, r0
 8014518:	e003      	b.n	8014522 <atanf+0x2a>
 801451a:	2800      	cmp	r0, #0
 801451c:	f300 80ce 	bgt.w	80146bc <atanf+0x1c4>
 8014520:	4c67      	ldr	r4, [pc, #412]	; (80146c0 <atanf+0x1c8>)
 8014522:	4620      	mov	r0, r4
 8014524:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014528:	4b66      	ldr	r3, [pc, #408]	; (80146c4 <atanf+0x1cc>)
 801452a:	429d      	cmp	r5, r3
 801452c:	dc0e      	bgt.n	801454c <atanf+0x54>
 801452e:	f1b5 5f44 	cmp.w	r5, #822083584	; 0x31000000
 8014532:	da08      	bge.n	8014546 <atanf+0x4e>
 8014534:	4964      	ldr	r1, [pc, #400]	; (80146c8 <atanf+0x1d0>)
 8014536:	f7ec f825 	bl	8000584 <__addsf3>
 801453a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 801453e:	f7ec fae5 	bl	8000b0c <__aeabi_fcmpgt>
 8014542:	2800      	cmp	r0, #0
 8014544:	d1ed      	bne.n	8014522 <atanf+0x2a>
 8014546:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 801454a:	e01c      	b.n	8014586 <atanf+0x8e>
 801454c:	f000 f8e0 	bl	8014710 <fabsf>
 8014550:	4b5e      	ldr	r3, [pc, #376]	; (80146cc <atanf+0x1d4>)
 8014552:	4604      	mov	r4, r0
 8014554:	429d      	cmp	r5, r3
 8014556:	dc7c      	bgt.n	8014652 <atanf+0x15a>
 8014558:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 801455c:	429d      	cmp	r5, r3
 801455e:	dc67      	bgt.n	8014630 <atanf+0x138>
 8014560:	4601      	mov	r1, r0
 8014562:	f7ec f80f 	bl	8000584 <__addsf3>
 8014566:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 801456a:	f7ec f809 	bl	8000580 <__aeabi_fsub>
 801456e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8014572:	4605      	mov	r5, r0
 8014574:	4620      	mov	r0, r4
 8014576:	f7ec f805 	bl	8000584 <__addsf3>
 801457a:	4601      	mov	r1, r0
 801457c:	4628      	mov	r0, r5
 801457e:	f7ec f9bd 	bl	80008fc <__aeabi_fdiv>
 8014582:	2600      	movs	r6, #0
 8014584:	4604      	mov	r4, r0
 8014586:	4621      	mov	r1, r4
 8014588:	4620      	mov	r0, r4
 801458a:	f7ec f903 	bl	8000794 <__aeabi_fmul>
 801458e:	4601      	mov	r1, r0
 8014590:	4607      	mov	r7, r0
 8014592:	f7ec f8ff 	bl	8000794 <__aeabi_fmul>
 8014596:	4605      	mov	r5, r0
 8014598:	494d      	ldr	r1, [pc, #308]	; (80146d0 <atanf+0x1d8>)
 801459a:	f7ec f8fb 	bl	8000794 <__aeabi_fmul>
 801459e:	494d      	ldr	r1, [pc, #308]	; (80146d4 <atanf+0x1dc>)
 80145a0:	f7eb fff0 	bl	8000584 <__addsf3>
 80145a4:	4629      	mov	r1, r5
 80145a6:	f7ec f8f5 	bl	8000794 <__aeabi_fmul>
 80145aa:	494b      	ldr	r1, [pc, #300]	; (80146d8 <atanf+0x1e0>)
 80145ac:	f7eb ffea 	bl	8000584 <__addsf3>
 80145b0:	4629      	mov	r1, r5
 80145b2:	f7ec f8ef 	bl	8000794 <__aeabi_fmul>
 80145b6:	4949      	ldr	r1, [pc, #292]	; (80146dc <atanf+0x1e4>)
 80145b8:	f7eb ffe4 	bl	8000584 <__addsf3>
 80145bc:	4629      	mov	r1, r5
 80145be:	f7ec f8e9 	bl	8000794 <__aeabi_fmul>
 80145c2:	4947      	ldr	r1, [pc, #284]	; (80146e0 <atanf+0x1e8>)
 80145c4:	f7eb ffde 	bl	8000584 <__addsf3>
 80145c8:	4629      	mov	r1, r5
 80145ca:	f7ec f8e3 	bl	8000794 <__aeabi_fmul>
 80145ce:	4945      	ldr	r1, [pc, #276]	; (80146e4 <atanf+0x1ec>)
 80145d0:	f7eb ffd8 	bl	8000584 <__addsf3>
 80145d4:	4639      	mov	r1, r7
 80145d6:	f7ec f8dd 	bl	8000794 <__aeabi_fmul>
 80145da:	4943      	ldr	r1, [pc, #268]	; (80146e8 <atanf+0x1f0>)
 80145dc:	4607      	mov	r7, r0
 80145de:	4628      	mov	r0, r5
 80145e0:	f7ec f8d8 	bl	8000794 <__aeabi_fmul>
 80145e4:	4941      	ldr	r1, [pc, #260]	; (80146ec <atanf+0x1f4>)
 80145e6:	f7eb ffcb 	bl	8000580 <__aeabi_fsub>
 80145ea:	4629      	mov	r1, r5
 80145ec:	f7ec f8d2 	bl	8000794 <__aeabi_fmul>
 80145f0:	493f      	ldr	r1, [pc, #252]	; (80146f0 <atanf+0x1f8>)
 80145f2:	f7eb ffc5 	bl	8000580 <__aeabi_fsub>
 80145f6:	4629      	mov	r1, r5
 80145f8:	f7ec f8cc 	bl	8000794 <__aeabi_fmul>
 80145fc:	493d      	ldr	r1, [pc, #244]	; (80146f4 <atanf+0x1fc>)
 80145fe:	f7eb ffbf 	bl	8000580 <__aeabi_fsub>
 8014602:	4629      	mov	r1, r5
 8014604:	f7ec f8c6 	bl	8000794 <__aeabi_fmul>
 8014608:	493b      	ldr	r1, [pc, #236]	; (80146f8 <atanf+0x200>)
 801460a:	f7eb ffb9 	bl	8000580 <__aeabi_fsub>
 801460e:	4629      	mov	r1, r5
 8014610:	f7ec f8c0 	bl	8000794 <__aeabi_fmul>
 8014614:	4601      	mov	r1, r0
 8014616:	4638      	mov	r0, r7
 8014618:	f7eb ffb4 	bl	8000584 <__addsf3>
 801461c:	4621      	mov	r1, r4
 801461e:	f7ec f8b9 	bl	8000794 <__aeabi_fmul>
 8014622:	1c73      	adds	r3, r6, #1
 8014624:	4601      	mov	r1, r0
 8014626:	d133      	bne.n	8014690 <atanf+0x198>
 8014628:	4620      	mov	r0, r4
 801462a:	f7eb ffa9 	bl	8000580 <__aeabi_fsub>
 801462e:	e772      	b.n	8014516 <atanf+0x1e>
 8014630:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8014634:	f7eb ffa4 	bl	8000580 <__aeabi_fsub>
 8014638:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 801463c:	4605      	mov	r5, r0
 801463e:	4620      	mov	r0, r4
 8014640:	f7eb ffa0 	bl	8000584 <__addsf3>
 8014644:	4601      	mov	r1, r0
 8014646:	4628      	mov	r0, r5
 8014648:	f7ec f958 	bl	80008fc <__aeabi_fdiv>
 801464c:	2601      	movs	r6, #1
 801464e:	4604      	mov	r4, r0
 8014650:	e799      	b.n	8014586 <atanf+0x8e>
 8014652:	4b2a      	ldr	r3, [pc, #168]	; (80146fc <atanf+0x204>)
 8014654:	429d      	cmp	r5, r3
 8014656:	dc14      	bgt.n	8014682 <atanf+0x18a>
 8014658:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 801465c:	f7eb ff90 	bl	8000580 <__aeabi_fsub>
 8014660:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 8014664:	4605      	mov	r5, r0
 8014666:	4620      	mov	r0, r4
 8014668:	f7ec f894 	bl	8000794 <__aeabi_fmul>
 801466c:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8014670:	f7eb ff88 	bl	8000584 <__addsf3>
 8014674:	4601      	mov	r1, r0
 8014676:	4628      	mov	r0, r5
 8014678:	f7ec f940 	bl	80008fc <__aeabi_fdiv>
 801467c:	2602      	movs	r6, #2
 801467e:	4604      	mov	r4, r0
 8014680:	e781      	b.n	8014586 <atanf+0x8e>
 8014682:	4601      	mov	r1, r0
 8014684:	481e      	ldr	r0, [pc, #120]	; (8014700 <atanf+0x208>)
 8014686:	f7ec f939 	bl	80008fc <__aeabi_fdiv>
 801468a:	2603      	movs	r6, #3
 801468c:	4604      	mov	r4, r0
 801468e:	e77a      	b.n	8014586 <atanf+0x8e>
 8014690:	4b1c      	ldr	r3, [pc, #112]	; (8014704 <atanf+0x20c>)
 8014692:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
 8014696:	f7eb ff73 	bl	8000580 <__aeabi_fsub>
 801469a:	4621      	mov	r1, r4
 801469c:	f7eb ff70 	bl	8000580 <__aeabi_fsub>
 80146a0:	4b19      	ldr	r3, [pc, #100]	; (8014708 <atanf+0x210>)
 80146a2:	4601      	mov	r1, r0
 80146a4:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 80146a8:	f7eb ff6a 	bl	8000580 <__aeabi_fsub>
 80146ac:	f1b8 0f00 	cmp.w	r8, #0
 80146b0:	4604      	mov	r4, r0
 80146b2:	f6bf af36 	bge.w	8014522 <atanf+0x2a>
 80146b6:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80146ba:	e72c      	b.n	8014516 <atanf+0x1e>
 80146bc:	4c13      	ldr	r4, [pc, #76]	; (801470c <atanf+0x214>)
 80146be:	e730      	b.n	8014522 <atanf+0x2a>
 80146c0:	bfc90fdb 	.word	0xbfc90fdb
 80146c4:	3edfffff 	.word	0x3edfffff
 80146c8:	7149f2ca 	.word	0x7149f2ca
 80146cc:	3f97ffff 	.word	0x3f97ffff
 80146d0:	3c8569d7 	.word	0x3c8569d7
 80146d4:	3d4bda59 	.word	0x3d4bda59
 80146d8:	3d886b35 	.word	0x3d886b35
 80146dc:	3dba2e6e 	.word	0x3dba2e6e
 80146e0:	3e124925 	.word	0x3e124925
 80146e4:	3eaaaaab 	.word	0x3eaaaaab
 80146e8:	bd15a221 	.word	0xbd15a221
 80146ec:	3d6ef16b 	.word	0x3d6ef16b
 80146f0:	3d9d8795 	.word	0x3d9d8795
 80146f4:	3de38e38 	.word	0x3de38e38
 80146f8:	3e4ccccd 	.word	0x3e4ccccd
 80146fc:	401bffff 	.word	0x401bffff
 8014700:	bf800000 	.word	0xbf800000
 8014704:	08015458 	.word	0x08015458
 8014708:	08015448 	.word	0x08015448
 801470c:	3fc90fdb 	.word	0x3fc90fdb

08014710 <fabsf>:
 8014710:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8014714:	4770      	bx	lr

08014716 <finitef>:
 8014716:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 801471a:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 801471e:	bfac      	ite	ge
 8014720:	2000      	movge	r0, #0
 8014722:	2001      	movlt	r0, #1
 8014724:	4770      	bx	lr
	...

08014728 <nanf>:
 8014728:	4800      	ldr	r0, [pc, #0]	; (801472c <nanf+0x4>)
 801472a:	4770      	bx	lr
 801472c:	7fc00000 	.word	0x7fc00000

08014730 <rintf>:
 8014730:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8014732:	f3c0 55c7 	ubfx	r5, r0, #23, #8
 8014736:	3d7f      	subs	r5, #127	; 0x7f
 8014738:	2d16      	cmp	r5, #22
 801473a:	4601      	mov	r1, r0
 801473c:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8014740:	dc3c      	bgt.n	80147bc <rintf+0x8c>
 8014742:	b1e2      	cbz	r2, 801477e <rintf+0x4e>
 8014744:	2d00      	cmp	r5, #0
 8014746:	4602      	mov	r2, r0
 8014748:	ea4f 74d0 	mov.w	r4, r0, lsr #31
 801474c:	da1a      	bge.n	8014784 <rintf+0x54>
 801474e:	4a1f      	ldr	r2, [pc, #124]	; (80147cc <rintf+0x9c>)
 8014750:	f3c0 0116 	ubfx	r1, r0, #0, #23
 8014754:	4249      	negs	r1, r1
 8014756:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
 801475a:	0d03      	lsrs	r3, r0, #20
 801475c:	0a49      	lsrs	r1, r1, #9
 801475e:	051b      	lsls	r3, r3, #20
 8014760:	f401 0180 	and.w	r1, r1, #4194304	; 0x400000
 8014764:	4319      	orrs	r1, r3
 8014766:	4628      	mov	r0, r5
 8014768:	f7eb ff0c 	bl	8000584 <__addsf3>
 801476c:	9001      	str	r0, [sp, #4]
 801476e:	4629      	mov	r1, r5
 8014770:	9801      	ldr	r0, [sp, #4]
 8014772:	f7eb ff05 	bl	8000580 <__aeabi_fsub>
 8014776:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 801477a:	ea40 71c4 	orr.w	r1, r0, r4, lsl #31
 801477e:	4608      	mov	r0, r1
 8014780:	b003      	add	sp, #12
 8014782:	bd30      	pop	{r4, r5, pc}
 8014784:	4b12      	ldr	r3, [pc, #72]	; (80147d0 <rintf+0xa0>)
 8014786:	412b      	asrs	r3, r5
 8014788:	4218      	tst	r0, r3
 801478a:	d0f8      	beq.n	801477e <rintf+0x4e>
 801478c:	0859      	lsrs	r1, r3, #1
 801478e:	ea10 0353 	ands.w	r3, r0, r3, lsr #1
 8014792:	d006      	beq.n	80147a2 <rintf+0x72>
 8014794:	ea20 0201 	bic.w	r2, r0, r1
 8014798:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 801479c:	fa41 f505 	asr.w	r5, r1, r5
 80147a0:	432a      	orrs	r2, r5
 80147a2:	4b0a      	ldr	r3, [pc, #40]	; (80147cc <rintf+0x9c>)
 80147a4:	4611      	mov	r1, r2
 80147a6:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
 80147aa:	4620      	mov	r0, r4
 80147ac:	f7eb feea 	bl	8000584 <__addsf3>
 80147b0:	9001      	str	r0, [sp, #4]
 80147b2:	4621      	mov	r1, r4
 80147b4:	9801      	ldr	r0, [sp, #4]
 80147b6:	f7eb fee3 	bl	8000580 <__aeabi_fsub>
 80147ba:	e004      	b.n	80147c6 <rintf+0x96>
 80147bc:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80147c0:	d3dd      	bcc.n	801477e <rintf+0x4e>
 80147c2:	f7eb fedf 	bl	8000584 <__addsf3>
 80147c6:	4601      	mov	r1, r0
 80147c8:	e7d9      	b.n	801477e <rintf+0x4e>
 80147ca:	bf00      	nop
 80147cc:	08015468 	.word	0x08015468
 80147d0:	007fffff 	.word	0x007fffff

080147d4 <scalbnf>:
 80147d4:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80147d8:	b538      	push	{r3, r4, r5, lr}
 80147da:	4603      	mov	r3, r0
 80147dc:	460d      	mov	r5, r1
 80147de:	4604      	mov	r4, r0
 80147e0:	d02a      	beq.n	8014838 <scalbnf+0x64>
 80147e2:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 80147e6:	d304      	bcc.n	80147f2 <scalbnf+0x1e>
 80147e8:	4601      	mov	r1, r0
 80147ea:	f7eb fecb 	bl	8000584 <__addsf3>
 80147ee:	4603      	mov	r3, r0
 80147f0:	e022      	b.n	8014838 <scalbnf+0x64>
 80147f2:	f010 4fff 	tst.w	r0, #2139095040	; 0x7f800000
 80147f6:	d117      	bne.n	8014828 <scalbnf+0x54>
 80147f8:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 80147fc:	f7eb ffca 	bl	8000794 <__aeabi_fmul>
 8014800:	4a17      	ldr	r2, [pc, #92]	; (8014860 <scalbnf+0x8c>)
 8014802:	4603      	mov	r3, r0
 8014804:	4295      	cmp	r5, r2
 8014806:	db0b      	blt.n	8014820 <scalbnf+0x4c>
 8014808:	4604      	mov	r4, r0
 801480a:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 801480e:	3a19      	subs	r2, #25
 8014810:	442a      	add	r2, r5
 8014812:	2afe      	cmp	r2, #254	; 0xfe
 8014814:	dd0a      	ble.n	801482c <scalbnf+0x58>
 8014816:	4913      	ldr	r1, [pc, #76]	; (8014864 <scalbnf+0x90>)
 8014818:	4618      	mov	r0, r3
 801481a:	f361 001e 	bfi	r0, r1, #0, #31
 801481e:	e000      	b.n	8014822 <scalbnf+0x4e>
 8014820:	4911      	ldr	r1, [pc, #68]	; (8014868 <scalbnf+0x94>)
 8014822:	f7eb ffb7 	bl	8000794 <__aeabi_fmul>
 8014826:	e7e2      	b.n	80147ee <scalbnf+0x1a>
 8014828:	0dd2      	lsrs	r2, r2, #23
 801482a:	e7f1      	b.n	8014810 <scalbnf+0x3c>
 801482c:	2a00      	cmp	r2, #0
 801482e:	dd05      	ble.n	801483c <scalbnf+0x68>
 8014830:	f024 40ff 	bic.w	r0, r4, #2139095040	; 0x7f800000
 8014834:	ea40 53c2 	orr.w	r3, r0, r2, lsl #23
 8014838:	4618      	mov	r0, r3
 801483a:	bd38      	pop	{r3, r4, r5, pc}
 801483c:	f112 0f16 	cmn.w	r2, #22
 8014840:	da05      	bge.n	801484e <scalbnf+0x7a>
 8014842:	f24c 3250 	movw	r2, #50000	; 0xc350
 8014846:	4295      	cmp	r5, r2
 8014848:	dce5      	bgt.n	8014816 <scalbnf+0x42>
 801484a:	4907      	ldr	r1, [pc, #28]	; (8014868 <scalbnf+0x94>)
 801484c:	e7e4      	b.n	8014818 <scalbnf+0x44>
 801484e:	3219      	adds	r2, #25
 8014850:	f024 44ff 	bic.w	r4, r4, #2139095040	; 0x7f800000
 8014854:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
 8014858:	ea44 50c2 	orr.w	r0, r4, r2, lsl #23
 801485c:	e7e1      	b.n	8014822 <scalbnf+0x4e>
 801485e:	bf00      	nop
 8014860:	ffff3cb0 	.word	0xffff3cb0
 8014864:	7149f2ca 	.word	0x7149f2ca
 8014868:	0da24260 	.word	0x0da24260

0801486c <_init>:
 801486c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801486e:	bf00      	nop
 8014870:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8014872:	bc08      	pop	{r3}
 8014874:	469e      	mov	lr, r3
 8014876:	4770      	bx	lr

08014878 <_fini>:
 8014878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801487a:	bf00      	nop
 801487c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801487e:	bc08      	pop	{r3}
 8014880:	469e      	mov	lr, r3
 8014882:	4770      	bx	lr
